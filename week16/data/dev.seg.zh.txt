这个 模块 中 最 有用 的 工具 是   " functools . partial ( ) "   函数
创建 一个   " BytesFeedParser "   实例
返回 指定   section   中 可用 选项 的 列表
" if "   语句
字 面值
源代码   Lib / contextlib . py
唯一 的 区别 是 生成器 函数 不能 控制 在 它 在   yield   后 交给 哪里 继续执行 ； 控制权 总是 转移 到 生成器 的 调用者
要 添加 一个 元素 到 堆栈 的 顶端 ， 使用   " append ( ) "
在 指定 窗口 的 当前 行 上方 插入   nlines   行
记录 日志 中 引发 的 异常
目标 列表 的 删除 将 从 左 至 右 递归 地 删除 每 一个 目标
可用性 :   FreeBSD ，   NetBSD   7   或 更新 ，   OpenBSD .
创建 套 接字
打印 窗口 通过 默认 打印机 打印 当前 窗口
" SystemExit "   和   " KeyboardInterrupt "   异常 永远 不会 被 忽略
然后 必须 将 CPython 配置 为 ` `   with   dtrace ` ` ：
有关 完整 的 许可证 和 许可 信息 ， 参见 历史 和 许可证
" pathlib "   面向对象 的 文件系统 路径
不 支持   " loop . add _ signal _ handler ( ) "   和   " loop . remove _ signal _ handler ( ) "
（ 由   Lisa   Roach   在   bpo   26467   中 贡献 。 ）
形符 之间 的 空白
Python   将 安装 到 Program   Files 目录 中
作为   CPython   的 实现 细节 ， 如果   o   已经 是 一个 序列 或 列表 ， 它 将 被 直接 返回
返回 匹配   pathname   的 可能 为空 的 路径名 列表 ， 其中 的 元素 必须 为 包含 路径 信息 的 字符串
第三个 默认 查找 器会 在   import   path   中 搜索 模块
其他 语言 特性 修改
通过 使用 非 数据 描述 器 ，   这 两 方面 完成 了 无缝 融合
3.5   新版 功能 .
" if "   语句 用于 有 条件 的 执行 :
核心 与 内置
在   3.6   版 更改 :   items   can   be   passed   as   separate   arguments ,   not   just   as   a   single   tuple .
本 指南 的 这 一部分 包括 在 没有 第三方 工具 帮助 的 情况 下 创建   C   和   C   ++   扩展
从 一个 单独 的 可 迭代 参数 中 得到 链式 输入 ， 该 参数 是 延迟 计算 的
进阶 教程
通过 文件   " setup . py "   ， 和 文件   " demo . c "   ， 运行 如下
（ 由   Georg   Brandl   在   bpo   7962   中 贡献 ）
类 属性 ：
" xmlrpclib "   不 扩展 外部 实体 并 省略 它们
此 函数 会 创建 一个 可变 的 字符 缓冲区
命名 空间 对象
option   的 查找 顺序 为   vars   （ 如果 有 提供 ） 、   section   以及   DEFAULTSECT
在 这 两种 情况 下 都 返回 一个   " struct _ time "   对象 ， 日历 日期 组件 可以 从中 作为 属性 访问
扩展名 是 基于 日期 和 时间 的 ， 根据 轮换 间隔 的 长短 使用   strftime   格式   " % Y   % m   % d _% H   % M   % S "   或是 其中 有 变动 的 部分
海龟 前进   distance   指定 的 距离 ， 方向 为 海龟 的 朝向
这些 模块 不仅 可以 定义新 的 函数 ， 还 可以 定义新 的 对象 类型 及其 方法
本 函数 实现 了   " samefile ( ) "   和   " sameopenfile ( ) "   底层 所 使用 的 比较 过程
这 允许 应用程序 获得 一个 暂停 感知 的 单调 时钟 ， 而 不必 处理   " CLOCK _ REALTIME "   的 复杂性 ， 如果 使用   " settimeofday ( ) "   或 类似 的 时间 更改 时间 可能 会 有 不连续性
使用 示例 :   " fi   fileinput . FileInput ( openhook   fileinput . hook _ encoded ( " utf   8 " ,   " surrogateescape " ) ) "
其它
结束 压缩 进程 ， 返回 包含 保存 在 压缩器 的 内部 缓冲区 中 的 任意 数据 的   " bytes "   对象
来自   " popen2 "   模块 的 替代 函数
使用 累积 分布 函数   ( cdf ) ， 计算 一个 随机变量   X   小于 等于   x   的 概率
退出   raw   模式
展开 文本 展开 键入 的 前缀 以 匹配 同一 窗口 中 的 完整 单词 ； 重复 以 获得 不同 的 扩展
在 调用 此 方法 之后 ， 对象 将 无法 再 被 使用
我们 先 挑选 一部分 ， 每次 一个 字 段 :
立体声 片段 中 的 两对 采样 都 是从 单声道 计算 而来 的 ， 即 左声道 是 乘以   lfactor   ， 右声道 是 乘以   rfactor
第二个 参数 必须 为   " char   " ； 它 所 引用 的 指针 值 将 被 设为 带有 参数 文本 内容 的 缓冲区
" readline "   模块 定义 了 许多 方便 从   Python   解释器 完成 和 读取 / 写入 历史 文件 的 函数
此 行为 可 通过 对外部 函数 对象 的 特殊 属性 赋值 来自 定义
例如 ，   " word [ 1 : 3 ] "   的 长度 为 2 .
它 的 参数 与   " break "   相同
某些 归档 在 带有 非   ASCII   字符 字段 的 情况 下会 产生 计算错误 的 标头 校验 和
但 其 对应 的 函数 仍然 可用
注解 :
以下 是 一个 如何 使用 模版 的 示例 ：
当所 请求 的 文件 或 目录 不 存在 时 将 被 引发
默认 情况 下 解析器 还会 将 空行 视为 值 的 一部分
如果 编译 的 源码 不 合法 ， 此 函数 会 触发   " SyntaxError "   异常 ； 如果 源码 包含   null   字节 ， 则 会 触发   " ValueError "   异常
另 一个 常见 任务 是从 字符串 中 删除 单个 字符 的 每个 匹配 项 或 将 其 替换 为 另 一个 字符
具有 两个 可 选 参数 ， 它们 都 必须 指定 为 关键字 参数
返回 当前 抽象 基类 的 缓存 令牌
第三个 可 选 关键字 参数 是   stacklevel   ， 默认 为   " 1 "
" multiprocessing "   支持 进程 之间 的 两种 通信 通道 ：
信号 与 线程
补充 说明
条件 对象
当然 有 一种 变体 使用 组名 而 不是 数字
对于 大于 512 字节 的 分配 ， 它 回到 使用   " PyMem _ RawMalloc ( ) "   和   " PyMem _ RawRealloc ( ) "
通常 ， 我们 可以 指定 一个 扩展 模块 命名 空间 的 名字
一个 相关 的 函数 是   " itertools . accumulate ( iterable ,   func   operator . add ) "
用户 不 应 自行 创建 这些 类 的 实例
obj   必须 支持 单段 字符 缓冲 接口
generator   expression   生成器 表达式 返回 一个 迭代 器 的 表达式
如果 不再 有 可用 对象 则 返回   " None "
解析 一个 文档 类型 声明 :
发布 日期 :   2018   06   11
返回 一个   " time . struct _ time " ， 即   " time . localtime ( ) "   所 返回 的 类型
如果 对象 有效 并且 匹配 传入 的 名称 则 返回 非零值
模块 搜索 路径
文档
（ 由   Joannah   Nanjekye   在   bpo   35702   中 贡献 。 ）
此 方法 返回 一个 共享   source   对象 缓冲区 的   ctypes   实例
" tzinfo "   方法 可以 依赖 这 一点 ， 除非 用户 代码 直接 调用 了   " tzinfo "   方法
注册
出于 调试 目的 ， 如果 激活 了 区域 强制 转换 ， 或者 如果 当   Python   运行 时 被 初始化 时 某个 应该 触发 强制 转换 的 区域 选项 仍 处于 激活状态 则 设置   " PYTHONCOERCECLOCALE   warn "   将 导致   Python   在   " stderr "   上 发出 警告 消息
bpo   38117 :   使用 OpenSSL   1.1 . 1d 进行 测试
当 构造 类 对象 时 ， 基类 会 被 记住
在   3.7   版 更改 :   The   invalidation _ mode   parameter   was   added .
（ 由   Dong   hee   Na   在   bpo   35283   中 贡献 。 ）
PEP   3155 :   类 和 函数 的 限定 名称
" compileall "   模块 可以 为 一个 目录 下 的 所有 模块 创建 . pyc 文件
本   HOWTO   是 关于 使用   curses   和   Python   编写 文本 模式 程序 的 概述
这是 来自   Unix   第七版 的 第一个   tar   格式 ， 它 只 存储 常规 文件 和 目录
注解 :
请 注意 路径 的 任何 开头 部分 都 将 被 保留
在 默认 的   Task   实现 中 ， 名称 将 在 任务 对象 的   " repr ( ) "   输出 中 可见
为了 适用 于 Python ， 它们 都 被 重新 写过
用法 :
返回 一个 具有   k   个 随机 比特 位 的 整数
在 可能 的 情况 下 ， 会 通过 给 系数 添加 零来 将 指数 缩减 至 符合 限制
从流 中 读取 子 进程 提供 的 输出
返回 字节 码 操作 的 格式化 视图 （ 与   " dis . dis ( ) "   打印 相同 ， 但 作为 多行 字符串 返回 ）
3.8   新版 功能 .
如果 子类 定义 具有 单独 的   " _ fields _ "   变量 ， 在 其中 指定 的 字 段 会 被 添加 到 基类 的 字 段 中
（ 请参阅   PEP   393   了解 有关 实现 的 详情 。 ）   一旦 字符串 对象 要 在   CPU   和 内存 以外 使用 ， 字节 的 大小 端 顺序 和 字节 数组 的 存储 方式 就 成为 一个 关键问题
库
mode   参数 可设 为 二进制 模式 的   " ' r ' " 、 " ' rb ' " 、 " ' w ' " 、 " ' wb ' " 、 " ' x ' " 、   " ' xb ' " 、 " ' a ' "   或   " ' ab ' " ， 或者 文本 模式 的   " ' rt ' " 、 " ' wt ' " 、 " ' xt ' "   或   " ' at ' "
3.9   版后 已 移除 :   Classes   " Pattern "   and   " Match "   from   " re "   now   support   " [ ] "
如果 （ 在 文件系统 限制 下 ） 允许 将 任意   Unicode   字符串 用作 文件名 ， 则 为   " True "
在   3.5   版 更改 :   Added   support   for   the   " xz "   compression .
国际化
" SysLogHandler "   类 位于   " logging . handlers "   模块 ， 它 支持 将 日志 记录 消息 发送到 远程 或 本地   Unix   syslog
3.3   新版 功能 .
有效 的 描述符 包括 程序 名称   " % ( prog ) s "   和 传给   " add _ argument ( ) "   的 大部分 关键字 参数 ， 例如   " % ( default ) s " ,   " % ( type ) s "   等等 :
假定 有 一个 测试函数 ：
如果 该值 为 一个 整数 ， 它 将 被 原样 传递
为   AST   节点 添加 了 文档 字符串 ， 其中 包含   ASDL   签名 ， 可 被 用来 构造 对应 的 节点
对象 实现 支持
当前 海龟 位置 为 多边形 的 第一个 顶点
" ZoneInfo "   对象 的 序列化 是 基于 键 的 ， 而 不是 序列化 所有 过渡 数据 ， 并且 基于 文件 构造 的   " ZoneInfo "   对象 （ 即使 是 指定 了   " key "   值 的 对象 ） 不能 被 封存
当 给定   inline _ comment _ prefixes   时 ， 它 将 被 用作 非 空行 的 注释 的 前缀 子 字符串 的 集合
在   3.2   版 更改 :   这个 类 目前 会 在 可能 的 情况 下 （ 即 如果   " ssl . HAS _ SNI "   为 真值 ） 支持   HTTPS   虚拟主机
栈顶 元素 包含 一个 关键字 参数 名称 的 元组 ， 名称 必须 为 字符串
指明 数组 中 每个 元素 的 类型
如果 这些 属性 在 文法 中 标记 为 可选 （ 使用 问号 ） ， 对应 值 可能 会 是   " None "
杂项
从   Python   3.2   和   2.7 . 9   开始 ， 建议 使用   " SSLContext "   实例 的   " SSLContext . wrap _ socket ( ) "   来 将 套 接字 包装 为   " SSLSocket "   对象
在   3.7   版 更改 :   加入 对   " contextvars "   模块 的 支持
当然 ， 如果 你 想   " import   foo "   ， 则 需要   foo . pyd
在   3.2   版 更改 :   Added   the   "   i " ,   "   b "   and   "   h "   options .
（ 由   Raymond   Hettinger   在   bpo   13742   中 贡献 。 ）
ST   对象
encoding   如果 此 关键字 参数 与   filename   一同 被 指定 ， 则   该值 会 在 创建   FileHandler   时 被 使用 ， 因而 也 会 在   打开 输出 文件 时 被 使用
其他 线程 可以 调用 一个 线程 的   " join ( ) "   方法
其他 事项
关键 术语
3.7   版后 已 移除 :   The   option   is   deprecated   since   OpenSSL   1.1 . 0 .
源代码 :   Lib / plistlib . py
这些 类 的 实例 没有 共用 方法
Popen   构造函数
行 缓冲区
详情 参见   Porting   Python   code
返回 最近 打开 的 开始 标记 中 的 文本
" csv "   模块 定义 了 以下 类 ：
在   3.6   版 更改 :   接受 一个 类 路径 对象
如果 方法 成功 ， 则 整个 键 ， 包括 其 所有 值项 都 会 被 移除
重新 加载 之前 导入 的   module
" str "   和   " bytes "   对象 是 不可 变 的 ， 因此 将 多个 字符串 连接 在 一起 效率 很 低 ，   因为 每个 连接 都 会 创建 一个 新 对象
特殊 属性   " __ members __ "   是 一个 从 名称 到 成员 的 只读 有序 映射
3.9   新版 功能 .
队列 能 被 用于 多个 的 并发 任务 的 工作量 分配 ：
3.3   新版 功能 .
这些 内置 工具 同时 也 能 很 好 地 与   " operator "   模块 中 的 高效 函数 配合 使用
在   Content   Type   头字段 当中 设置 一个 参数
" dbm . dumb "   不是 为 高速运行 而 编写 的 ， 也 不 像 其他 数据库 模块 一样 被 经常 使用
这些 类型 的 对象 都 是 不可 变 的
现有 的   " FileHandler "   及其 子类 目前 并 不 使用   " multiprocessing " ， 尽管 它们 将来 可能 会 这样 做
bpo   23686 :   更新 OS   X   10.5   安装程序 以 使用 OpenSSL   1.0 . 2a .
正则 现在 已经 结束 了 ， 它 已经 匹配 了   " ' abcb ' "
[   脚注   ]
" posix "   最 常见 的   POSIX   系统 调用
因此 ， 在 默认 情况 下   " typed _ subpart _ iterator ( ) "   会 返回 每 一个   MIME   类型 为   text /   的 子 部分
Python 也 提供 一些 内置 数据类型 ， 特别 是 ， " dict " 、   " list " 、 " set " 、   " frozenset " 、 以及   " tuple "
以下 代码 将 打印 数据库   " db "   中 的 每个 键 ， 而 不会 在 内存 中 创建 一个 包含 所有 键 的 列表 :
工具 / 示例
打包 可变 长度 不 透明 数据流 ， 类似 于   " pack _ string ( ) "
如果   name   在 归档 中 找 不到 ， 则 会 引发   " KeyError "
可 选 参数   localedir   与   " bindtextdomain ( ) "   中 的 相同
创建 一个 共享 的   " threading . Condition "   对象 并 返回 它 的 代理
键 由 名称 以   " KEY _ "   开头 的 整数 常量 引用
在   3.7   版 更改 :   DST   差值 不再 限制 为 一个 整数 分钟 值
Server   对象
仔细 看 ：   " else "   子句 属于   " for "   循环 ，   不 属于   " if "   语句 。 ）
此 函数 会 调用 底层 库中 的   " remove _ history ( ) "
返回   x   的 以   10   为底 的 对数
一个 用户 定义 的 泛型 类 能够 使用 抽象 基本 类 作为 基类 ， 而 不会 发生 元类 冲突
这时 不再 需要 直接 调用   " asyncio . run ( ) " ， 因为 此 操作 会 在 每次 发起 调用 时 产生 一个 新 事件 循环 ：
与   Python   解释器 公开 的 大多 部 数据类型 不同 ， 缓冲区 不是   " PyObject "   指针 而是 简单 的   C   结构
安全
PEP   305   CSV   文件   API   由   Kevin   Altis ,   Dave   Cole ,   Andrew   McNamara ,   Skip   Montanaro ,   Cliff   Wells   撰写 并 实现
" xml . etree . ElementTree "   模块 实现 了 一个 简单 高效 的 API ， 用于 解析 和 创建 XML   数据
例如 ，   " Decimal ( float ( ' 1.1 ' ) ) "   转换 为 ` ` Decimal ( ' 1.10000000000000008881784   1970012523233890533447265625 ' ) ` `
Python   接口
在   Windows   上 ， 盘符 和 共享   UNC   始终 是 挂载 点 ， 对于 任何 其他 路径 ， 将 调用   " GetVolumePathName "   来 查看 它 是否 与 输入 的 路径 不同
在   3.8   版 更改 :   The   " punctuation _ chars "   attribute   was   made   compatible   with   the   " whitespace _ split "   attribute .
这个 函数 是 一个   decorator   ， 它 可以 定义 一个 支持   " with "   语句 上下文 管理器 的 工厂 函数 ，   而 不 需要 创建 一个 类 或区   " __ enter __ ( ) "   与   " __ exit __ ( ) "   方法
在   3.4   版 更改 :   将 代码 更 改为 使用   " importlib "   执行 字节 码 缓存 文件 写入
（ 由   Victor   Stinner   在   bpo   37481   中 贡献 。 ）
其他 语言 特性 修改
与   " logging . Handler "   类 不同 ， 应用 程序代码 可以 实例 化 格式化 程序 类 ， 但 如果 应用程序 需要 特殊 行为 ， 则 可能 会 对 格式化 程序 进行 子 类化
将 一个 方法 转换 为单 分派   generic   function
本章 介绍 的 模块 提供 了 网络 和 进程 间通信 的 机制
发生 异常 的 原因 是 显而易见 的 :   " 1 "   会 与 对象   " a _ tuple [ 0 ] "   相加 ， 而 该 对象 为   ( " 1 " ) ， 得到 结果 对象   " 2 " ， 但 当 我们 试图 将 运算 结果   " 2 "   赋值 给 元组 的   " 0 "   号 元素 时 就 将 报错 ， 因为 我们 不能 改变 元组 的 元素 所 指向 的 对象
如果 指定   angle   则 旋转 海龟 形状 使 其 指向   angle   指定 的 方向 ， 忽略 其 当前 的 倾角
测试
默认 情况 下 ， 尝试 创建 一个 设置 了 主机 位 的 网络 对象 将 导致   " ValueError "   被 引发
构建
方法 引用 将 按 以下 方式 解析 ： 搜索 相应 的 类 属性 ， 如 有 必要 将 按 基类 继承 链 逐步 向下 查找 ， 如果 产生 了 一个 函数 对象 则 方法 引用 就 生效
构建
一旦 调用 生成器 的 代码 创建 一个 迭代 器 ， 就 没有 办法 在 函数 恢复 执行 的 时候 向 它 传递 新 的 信息
十进制 浮点运算
将 本地 时间 与   UTC   时差 返回 为 一个   " timedelta "   对象 ， 如果 本地 时区 在   UTC   以东 则 为 正值
输出 以   10   为 基数 的 数字
" NormalDist "   示例 和 用法
本页 列出 常见 的 错误 和 陷阱 ， 并 解释 如何 避免 它们
" encodings . mbcs "   Windows   ANSI 代码 页
返回 或 设置 填充 颜色
如果 没有 强制 类型转换 机制 ， 程序员 必须 将 所有 可 兼容 参数 归一化 为 相同 类型 ， 例如 要 写成   " float ( 3 ) + 4.5 "   而 不是   " 3 + 4.5 "
确切 的 功能 取决于 系统
如果 一个 成员 在 归档 中 出现 超过 一次 ， 它 的 最后 一次 出现 会 被 视为 是 最新 的 版本
布尔运算   " and " ,   " or " ,   " not "
对应 于   " errno "   " ENOTDIR "
返回 当前 线程 状态 的 帧 ， 如果 没有 当前 执行 的 帧 则 返回   " NULL "
转换 由   " gmtime ( ) "   或   " localtime ( ) "   所 返回 的 表示 时间 的 元组 或   " struct _ time "   为 以下 形式 的 字符串 :   " ' Sun   Jun   20   23 : 21 : 05   1993 ' "
从块 堆栈 中 删除 一个 块
在 所有 情况 下 ， " join ( head ,   tail ) "   指向 的 位置 都 与   path   相同 （   但 字符串 可能 不同 ）
3.7   新版 功能 .
或者 ：
Python   支持 一些   Perl   的 扩展 ， 并 增加 了 新 的 扩展 语法 用于   Perl   的 扩展 语法
如果 创建 / 安装 任何 模块 ， 同时 正在 运行 的 程序 是 为了 保证 所有 的 查找 器 知道 新 模块 的 存在 ， 那么 应该 调用 这个 函数
注解 :
请 注意 客户端 可以 向 一个 实例 对象 添加 他们 自己 的 数据 属性 而 不会 影响 方法 的 可用性 ， 只要 保证 避免 名称 冲突 再次 提醒   ， 在 此 使用 命名 约定 可以 省去 许多 令人 头痛 的 麻烦
此 字典 可 作为 后续 调用   " pen ( ) "   时 的 参数 ， 以 恢复 之前 的 画笔 状态
它们 在   UTF   16   和   UTF   32   数据流 中 被 用以 指明 所 使用 的 字节 顺序   ， 并 在   UTF   8   中 被 用作   Unicode   签名
此 方法 将 在 每次 按 顺序 从 参数 文件 读取 一行 时 被 调用 一次
概述
这个 方法 使用 参数   " ' bar ' "   调用 ，   调用 对应 的 方法   " help _ bar ( ) "   ， 如果 不 存在 ， 打印   " do _ bar ( ) "   的 文档 字符串 ， 如果 可用
如果 匹配 指定 名称 的 字 段 没有 找到 ， 也 不会 抛出 任何 异常
在   3.7   版 更改 :   The   function   now   uses   the   UTF   8   encoding   in   the   UTF   8   mode .
3.5   新版 功能 .
请 注意   choices   容器 包含 的 内容 会 在 执行 任意   type   转换 之后 被 检查 ， 因此   choices   容器 中 对象 的 类型 应当 与 指定 的   type   相匹配 :
在   3.5   版 更改 :   _ charset   also   accepts   " Charset "   instances .
3.7   新版 功能 :   请参阅   PEP   538   了解 详情
" ; "   格式 单元 的 列表 结束 标志 ； 分号 后 的 字符串 被 用来 作为 错误 消息 取代 默认 的 错误 消息
实现   " TOS1 [ TOS ]   TOS2 "
" 导入 "   声明
" urllib . response "   urllib   使用 的   Response   类
3.4   新版 功能 .
函数 细节
这个 进程 可以 使用   " cancel _ join _ thread ( ) "   让   " join _ thread ( ) "   方法 什么 都 不 做 直接 跳过
在   3.2   版 更改 :   " ContextDecorator "   的 使用
在   o1   支持 的 前提 下该 操作 将 原地 执行
当找 不到 指定 节 时 引发 的 异常
从 回收 器 跟踪 的 容器 对象 集合 中 移除   op   对象
当 多个 条件 变量 需要 共享 同一个 锁时 ， 传入 一个 锁 很 有用
在 读取 和 写入 时 不会 自动 执行   " ' \ n ' "   的 转换
公共 类
所有 比较 操作 名称 的 序列
类型 ， 函数 和 其他 对象 的 自定义 归约
当前 指令 ， 表示 为   "   > "   ，
设置 线条 的 粗细 为   width   或 返回 该值
切片 项如为 一个 表达式 ， 则 其 转换 就是 该 表达式
在   3.7   版 更改 :   " README . rst "   is   now   included   in   the   list   of   distutils   standard   READMEs .
定制 解析器 行为
属性   " Color . RED " ,   " Color . GREEN "   等等 是 枚举 成员   ( 或称   enum   成员   )   并且 被 用作 常量
Unicode 对象 和 编码 解码器
扩展 / 嵌入 更改
" modulefinder "   查找 脚本 使用 的 模块
自定义 级别
理想 情况 下 ， 函数 应该 适合 一个 屏幕 （ 例如 ， 20   30 行 ）
宏 版本 的   " PyBytes _ AsString ( ) "   但是 不带 错误 检测
序列 的 解压 操作 也 支持 迭代 器 ： 如果 你 知道 一个 迭代 器 能够 返回   N   个 元素 ， 你 可以 把 他们 解压 到 有   N   个 元素 的 元组 :
这些 脚本 可以 通过 以下 命令 打开 所 提供 的 演示 查看器 运行 和 查看 :
如果 你 想要 讨论   Python   在 教育 中 的 使用 ， 你 可能 会 有 兴趣 加入   edu   sig   邮件 列表
必须 使用   " PyObject _ GC _ Del ( ) "   释放 对象 的 内存
在 您 的 可执行文件 中 包含 一个   " ._ pth "   文件 ， 其中 包含 目录
数字 类型   int ,   float ,   complex   描述 了 复数 类型
队列 集
类型 检查 器 应当 标记 违反 的 情况 ， 但 应当 也 允许 子类 中 调用 构造 器 符合 指示 的 基类
生成器 迭代 器 的 方法
特殊 的 值
虽然 内置 浮点 类型 只 公开 其 功能 的 一小部分 ， 但 十进制 模块 公开 了 标准 的 所有 必需 部分
连续性 的 请求
在 异步 生成器 函数 中 ， yield   表达式 允许 出现 在   " try "   结构 的 任何 位置
例外 ： 如果 最后 一个 命令 是   " list "   命令 ， 则 会 列出 接下来 的   11   行
在   3.9   版 更改 :   " default _ msec _ format "   可以 为   " None "
3.4   新版 功能 .
Popen   构造函数
与 标准 回溯 相比 ， 优势 在于 将 显示 已 编译 模板 中 的 源行
以下 特殊 序列 列表 不 完整
想要 给 一个 类 定义 它 自己 的 拷贝 操作 实现 ， 可以 通过 定义 特殊 方法   " __ copy __ ( ) "   和   " __ deepcopy __ ( ) "
[   脚注   ]
如果   " dataclass ( ) "   仅 用作 没有 参数 的 简单 装饰 器 ， 它 就 像 它 具有 此 签名 中 记录 的 默认值 一样
此外 ，   foo . pyd   不 需要 存在 来 运行 你 的 程序 ， 而 如果 你 将 程序 与   dll   链接 ， 则 需要   dll
PEP   471   os . scandir ( )   function   a   better   and   faster   directory   iterator   PEP   由   Ben   Hoyt   在   Victor   Stinner   的 帮助 下 撰写 并 实现
例程
摘要   ^ ^ ^ ^
最后 一个 三元组 用于 占位 ， 其值 为   " ( len ( a ) ,   len ( b ) ,   0 ) "
这份 文档 是否 有助于 你 理解 它们 ？   是否 存在 不 清楚 的 部分 ， 或者 你 遇到 的 问题 未 在 此处 涉及 ？   如果 是 ， 请 向 作者 发送 改进 建议
bpo   41045 :   添加 了 关于 f   strings 调试 功能 的 文档 .
更新 日志
库
替换 表达式 可以 包含 换行 （ 例如 在 三重 引号 字符串 中   ） ， 但是 不能 包含 注释
Python   3.7   有 什么 新 变化
如果 你 不 添加   "   v "   标志 ， 这一 标志 的 值会 是   " None "
是 的 ， 您 可以 在 C 中 创建 包含 函数 、 变量 、 异常 甚至 新 类型 的 内置 模块
传入 超过 这个 值 的   timeout   会 抛出   " OverflowError "   异常
设置 任何 其他 非空 字符串 会 在 解释器 初始化 期间 导致 错误
如果 提供 了 参数 ， 它会用   " shlex "   来 拆分 且 拆分 结果 将 被 用作 新 的   " sys . argv "
PEP   515 ,   数字 文字 中 的 下划线
" del "   语句
有关 过滤器 链 的 更 多 信息 请参阅 指定 自定义 的 过滤器 链
（ 由   Mark   Shannon ,   Antoine   Pitrou   和   Serhiy   Storchaka   在   bpo   17611   中 贡献 。 ）
除了   " getboolean ( ) " ， 配置 解析器 还 提供 了 同类 的   " getint ( ) "   和   " getfloat ( ) "   方法
ServerProxy   对象
其他 语言 特性 修改
在   3.3   版 更改 :   支持 任何 错误处理
" Counter "   对象
这个 标记 表示 一个   Python   行 即将 被 执行
我们 已经 知道 列表 和 元组 支持 迭代 器
如果 该 参数 为   " false "   则 当   ZIP   文件 需要   ZIP64   扩展 时   " zipfile "   将 引发 异常
更 多 相关 信息 ， 请参阅 有关 仅限 位置 形参 的   FAQ   条目
快速 上 手
用户 如果 要 重载 内置 命名 空间 中 的 值 则 应该   " import "   " builtins "   并 相应 地 修改 该 模块 中 的 属性
在   3.5   版 更改 :   该 功能 现在 始终 可用 且 始终 在 系统 范围 内
参见 由   " shutil "   模块 提供 的 归档 操作
（ 注意 每列 之间 的 一个 空格 是 通过 使用   " print ( ) "   的 方式 添加 的 ： 它 总是 在 其 参数 间 添加 空格 。 ）
这样 做 的 好处 是从   " io . IOBase . readlines ( ) "   创建 的 输入 将 得到 适用 于   " io . IOBase . writelines ( ) "   的 差异 信息 ， 因为 输入 和 输出 都 带有 末尾 换行符
线程 相关
" ' ! a ' "   应用   " ascii ( ) "   ， " ' ! s ' "   应用   " str ( ) " ， 还有   " ' ! r ' "   应用   " repr ( ) " :
这 使得 程序 相当 长 ， 浪费 了 宝贵 的 屏幕 空间 ， 使得 更 难以 对 程序 进行 全面 的 了解
" format _ field ( ) "   会 简单 地 调用 内置 全局 函数   " format ( ) "
[   示例   ]
属性 管理
你 也 可以 选择 将 此 信息 保存 至 文件 而 不是 将 其 发送至 浏览器
构建
访问 参数 的 项 :
也 可能 你 想 写 一个 小型 的 数据库 应用 ， 一个 特定 的 界面 应用 ， 或者 一个 简单 的 游戏
这是   " IndentationError "   的 一个 子类
Self   只是   " 方法 "   的 第一个 参数 的 常规 名称
在   o   由   " PySequence _ Fast ( ) "   返回 且   o   不 为   " NULL "   的 情况 下 返回   o   的 长度
查找 模块
3.7   新版 功能 .
如果 本地 时区 在   UTC   以西 则 为 负值
映射 接口 是 完整 而且 遵循   " MutableMapping "   ABC   规范 的
使用   " put _ nowait ( ) "   将 记录 排入 队列 ； 如果 你 想要 使用 阻塞 行为 ， 或 超时 设置 ， 或 自定义 的 队列 实现 ， 则 你 可能 会 想要 重载 此 方法
注意 ： " msvcrt "   是 微软   C   标准 库 ， 包含 了 大部分   C   标准 函数 ， 这些 函数 都 是 以   cdecl   调用 协议 进行 调用 的
与   " max ( ) "   方法 相似 ， 但是 操作数 使用 绝对值 完成 比较
EAFP   “ 求 原谅 比求 许可 更 容易 ” 的 英文 缩写
使用 起来 很 简单 ， 阅读 在 哪里 打补丁 来 快速 上 手
" ' AF _ UNIX ' "   地址 是 文件系统 上 文件名 的 字符串
第三方 工具 提供 更 易于 使用 和 更 安全 的 替代 方案
节点 对象
例如 :
这个 对象 仅 可以 使用   " Py _ None "   宏 访问 ， 这个 宏 取得 指向 这个 对象 的 指针
发布 日期 :   2018   02   27
返回 与 当前 进程 相对 应 的   " Process "   对象
上下文 和 启动 方法
通过 此 方法 可以 令 之前 绘制 于 画布 之外 的 图形 变为 可见
由   " open ( ) "   返回 的   Wave _ write   对象 ， 有 以下 几种 方法 :
常数
该类 中 所有 的 实值 分布 都 将 使用 新 的 方法 :
当 你 在 这些 操作 中 使用 一个 常规 字典 时 ， 键 将 按 顺序 进行 排列
如果 你 打开 过 一个 命令 窗口 ，   尝试 输入 命令   " py "   然后 按 回车 ：
已经 提出 的 一些 不可 接受 的 解决方案 ：
目前 ， 此 模块 跳过 输入 中 的 任何 XML 注释 、 处理 指令 和 文档 类型 声明
为了 安全 考虑 ， 默认值 为   " False "
这样 的 一个 测试代码 运行 的 环境 被 称为   test   fixture
此事 释放器 的 任何 行为 都 会 导致 额外 增加 的 Python 代码 来 检查 异常 是否 被 设置
要 从   " sys . modules "   删除 实体 或 导入 已 编译 模块 到 一个 进程 里 的 多个 解释器 (   或 使用   " fork ( ) "   而 没用   " exec ( ) "   ) 会 在 一些 扩展 模块 上 产生 错误
也就是说 默认 使用 小写字母 键名
执行 格式 错误
如果 没有 默认值 的 字 段 跟 在 具有 默认值 的 字 段 后 ， 将 引发   " TypeError "
引发 一个 审计 事件   " mmap .__ new __ "   附带 参数   " fileno " ,   " length " ,   " access " ,   " offset "
文字 转换
可以 使用   " Value "   或   " Array "   将 数据 存储 在 共享内存 映射 中
库
在   CPython   中 ， 以   C   编写 并 使用   " PyArg _ ParseTuple ( ) "   来 解析 其 参数 的 函数 实现 就 属于 这种 情况
取值 范围 是   " range ( 1000000 ) "
默认 使用 的 是   " utf8 "   charset   ，   language   为   " None "
直接   API   函数
编解码器 注册 与 支持 功能
此 模块 的 底层 的 进程 创建 与 管理 由   " Popen "   类 处理
随机 哈希 为 签名者 提供 了 额外 的 保护 ， 可以 降低 准备 者 在 数字签名 生成 过程 中 使得 两条 或 更 多条 消息 最终 产生 相同 哈希 值 的 可能性 即使 为 特定 哈希 函数 找到 碰撞 现象 是 可行 的
请 查看   " curses . textpad "   的 库 文档 了解 更 多 细节
（ 由   Xiang   Zhang   在   bpo   33106   中 贡献 。 ）
记录 日志 到 文件
更 多 关于 字符串 的 信息 查看 文本 序列 类型   str
你 可以 在 使用   " addfile ( ) "   添加   " TarInfo "   的 某些 属性 之前 修改 它们
将 数字 乘以   100   并 显示 为 定点   ( " ' f ' " )   格式 ， 后面 带   一个 百分号
唯一 的 限制 是 所用 的 所有 级别 必须 使用 此 函数 来 注册 ， 级别 值 必须 为 正整数 并且 它们 应当 按 严重 程度 递增 顺序 逐一 递增
" ipaddress "   IPv4 / IPv6   操作 库
返回 一个 新 的   " datetime "   对象 ， 对象 的 日期 部分 等于 给定 的   " date "   对象 的 值 ， 而 其 时间 部分 等于 给定 的   " time "   对象 的 值
由于 启用 了 许多 陷阱 ， 此 上下文 适用 于 进行 调试
然后 就 可以 单步 执行 上述 语句 之后 的 代码 ， 要 关闭 调试器 继续 运行 ， 请 使用   " continue "   命令
" Any "   对 每 一个 类型 都 兼容
返回 具有 同样   year ,   month   和   day   值 的   " date "   对象
PEP   540 :   强制   UTF   8   运行 时 模式
此 异常 将 在 使用   " weakref . proxy ( ) "   函数 所 创建 的 弱 引用 来 访问 该 引用 的 某个 已 被 作为 垃圾 回收 的 属性 时 被 引发
打包 由 同质 条目 构成 的 可变 长度   list
这是 作为 构造 器 的   template   参数 被 传入 的 对象
所有者 的 用户   ID
请 注意 此 返回值 不同于   Python   " sys . version " ， 它 将 总是 包括   patchlevel   ( 默认 为   " ' 0 ' " )
参考 指南
一个 仅 使用   Unix   风格 选项 的 例子 :
它们 也 可以 在 不 捕获   " DivisionByZero "   信号 捕获 时 通过 除以 零来 产生
在   3.6 . 6   版本 中 没有 新 的 更改
参见 :
返回 保存 在   capsule   中 的 当前 名称
这能 解释 它 为什么 报错
logdir   的 值 应当 是 一个 用于 存放 所 写入 文件 的 目录
从   collections   导入 的 操作 在   3.8   中 已 标记 为 被 移除 ， 但 将 推迟 到   3.9   中 实施
移植 到   Python   3.4
产生 这种 结果 有 两个 因素 ：
如果 未 提供 此 方法 ， 则 将 使用 适当 的 默认值
Type   对象
例如 ， 语句   " import   spam "   的 结果 将 为 与 以下 代码 作用 相同 的 字节 码 :
日志 操作手册
我 在 一些 应用 中 用到 了 它们 ， 并且 认为 保留 一个   ' heap '   模块 是 很 有 意义 的
两个 对象 不 要求 为 相同 类型
返回 指定 文件 路径 修改 时间 的 可选 的 抽象 方法
将 编码器 的 状态 设 为   state
输出 形参 可以 与   " errcheck "   协议 相结合 以 执行 进一步 的 输出 处理 与 错误 检查
图案 可以 作为 对象 或 字符串 提供 ； 如果 需要 指定 正则表达式 标志 ， 则 必须 使用 模式 对象 作为 第一个 参数 ， 或者 在 模式 字符串 中 使用 嵌入式 修饰符 ， 例如 :   " sub ( " ( ? i ) b + " ,   " x " ,   " bbbb   BBBB " ) "   返回   " ' x   x ' "
用法 示例 :   " datetime "
除   n   之外 的 所有 输入 都 必须 为 字节 串 对象 而 非 字符串
在 多个 地方 记录 日志
（ 此 功能 是 通过 调用   " getattr ( object ,   name ) "   看 是否 有   " AttributeError "   异常 来 实现 的 。 ）
[ 1 ]   实际上 ，   通过 对象 引用 调用 会 是 一个 更好 的 表述 ， 因为 如果 传递 的 是 可变 对象 ， 则 调用者 将 看到 被 调用者 对 其 做出 的 任何 更改 （ 插入 到 列表 中 的 元素 ）
拼接 字符串 序列 的 更好 更 快 方式 是 调用   " ' ' . join ( sequence ) "
Python   的 类 提供 了 面向对象编程 的 所有 标准 特性 ： 类 继承 机制 允许 多个 基类 ， 派生类 可以 覆盖 它 基类 的 任何 方法 ， 一个 方法 可以 调用 基类 中 相同 名称 的 的 方法
分子 和 分母 都 除以 二则 结果 小数 为 :
由   onerror   所 引发 的 异常 将 不会 被 捕获
如果 指定 了 一个 有效 的   align   值 ， 则 可以 在 该值 前面 加 一个   fill   字符 ，   它 可以 为 任意 字符 ， 如果 省略 则 默认 为 空格符
你 之前 很 可能 应该 已经 看过 这种 用法
无法 创建 真正 不可 变 的   Python   对象
构建
例如 ， 运行
将子 进程 的 控制 终端 连接 到 一个 伪 终端
示例 ：
增强 赋值 语句 将 对 目标 和 表达式 列表 求值 （ 与 普通 赋值 语句 不同 的 是 ， 前者 不能 为 可 迭代 对象 拆包 ） ， 对 两个 操作数 相应 类型 的 赋值 执行 指定 的 二元 运算 ， 并 将 结果 赋值 给 原始 目标
对于 一次性 压缩 ， 请 改用   " compress ( ) "   函数
连接 （ Connection ） 对象
当   DST   结束 时 （ 见   " end "   行 ） ， 会 有 更 糟糕 的 潜在 问题 ： 本地 时间 值中 有 一个 小时 是 不 可能 没有 歧义 的 ： 夏令时 的 最后 一 小时
" getcomptype ( ) "   的 通俗 版本
返回 由 输入   iterable   中 元素 组成 长度 为   r   的 子 序列
本 模块 中 的 所有 函数 都 带有 一个   dir   参数 ， 该 参数 可 用于 指定 目录 ， 这是 推荐 的 方法
" choices ( ) "   使用 的 算法 使用 浮点运算 来 实现 内部 一致性 和 速度
" HTMLCalendar "   有 以下 属性 ， 你 可以 重载 它们 来自 定义 应用 日历 的 样式
返回 列表 的 一个 浅 拷贝
3.1   新版 功能 .
结果 具有 以下 属性 ：
" turtle . cfg "   文件 可以 保存 于   " turtle "   所在 目录 ， 当前工作 目录 也 可以 有 一个 同名 文件
使用   DTrace   和   SystemTap   检测 CPython
maxsize   是 个 整数 ， 用于 设置 可以 放入 队列 中 的 项目数 的 上限
缓冲区 的 字节 大小 从 位置   offset   开始 必须 至少 为   " calcsize ( ) "   显示 的 格式 所 要求 的 大小
将 信号   signal   发送给 子 进程
而   " PyErr _ NewException ( ) "   函数 可以 创建 一个 类 ， 其 基类 为   " Exception "   ( 除非 是 另 一个 类 传入 以 替换   " NULL "   ) ，   细节 参见 内置 异常
异常 有 多 快 ？
导入 模块
由于 多线程 或者 多 进程 的 上下文 ， 这个 数字 是 不 可靠 的
大多数 动作 会 使用   " setattr ( ) "   为此 对象 添加 属性
当未 完成 计数 降到 零 的 时候 ，   " join ( ) "   阻塞 被 解除
PEP   484   类型 提示
参见 :
如果 名为   " pyvenv . cfg "   的 文件 存在 于   sys . executable   之上 的 一个 目录 中 ， 则   sys . prefix   和   sys . exec _ prefix   将 被 设置 为 该 目录 ， 并且 还会 检查   site   packages   （   sys . base _ prefix   和   sys . base _ exec _ prefix   始终 是   Python   安装 的   " 真实 "   前缀 ）
类似 于   " writeframes ( ) " ， 不同之处 在于 音频文件 的 标头 不会 被 更新
相比 原始   I / O ， 缓冲   I / O   流 提供 了 针对   I / O   设备 的 更 高层 级 接口
这些 弱 容器 类型 之一 或者   " finalize "   就是 大多数 程序 所 需要 的 通常 不 需要 直接 创建 自己 的 弱 引用
此 模块 支持 两种 数据格式 版本 ： 第   0   版为 历史 版本 ， 第   1   版本 会 在 文件 和   marshal   反 序列化 中 共享 固化 的 字符串
bpo   33184 :   在 Windows 安装程序 中将 OpenSSL 更新 为 1.1 . 0h .
对于 字符串 和 字节 串 类型 来说 ， 当且 仅 当   x   是   y   的 子串 时   " x   in   y "   为   " True "
除了 （ 部分 原因 ） 让 代码 兼容   Windows   以及 其他 的 进程 启动 方式 外 ， 这种 形式 还 保证 了 在 子 进程 生命期 这个 对象 是 不会 被父 进程 垃圾 回收 的
" if "   语句
集合
如果 结果 能 适合   width   则 将 其 返回
对 原始 输入 的 编码 操作 会 在 指定 位置 继续 进行
对于 与 文件系统 路径 有关   ( 例如   " open ( ) "   或   " os . unlink ( ) " )   的 异常 ，   " filename "   是 传给 函数 的 文件名
被 收录 软件 的 许可证 与 鸣谢
一个 集合 ， 其中 包含 此 模块 在 所有 平台 上 都 保证 支持 的 哈希 算法 的 名称
注解 :
字符 例如 空格 ， 制表符 ， 冒号 和 逗号 在 格式化 字符串 中会 被 忽略 ( 但是 不 包括 格式 单元 ， 如   " s # " )
然后 通过 调用   opener   并 传入   (   name   ,   flags   )   来 获取 文件 对象 所 对应 的 下层 文件 描述符
代码 对象 是   CPython   实现 的 低级 细节
返回   " set "   或   " frozenset "   对象 的 长度
初始值 继承 于 创建 线程
" % b "   本地化 的 月 缩写 名称
" Lock . acquire ( ) "   方法 中   timeout   参数 允许 的 最大值
字符串   " ' 0123456789 ' "
通过 组合 使用 此类 命令 ， 可以 轻松 地 绘制 出 精美 的 形状 和 图案
将 立体声 片段 转换 为 单声道 片段
二元 操作 从 堆栈 中 删除 堆栈 顶部 （ TOS ） 和 第二个 最 顶层 堆栈 项 （ TOS1 ）
在 开发阶段 此 特性 会 特别 有用 ， 因为 这样 你 将 能 在 一个 容器 中 运行   pydoc
十进制 的 等效值 是   ` 0.1000000000000000055511151231257827021181583404541015625 `
发布 日期 :   2019   06   04
" asyncio . Future . result ( ) "   和   " asyncio . Future . exception ( ) "   不 接受   timeout   参数
如果   max _ length   为 非 负数 ， 将 返回 至多   max _ length   个 字节 的 解压缩 数据
annotation   注解 关联 到 某个 变量 、 类 属性 、 函数 形参 或 返回值 的 标签 ， 被 约定 作为   type   hint   来 使用
注意 ： 如果 你 的 枚举 定义 了   " __ new __ ( ) "   和 / 或   " __ init __ ( ) "   那么 给予 枚举 成员 的 任何 值 都 会 被 传入 这些 方法
" ContextDecorator "   使得 你 可以 这样 改写 ：
PEP   8   建议 单例 对象 的 比较 应当 总是 通过   " is "   或   " is   not "   而 不是 等于 运算符 来 进行
高阶   API
类   " multiprocessing . Queue "   一个 用于 多 进程 上下文 的 队列 类 （ 而 不是 多线程 ）
同时 也 会 将   " map ( None ,   x ) "   替换 为   " list ( x ) "
核心 与 内置
"   "   和   " + "   操作符 的 绑定 是 最 紧密 的 ； 圆括号 用于 分组
发生 异常 会 令人 略感 吃惊 ， 还有 一个 更为 令人吃惊 的 事实 ： 虽然 有 报错 ， 但是 添加 操作 却 生效 了 :
默认 为   " 6 "
Cursor   对象
派生 的 枚举
此外 ， tab   补全 和 历史 编辑 会 自动 启用 ， 如果 你 的 系统 平台 支持 此 功能 的话   ( 参见   Readline   configuration )
PEP   487   自定义 类 创建   PEP   由   Martin   Teichmann   撰写 并 实现
在 需要 时   ， 程序员 可以 完全 控制 舍入 和 信号处理
该值 为   " True "
堆栈 查看器 在 树状 目录 中 显示 最后 一个 异常 的 堆栈 回溯 ， 可以 访问 本地 和 全局
抛出 异常
注解 :
上面 的 子类 设置   " __ slots __ "   为 一个 空 元组
意外
QUIT   干净 地 关闭 连接
在 文档 中用 Monty   Python 来 开玩笑 不 只是 可以 的 ， 还是 推荐 的 ！
文件 或者 是 命名 为   name   ， 或者 是 使用 文件 描述符 指定 为 一个   file   object   fileobj
它 作为   " types . MethodType "   向   Python   程序 公开
假设 有 一个 拥有 三个 孙 目录   " foo " ,   " bar "   和   " spam "   的 子目录   " / usr / local / lib / python   X . Y   / site   packages " ， 并且 有 两个 路径 配置文件   " foot . pth "   和   " bar . pth "
有 一些 是 由 语言 核心 定义 的 ， 但是 许多 对于 核心 语义 不是 必需 的 ， 并且 仅 在 这里 描述
PEP   307   Extensions   to   the   pickle   protocol   PEP   由   Guido   van   Rossum   和   Tim   Peters   撰写 和 实现
成功 时 返回   o   转换 为 浮点 对象 后 的 结果 ， 失败 时 返回   " NULL "
在 所有 情况 下 ， " drive   +   tail "   都 与   path   相同
由 日志 记录器 对应 过滤器 的   ID   组成 的 列表
在   3.7   版 更改 :   添加 了 仅 关键字 参数   preferred
如果 没有 字面 文本 （ 如果 连续 出现 两个 替换 字段 就 会 发生 这种 情况 ） ， 则   literal _ text   将 是 一个 长度 为 零 的 字符串
读取 由 之前 的   " putwin ( ) "   调用 存放 在 文件 中 的 窗口 相关 数据
在   3.7   版 更改 :   Previously   " DeprecationWarning "   and   " FutureWarning "   were   distinguished   based   on   whether   a   feature   was   being   removed   entirely   or   changing   its   behaviour
（ 由   Carl   Meyer   在   bpo   33499   中 贡献 。 ）
" os . path "   模块 始终 是 适合   Python   运行 的 操作系统 的 路径 模块 ， 因此 可 用于 本地 路径
在   3.5   版 更改 :   添加 了 对   " xztar "   格式 的 支持
查看   " BaseHandler . http _ error _ < nnn > ( ) "   以 获取 更 多 信息
添加 了   policy   关键字
由于   csv   模块 会 执行 自己 的 （   通用   ） 换行符 处理 ， 因此 指定   " newline   ' ' "   应该 总是 安全 的
参见 :
[ 1 ]   在   Distutils   完全 支持 自动 配置 之前 ， 这一 理想 可能 是 无法 实现 的
" html . entities "   HTML   一般 实体 的 定义
针对 无效   gzip   文件 也 可能 引发   " EOFError "   和   " zlib . error "
通常 ， nuget 包 不可 升级 ， 应该 平行 安装 较 新 版本 并 使用 完整 路径 引用
一个 用于 查找 指定 的 模块 中   loader   的 遗留 方法
bpo   41492 :   修复 了 UAC 提示 的 描述 .
在   3.9   版 更改 :   类 方法 现在 可以 包装 其他 描述 器 例如   " property ( ) "
[ 1 ]   可 选 参数   dialect   是 用于 不同 的   CSV   变种 的 特定 参数 组
请求 零 字节 可能 返回 一个 独特 的 非   " NULL "   指针 ， 就 像 调用 了   " PyMem _ Malloc ( 1 ) "   一样
如果 没有 任务 正在 等待 则 此 方法 为空 操作
The   background   state   is   set   for   widgets   in   a   background   window ,   and   cleared   for   those   in   the   foreground   window   只读   Widget   should   not   allow   user   modification   alternate   A   widget   specific   alternate   display   format   无效 的   控件 的 值 是 无效 的
本 参考手册 描述 了   Python   的 语法 和 “ 核心 语义 ”
在 一个 使用   " async   def "   定义 的 函数 或 方法 中 出现 的   yield   表达式 会 进一步 将 该 函数 定义 为 一个   asynchronous   generator   函数
filename   是 在 命令行 中 用来 替换   " % s "   的 文件名 ； 默认值   " ' / dev / null ' "   几乎 肯定 不是 你 想要 的 ， 因此 通常 你 要 通过 指定 一个 文件名 来 重载 它
请 注意 许多 平台 都 不 提供 此 信息 或是 简单 地 返回 与   " machine ( ) "   相同 的 值
该 规范 程序 在 概念 上 等效于 在   0.0   ≤   x   <   1.0   范围 内 对 所有   2 ⁻ ¹ ⁰ ⁷ ⁴   的 倍数 进行 选择 的 算法
模块
" datetime "   基本 的 日期 和 时间 类型
asyncio   提供 一组 高层 级   API   用于 :
可 选 参数 介绍
参阅   " dump ( ) "   的 文档 获取 此 函数 的 关键字 参数 的 说明
3.4   版后 已 移除 :   flags   参数
测试
如果 函数 失败 ， 则 引发 一个   " OSError "   异常
" sched "   事件 调度 器
你 还 可以 在 文件 的 当前 位置 开始 读取 和 写入 数据 ， 并 使用   " seek ( ) "   前往 另 一个 位置
参数   dir   、   prefix   和   suffix   的 含义 和 默认值 都 与 它们 在   " mkstemp ( ) "   中 的 相同
" codecs "   模块 定义 了 一系列 基类 用来 定义 配合 编解码器 对象 进行 工作 的 接口 ，   并且 也 可 用作 定制 编解码器 实现 的 基础
如果 索引 超出范围 ， 将会 引发   " IndexError "   ( 给 被 抽取 序列 赋值 不能 向 列表 添加 新项 )
在   " with "   语句 中 使用 锁 、 条件 和 信号量
3.1   新版 功能 .
等价 于   Python   表达式   " o1   o2 "
如果 获取 的 缓冲区 无效 则 会 由   " TarInfo . frombuf ( ) "   引发 的 异常
启用 所有 陷阱 （ 视为 异常 ） ， 但   " Inexact " ,   " Rounded "   和   " Subnormal "   除外
该 函数 在   Windows   上 不再 被 弃用
例如 ， 之后 :
当   o3   是   " Py _ None "   时 ， 等价 于   Python   语句   " o1   o2 " ； 否则 等价 于 在 原来 位置 储存 结果 的   " pow ( o1 ,   o2 ,   o3 ) "
本 模块 中 可用 的   HTTP   状态 码 常量 可以 参见   HTTP   状态 码
3.6   新版 功能 .
日志   HOWTO
3.9   新版 功能 .
在   3.6   版 更改 :   可 识别 针对   us   ascii   的 优化 机会
" Popen "   类 的 实例 拥有 以下 方法 ：
这会 阻塞 当前 进程 ， 直到 后台 线程 退出 ， 确保 所有 缓冲区 中 的 数据 都 被 写入 管道 中
这样 就 生成 了 一个 包含   3   个 长度 为 二 的 不同 列表 的 列表
非空 格式 描述 通常 会 修改 此 结果
" tarfile "   模块 现在 对 新 的 归档 默认 使用   modern   pax   ( POSIX.1   2001 )   格式 而 不再 是 之前 的   GNU   专属 格式
这是   " Repr "   的 一个 实例 ， 用于 提供 如下 所述 的   " repr ( ) "   函数
如果 所用 的 字典 类型 会 保留 顺序 ， 则 节 和 其中 的 键 将 按 顺序 加入
文字 编码
通常 情况 下 ， 使用   a . b   来 获取 、 设置 或 删除 一个 属性 时会 在   a   的 类 字典 中 查找 名称 为   b   的 对象 ， 但 如果   b   是 一个 描述 器 ， 则 会 调用 对应 的 描述 器 方法
" callback "   " buffer _ updated ( ) "   用 接收 的 数据 更新 缓冲区 时 被 调用
" ' r   gz ' "   打开 一个   gzip   压缩 的   stream   用于 读取
See   the   示例   section   of   the   " importlib "   documentation   for   details   of   the   various   approaches .
它 定义 了 以下 方法 ，   每个 增量 式 编码器 都 必须 定义 这些 方法 以便 与   Python   编解码器 注册表 相 兼容
依赖于 具体 平台 的 高效 拷贝 操作
" Pdb "   是 调试器 类
通过 调用   " text . splitlines ( True ) "   来 对行 进行 拆分
打开 一个   dbm   数据库 并 返回   " ndbm "   对象
https : / / github . com / ghaering / pysqlite   pysqlite 的 主页   sqlite3   在 外部 使用   “ pysqlite ”   名字 进行 开发
" py _ compile "   编译   Python   源文件
供参考 的 最新   PyPI   文档 可以 在 阅读 Python 包 用户 指南 找到
空 元组 的 类型 可 写作   " Tuple [ ( ) ] "
字节 串 的 内容 会 被 原样 发送到 终端
如果 成功 获取 到 所会 返回   " True " ， 否则 返回   " False "
等价 于 返回 第一个 操作数 乘以   " 10   other "   的 结果
我们 会 在 后面 了解 到   " del "   的 其他 用法
模块   " datetime "   为 日期 和 时间 提供 与   " time "   模块 相似 功能 的 面向对象 接口
由于 任何 字符 映射 编码 后 的 文件 都 不大可能 以 这些 字节 值 开头 （ 例如 它们 会 映射 为
然后 ， 你 记录 在 适配器 中 的 任何 事件 消息 前 将 添加 ` ` some _ conn _ id ` ` 的 值
相对   finally   代码 块 或 第一个   except   代码 块   delta   个 点数
在   3.6   版 更改 :   接受 一个 类 路径 对象
它们 可以 看作 面向 消息 的 连接 套 接字
在 锁定 状态 下 ， 某些 线程 拥有 锁   ；   在 非 锁定 状态 下 ，   没有 线程 拥有 它
" tkinter . commondialog "   对话 窗口 模板
针对 无效   gzip   文件 引发 的 异常
如果 被 读取 的 模块 是 一个包 ， 则 返回 的 字典 将 具有   " ' __ path __ ' "   键 ， 其值 是 一个 包含 包 搜索 路径 的 列表
返回值 被 用作   " onecmd ( ) "   方法 执行 的 命令 ；   " precmd ( ) "   的 实现 或许 会 重写 命令 或者 简单 的 返回   line   不变
" gc "   模块 提供 了 执行 垃圾 回收 、 获取 调试 统计 信息 和 优化 收集器 参数 的 函数
因此 ， 创建 了   " Decimal "   类型
此 操作 通常 只 在 没有 更好 随机性 源 的 系统 上 才 是 必要 的
( 2 )   " timedelta   date1   date2 "   ( 3 )   " date1   <   date2 "   如果   date1   的 时间 在   date2   之前 则 认为   date1   小于   date2
该 可 迭代 对象 前面 的 项 将 按 从 左 至 右 的 顺序 被 赋值 给 加星 目标 之前 的 目标
" z   "   ( " str " ,   bytes   like   object   or   " None " )   [ Py _ buffer ]   与   " s   "   类似 ， 但   Python   对象 也 可能 为   " None " ， 在 这种 情况 下 ，   " Py _ buffer "   结构 的   " buf "   成员 设置 为   " NULL "
bpo   34126 :   修复 在 分析 某些 未 绑定 的 方法 的 无效 调用 时 崩溃 的 问题
http : / / effbot . org / zone / element   index . htm   ElementTree   的 官方 文档
现在   " MessageBox "   外部 函数 可以 通过 以下 方式 来 调用 :
当   " n   >   0 "   时 ， 返回 项 个数 为   " ( n + r   1 ) !   /   r !   /   ( n   1 ) ! " .
返回 队列 的 大致 大小
返回 或 设置 画笔 颜色 和 填充 颜色
在 此 情况 下 ， 如果 对象 的   " name "   属性 存在 则 它 会 被 使用
枚举 成员 （ 即 实例 ）
将 服务器 设置 为 扩   展 命令 模式
现在   dict   和   dictview   可以 使用   " reversed ( ) "   按 插入 顺序 反向 迭代
3.6   新版 功能 :   [ 1 ]
构建
它会 等待 连接 然后 发送 一些 数据 给 客户端 :
请 注意   " ctypes . c _ char "   的 数组 具有   value   和   raw   属性 ， 允许 被 用来 保存 和 提取 字符串
如果   autoraise   为   “ True ” ， 则 会 尽可能 置前 窗口 （ 请 注意 ， 在 许多 窗口 管理器 下 ， 无论 此 变量 的 设置 如何 ， 都 会 置 前 窗口 ）
然后 使用   code   作为   " str . encode ( ) "   调用 的 编码
方法 和 特征 属性
必选 选项   an   option   that   must   be   supplied   on   the   command   line ;   note   that   the   phrase   " required   option "   is   self   contradictory   in   English
查找 给定 编码 的 编解码器 并 返回 其   " StreamWriter "   类 或 工厂 函数
这里 的   “ 可 直接 访问 ”   意味着 对 名称 的 非 限定 引用 会 尝试 在 命名 空间 中 查找 名称
当 你 的 数据 是 离散 的 ， 并且 你 希望 中位数 是 一个 实际 数据 点 而 非 插值 结果 时 可以 使用 高 中位数
" import "   语句 有 一个 变体 ， 它 可以 把 名字 从 一个 被 调 模块 内 直接 导入到 现 模块 的 符号表 里
" tzinfo "   对象
（ 由   Victor   Stinner   在   bpo   23404   中 贡献 。 ）
构造函数 接受 任何 具有 真值 的 对象
完整 的 语法 规范
SortedCollection   recipe   使用   bisect   构造 了 一个 功能 完整 的 集合 类 ， 提供 了 直接 的 搜索 方法 和 对 用于 搜索 的   key   方法 的 支持
在   3.1   版 更改 :   添加 了 对   " with "   语句 的 支持
filters   参数 （ 如果 提供 ） 应当 指定 一个 过滤器 链
将 文件 描述符   fd   的 模式 更 改为   cbreak
软件 打包 和 分发
经   hide   和   ignore   过滤 ， 目录   a   中 的 文件 与 子目录
存储 和 获取 指针 也 可以 用 多种 方式 ， 供 客户端 模块 使用
name   形参 应当 为 以 字节 数组 表示 的 人类 可读 的 压缩 类型 描述 ， type   形参 应当 为 长度 为   4   的 字节 数组
注解 :
什么 是   Python   软件 基金会 ？
setup   的 执行 时间 从 总体 计时 执行 中 排除
3.2   新版 功能 :   optimize   形参
返回 对应 于   POSIX   时间 戳 的 当地 时间 ， 例如   " time . time ( ) "   返回 的 就是 时间 戳
如果   flag   为   " True " ， 则 在 下次 调用   " refresh ( ) "   时 将 完全 清除 窗口
Python   本身 可以 告诉 你 哪些 功能 是 在 本 机上 可用 的
调用
让 我们 修改 以上 示例 ，   并发 运行 两个   " say _ after "   协程 :
" FileIO "   在 继承 自   " RawIOBase "   和   " IOBase "   的 现有 成员 以外 还 提供 了 以下 数据 属性 和 方法 :
例如 ， 相对 权重 ` ` [ 10 ,   5 ,   30 ,   5 ] ` ` 相当于 累积 权重 ` ` [ 10 ,   15 ,   45 ,   50 ] ` `
结果 是 无论 你 写下 多少 的 数字 ， 它 都 永远 不会 等于   1 / 3   ， 只是 更加 更加 地 接近   1 / 3
在   3.5   版 更改 :   Add   " __ qualname __ "   and   " gi _ yieldfrom "   attributes   to   generators . The   " __ name __ "   attribute   of   generators   is   now   set   from   the   function   name ,   instead   of   the   code   name ,   and   it   can   now   be   modified .
通过   " cdll . msvcrt "   调用 的 标准   C   函数 ， 可能 会 导致 调用 一个 过时 的 ， 与 当前   Python   所 不 兼容 的 函数
" LOAD _ GLOBAL "   指令 现在 会 使用 新 的   " per   opcode   cache "   机制
3.3   新版 功能 .
参见 :   PEP   441   Improving   Python   ZIP   Application   Support
大多数 更改 都 与 源代码 兼容 ， 通常 只 添加 API ， 而 不是 更改 现有 API 或 删除 API （ 尽管 某些 接口 会 首先 弃用 然后 再 删除 ）
无需 做出 特殊 努力 即可 获得 准确 的 结果
在 处理 符合标准 的 消息 的 时候   " BytesFeedParser "   非常 准确 ； 在 处理 不 符合标准 的 消息 的 时候 它 做 的 也 不差 ， 但 这视 消息 损坏 的 程度 而定
" LoadError "   是   " OSError "   的 一个 子类
如果 所 定义 的 任何 关键字 仅 在 特定   " __ future __ "   语句 生效 时 被 激活 ， 它们 也 将 被 包含 在内
可选 的   flag   参数 可以 是 ：
在 我们 的 例子 中 ， 我们 不仅仅 只是 输出 每个 文件 的 文件名 ， 还 输出 了 更 多 信息
构建 和   C   API   的 改变
使用   " object "   的 形式 如下 :
写入 已 包装 文件 的 数据 会 根据 给定 的   data _ encoding   解码 ， 然后 以 使用   file _ encoding   的 字节 形式 写入 原始 文件
例如 ， 可以 将 它们 合并 到 已 记录 的 消息 中
C   字符串 指明 异常 原因 ， 并 被 转换 为 一个   Python   字符串 对象 存储 为 异常 的 “ 关联 值 ”
内存 里 数据 读取 是 缓冲 的 ， 所以 如果 数据 尺寸 过大 或 无限 ， 不要 使用 此 方法
比方说 ， 要 创建 和 填充 节点   " ast . UnaryOp " ， 你 得 用
这种 比较 使用 字典 式 顺序 ： 首先 比较 开头 的 两个 对应 元素 ， 如果 两者 不 相等 则 比较 结果 就 由此 确定 ；   如果 两者 相等 则 比较 之后 的 两个 元素 ， 以此类推 ， 直到 有 一个 序列 被 耗尽
如果 可 选 参数   tz   为   " None "   或 未指定 ， 这 就 类似 于   " today ( ) " ， 但 该 方法 会 在 可能 的 情况 下 提供 比 通过   " time . time ( ) "   时间 戳 所 获 时间 值 更 高 的 精度 （ 例如 ， 在 提供 了   C   " gettimeofday ( ) "   函数 的 平台 上 就 可以 做到 这 一点   ）
（ 由   Aviv   Palivoda   在   bpo   30262   中 贡献 。 ）
提供 任何   pass _ fds   将 强制   close _ fds   为   " True "
当   " keylog _ filename "   受 支持 并且 设置 了 环境变量   " SSLKEYLOGFILE "   时 ，   " create _ default _ context ( ) "   会 启用 密钥 日志 记录
删除 轮询 对象 正在 跟踪 的 某个 文件 描述符
这 使得 区分 正确 构造 的 压缩 数据流 和 不 完整 或 被 截断 的 压缩 数据流 成为 可能
使用 增量 式 编码器 通过 迭代 来 编码 由   iterator   所 提供 的 输入
请 注意 ，   " filter ( function ,   iterable ) "   相当于 一个 生成器 表达式 ， 当   function   不是   " None "   的 时候 为   " ( item   for   item   in   iterable   if   function ( item ) ) " ； function   是   " None "   的 时候 为   " ( item   for   item   in   iterable   if   item ) "
" x   <   y   and   y   <   z "   意味着   " x   <   z "
构建
不 推荐 在 生产 环境 中 使用   " http . server "
当 从 命令行 发起 调用 时 ， " python   m   pickletools "   将 对 一个 或 更 多   pickle   文件 的 内容 进行 拆解
[   脚注   ]
profiler   分析器 模块 被 设计 为 给 指定 的 程序 提供 执行 概要 文件 ， 而 不是 用于 基准 测试 目的 （   " timeit "   才 是 用于 此 目标 的 ， 它 能 获得 合理 准确 的 结果 ）
这种 内存 泄漏 ， 一旦 引入 ， 通常 很 长时间 都 难以 检测 到 ， 错误 退出 被 调用 的 频度 较 低 ， 而 现代 电脑 又 有 非常 巨大 的 虚拟内存 ， 所以 泄漏 仅 在 长期 运行 或 频繁 调用 泄漏 函数 时才 会 变得 明显
引发 一个 审计 事件   " winreg . LoadKey " ， 附带 参数   " key " ,   " sub _ key " ,   " file _ name "
由此 构造 器 创建 的 对象 不可 被 封存   ( 参见   pickling )
幂 运算符
3.6   版后 已 移除 :   keyfile   and   certfile   are   deprecated   in   favor   of   ssl _ context
它 扩展 了 现有 的   ustar   格式 ， 包括 用于 无法 以 其他 方式 存储 的 附加 标头
如 未指定   extent   则 绘制 整个 圆
如果 你 只 想 匹配 小写字母 ， 你 的 正则 是   " [ a   z ] "
IDEL   具有 两个 主要 窗口 类型 ， 分别 是 命令行 窗口 和 编辑器 窗口
常用 于   " map ( ) "   中 的 实参 来 生成 连续 的 数据 点
" quopri "   编码 与 解码 经过   MIME   转码 的 可 打印 数据
安全
Python   Profilers   分析器
如果 指定 的 行自 上次 调用   " refresh ( ) "   后 发生 了 改变 则 返回   " True " ； 否则 返回   " False "
（ 由   Tarek   Ziad é   在   bpo   6693   中 贡献 。 ）
为什么   if / while / def / class 语句 需要 冒号 ？
3.3   新版 功能 .
有 一个 已 过时 方法   " warn "   其 功能 与   " warning "   一致
对于 一个 普通   Python   对象   " x " ， " complex ( x ) "   会 委托 给   " x .__ complex __ ( ) "
例如 ， 如果 你 有 一个 执行 某些 操作 的 函数 :
" queue "   模块 实现 了 多 生产者 、 多 消费者 队列
包
这 包括 使用 标准 通用 标记 语言 （ SGML ） 和 超文本 标记 语言 （ HTML ） 的 模块 ， 以及 使用 可 扩展 标记 语言 （ XML ） 的 几个 接口
命名 空间 包 的   " __ path __ "   属性 不 使用 普通 的 列表
所有 模块 都 有 自己 的 名字
要 找出 在 程序代码 中 写入 的 内容 ， 请 从 要 匹配 的 字符串 开始
以下 是 对 包含 两个 叶子 节点 的 最 小树 进行 哈希 的 例子 :
修改 XML 文件
实际 传给 处理程序 的 对象 就 是从   " prepare ( ) "   返回 的 对象
将 指定 的 异常 信息 （ 由   " sys . exc _ info ( ) "   返回 的 标准 异常 元组 ） 格式化 为 字符串
可选 的 第三项 是 该 形参 的 默认值
在   3.2   版 更改 :   已 移至 版本 2 方案 ， 该 方案 使用 字符串 种子 中 的 所有 位
数据 类 、 字典 、 列表 和 元组 被 递归
bpo   35471 :   Python2.4   取消 了 对 MacOS   9   的 支持
基于   frame   对象 创建 并 返回 一个 新 的 生成器 对象 ， 其中   " __ name __ "   和   " __ qualname __ "   设 为   name   和   qualname
通过 正则表达式 的 匹配 拆分 字符串
解冻 永久 代中 的 对象 ， 并 将 它们 放 回到 年老 代中
两个 形参 都 会 使用   " os . path . normcase ( ) "   进行 大小写 正规化
function   是 将 被 用来 解包 归档文件 的 可 调用 对象
如何 找到 未定义 的 g ++ 符号 __ builtin _ new 或 __ pure _ virtual ？
返回 采样 频率
这种 精确 的 十六进制 表示法 可 被 用来 精确 地 重建 浮点 值 :
这样 结果 块 绝对 不会 匹配 垃圾 元素 ， 除非 同样 的 垃圾 元素 正好 与 有 意义 的 匹配 相邻
例如 ：
这篇 文档 只有 在   https : / / setuptools . readthedocs . io / en / latest / setuptools . html   上 的   " setuptools "   文档 独立 涵盖 此处 包含 的 所有 相关 信息 之前 ， 才 会 单独 保留
少数 内置 模块 也 会 在 此 提及 ， 如果 它们 同 语言 描述 存在 明显 的 关联
参见 :
设备 已 无 可用 空间
contiguous   连续 一个 缓冲 如果 是   C   连续 或   Fortran   连续 就 会 被 认为 是 连续 的
" encodings . utf _ 8 _ sig "   带 BOM 签名 的 UTF   8 编解码器
和 以下 文本 中 的   " Spot . "
请 相信 我 ， 真正 优秀 的 磁带机 排序 看起来 是 极其 壮观 的 ， 排序 从来 都 是 一门 伟大 的 艺术 ！   :   )
time   参数 应该 有 一个 数字 类型 兼容 的 返回值 ， 与 传递 给 构造函数 的   timefunc   函数 的 返回值 兼容
其他 语言 特性 修改
filename   是 归档文件 的 完整 路径
如果 结果 四舍五入 到 最 接近 的 分数 差异 会 更 大 :
类似 于   " PyTuple _ GetItem ( ) " ， 但 不 检查 其 参数
https : / / docs . python . org   ： 快速访问 Python 的 文档
例如 ， 在 上面 的 示例 中 ， " Formatter "   已 设置 了 格式 字符串 ， 其 在   " LogRecord "   的 属性 字典 中 键值 为   “ clientip ”   和   “ user ”
通常 来说 是 做 不到 的 ， 因为 对象 并 不 真正 具有 名称
bpo   33128 :   修复 导致 PathFinder 在 sys . meta _ path 上 出现 两次 的 错误
注解 :
为了 获得 对 被 复制 区域 的 细粒度 控制 ， 可以 使用   " overlay ( ) "   的 第二种 形式
在 堆栈 回溯 中 ， 将 当前 帧 向下 移动   count   级 （ 默认 为   1   级 ， 移 向 更新 的 帧 ）
此 函数 的 调用 通常 会 先于 在   " listen ( ) "   的 返回值 上 调用   " join ( ) "
返回 最大 的   " int "   " <   self "
" tkinter . simpledialog "   标准   Tkinter   输入 对话框
这 是 个 更 高级 的 例子 ， 它 调用 了   " strchr "   函数 ， 这个 函数 接收 一个 字符串 指针 以及 一个 字符 作为 参数 ， 返回 另 一个 字符串 指针
或者 如果 一个 挂 起 的 任务 需要 被 删除 ， 你 该 如何 找到 它 并 将 其 移出 队列 ？
在 大多数 情况 下 ，   自定义 启动 程序 应该 只 需 使用 硬 编码 的 命令行 就 能 调用   " Py _ Main "
域   意义   " time _ low "   UUID 的 前 32 位   " time _ mid "   接前 一域 的 16 位   " time _ hi _ version "   接前 一域 的 16 位   " clock _ seq _ hi _ variant "   接前 一域 的 8 位   " clock _ seq _ low "   接前 一域 的 8 位   " node "   UUID 的 最后 48 位   " time "   UUID 的 总长 60 位 的 时间 戳   " clock _ seq "   14 位 的 序列号
这个 类 可 用于 创建   HTML   表格 （ 或 包含 表格 的 完整   HTML   文件 ） 以 并排 地 逐行 显示 文本 比较 ， 行间 与 行外 的 更改 将 突出 显示
重复 中 我们 要 了解 的 第一个 元字符 是   "   "
因此 ， 它 是 特定 于 平台 的 ， 除了 识别 始终 已知 的   UTC   和   GMT   （ 并且 被 认为 是非 夏令时 时 区 ）
发布 日期 :   2020   08   11
成功 时 返回   " 0 "
如果   max _ length   为 零则 整个 输入 都 会 被 解压缩 ， 并且   " unconsumed _ tail "   将 为 空
我们 将 在   Python   3.10   及 之后 版本 中 开始 使用 这种 灵活性
" webbrowser "   方便 的 Web 浏览器 控制器
将 继续 打印   " hello   world " ， 直到 结束
处理 异常
字典 的 工作 方式 是 使用   " hash ( ) "   内置 函数 计算 字典 中 存储 的 每个 键 的 hash 代码
致谢
些 方法 在 调用 时会 引发   " FrozenInstanceError "
匹配 字符
Pylint   和   Pyflakes   可 进行 基本 检查 来 帮助 你 尽早 捕捉 漏洞
请参阅 回调 函数 了解 有关 示例
在 所有 其他 空间 中 ， 坐标 取值 均 为   0   和   1   之间
" heapq "   堆 队列 算法
需要 注意 的 是 ， 对象 在 调用 此 方法 后 必须 仍 是 有效 的 （   不能 对 引用 只 调用   " Py _ DECREF ( ) "   方法 ）
DocTestParser   对象
第一个 字母 可以 为   " '   ' "   ( 这 表示命令 将 读取 其 标准 输入 ) ,   " ' f ' "   ( 这 表示命令 将 读取 在 命令行 中 给定 的 文件 )   或   " ' . ' "   ( 这 表示命令 将 不 读取 输入 ，   因而 必须 放在 前面 。 )
返回 一个 由 三 部分 组成 的   named   tuple   对象 :   " year " ,   " week "   和   " weekday "
多个 相邻 的 字符串 或 字节 串字 面值   ( 以 空白符 分隔 ) ， 所用 的 引号 可以 彼此 不同   ， 其 含义 等同于 全部 拼接 为 一体
" os "   多种 操作系统 接口
提供 的 运算   (   a   ,   b   为 矢量 ,   k   为 数值 ) :
Python 文档 内容
提示 用户 选择 一个 目录
6   个 可选 参数 仅 在 窗口 为 使用   " newpad ( ) "   创建 的 面板 时 可 被 指定
使用   " stdcall "   调用 规范 的 函数 只能 附带 与 此 元组 长度 相同 数量 的 参数 进行 调用 ； 使用   C   调用 规范 的 函数 还 可 接受 额外 的 未 指明 参数
如果   replacement   是 一个 函数 ， 则 为   pattern   的 每次 非 重叠 出现 将 调用 该 函数
在   3.4   版 更改 :   现在 可 接受 任意   bytes   like   object
概述
它会 影响 Python 的 每次 启动 ， 除非 它 以   "   s "   选项 启动 ， 以 禁用 自动 导入
" ' seconds ' " :   以   " HH : MM : SS "   格式 包含   " hour " ,   " minute "   和   " second "
发生 这种 情况 是因为   " x "   不是 lambdas 的 内部 变量 ， 而是 在 外部 作用域 中 定义 ，   并且 在 调用 lambda 时 访问 它 而 不是 在 定义 它 时
" itertools . takewhile ( predicate ,   iter ) "   返回 一直 让   predicate   返回   true   的 元素
一旦 你 真正 链接 上 了 ， 就 能 在 Python 解释器 中 扩展 或者 控制 C语言 编写 的 应用 了
3.3   新版 功能 .
此 方法 调用 之后 ，   查询 将会 终止 ， 而且 查询 的 调用者 会 获得 一个 异常
hash   对象 具有 以下 属性 ：
[ 2 ]   如果   x   恰好 非常 接近 于   y   的 整数倍 ， 则 由于 舍入 的 存在   " x / / y "   可能 会 比   " ( x   x% y ) / / y "   大
解释 型 语言 通常 具有 比 编译 型 语言 更 短 的 开发 /   调试 周期 ， 但是 其 程序 往往 运行 得 更慢
返回 三个 值 ： 字符串 形式 的   object   已 格式化 版本 ， 指明 结果 是否 可读 的 旗标 ， 以及 指明 是否 检测 到 递归 的 旗标
不 允许 导入   ZIP   中 的 动态 模组 （   " . pyd "   ，   " . so "   ）
[ 图片 ]
例如 :
对 分散 程度 的 评估
引发 一个 审计 事件   " shutil . copymode "   附带 参数   " src " ,   " dst "
记录 的 属性 字典 用作 字符串 格式化 操作 的 参数
PEP   465   用于 矩阵 乘法 的 专用 中缀 运算符
其他 功能
闰日 不 计算 在内 ， 因此 在 所有 年份 中 ， 2 月 28 日 是 第 59 天 ， 3 月 1 日 是 第 60 天
返回 具有 指定   hour ,   minute ,   second   and   microsecond   属性 的   " datetime . time "   对象
如果 对象   o   是 字节 对象 或 字节 类型 的 子 类型 的 实例 ， 则 返回   true
单个 元素 的 项 大小 （ 以 字节 为 单位 ）
回调 函数
这是 分块 的 头   4   个 字节
" msvcrt "   来自   MS   V C++   运行 时 的 有用 例程
组织 你 的 测试代码
好 的 设计 强制 要求 这种 方法 在 每个 情况 下 具有 相同 的 调用 签名 （ 因为 调用 顺序 是 在 运行 时 确定 的 ， 也 因为 该 顺序 要 适应 类 层级 结构 的 更改 ， 还 因为 该 顺序 可能 包含 在 运行 时 之前 未知 的 兄弟 类 ）
设置 为   " True "   如果 主机 打开 IPv6 ,   否则   " False "   .
度量 单位 设置
工具
在 其他 情况 下 ， 则 将 引发   " FileNotFoundError "   异常
要 读写   " . gz "   格式 的 文件 ， 请 参考   " gzip "   模块
PEP   526 :   变量 注释 的 语法
仅 初始化 变量
相当于   " a [ len ( a ) : ]   [ x ] "
当 异常 被 引发 时 通常 会 自动 创建 一个 回溯 对象 并 将 其 关联 到 可 写 的   " __ traceback __ "   属性
更 高 的 预设 等级 会 产生 更 小 的 输出 ， 但会 使得 压缩 过程 更 缓慢
只要 在 十六进制 数 之前 加 一个零 和 一个 小写 或 大写字母   " x "
如果 有   " maxsize "   个 条目 在 队列 中 ， 则 返回   " True "
在   3.3   版 更改 :   移 除了   strict   参数
不 需要 进行 边界 检查
（ 由   Dong   hee   Na   在   bpo   38493   中 贡献 。 ）
参见 :
上 一个 示例 的 配置 脚本 也 可以 写成 ：
输入 数据 应 经过   RLE   编码 ， 且 数据 长度 可 被 3 整除 （ 除了 最后 一个 片段 ）
参数 :   angle   一个 数值   ( 整型 或 浮点 型 )
构建
此 版本 只是 将 缓冲区 清空
之后 是 字符串 对应 的 字节
根据 字符串   str   的 值 创建 一个   " PyFloatObject " ， 失败 时 返回   " NULL "
IP 网络 对象 由 字符串 构成 ， 这些 字符串 定义 作为 该 网络 一部分 的 主机 地址 范围
否则 ， 这是 一个 查找 子包 或者 模块 的 方法 ， 并且   path   的 值 将 会 是 来自 父包 的   " __ path __ "   的 值
解析 参数
集成 新 的 命令
正则 作为 字符串 传递 给   " re . compile ( ) "
源代码 ：   Lib / traceback . py
这些 选择 当然 是 相互 排斥 的
3.3   新版 功能 .
用来 弹 出 对话框 接受 输入 并 分别 返回 字符串 和 数值
在   3.7   版 更改 :   The   function   now   also   uses   the   current   locale   encoding   for   the   " surrogateescape "   error   handler ,   except   on   Android
如果 没有 数字 ， 将 引发   " ValueError "
返回 活动 线程 的 当前 上下文
另 一节 描述 了 在 Python 中 使用 DOM 定义 的 异常
参考 内置 函数   " divmod ( ) "
" webbrowser "   模块 提供 了 一个 高级 接口 ， 允许 向 用户 显示 基于 Web 的 文档
可选 的 原地 过滤 :   如果 传递 了 关键字 参数   " inplace   True "   给   " fileinput . input ( ) "   或   " FileInput "   构造 器 ， 则 文件 会 被 移至 备份文件 并 将 标准 输出 定向 到 输入 文件 （ 如果 已 存在 与 备份文件 同名 的 文件 ， 它 将 被 静默 地 替换 ）
Python   中 赋值 语句 不 复制 对象 ， 而是 在 目标 和 对象 之间 创建 绑定   ( bindings )   关系
PEP   3118 :   新 的 内存 视图 实现 和 缓冲 协议 文档
返回 头字 段 的 总数 ， 重复 的 也 计算 在内
打包 可变 长度 字符串   s
本 机 字节 顺序 可能 为大端 或是 小端 ， 取决于 主机 系统 的 不同
解释器 所 加载 的   zlib   库 的 版本 字符串
命名 元组 赋予 每个 位置 一个 含义 ， 提供 可读性 和 自 文档 性
应 始终 使用 关键字 参数 调用 构造函数
测试 警告
该 函数 大致 相当于 下面 的 代码 ， 只不过 实际 实现 方案 不会 在 内存 中 创建 中间 结果
在 一个 文本文件 中 ， 没有 将   " sys . stderr "   与 字符串 字 面值   " ' sys . stderr ' "   区分 开来 的 标准 方式
DocTestParser   对象
参见 :
" str "   这个 类 是 用来 存储 Unicode 字符串 的 ， 而   " bytes "   和   " bytearray "   这 两个 类 是 用来 存储 二进制 数据 的
有关 装饰 器 的 详情 可 参见 函数 定义 和 类 定义 的 文档
这是 改变 计数器 的 一个 示例
datefmt   使用 指定 的 日期 / 时间 格式 ， 与   " time . strftime ( ) "   所 接受 的 格式 相同
移除
（ 由   Vinay   Sajip   在   bpo   4384   中 贡献 。 ）
gztar   :   gzip   压缩 的   tar   文件 （ 如果   " zlib "   模块 可用 ）
当 多个 线程 在   " acquire ( ) "   等待 状态 转变 为 未 锁定 被 阻塞 ， 然后   " release ( ) "   重置 状态 为 未 锁定 时 ， 只有 一个 线程 能 继续执行 ； 至于 哪个 等待 线程 继续执行 没有 定义 ， 并且 会 根据 实现 而 不同
构建 和   C   API   的 改变
元组 对象
从 共享内存 中 申请 一片 空间 将   ctypes   对象   obj   过来 ， 然后 返回 一个 新 的   ctypes   对象
要 从 堆栈 顶部 取出 一个 元素 ， 使用   " pop ( ) "   ， 不用 指定 索引
在   3.3   版 更改 :   默认 的   encoding   现在 将 为   " locale . getpreferredencoding ( False ) "   而 非   " locale . getpreferredencoding ( ) "
" Logger . log ( ) "   将 日志 级别 作为 显式 参数
有关   TtkStyling   的 更 多 信息 ， 请参阅   " Style "   类 文档
获取 最新 版本 的 Python
" secrets "   生成 安全 随机 数字 用于 管理 密码
有 一个   " __ hash __ ( ) "   意味着 类 的 实例 是 不可 变 的
3.7   新版 功能 .
为了 更 容易 指定 输入 和 输出 记录 的 格式 ， 特定 的 一组 格式 参数 组合 为 一个   dialect （ 变种 ）
例如 :
（ 由   Serhiy   Storchaka   在   bpo   40824   中 贡献 。 ）
如果 你 想 使用 无 填充色   ( 即令 海龟 变 透明 ) ， 你 必须 写   " fillcolor   " " "   ( 但   cfg   文件 中 所有 非空 字符串 都 不可 加 引号 )
以下 案例 展示 了   " SharedMemoryManager "   对象 的 一种 可能 更 方便 的 使用 方式 ，   通过   " with "   语句 来 保证 所有 共享内存 块 在 使用 完后 被 释放
" TMPDIR "   环境变量 指向 的 目录
" netrc "   netrc   文件 处理
一个 可选 的 增强型 交互式 解释器 是   IPython ， 它 已经 存在 了 有 一段时间 ， 它 具有   tab   补全 ， 探索 对象 和 高级 历史记录 管理 功能
请 注意 字典 的 键 和 值 均 为 任意 字节 数组
用于   plist   文件 的   XML   格式
名字 可以 传递 给 构造函数 ， 也 可以 通过   " name "   属性 读取 或者 修改
" RawTurtle "   ( 别名 :   " RawPen " )   类 定义 海龟 对象 在   " TurtleScreen "   上 绘图
如果 给出 了   extra _ args   ， 则 其 应为 一个   " ( name ,   value ) "   对 的 序列 ， 将 在 归档 器 可 调用 对象 被 使用 时 作为 附加 的 关键字 参数
参见 :
作用域 的 区   ID   如果 存在 ， 可 通过   " scope _ id "   属性 来 获取
" pwd "   用户 密码 数据库
为了 协助 管理 不同 进程 间 的 共享内存 生命周期   ， " multiprocessing . managers "   模块 也 提供 了 一个   " BaseManager "   的 子类 ：   " SharedMemoryManager "
这个 计数 比 它 的 等价 方法   " dict . setdefault ( ) "   要 快速 和 简单 ：
元 路径 查找 器 必须 实现 名为   " find _ spec ( ) "   的 方法 ， 该 方法 接受 三个 参数 ： 名称 、 导入 路径 和 目标 模块 （ 可 选 ）
比较 名为   f1   和   f2   的 文件 ， 如果 它们 似乎 相等 则 返回   " True "   ， 否则 返回   " False "
则 下面 特定 版 目录 将 以 如下 顺序 被 添加 到   " sys . path "
3.5   新版 功能 .
（ 由   Raymond   Hettinger   在   bpo   36320   中 贡献 。 ）
如果 正则表达式 模式 以 字节 类 表示 ， 这 相当于 类   " [ a   zA   Z0   9 _ ] "
例如 ， " tuple ( [ 1 ,   2 ,   3 ] ) "   产生   " ( 1 ,   2 ,   3 ) "   而   " tuple ( ' abc ' ) "   产生   " ( ' a ' ,   ' b ' ,   ' c ' ) "
PEP   362 :   函数 签名 对象
3.3   版后 已 移除 :   This   function   uses   simple   case   mappings .
如果 队列 满 了 ， 在 添加 元素 之前 ， 会 一直 等待 空闲 插槽 可用
安全
自定义 模块 属性 访问
此 操作 不 受 上下文 影响 且 静默 ： 不 更改 任何 标志 且 不 执行 舍入
字典 的 哈希 表 实现 使用 从 键值 计算 的 哈希 值来 查找 键
msg   事件 描述 消息 ， 可能 为 带有 可变 数据 占位 符 的 格式 字符串
（ 由   Marc   Andr é   Lemburg   实现 。 ）
给 函数 定义 有 可 变数 目的 参数 也 是 可行 的
删除 列表 中 给定 位置 的 元素 并 返回 它
对主 构造 器 的 调用 将 总是 返回 可 进行 标识 比较 的 对象 ； 但是 另 一种 方式 ， 对 所有 的   " key "   值 通过   " ZoneInfo . clear _ cache ( ) "   禁止 缓存 失效 ， 对 以下 断言 将 总是 为 真值 :
返回 的 值 等于 舍入 后 的 第一个 运算 数 并且 具有 第二个 操作数 的 指数
3.6 . 1   新版 功能 :   filenames   形参 接受 一个   path   like   object
严格 地说 ， 这些 定义 暗示 了 这样 的 说法 是 没有 意义 的 ： “ 这是 字符   " U + 265E " ”
它 不会 在 C 函数 中 触发
因此 ， 你 可以 使用   " WatchedFileHandler "   （ 相对 于 日志 记录 模块 ） 或   " mypackage . mymodule . MyHandler "   （ 对于 在   " mypackage "   包中 定义 的 类 和 模块   " mymodule "   ， 其中   " mypackage "   在 Python 导入 路径 上 可用   ）
" ^ "   在 行 的 开头 匹配
（ 由   Victor   Stinner   在   bpo   23404   中 贡献 。 ）
" colorsys "   颜色 系统 间 的 转换
3.9   新版 功能 .
但是 ， 可以 基于 ' derived '   " NewType "   创建   " NewType ( ) "
bpo   24214 :   修复 了 UTF   8 增量 解码器 对 surrogatepass 的 错误 回调 方法 的 支持
升序 和 降序
如果 不 想要 这样 的 行为 ， 请 通过 检测   " _ Py _ IsFinalizing ( ) "   或   " sys . is _ finalizing ( ) "   来 保护 该 调用
序列 （ 元组 / 列表 ）
请 注意 如果   fsrc   对象 的 当前 文件 位置 不 为   0 ， 则 只有 从 当前 文件 位置 到 文件 末尾 的 内容 会 被 拷贝
" KQ _ FILTER _ VNODE "   筛选 标志 ：
当 我 编辑 了 导入 过 的 模块 并 重新 导入 它 时 ， 这些 变化 没有 显示 出来
参见 :   Python   封装 使用指南 ： 二进制 扩展
删除 列表 中 所有 的 元素
如果 标识符 列表 改为 一个 星号   ( " '   ' " ) ， 则 在 模块 中 定义 的 全部 公有 名称 都 将 按   " import "   语句 所在 的 作用域 被 绑定 到 局部 命名 空间
注解 :
新 的 特性
但是 ， 句子 检测 算法 并 不 完美 ： 它 假定 句子 结尾 是 一个 小写字母 加 字符   " ' . ' " ,   " ' ! ' "   或   " ' ? ' "   中 的 一个 ， 并 可能 带有 字符   " ' " ' "   或   " " ' " " ， 最后 以 一个 空格 结束
https : / / bugs . python . org   Python   的 错误 追踪 器
但是 ， 切片 中 的 越界 索引 会 被 自动 处理 :
无效 的 参数
属性   描述   compiler   C / C   编译器   linker _ so   用于 创建 共享 对象 和 库 的 链接 器   linker _ exe   用于 创建 二进制 可执行文件 的 链接 器   archiver   静态 库 创建者
源代码 :   Lib / tabnanny . py
在 进行 解码 时   " utf   8   sig "   将 跳 过 这 三个 字节 ， 如果 它们 作为 文件 的 头 三个 字节 出现 的话
多线程
" CalledProcessError "   对象 将 在   " returncode "   属性 中 保存 返回 码
构建
3.2   新版 功能 .
返回 秒 ， 从 0 到 59 的 整数
在   3.5   版 更改 :   依据   PEP   488   修改   " . pyc "   文件名
在 Python 初始化 之前
泛型 元类 不再 被 支持
根据 C 类型   " Py _ complex "   的 值 生成 一个 新 的 Python 复数 对象
任何 包含 了   " yield "   关键字 的 函数 都 是 生成器 函数 ； Python   的   bytecode   编译器 会 在 编译 的 时候 检测 到 并 因此 而 特殊 处理
这样 可以 在 搜索 的 时候 跳过 第一个 映射
此 字典 必须 被 传给   " findmatch ( ) "   函数
双曲 函数
Installer   PATH   modification :   查找 Python 可执行文件
默认 为   " utf   8 "
当 没有 更 多 可用 行时 将 返回 一个 空 列表
构建
在 文件 描述符   fd   上 发送 一个 中断
调用 super 的 ` ` load _ module ( ) ` `
" FMT _ XML " :   XML   文件格式
如果 发生 了 异常 （ 例如 由于 有 界 队列 已满 ） ， 则 会 调用   " handleError ( ) "   方法 来 处理错误
此外 ， 可以 通过 在 次要 版本 之后 添加   “   32 ”   来 请求   32   位 版本
取值 范围 是   " range ( 1000000 ) "
参见 :
3.7   新版 功能 .
作为 替代 方式 ， 你 也 可以 子 类化 这个 类型 并 定义   " _ length _ "   和   " _ type _ "   类 变量
" collections . abc . Iterator "   的 泛型 版本
它们 从不 写入 超过   size   字节 （ 包括 结尾 的   " ' \ 0 ' "   ） 到 字符串
全局 配置 变量
选项
例如 ， 使用   spawn   或   forkserver   启动 方式 执行 下面 的 模块 ， 会 引发   " RuntimeError "   异常 而 失败
这 基本上 等价 于 ：
为了 使 数据 描述 器 成为 只读 的 ， 应该 同时 定义   " __ get __ ( ) "   和   " __ set __ ( ) "   ，   并 在   " __ set __ ( ) "   中 引发   " AttributeError "
对应 于   " errno "   " EISDIR "
默认 情况 下 ， 如果 一个 不是 队列 创建者 的 进程 试图 退出 ， 它会 尝试 等待 这个 队列 的 后台 线程
如果 一个 是 感知 型 而 另 一个 是 简单 型 ， 则 会 引发   " TypeError "
安装 期间 可以 选择 可 选 功能
这 可以 是 任何   Python   对象
使用   DTrace   和   SystemTap   检测 CPython
在   3.8   版 更改 :   在 Windows   上   executable   形参 可以 接受 一个 字节 串 和   path   like   object
默认 适配器 和 转换器
value   可以 为   " NULL "
返回 一个 具有 同样 属性 值 的   " time " ， 除非 通过 任何 关键字 参数 指定 了 某些 属性 值
可以 注意 到 ， 这 一新 的 能力 也 反映 在 帮助 文本 里
在   3.6   版 更改 :   Added   two   keyword   only   argument   to   the   reset _ mock   function .
修复 了 一个 漏洞 ， 它会 在 将 预期 的 调用 绑定 到   mock   的 规格 时 静默 接收 所 遇到 的 任何 错误 ， 从而 产生 误导性 的 错误 输出
对于 批量 格式化 多个 消息 ， 可以 使用   " BufferingFormatter "   的 实例
你 也 可以 通过 使用   pdb   代码 作为 样例 来 编写 你 自己 的 调试器
将 带有 属性   attr   的 字符串   str   中 的 至多   n   个字符 绘制 到   " ( y ,   x ) "   ， 覆盖 之前 在 屏幕 上 的 任何 内容
不同于   " PyMarshal _ ReadObjectFromFile ( ) " ， 此 函数 假定 将 不再 从 该 文件 读取 更 多 的 对象 ， 允许 其 将 文件 数据 积极 地 载入 内存 ， 以便 反 序列化 过程 可以 在 内存 中 的 数据 上 操作 而 不是 每次 从文件 读取 一个 字节
返回 关联 到 方法   meth   的 函数 对象
" functools . partialmethod ( ) " ,   " weakref . finalize ( ) " ,   " profile . Profile . runcall ( ) " ,   " cProfile . Profile . runcall ( ) " ,   " bdb . Bdb . runcall ( ) " ,   " trace . Trace . runfunc ( ) "   与   " curses . wrapper ( ) "   中 的   func
反汇编   x   对象
递归 控制
为 可 迭代 类 提供 了   " __ reversed __ ( ) "   方法 的 抽象 基类
如果 给定 一个 列表 或 字符串 ， 该   initializer   会 被 传给 新 数组 的   " fromlist ( ) " ,   " frombytes ( ) "   或   " fromunicode ( ) "   方法 （ 见下文 ） 以 将 初始 条目 添加 到 数组 中
DOM 的 权威 文档 是 来自 W3C 的 DOM 规范
核心 与 内置
类型 码   C   类型   Python   类型   以 字节 表示 的 最小 尺寸   注释   " ' b ' "   signed   char   int   1   " ' B ' "   unsigned   char   int   1   " ' u ' "   wchar _ t   Unicode   字符   2   ( 1 )   " ' h ' "   signed   short   int   2   " ' H ' "   unsigned   short   int   2   " ' i ' "   signed   int   int   2   " ' I ' "   unsigned   int   int   2   " ' l ' "   signed   long   int   4   " ' L ' "   unsigned   long   int   4   " ' q ' "   signed   long   long   int   8   " ' Q ' "   unsigned   long   long   int   8   " ' f ' "   float   float   4   " ' d ' "   double   float   8
与   " global "   语句 中 列出 的 名称 不同 ， " nonlocal "   语句 中 列出 的 名称 必须 指向 之前 存在 于 包含 作用域 之中 的 绑定 （ 在 这个 应当 用来 创建 新 绑定 的 作用域 不能 被 无 歧义 地 确定 ）
（ 由   Raymond   Hettinger   在   bpo   40465   中 贡献 。 ）
该 对象 不是 线程 安全 的
摘要 发布 重点
" linecache "   模块 允许 从 一个   Python   源文件 中 获取 任意 的 行 ， 并会 尝试 使用 缓存 进行 内部 优化 ， 常 应用 于 从 单个 文件 读取 多行 的 场合
通过 队列 实现 分布式 任务 ;
其他 语言 特性 修改
注意 urllib . request 中 的 Request 接口 也 支持 处理 所有 的 互联网协议
descr   必须 是 描述符 对象 ； 没有 错误 检查
基本 的   import   语句 （ 不带   " from "   子句 ） 会 分 两步 执行 :
“ 优化 过 的 ” 模块 有 一个   " opt   "   标签 并且 通常 小些
如果   " pyvenv . cfg "   （ 引导 程序 配置文件 ） 包含 设置 为 非   " true " （ 不 区分 大小写 ） 的   " include   system   site   packages "   键 ， 则 不会 在 系统 级 前缀 中 搜索   site   packages ； 反之 则 会
3.4   版后 已 移除 .
stdout   和   stderr   参数 不 应当 与   capture _ output   同时 提供
该 方法 必须 返回   " True " ,   " False "   或是   " NotImplemented "
测试 和 调试 函数 式 程序 相对来说 更 容易
在 不 支持 符号 链接 的 系统 上 参数 将 不起作用
该 标准 还 区分   "   0 "   和   " + 0 "
它们 将会 引发   " UnsupportedOperation "
需要   " lzma "   模块
如果 添加 了 新 的 播种 方法 ， 则 将 提供 向 后 兼容 的 播种机
协议
有关 新 软件 发布 和 活动 的 公告 可以 在   comp . lang . python . announce   中 找到 ， 这 是 个 严格管理 的 低 流量 列表 ， 每天 会 收到 五个 左右 的 发帖
其他 对象
在 最 简单 的 情况 下 ， 一个 Request 对象 里 包含 你 所 请求 的 特定 URL
简单 的 升序 排序 非常简单 ： 只 需 调用   " sorted ( ) "   函数 即可
limit   参数 为   " Process . stdout "   和   " Process . stderr "   设置   " StreamReader "   包装 器 的 缓冲区 上限 （ 如果 将   " subprocess . PIPE "   传给 了   stdout   和   stderr   参数 ）
通过 对此 属性 赋值 就 可以 在   " IncrementalEncoder "   对象 的 生命 期内 在 不同 的 错误处理 策略 之间 进行 切换
由   urlopen   （ 或者   " HTTPError "   实例 ） 所 返回 的 响应 包含 两个 有用 的 方法 ：   " info ( ) "   和   " geturl ( ) " ， 该 响应 由 模块   " urllib . response "   定义
请 注意 ， 该 分析器 中 对 累积 时间 的 异常 处理 ， 允许 直接 比较 算法 的 递归 实现 与 迭代 实现 的 统计 信息
如果 定义 了   " find _ spec ( ) "   ， 则 提供 了 向 后 兼容 的 功能
这 意味着 如果 你 需要 其他 数据类型 ， 你 应当 自己 来 转换 :
配置 的 处理 方式 将 与 所有 日志 记录器 一致 ， 除了   " propagate "   设置 将 不可 用 之外
如果   capture   是   " False " ， 则 将 停止 将 警告 重定向 到 日志 记录 系统 ， 并且 将 警告 重定向 到 其 原始 目标 （ 即 在   " captureWarnings ( True ) "   调用 之前 的 有效 目标 ）
配置 数据源
decimal . py   _ decimal   加速   pi   42.02 秒   0.345 秒   120 倍   telco   172.19 秒   5.68 秒   30 倍   psycopg   3.57 秒   0.29 秒   12 倍
将 非   " multipart "   消息 转换 为   " multipart / related "   消息 ， 将 任何 现有 的   Content   标头 和 载荷 移入   " multipart "   的 （ 新加 ） 首 部分
参见 :
牢记 ， 即使 输出 的 结果 看起来 好像 就是   1 / 10   的 精确 值 ， 实际 储存 的 值 只是 最 接近   1 / 10   的 计算机 可 表示 的 二进制 分数
Python   3.6 . 4   正式版
这些 说明 材料 同时 适用 于   Windows   程序员 学习 构建   Python   扩展 以及   Unix   程序员 学习 如何 生成 在   Unix   和   Windows   上 均 能 成功 构建 的 软件
成功 时 返回   o1   和   o2   的 拼接 ， 失败 时 返回   " NULL "
请 注意 此 方法 对于 递归 对象 将 返回   " False "
将   " raise   E ,   V "   转换 为   " raise   E ( V ) " ， 将   " raise   E ,   V ,   T "   转换 为   " raise   E ( V ) . with _ traceback ( T ) "
在 大多数 情况 下 ， 你 应该 使用 你 想要 的 各种 部分 来 构造 一个 新 字符串
实现   " TOS   TOS1   > >   TOS "
3.4   版后 已 移除 :   The   import   machinery   takes   care   of   this   automatically .
这个 修复器 是 可选 的
库
这 类似 于 非   GNU   Unix   系统 的 运作 方式
外部 函数 也 可 通过 实例 化 函数 原型 来 创建
用   bytes   like   object   来 更新 哈希 对象
第二个 位是 类型 对象 的 定义 :
" collections . abc . Reversible "   的 泛型 版本
修正 拼写错误
" enum "   对 枚举 的 支持
有关 其他 容器 请 参看 内置 的   " frozenset " ,   " list " ,   " tuple "   和   " dict "   类   ， 以及   " collections "   模块
警告 :
或者 ， 更 近似 的 ， :
一个 只读 属性
数字 和 数学 模块
自定义 字符串 格式化
在 其他 情况 下 ， 一个 多行 选项 内部 的 空行 会 被 保留 为值 的 一部分
Repr   对象
在   3.5   版 更改 :   添加 了 对 切片 操作 的 支持
在   3.1   版 更改 :   Added   ability   to   execute   packages   by   looking   for   a   " __ main __ "   submodule .
以下 形符 在 语法 中 归类 为 分隔符 :
例如 ， " 0 / 0 "   会 返回   " NaN "   表示 结果 “ 不是 一个 数字 ”
此 对象 可 被 用来 执行 增量 数据 解压缩
当 处于 非 阻塞 模式 时 ， 如果 需要 将 数据 写入 原始 流 但 它 无法 在 不 阻塞 的 情况 下 接受 所有 数据 则 将 引发   " BlockingIOError "
3.2   新版 功能 :   将 可选 的   " source "   和   " lineno "   属性 和 参数 添加 到   " __ init __ ( ) "
成功 时 返回   " 0 " ， 失败 时 返回   "   1 "
参见 :
画笔 抬起 移动 时 不 画线
如果 你 想要 的 只是 一个 独立 的 程序 ， 用户 可以 下载 和 运行 而 不必 先 安装 Python 发行版 ， 你 就 不 需要 将 Python 编译成 C 代码
返回   code   依据   tableB.3   ( 不 附带 正规化 的 大小写 折叠 映射 )   所 映射 的 值
另外 还 可以 通过 使用 一个 管理器 对象 创建 一个 共享 队列 ， 详见 管理器
XML   解析器 访问 资源 并 将 内容 嵌入 到   XML   文档 中
" groupby ( ) "   假定 了 所 依据 的 可 迭代 对象 的 内容 已经 根据 键值 排序
基于 文件 句柄   handle   创建 一个   C   运行 时 文件 描述符
3.3   新版 功能 .
这个 实现 会 轮询 处理 文件 描述符   ( pidfds )   以 等待 子 进程 终结
（ 由   Eric   V
如果 找 不到 指定 模块 名称 ， Python   将 继续 搜索 该 模块
如果   Python   是 在 调试模式 下 编译 的 ， 这些 钩子 是   installed   by   default
它们 不 被   " bytes . decode ( ) "   所 支持 （ 该 方法 只 生成   " str "   类型 的 输出 ）
制表符 会 引入 混乱 ， 最好 不要 使用 它
组合 函数
以下 是 综述 ：
在   3.7   版 更改 :   加入   initializer   和   initargs   参数
default   section   不 包含 在内
可 调用 类型 ；   " Callable [ [ int ] ,   str ] "   是 一个 函数 ， 接受 一个   int   参数 ，   返回 一个   str
[   Future   对象   ]
" Exception "   的 子类 ， 此 异常 可 由   " uu . decode ( ) "   在 多种 情况 下 引发 ， 如上 文 所述 ， 此外 还 包括 格式 错误 的 标头 或 被 截断 的 输入 文件 等
对象 上 的 方法 调用 的   mock
此 方法 不可 用于 生成 安全 凭据
请 注意 它 的 输出 在 多线程 应用程序 中 可能 会 出错
具体 的 对象 层
作为   tzinfo   参数 被 传给   " datetime "   构造 器 的 对象 ， 如果 没有 传入 值则 为   " None "
字符串 在 花 括号 以外 的 部分 按其字 面值 处理 ， 除了 双重 花 括号   " ' { { ' "   或   " ' } } ' "   会 被 替换 为 相应 的 单个 花 括号
这仅 适用 于 格式 字符串   fmt   ( 例如   " ' % ( message ) s ' "   或   " { message } " ) ， 不适 用于 传递 给   " Logger . debug "   的 实际 日志 消息 等 ； 请参阅   Using   particular   formatting   styles   throughout   your   application   了解 有关 在 日志 消息 中 使用   {   和   $   formatting   的 更 多 详情
它 继承 自   " IOBase "   类
抽象 语法 定义 的 每个 左侧 符号 ( 比方说 ，   " ast . stmt "   或者   " ast . expr " ) 定义 了 一个 类
用于 硬 编码 一个 断点 到 程序 中 的 固定点 处 ， 即使 该 代码 不 在 调试 状态 （ 如 断言 失败 时 ）
注解 :
默认值 为   " None "   ( 直接 比较 元素 )
提取 给定 的 字 段值
以下 函数 已 从 受限   C   API   中 排除 :
它 总是 会 被 添加 到   " PYTHONPATH "
3.4   版后 已 移除 :   加载 模块 推荐 的 使用 的   API   是   " exec _ module ( ) "   ( 和   " create _ module ( ) " )
使用   " _ structure "   除错 帮助 函数 可以 帮助 我们 在 下面 这个 例子 当中 看清楚 这 一点 ：
Decimal   对象
函数
" Process .__ init __ ( ) "   的 所有 参数 都 必须 可 序列化
补充 说明
例如 ， " ( ab )   "   将 匹配   " ab "   的 零次 或 多次重复
可选 的   mode   参数 是 文件 的   Unix   模式 ， 仅 在 要 创建 数据库 时才 会 被 使用
如果 收到 的 回复 与 使用   authkey   作为 键 生成 的 信息 摘要 匹配 成功 ， 就 会 发送 一个 欢迎 信息 给 管道 另一端
另 一个   " dataclass ( ) "   检查 类型 注解 地方 是 为了 确定 一个 字 段 是否是 一个 仅 初始化 变量
我应 如何 获取 一份   Python   源代码 的 副本 ？
这 不 一定 是 一个 简单 的 问题
" fillcolor ( r ,   g ,   b ) "   设置 填充 颜色 为   r   ,   g   ,   b   表示 的   RGB   颜色
返回   "   1 "   表示 出错
" tp   槽 "
返回 一个 文件 类 对象 ， 打开 到   file   ， 但是 将 从 管道 读取 或 写入
返回 这些 分隔 区 对应 的   ( n   1 )   个 分隔 点 的 列表
内省
测试
当 需要 为 缓冲区 加上 泛型 包装 器时 ， 可以 创建 一个 内存 视图 对象
队列 集
在   3.6   版 更改 :   退出 时 打印 退出 消息
它 等价 于   " [ n   for   n   in   names   if   fnmatch ( n ,   pattern ) ] " ， 但 其 实现 更为 高效
在   3.3   版 更改 :   新增 了   " wait _ for ( ) "   方法
打印 由   " calendar ( ) "   返回 的 整年 的 日历
要 同时 支持   3.8   和 旧版本 ， 请 先 尝试   " python3   config   libs   embed "   并 在 此 命令 失败 时 回退 到   " python3   config   libs "   ( 即不带   "   embed " )
否则 ： 该 对象 必须 为 具有 与 目标 列表 相同 项数 的 可 迭代 对象 ， 这些 项 将 按 从 左 至 右 的 顺序 被 赋值 给 对应 的 目标
如果 监听器 对象 使用 了 套 接字 ，   backlog   ( 默认值 为 1 )   会 在 套 接字 绑定 后 传递 给 它 的   " listen ( ) "   方法
参见 :
即使 存在 原生 的 密钥 哈希 模式 ， BLAKE2   也 同样 可 在   " hmac "   模块 的   HMAC   构造 过程 中 使用 :
在 最终 的 归档 中 ， 应当 会 包括   " please _ add . txt " ， 但 不 应当 包括   " do _ not _ add . txt "
对象 、 值 与 类型
它 被 创建 时为 非 锁定 状态
本质 上 ， 这些 函数 只是 为 你 创建 一个 模式 对象 ， 并 在 其 上 调用 适当 的 方法
一个 再次 读取 配置文件 的 示例 :
标准 模块
如果   backupCount   不为 零 ， 则 最 多 将 保留   backupCount   个 文件 ， 而 如果 当 轮换 发生 时 创建 了 更 多 的 文件 ， 则 最 旧 的 文件 会 被 删除
这个 类 不是 线程 安全 的
PyZipFile   对象
分隔符
接下来 的 属性 仅能 通过 关键词 参数设置
返回 以 坐标值 对 元组 表示 的 当前 形状 多边形
另一方面 ， 如果 所有 全局 引用 都 需要   " global "   ， 那么 你 一直 都 在 使用   " global "
escaped   这个 组 匹配 转义序列 ， 在 默认 模式 中即   " $ $ "
数字 字 面值
这 在 使用 协作 多重 继承 的 框架 中 可以 被 用作 超 调用 的 一个 端点
在 解压缩 期间 中断 执行 ， 例如 按下   ctrl   C   或 杀死 解压缩 进程 可能 会 导致 归档文件 的 解压缩 不 完整
如果 对象 一直 未 被 作为 垃圾 回收 ， 终结 器 仍会 在 退出 时 被 调用
相邻 的 两个 或 多个 字符串 字 面值   （ 引号 引起 来 的 字符 ） 将会 自动 连接 到 一起   .
简单 的 队列 ， 缺少 任务 跟踪 等 高级 功能
Python   3.7 . 2   中 的 重要 变化
为了 产生 这种 行为 ，   " ' resolve ' "   值 可以 提供 给   " ArgumentParser "   的   " conflict _ handler   "   参数 :
一旦 使用 花 括号 将 占位 符括 起来 ， 就 可以 在 后面 直接 跟上 更 多 的 字母 和 数字 而 无需 空格 分割
此 函数 被 用作 较 旧版本   " ndiff ( ) "   中   linejunk   形参 的 默认值
编程 指导
空格 的 作用 仅限于 分隔 形符
异常
3.4   新版 功能 .
返回 用于 显示 指定 颜色 的 文本 的 属性 值
在 调用   " flush ( ) "   之后 ， " decompress ( ) "   方法 将 无法 被 再次 调用 ； 唯一 可行 的 操作 是 删除 该 对象
如果   ensure _ ascii   是   true   （ 即 默认值 ） ， 输出 保证 将 所有 输入 的 非   ASCII   字符 转义
这篇 文档 只有 在   https : / / setuptools . readthedocs . io / en / latest / setuptools . html   上 的   " setuptools "   文档 独立 涵盖 此处 包含 的 所有 相关 信息 之前 ， 才 会 单独 保留
它们 将 比较 运算符 定义 为 子集 和 超集 检测
使用 默认 浏览器 显示   url
（ 由   Geert   Jansen   在   bpo   21965   中 贡献 。 ）
换句话说 ， 导入 时 的 函数调用 不会 被 列出
以下 示例 仅 当 它 是 一个 完整 的 单词 时 匹配   " class " ； 当 它 包含 在 另 一个 单词 中时 将 不会 匹配
当 一个 非 冗余 属性 被 更新 时 ， 之前 存在 一个 更新   slots   的 非必要 调用
因此 ， 在 今天 的 大部分 架构 上   ， 浮点数 都 只能 近似 地 使用 二进制 小数 表示 ， 对应 分数 的 分子 使用 每   8   字节 的 前   53   位 表示 ， 分母 则 表示 为   2   的 幂次
如果 你 通过   " stderr   subprocess . STDOUT "   运行 ,   标准 输入 和 标准 错误 将 被 组合 在 一起 ,   并且   " stderr ` "   将 为   " None " .
最初 格式 （ 它 是 所有 其他 格式 的 基础 ） 的 一个 问题 是 它 没有 支持 不同 字符 编码 格式 的 概念
图片   Specifies   an   image   to   display
在   3.7   版 更改 :   移 除了   verbose   形参 和   " _ source "   属性
在   3.7   版 更改 :   这个 模块 曾经 是 可选 的 ， 但 现在 总是 可用 的
注解 :
如同 后面 跟着 一个 文件 结束 标记 一样 ， 强制 处理 所有 缓冲 数据
这里 是 一个 用 生成器 实现 树 的 递归 中序 遍历 示例
3.4   新版 功能 .
库
枚举 是 一组 符号 名称 （ 枚举 成员 ） 的 集合 ， 枚举 成员 应该 是 唯一 的 、 不可 变 的
描述 器 使用指南
这 也 被 称为 “ 真 ” 除法
将   Python   2   代码 迁移 到   Python   3
" os "   多种 操作系统 接口
可以 从 返回 对象 的   " name "   属性 中 找到 临时 目录 的 名称
（ 而 在 另一方面 ， 用   C   语言 编写 的   Python   实现 则 可以 完全 隐藏 实现 细节 ， 并 在 必要 时 控制 对象 的 访问 ； 此 特性 可以 通过 用   C   编写   Python   扩展 来 使用 。 ）
该 模块 为 导入 系统 提供 了 工具 ， 尤其 是 在 包 支持 方面
" http . cookiejar "   — —   HTTP   客户端 的   Cookie   处理
作者 :   Vinay   Sajip   < vinay _ sajip   at   red   dove   dot   com >
" ( items ) "   ( " tuple " )   [   matching   items   ]   对象 必须 是   Python   序列 ， 它 的 长度 是   items   中 格式 单元 的 数量
指明 从   beg   行 开始 的   num   个 屏幕 行已 被 破坏 并且 应当 在 下次   " refresh ( ) "   调用 时 完全 重绘
如果 要 用   " Client ( ) "   连接 到 一个 名为   ServerName   的 远程 命名 管道 ， 应该 替换 为 使用   " r ' \   ServerName   \ pipe { PipeName } ' "   这种 格式
异步 策略 的 抽象 基类
生成   XKCD   风格 的 密码 串 :
工具 / 示例
" $ { identifier } "   等价 于   " $ identifier "
将 当前 profile   的 结果 写入   filename
一个 继承 自   " ResourceLoader "   和   " ExecutionLoader " ， 提供   " ResourceLoader . get _ data ( ) "   和   " ExecutionLoader . get _ filename ( ) "   具体 实现 的 抽象 基类
sep   和   end   都 必须 为 字符串 ； 它们 也 可以 为   " None " ， 这 意味着 使用 默认值
保留 所有 权利
通过 操作 dll 对象 的 属性 来 操作 这些 函数
在   " xmlcharrefreplace _ errors ( ) "   中 实现
在   Python   3.6   3.7   中是 则 是 引发   " DeprecationWarning "
核心 与 内置
提取   IP   版本 :
" \ d "   匹配 任何 十进制 数字 ； 这 等价 于类   " [ 0   9 ] "
命令行 选项
例如 :
可用 的   Turtle   和   Screen   方法 概览
本 方法 不能 可靠 地 检测 同一 文件系统 上 的 绑定 挂载   ( bind   mount )
在   3.8   版 更改 :   Before   version   3.8 ,   this   slot   was   named   " tp _ print "
即使 是 微不足道 的 程序 都 需要 几页 长 的 证明 ； 一个 中等 复杂 的 程序 的 正确性 证明 会 非常 庞大 ， 而且 ， 极少 甚至 没有 你 日常 所 使用 的 程序 （ Python   解释器 ，   XML   解析器 ， 浏览器 ） 的 正确性 能够 被 证明
查找 给定 编码 的 编解码器 并 返回 其 增量 式 编码器 类 或 工厂 函数
换句话说 ， 应该 使用   "   "   来 比较 字典 键 ， 而 不是 使用   " is "
这些 库 可 帮助 你 发布 和 安装   Python   软件
复数 公式 取自 编目 头文件
如果 没有 提供   context   ， 则 使用 当前 上下文
以下 是 两种 风格 的 示例 ：
例子 ( 左侧 是 调用 ， 右侧 是 Python 值 结果 ) ：
参见   PEP   589   和   " typing . TypedDict "
当 冻结 ( freeze )   Tkinter 程序 时   ， 程序 并 不是 真的 能够 独立 运行 ， 因为 程序 仍然 需要 Tcl 和 Tk 库
（ 由   Carl   Chenet   在   bpo   7418   中 建议 。 ）
" tkinter . font "   Tkinter   字体 封装
整数 （ 比如   " 2 " 、 " 4 " 、 " 20 "   ） 的 类型 是   " int " ， 有 小数 部分 的 （ 比如   " 5.0 " 、   " 1.6 "   ） 的 类型 是   " float "
参见 :
使用   " TextCalendar "   类 的   " formatyear ( ) "   返回 整年 的 3 列 的 日历 以 多行 字符串 的 形式
注解 :
返回 结果 字符串
ZipInfo   对象
如果 事件 已 被 设置 ， 则 立即 返回   " True "
在   3.6   版 更改 :   增加 了   encoding   和   errors
在   Windows   上 ， 以下 文件属性 常量 可 被 用来 检测   " os . stat ( ) "   所 返回 的   " st _ file _ attributes "   成员 中 的 位
此 模块 定义 了 下列 变量 和 函数 ：
3.7   新版 功能 .
默认 方案 为   " ' surrogateescape ' " ， 它 也 被   Python   用于 文件系统 调用 ， 参见 文件名 ， 命令行 参数 ， 以及 环境变量 。
返回 当前 面板 之下 的 面板
该 问题 可能 是 由于 计算机 上 的 杀毒软件 配置 错误 造成 的
[ 1 ]   参见   " types . ModuleType "
" MagicMock "   是 预先 创建 了 所有 魔术 方法 （ 所有 有用 的 方法 ）   的   Mock
以下 函数 集 ， 仿照   ANSI   C   标准 ， 并 指定 了 请求 零 字节 时 的 行为 ， 可 用于 从   Python 堆 分配 和 释放 内存
fieldnames   参数 是 一个   sequence
如果 至少 缓冲 了 一个 字节 ， 则 只 返回 缓冲 的 字节
该 函数 返回 的 是 不可 变 的   " Dialect "   对象
" do _ playback ( ) "   方法 读取 文件 并 添加 记录 命令 至   " cmdqueue "   用于 即时 回放 :
当 在 没有 足够 操作 权限 的 情况 下 试图 执行 某个 操作 时 将 被 引发   — —   例如 缺少 文件系统 权限
这个 调用 通过 运行   " distutils . core . setup ( ) "   函数 读取   " name "   元 数据
模块   " unittest "   编写   PyUnit   回归 测试 .
使用   " PyErr _ Occurred ( ) "   来消 歧义
" parse _ qs " ,   " parse _ qsl "   和   " escape "   已 从   " cgi "   模块 中 被 移除
在   3.2   版 更改 :   现在 获取 锁 的 操作 可以 被   POSIX   信号 中断
当 条目 添加 到 队列 的 时候 ， 未 完成 任务 的 计数 就 会 增加
命令行 参数 扩展   " sys . argv "   ， 就 像 在 命令行 上 传递 一样
返回 从 当前目录 或   start   目录 （ 可 选 ） 到达   path   之间 要 经过 的 相对路径
cp1140   ibm1140   西欧   cp1250   windows   1250   中欧 和 东欧   cp1251   windows   1251   保加利亚语 ， 白俄罗斯 语 ， 马其顿 语   ， 俄语 ， 塞尔维亚语   cp1252   windows   1252   西欧   cp1253   windows   1253   希腊语   cp1254   windows   1254   土耳其语   cp1255   windows   1255   希伯来语   cp1256   windows   1256   阿拉伯语   cp1257   windows   1257   波罗的海 语言   cp1258   windows   1258   越南语   euc _ jp   eucjp ,   ujis ,   u   jis   日语   euc _ jis _ 2004   jisx0213 ,   eucjis2004   日语   euc _ jisx0213   eucjisx0213   日语   euc _ kr   euckr ,   korean ,   ksc5601 ,   韩语   ks _ c   5601 ,   ks _ c   5601   1987 ,   ksx1001 ,   ks _ x   1001   gb2312   chinese ,   csiso58gb231280 ,   euc   简体中文   cn ,   euccn ,   eucgb2312   cn ,   gb2312   1980 ,   gb2312   80 ,   iso   ir   58   gbk   936 ,   cp936 ,   ms936   统一 汉语   gb18030   gb18030   2000   统一 汉语   hz   hzgb ,   hz   gb ,   hz   gb   2312   简体中文   iso2022 _ jp   csiso2022jp ,   iso2022jp ,   日语   iso   2022   jp   iso2022 _ jp _ 1   iso2022jp   1 ,   iso   2022   jp   1   日语   iso2022 _ jp _ 2   iso2022jp   2 ,   iso   2022   jp   2   日语 ， 韩语 ， 简体中文 ， 西欧 ， 希腊   语   iso2022 _ jp _ 2004   iso2022jp   2004 ,   iso   2022   jp   2004   日语   iso2022 _ jp _ 3   iso2022jp   3 ,   iso   2022   jp   3   日语   iso2022 _ jp _ ext   iso2022jp   ext ,   iso   2022   jp   ext   日语   iso2022 _ kr   csiso2022kr ,   iso2022kr ,   韩语   iso   2022   kr   latin _ 1   iso   8859   1 ,   iso8859   1 ,   8859 ,   西欧   cp819 ,   latin ,   latin1 ,   L1   iso8859 _ 2   iso   8859   2 ,   latin2 ,   L2   中欧 和 东欧   iso8859 _ 3   iso   8859   3 ,   latin3 ,   L3   世界语 ， 马耳他 语   iso8859 _ 4   iso   8859   4 ,   latin4 ,   L4   波罗的海 语言   iso8859 _ 5   iso   8859   5 ,   cyrillic   保加利亚语 ， 白俄罗斯 语 ， 马其顿 语   ， 俄语 ， 塞尔维亚语   iso8859 _ 6   iso   8859   6 ,   arabic   阿拉伯语   iso8859 _ 7   iso   8859   7 ,   greek ,   greek8   希腊语   iso8859 _ 8   iso   8859   8 ,   hebrew   希伯来语   iso8859 _ 9   iso   8859   9 ,   latin5 ,   L5   土耳其语   iso8859 _ 10   iso   8859   10 ,   latin6 ,   L6   北欧 语言   iso8859 _ 11   iso   8859   11 ,   thai   泰语   iso8859 _ 13   iso   8859   13 ,   latin7 ,   L7   波罗的海 语言   iso8859 _ 14   iso   8859   14 ,   latin8 ,   L8   凯尔特语   iso8859 _ 15   iso   8859   15 ,   latin9 ,   L9   西欧   iso8859 _ 16   iso   8859   16 ,   latin10 ,   L10   东南欧   johab   cp1361 ,   ms1361   韩语   koi8 _ r   俄语   koi8 _ t   塔吉克   3.5   新版 功能
如果 一个   " tzinfo "   子类 不能 保证 这 一点   ， 也许 可以 重载   " tzinfo . fromutc ( ) "   的 默认 实现 以便 在 任何 情况 下 与   " astimezone ( ) "   正确 配合
如果 你 在 命令行 中 输入 这些 代码 并 运行 ， 你 将 会 看到 ：
不同之处 在于 原始 函数 并 不会 被 临时 绑定 到 名称   " func "
sub _ key   是 用于 命名 该 方法 所 打开 或 创建 的 键 的 字符串
如果 你 的 类型 有 内存 可 供 释放 或 执行 其他 清理 ， 你 可以 把 它 放在 这里
我 希望 尽可能 地 保证 内容 精确 无误 ， 但 还是 选择 使用 自然 词句 进行 描述 ， 正式 的 规格 定义 仅 用于 句法 和 词法 解析
可 选 键值 类 的 参数   context   允许   callback   运行 在 一个 指定 的 自定义   " contextvars . Context "   对象 中
当然 ， 你 可以 在   Python   代码 中 构造 字典 ， 通过 套 接字 以   pickle   形式 接收 它 ， 或者 使用 对 你 的 应用程序 合理 的 任何 方法
PTP   或   NTP   软件 可以 用来 维护 闰秒 表
将 列表 中 索引 为   index   的 项设 为   item
这 意味着 ， 任何 使用 队列 的 时候 ， 你 都 要 确保 在 进程 join 之前 ， 所有 存放 到 队列 中 的 项 将 会 被 其他 进程 、 线程 完全 消费
在 文件 描述符   fd   上 挂 起 一战 恢复 输入 或 输出
所有 用于 搜索 的 键 都 是 预先 计算 的 ， 以 避免 在 搜索 时 对   key   方法 的 不必要 调用
细节 参考   Python / C   API 参考手册 的 章节   Capsule   对象 和   Capsule 的 实现 ( 在 Python 源码 发行 包 的   " Include / pycapsule . h "   和   " Objects / pycapsule . c "   )
（ 由   Mark   Dickinson   在   bpo   36669   中 贡献 。 ）
让 我们 来 做 个 综合 练习
其他 改进
对于 任意   " date "   对象   d   ， " date . fromordinal ( d . toordinal ( ) )   d "
此 函数 提供 与   sqlite3   shell   中 的   " . dump "   命令 相同 的 功能
该 可 迭代 对象 末尾 的 项 将 被 赋值 给 加星 目标 之后 的 目标
这是 内置 的   " BlockingIOError "   异常 的 兼容性 别名
其他 对象
引发 一个 审计 事件   " open "   附带 参数   " file " ,   " mode " ,   " flags "
学习 描述 器 不仅 能 提供 接触 到 更 多 工具集 的 方法 ， 还 能 更深 地 理解   Python   工作 的 原理 并 更加 体会 到 其 设计 的 优雅 性
封存 序列化
" close ( ) "   也 会 在   Python   垃圾 回收 器 回收 生成器 的 时候 调用
Attr   对象
所有 标识符 在 解析 时会 被 转换 为 规范 形式   NFKC ； 标识符 的 比较 都 是 基于   NFKC
在   3.6   版 更改 :   接受 一个 类 路径 对象
另 一个 关键 特性 在于 局部变量 和 执行 状态 会 在 每次 调用 之间 自动 保存
如果 添加 的 部分 没有   Content   Disposition   标头 ， 则 会 添加 一个 值为   " attachment "   的 标头
参见 :
第二个 操作数 必须 为   precision   至   precision   精度 范围 内 的 整数
2to3   也 可以 重构   doctests
每种 编解码器 的 完整 细节 也 可以 直接 查找 获取 ：
在   3.6   版 更改 :   当   " exec _ module ( ) "   已 定义 但   " create _ module ( ) "   未定义 时 将 引发   " ImportError "
返回 音频 总帧 数
管理 线程 本地 数据 ， 只 需要 创建 一个   " local "   （ 或者 一个 子 类型 ） 的 实例 并 在 实例 中 储存 属性 ：
在   Python   3   中 ， 此 协议 已 不复存在 ， 但 这些 函数 仍然 被 公开 以便 移植   2 . x   的 代码
在   3.3   版 更改 :   ssl _ context   parameter   was   added .
Python   3.9 . 0   发布 候选 版   1
许多 人 认为 异常 捕获 可以 方便 地 模拟 C ， Fortran 和 其他 语言 的   " go "   或   " goto "   结构 的 所有 合理 用法
包含 具体 的 命令 （ 请求 类型 ）
使用 装饰 排序 去 装饰 的 旧 方法
Shell 中 的 用户 输出
Cython   将 带有 可 选 注释 的 Python 修改 版本 编译 到 C 扩展 中
本 模块 提供 DEBUG 标识
请 注意 此 模块 与   " aifc "   和   " wave "   是 兼容 接口 的
细节 如下 :
有关 更 多 提示   ， 请参阅   " Modules / readline . c "   和   " Parser / myreadline . c "
该 组合 操作 比先 调用   " heappush ( ) "   再 调用   " heappop ( ) "   运行 起来 更 有效率
callback   与   " ref ( ) "   函数 的 同名 形参 含义 相同
PEP   414 :   显式 的 Unicode 文本
如果   dst   已经 存在 ， 它 将 被 替换
将 一行 源 文本 推入 解释器
例如 ， 可以 使用 锁来 确保 一次 只有 一个 进程 打印 到 标准 输出 :
来自   " popen2 "   模块 的 替代 函数
除非 另有 说明 ， 缓冲区 是 不会 以空 终止 的
yield   表达式 和 语句 仅 在 定义   generator   函数 时 使用 ， 并且 仅 被 用于 生成器 函数 的 函数 体 内部
如果   object   不是 给定 类型 的 对象 ， 函数 将 总是 返回   " False "
十进制 数 也 包括 特殊 值 ， 例如   " Infinity "   ，   "   Infinity "   ， 和   " NaN "
文档
此 异常 会 收集 在 多 文件 操作 期间 所 引发 的 异常
每 一份 错误报告 将 被 分派 给 一名 开发者 ， 并 由 这名 开发者 决定 如何 修正 这个 问题
注意 ， 与   " DictReader "   类 不同 ， " DictWriter "   类 的   fieldnames   参数 不是 可 选 参数
Unicode 字符 属性
目前 ， 此 包中 只有 一个 模块 ：
" Text "   Text   和   CDATASection   对象   包含 文档 中 文本 内容 的 节点
它 允许 你 输入 正则 和 字符串 ， 并 显示 RE 是 匹配 还是 失败
在   3.8   版 更改 :   如果 队列 已经 关闭 ， 会 抛出   " ValueError "   而 不是   " OSError "
在   Python   中 可 使用 一些 对象 来 包装 对 底层 内存 数组 或称 缓冲 的 访问
如果 可 选 参数   header   存在 且 为 true   ， 则 空格 将 被 编码 为 下划线   RFC   1522
凭借 我们 目前 已学 的 东西 你 就 可以 做到 许多 事情 ， 而 我们 还 仅仅 学了 一些 皮毛 而已
如果 未指定 可选 的   " infile "   和   " outfile "   参数 ， 则 将 分别 使用   " sys . stdin "   和   " sys . stdout " :
资源 限制
在   3.6   版 更改 :   decode _ data   is   now   " False "   by   default .
因此 如果 一个 加载 器 可以 从 缓存 加载 模块 但是 不能 从文件 加载 ， 那种 非典型 场景 就是 适当 的
注意 如果 你 想要 向 进程 的   stdin   传输数据 ， 你 需要 通过   " stdin   PIPE "   创建 此   Popen   对象
示例
请 注意 制表符 和 空格符 都 被 视为 是 空白符 ， 但 它们 并 不 相等 ： 以下 两行   " "   hello " "   和   " " \ thello " "   不会 被 视为 具有 相同 的 前缀 空白符
通常 文件 是 以   text   mode   打开 的 ， 这 意味着 从文件 中 读取 或 写入 字符串 时 ，   都 会 以 指定 的 编码方式 进行 编码
例如 ， 在 我们 的 示例 中   " ' CompressionLevel ' "   键仅 在   " ' DEFAULT ' "   小节 被 指定
除了   " send ( ) "   之外 ， 生成器 还有 两个 其他 的 方法 :
option   和   value   必须 为 字符串 ； 如果 不是 则 将 引发   " TypeError "
给出 一个 可选 的 参数 ： " ask _ ok ( ' OK   to   overwrite   the   file ? ' ,   2 ) "
Python   2.6   有 什么 新 变化
如果 传递 一个 简单 的 字符串 ， 则   shell   参数 必须 为   " True "   （ 见下文 ） 或者 该 字符串 中将 被 运行 的 程序 名 必须 用 简单 的 命名 而 不 指定 任何 参数
注解 :
解析 注释 :
如果 参数   object   是 可 调用 的 就 返回   " True " ， 否则 返回   " False "
将   value   转换 为   format _ spec   控制 的 “ 格式化 ” 表示
特别 是 父 进程 中非 必须 的 文件 描述符 和 句柄 不会 被 继承
在   3.2   版 更改 :   可以 被 用作 上下文 管理器
示例 :
3.3   新版 功能 .
通过   " setUp ( ) "   和   " tearDown ( ) "   方法 ， 可以 设置 测试 开始 前 与 完成 后 需要 执行 的 指令
但是 把 存放 在 容器 代理 中 的 值 本身 是 会 通过 管理器 传播 的 （ 会 触发 代理 对象 中 的   " __ setitem __ "   ） 从而 有效 修改 这些 对象 ， 所以 可以 把 修改 过 的 值 重新 赋值 给 容器 代理 :
对 大小写 敏感
读取   plist   文件
在   3.3   版 更改 .
源码 ：   Lib / decimal . py
" statistics "   数学 统计 函数
发生 文件 更改 可能 是 由于 使用 了 执行 文件 轮换 的 程序 例如   newsyslog   和   logrotate
还 可以 施加 更进一步 的 限制 以 防止 用户 注入 恶意代码
" del "   语句
（ 由   Antoine   Pitrou   和   Brian   Curtin   在   bpo   7461   和   bpo   10554   中 贡献
如果 是 打开 一个 现有 归档 则 这些 对象 的 排列 顺序 与 它们 对应 条目 在 磁盘 上 的 实际   ZIP   文件 中 的 顺序 一致
返回 当前 的 本地 日期
每个 字符 将 返回 为 长度 为   1   个字符 的 字符串 ， 特殊 键 例如 函数 键 将 返回 包含 键名 的 较长 字符串 例如   " KEY _ UP "   或   " ^ G "
PEP   3118 :   修改 缓冲区 协议
静态 类型 检查 器 ， 例如   Mypy   、   Pyre   和   Pytype   可以 检查 Python 源代码 中 的 类型 提示
3.1   新版 功能 :   " SEEK _   "   常量 .
从 C   API 看 ， Python 的 复数 对象 由 两个 不同 的 部分 实现 ： 一个 是 在 Python 程序 使用 的 Python 对象 ， 另外 的 是 一个 代表 真正 复 数值 的 C 结构 体
（ 由   Serhiy   Storchaka   在   bpo   31680   中 贡献 。 ）
3.7   新版 功能 .
" xml . etree . ElementTree "   模块 对于 恶意 构建 的 数据 是 不 安全 的
例如 ， 要 以 反向   age   顺序 获取 学生 数据 ：
在 这个 例子 中 ， 我们 调用 了   " time ( ) "   函数 ， 该 函数 返回 一个 系统 时间 戳 （ 从   Unix   时间 起点 到 现在 的 秒数 ） ， 而 ` ` GetModuleHandleA ( ) ` `   函数 返回 一个   win32   模块 句柄
计算   datetime2   使得   datetime2   +   timedelta   datetime1
Python   3.0   之后 的 变化
警告 :
记住 ， 默认 情况 下 如果 一个 可 选 参数 没有 被 指定 ， 它 的 值会 是   " None " ， 并且 它 不能 和 整数 值相 比较 （ 所以 产生 了   " TypeError "   异常   ）
跨平台
有些 时候 ， 先举个 例子 ， 当 处理 一个 特别 长 的 参数 列表 的 时候 ， 把 它 存入 一个 文件 中 而 不是 在 命令行 打 出来 会 很 有 意义
Tkinter   对话框
在 此 情况 下 在 模块 的 属性 和 模块 中 定义 的 全局 名称 之间 正好 存在 一个 直观 的 映射 ： 它们 共享 相同 的 命名 空间 ！   [ 1 ]
本章 介绍 的 模块 提供 与 数字 和 数学 相关 的 函数 和 数据类型
如果 使用   " __ anext __ ( ) "   则 结果 为   " None "
浮点数 对象
选项 名称   描述   默认值   strip _ comments   strip   from   " ' # ' "   to   end   of   line ,   true   as   well   as   any   whitespace   leading   up   to   the   " ' # ' "   unless   it   is   escaped   by   a   backslash   lstrip _ ws   strip   leading   whitespace   from   false   each   line   before   returning   it   rstrip _ ws   strip   trailing   whitespace   true   ( including   line   terminator ! )   from   each   line   before   returning   it
ProtocolError   对象
该 函数 会 缓存 过去 的 比较 及其 结果 ， 且 在 文件 的   " os . stat ( ) "   信息 变化 后 缓存 条目 失效
如果   Future   已 取消   ， 方法 会 引发 一个   " CancelledError "   异常
在   3.7 . 1   版 更改 :   The   SAX   parser   no   longer   processes   general   external   entities   by   default   to   increase   security   by   default
以下 形符 属于 运算符 :
" netrc "   netrc   文件 处理
函数 会 保证 可 迭代 对象 按 从 左 至 右 的 顺序 被 求值
客户端   /   服务器   SSLv2   SSLv3   TLS   [ 3 ]   TLSv1   TLSv1.1   TLSv1.2   SSLv2   是   否   否   [ 1 ]   否   否   否   SSLv3   否   是   否   [ 2 ]   否   否   否   TLS   (   SSLv23   )   [ 3 ]   否   [ 1 ]   否   [ 2 ]   是   是   是   是   TLSv1   否   否   是   是   否   否   TLSv1.1   否   否   是   否   是   否   TLSv1.2   否   否   是   否   否   是
这 使得   yield   和   return   的 语法 与 正常 的 赋值 语法 更为 一致 :
该类 提供 了 基于 字符 和 行 的 流   I / O   接口
当 语句 块 结束 时 它 将 自动 被 关闭
它 还 允许 传入 任意 值 并 通过   " sys ._ xoptions "   字典 来 提取 这些 值
Poll   对象
拼接   count   个 来自 栈 的 字符串 并 将 结果 字符串 推入 栈顶
" traceback "   打印 或 检索 堆栈 回溯
API   与 特性 的 移除
将   base64   数据 块 转换成 二进制 并 以 二进制 数据 形式 返回
它 提供 了 符合   DB   API   2.0   规范 的 接口 ， 这个 规范 是   PEP   249
（ 由   Weipeng   Hong   在   bpo   31553   中 贡献 。 ）
3.3   新版 功能 .
" transport . send _ signal ( ) "   发送 一个 信号 到子 进程
在 操作数 的 每个 数位 间 应用 逻辑运算   xor
事件 使用 “ 最后 的 处理程序 ” 输出 ， 存储 在   " logging . lastResort "   中
像 这样 的 后 向 引用 通常 不仅仅 用于 搜索 字符串   — —   很少 有 文本格式 以 这种 方式 重复 数据   — —   但是 你 很快 就 会 发现 它们 在 执行 字符串 替换 时 非常 有用
( 参见   method   " listen ( ) "   方法 。 )
除非 引发 了 异常 ， 调用 总是 会 有 返回值 ， 返回值 也 可能 为   " None "
ContentHandler   对象
二进制   I / O
导致   " HTTPError "   的 特定   HTTP   请求 的   HTTP   响应 头
有 一种 方式 可以 从 列表 按照 给定 的 索引 而 不是 值来 移除 一个 元素 :   那 就是   " del "   语句
Windows   :   object _ list   中 的 元素 必须 是 一个 表示 为 整数 的 可 等待 的 句柄 ( 按照   Win32   函数   " WaitForMultipleObjects ( ) "   的 文档 中 所 定义 )   或者 一个 拥有   " fileno ( ) "   方法 的 对象 ， 这个 对象 返回 一个套 接字 句柄 或者 管道 句柄
HTTPResponse   对象
弱 引用 对象
注解 :
安全
返回 相同 的   Decimal   对象   x
一个 包含 非   ASCII   字符 的 域名   ( 例如   " www . Alliancefran ç aise . nu " )   会 被 转换 为 兼容   ASCII   的 编码 格式   ( 简称   ACE ， 例如   " www . xn   alliancefranaise   npb . nu " )
以下 代码 :
" PyUnicode _ ClearFreeList ( ) " :   Unicode   自由 列表 已 在   Python   3.3   中 被 移除
有用 的 宏
重复 的 元素 可以 一个个 地 直接 列出 ， 或 使用 可选 的 仅限 关键 字形 参   counts   来 指定
例如 ， 假设 你 希望 你 的 扩展 在 “ 原地 ” 构建 就是说 你 有 一个 扩展   " pkg . ext "   ， 你 希望 编译 出 的 扩展 文件   ( 例如 在   Unix   上 为   " ext . so " )   放在 与 你 的 纯   Python   模块   " pkg . mod1 "   和   " pkg . mod2 "   相同 的 源目录 中
lno :   记录 调用 所在 文件 中 的 行号
将   TOS   解包 为   count   个 单独 的 值 ， 它们 将 按 从 右 至 左 的 顺序 被 放入 堆栈
另外 ， 此类 必须 支持   " __ eq __ ( ) "   方法
大多数   " tzinfo "   子类 应该 能够 毫无 问题 地 继承 默认 的   " fromutc ( ) "   实现
" logging "   Python   的 日志 记录 工具
完成 上下文 或 销毁 临时 目录 对象 后 ， 新创建 的 临时 目录 及其 所有 内容 将 从 文件系统 中 删除
在   3.5   版 更改 :   增加 了   charset   关键字 参数
使用 示例 :   " fi   fileinput . FileInput ( openhook   fileinput . hook _ compressed ) "
听过   " Process . terminate "   停止 一个 进程 很 容易 导致 这个 进程 正在 使用 的 共享资源 （ 如锁 、 信号量 、 管道 和 队列 ） 损坏 或者 变得 不可 用 ， 无法 在 其他 进程 中 继续 使用
" urllib . request "   模块 定义 了 适用 于 在 各种 复杂 情况 下 打开   URL （ 主要 为   HTTP   ） 的 函数 和 类 例如 基本 认证 、 摘要 认证 、 重定向 、 cookies   及其 它
请 注意   subtype   是 可选项 ； 如果 省略 ， 则 仅 使用 主 类型 来 进行 子 部分   MIME   类型 的 匹配
在   3.3   版 更改 :   增加 了   flags   参数
在   3.6   版 更改 :   添加 了   encoding   和   errors   形参 .
此   API   现在 是 通过   " make   install "   安装 的
ascent   基线 和 最高点 之间 的 距离   （ 在 该 字体 中 的 一个 字符 可以 占用 的 空间 中 ）
3.2   新版 功能 .
" timedelta "   算术 运算 的 示例 :
3.2   新版 功能 .
光标 右边 的 所有 字符 将 被 右移 ， 该行 右 端的 字符 将 丢失
这些 语义上 的 不同 是 刻意 而 为 之 的 ， 是 出于 在 绝大多数 常见 使用 情景 中 都 方便 的 初衷 下 设计 的
要 更改 系统 变量 ， 您 需要 对 计算机 进行 无 限制 访问 （ 即 管理员 权限 ）
源代码   Lib / fractions . py
Type   对象
这 也 可以 通过 使用   '   '   符号 将   table   作为 关键字 参数传递
方差 或称 相对 于 均值 的 二阶 矩 ， 是 对 数据 变化 幅度 （ 延展 度 或 分散度 ） 的 度量
请 使用   " array . tobytes ( ) . decode ( enc ) "   来 从 其他 类型 的 数组 生成   Unicode   字符串
与 往常 一样 ， 继承 自   " ContextDecorator "   的 上下文 管理器 必须 实现   " __ enter __ "   与   " __ exit __ "
源代码 ：   Lib / http / server . py
一个 对象 的 标识号 可 使用   " id ( ) "   函数 来 确定
abstract   base   class   抽象 基类 抽象 基类 简称   ABC ， 是 对   duck   typing   的 补充 ， 它 提供 了 一种 定义 接口 的 新 方式 ， 相比之下 其他 技巧 例如   " hasattr ( ) "   显得 过于 笨拙 或 有 微妙 错误 （   例如 使用 魔术 方法 ）
3.2   新版 功能 .
Python   " None "   对象 ， 表示 缺乏 值
有关 可能 的 值   ， 请参阅   Clock   ID   常量
此 方法 被 用来 处理 元素 的 结束 标记 （ 例如 ：   " < / div > "   ）
当 打开 一个 文件 用于 读取 时 ， 输入 文件 可以 为 多个 独立 压缩 流 的 拼接
默认 精度 为   " 6 "
无穷 迭代 器 ：
在 交互式 解释器 中 ， 输出 的 字符串 外面 会 加上 引号 ， 特殊字符 会 使用 反 斜杠 来 转义
HTTP   协议 在   1.1   版中 添加 了 块 传输 编码
3.5   新版 功能 :   " ' namereplace ' "   错误处理 方案
返回   set   中 任意 对象 的 新 引用 ， 并 从   set   中 移除 该 对象
可以 指定   errors   来 定义 错误处理 方案
字节 类 对象 可 在 多种 二进制 数据 操作 中 使用 ； 这些 操作 包括 压缩 、 保存 为 二进制 文件 以及 通过 套 接字 发送 等
将 指定 的 过滤器   filter   添加 到 此 记录器
Python   是否 有 平台 无关 的 图形界面 工具包 ？
使用   C   或   C++   扩展   Python
以下 两个 函数 可 用于 自定义 子 进程 监视器 实现 ， 它 将 被 asyncio 事件 循环 使用 :
suffix   和   prefix   现在 可以 接受   " None " ， 并且 默认 为   " None "   以 使用 合适 的 默认值
参见   " PyConfig . isolated " .
[ 1 ]   原先 在 3.4 版本 中以   provisional   module   添加
为什么 没有 goto ？
成功 时 返回 结果 ， 在 失败 时 抛出 一个 异常 并 返回   NULL
可能 的 取值 范围 依赖于   OpenSSL   的 版本
理论
文档 的 剩余 部分 详述 该 框架 的 完整 特性
如果 可 选 参数   header   存在 且 为 true ， 则 数据 中 的 下划线 将 被 解码 成 空格
y   一个 数值 — — 如果   x   是 一个 数值 ， 否则 为   " None "
" dumps ( ) "   函数 的 另 一个 变体 叫做   " dump ( ) "   ， 它 只是 将 对象 序列化 为   text   file
对于 简单 的 文本 日历 ， 这个 模块 提供 了 以下 方法
C   API   的 改变
Guido   van   Rossum   与   Jelke   de   Boer ,   " 使用   Python   编程语言 交互式 地 测试 远程 服务器 " ,   CWI   季刊 ,   第   4   卷 ,   第   4   期   ( 1991   年   12   月 ) ,   阿姆斯特丹 ,   第   283   303   页
如果 能够 导入 一个包 ， 那么 就 能够 访问 那个 包 里面 的 资源
要 确保 严格 符合标准 ， 请 改用   " compare ( ) "   和   " compare   signal ( ) "   方法
mtime   只 在 压缩 模式 中 使用
flags   将 在 编译 用于 识别 替换 内容 的 正则表达式 被 应用 的 正则表达式 旗标
如果 需要 更大 空间 ， 缓冲区 大小 将 按 需 增加 ， 因此 你 不 需要 让 这个 值 完全 精确 ； 对 其 进行 调整 仅会 节省 一点 对   " malloc ( ) "   的 调用 次数
读取 其他 格式 的 文件 :
两个 或 更 多个 物理 行可 使用 反 斜杠 字符   ( " \ " )   拼接 为 一个 逻辑 行 ， 规则 如下 :   当 一个 物理 行以 一个 不 在 字符串 或 注释 内 的 反 斜杠 结尾 时 ， 它 将 与 下 一行 拼接 构成 一个 单独 的 逻辑 行 ， 反 斜杠 及其 后 的 换行符 会 被 删除
其他 实现
不过 ,   对于 很多 使用   " functools . reduce ( ) "   的 情形 ,   使用 明显 的   " for "   循环 会 更 清晰 :
合理 的 坐标 应 位于   " ( 0 , 0 ) "   到   " ( curses . LINES   1 ,   curses . COLS   1 ) "   范围 内
" atexit "   退出 处理器
要 检查 启动 程序 是否 可用 ， 请 在 命令提示符 中 执行 以下 命令 ：
笔记本
下面 的 类 实现 了 一个 解析器 ， 用于 更 多 示例 的 演示 :
默认 旗标 被 设为 仅 加载 来自 可 信任 位置 的   DLL   依赖 项 ， 包括   DLL   的 存放 路径 （ 如果 加载 初始   DLL   时 使用 了 完整 或 部分 路径 ）   以及 通过   " add _ dll _ directory ( ) "   添加 的 路径
在   3.7   版 更改 :   增加   backtick   参数
这 取决于 对象 的 类型
发布 日期 :   2015   09   07
" mmap "   内存 映射 文件 支持
字符串 和 字节 串字 面值
包含 请求 的 版本 字符串
现在 ， 所有 函数 都 接受 任何 类 字节 串 对象
移除
重新 组织 了 所有 头文件 以 更好 地区 分 不同 种类 的   API ：
使用 方   API
由   asyncio   stream   APIs   提出
" action "   命名 参数 指定 了 这个 命令行 参数 应当 如何 处理
3.3   新版 功能 .
有 两个 可 选 只能 用 关键字 的 实参
shell   和 输出 窗口 还 具有 以下内容
等价 于   Python   表达式   " o1   ^   o2 "
与   " poll ( ) "   相比 ， 这是 一个 重要 的 区别
返回   o   ， 如果 失败 ， 返回   " NULL "
常见问题
这些 函数 采用 与 相应 模式 方法 相同 的 参数 ， 并 将 正则 字符串 作为 第一个 参数 添加 ， 并 仍然 返回   " None "   或 匹配 对象 实例
重要 的 是 应该 意识 到 作用域 是 按 字面 文 本来 确定 的 ： 在 一个 模块 内 定义 的 函数 的 全局 作用域 就是 该 模块 的 命名 空间 ， 无论 该 函数 从 什么 地方 或 以 什么 别名 被 调用
要 以 字节 串 对象 形式 操作   plist   数据 ， 请 使用   " dumps ( ) "   和   " loads ( ) "
该 模块 最初 由   Jim   Roskind   设计 和 编写
这一 做法 的 问题 在于 ， 一个 类 必须 显式 地 标注 为 支持 他们 ， 这即 不   Pythonic ， 也 不太可能 在 惯用 动态 类型 的   Python   代码 中 会 有人 正常 地去 用
非 指针 及 不 包含 指针 的   ctypes   数据类型 现在 将 可以 被 封存
但是 ， 某些 Unix 系统 可能 没有   env   命令 ， 因此 可能 需要 将   " / usr / bin / python3 "   硬 编码 为 解释器 路径
当 （ 某种 替代 的 ） 语法 规则 具有 如下 形式
现在 只 支持   " DEFLATED "   这个 算法
此 风险 仅限于 相互间 没有 信任 的 多个 用户 在 同一 台 机器 上 运行 代码 的 情况 ； 请参阅   " listen ( ) "   了解 更 多 信息
" importlib . import _ module ( ) "   被 提供 用来 为 动态 地 确定 要 导入 模块 的 应用 提供 支持
测试
如果 ` ` home ` `   是 一个 绝对路径 ， 并且   " PYTHONHOME "   未 设置 ， 则 在 推断 起始 位置 时 使用 此 路径 而 不是 主 可执行文件 的 路径
这个 对象 没有 方法
（ 日志 记录器 的 不同 实例 不 需要 具有 不同 类型 ， 因此 这个 配置 架构 并 不 支持 用户 定义 日志 记录器 类 。 ）
错误 输出 重定向 和 程序 终止
pwd   为 用于 已 加密 文件 的 密码 ， 并且 如果 指定 该 参数 则 它 将 覆盖 通过   " setpassword ( ) "   设置 的 默认 密码
异常 和 错误处理
使用 重新 采样 排列 测试 来 确定 统计学 显著性 或者 使用   p   值来 观察 药物 与 安慰剂 的 作用 之间 差异 的 示例 :
" at "   指定 此   Path   在   zipfile   中 的 位置 ， 例如   ' dir / file . txt ' ,   ' dir / '   或   ' '
timeout   可以 为   int   或   float   类型
要 调度 来自 另 一   OS   线程 的   callback   ， 应该 使用   " loop . call _ soon _ threadsafe ( ) "   方法
它 不可 被 撤销 分配
在 C 中 调用 Python 函数
未 附加 协议 驱动
它 通常 以 如下 的 形式 在 异常 处理程序 中 使用 :
它们 提供 了 字典 条 目的 一个 动态 视图 ， 这 意味着 当 字典 改变 时   ， 视图 也 会 相应 改变
列出 结果 归档 中 的 文件 我们 将会 得到 :
接口 选项
然而 ， 如果 值为   " None " ， 则 会 引发   " ModuleNotFoundError "
最终 ， 加载 器会 使用   " __ file __ "   和 / 或   " __ cached __ "
( 模块 代码 块 的 变量 既 为 局部变量 又 为 全局变量 。 )   如果 变量 在 一个 代码 块 中 被 使用 但 不是 在 其中 定义 ， 则 为 自由 变量
" WatchedFileHandler "   类 位于   " logging . handlers "   模块 ， 这个   " FileHandler "   用于 监视 它 所 写入 日志 记录 的 文件
测试
C   API   中 的 改变
这样 在   754   双 精度 下   1 / 10   的 最佳 近似值 为 :
如果   ob   的 类型 是   " PyDateTime _ TimeType "   则 返回 真值
教程   ^ ^ ^ ^
如果   blocking   为 false ， 则 执行 由于 最快 到期 （ 如果 有 ） 的 预定 事件 ， 然后 在 调度 程序 中 返回 下 一个 预定 调用 的 截止 时间 （ 如果 有 ）
在 执行 测试 前 ， 函数 并 不 依赖于 需要 重现 的 系统 状态 ； 相反 ， 你 只 需要 给出 正确 的 输入 ， 然后 检查 输出 是否 和 期望 的 结果 一致
在 Linux 机器 上 ， 这 可以 通过 ：
3.7   新版 功能 .
守护 线程 在 程序 关闭 时会 突然 关闭
测试
3.7   新版 功能 .
在 新版 发布 后 ， 如果 您 希望 掌握 最新 变化 ， 请 务必 阅读 这些 内容
借用 的 缺点 是 一些 看起来 正确 代码 上 的 借用 可能 会 在 拥有者 处置 后 使用 对象
Python   comes   with   roughly   100   different   encodings ;   see   the   Python   Library   Reference   at   标准 编码   for   a   list
如果 未指定 编码 格式 ， 默认值 与 平台 相关   ( 参见   " open ( ) " )
取消 制表符 化将 所有 制表符 转换 为 正确 的 空格 数
Nl   字母 数字
使用 面向 类型 函数 集 的 相同 代码 :
它 本身 无法 响应 任何 实际 的   HTTP   请求 ； 它 必须 被子 类化 以 处理 每个 请求 方法 （ 例如   GET   或   POST ）
在   3.4   版 更改 :   添加   file   形参
memlimit   参数 指定 解 压缩器 可以 使用 的 内存 上限 （ 字节数 ）
从 是 男 是 女 各   50%   的 先验概率 出发 ， 我们 通过 将 该 先验概率 乘以 给 定性 别的 特征 度量 值 的 可能性 累积 值来 计算 后验 概率 ：
3.9   版后 已 移除 :   " contextlib . AbstractContextManager "   now   supports   " [ ] "
此   Python   模块 相当 简单 地 封装 了   curses   提供 的   C   函数 ； 如果 你 已经 熟悉 在   C   语言 中 使用   curses   编程 ， 把 这些 知识 转移 的   Python   是 非常容易 的
在   3.4   版 更改 :   如果   base   不是   " int "   的 实例 ， 但   base   对象 有   " base .__ index __ "   方法 ， 则 会 调用 该 方法 来 获取 进制 数
Python   3.5 . 4   正式版
并 允许 你 编写 这样 的 代码 ：
3.3   新版 功能 .
如果 未指定 此 关键字 ， 则   " PrettyPrinter "   会 选择   " sys . stdout "
3.4   新版 功能 .
取决于 具体 平台 ， 以下 命令 中 的 一个 可以 用来 完成 此 任务
一个 更快 和 灵活 的 方法 是 使用   lambda   函数 ， 可以 提供 任何 常量 值 （ 不 只是 0 ） ：
（ 由   Serhiy   Storchaka   在   bpo   15248   中 贡献 。 ）
安全
此 令牌 是 一个 不 透明 对象 （ 支持 相等 性 测试 ） ， 用于 为 虚 子类 标识 抽象 基类 缓存 的 当前 版本
改为 :
此参数 默认 为 真值
设置 并 返回   " returncode "   属性
请参阅   " itertools . accumulate ( ) "   了解 有关 可 产生 所有 中间 值 的 迭代 器
3.7   新版 功能 .
库
运算符
请 注意 ， 由于 额外 的 函数调用 ， 在 这种 情况 下 ， 计时 开销 会略 大 一些
Binary   对象
这个 函数 接受 一个 以   null   结尾 的 字符串 参数 并 返回 一个 整数
默认 情况 下 ， 函数 的 参数传递 形式 可以 是 位置 参数 或是 显式 的 关键字 参数
它 接受 一个 可 选 参数 来 指定 弹 出 哪个 元素
" Manager ( ) "   返回 的 管理器 支持 类型 ：   " list "   、   " dict "   、   " Namespace "   、   " Lock "   、   " RLock "   、   " Semaphore "   、   " BoundedSemaphore "   、   " Condition "   、   " Event "   、   " Barrier "   、   " Queue "   、   " Value "   和   " Array "
name   转换 为 小写   ，   value   的 引号 被 去除 ， 字符 和 实体 引用 都 会 被 替换
常数
操作系统 实用程序
简单 等待
有时候 你 想要 给 一个   URL   发送数据 （ 通常 这个 URL 指向 一个 CGI （ 通用 网关 接口   ） 脚本 或者 其他   web   应用 ）
" name "   ： 字段 的 名字
PEP   353 :   使用 ssize _ t 作为 索引 类型
因此 当 发现 一个   " UTF   16 "   或   " UTF   32 "   字节 序列 的 首个 字符 是   " U + FFFE "   时 ， 就 必须 在 解码 时 进行 字节 翻转
一个 已 编译 正则表达式 会 被 用来 解析 节标头
转换 为 字符串 ， 如果 需要 指数 则 会 使用 工程 标注 法
它 对子 进程 的 输出 没有 影响
" itertools . filterfalse ( predicate ,   iter ) "   和   " filter ( ) "   相反 ， 返回 所有 让   predicate   返回   false   的 元素 :
此 函数 并 不 支持 解析 任意   ISO   8601   字符串   — —   它 的 目的 只是 作为   " datetime . isoformat ( ) "   的 逆 操作
当 没有 实现 映射 的 类 有 get ( ) 或 key ( ) 方法 ， 或者 不是 文件 的 类 有   write ( ) 方法 时 ， 我们 偶尔 会 感到 困惑
子类   " RuntimeError "
一个   " ChainMap "   通过 引用 合并 底层 映射
另见   parameter   ,   method   和 函数 定义 等节
要 标识 其他 种类 的 重 解析 点 ， 请 检查 新 的   " stat _ result . st _ reparse _ tag "   属性
" tp _ traverse "   处理 必须 是 以下 类型 ：
使用 以下 两种 方法 的 其中 一种 以 创建 消息 对象 结构 ： 直接 创建 一个   " EmailMessage "   对象 ， 使用 字典 接口 添加 消息 头 ， 并且 使用   " set _ content ( ) "   和 其他 相关 方法 添加 消息 负载 ； 或者 通过 解析 一个 电子邮件 消息 的 序列化 表达 来 创建 消息 对象 结构
当 给定   comment _ prefixes   时 ， 它 将 被 用作 在 否则 为 空行 的 注释 的 前缀 子 字符串 的 集合
文件 通配符
这 是因为 在 模块 里 ， " __ name __ "   是 该 模块 在   Python   包 命名 空间 中 的 名字
第二次 ， " mydict "   包含 两项 ， 因为 当   " foo ( ) "   开始 执行 时 ，   " mydict "   中 已经 有 一项 了
请 留意
3.4   版后 已 移除 :   " ' rU ' "   和   " ' U ' "   模式
此 名称 被 用来 在 导入 系统 中 唯一 地 标识 模块
有 的
返回 指涉 对象 的 内部 字符串 表示
返回 包含 至少 两个 实 数值 的 可 迭代 对象   data   的 样本 方差
这样 的 序列 可以 通过 文件 类 对象 的   " readlines ( ) "   方法 来 获取
" @ classmethod "   这样 的 形式 称为 函数 的   decorator   详情 参阅 函数 定义
此 模块 中 其他 异常 的 基类
preexec _ fn   形参 在 应用程序 中 存在 多线程 时 是 不 安全 的
6   " abcb "   再试一次   " b "
因为 配置 的 各 部分 是 通过   " eval ( ) "   传递 的 ， 使用 此 函数 可能 让 用户 面临 安全 风险
" ast "   中 的 辅助 函数
和   Python   里 的 字符串 和 列表 切片 不同 ， 你 不能 在   start   ,   stop   或者   step   这些 参数 中 使用 负数
var   的 默认值 ， 如果 不是   " NULL " ；
3.1   新版 功能 .
不 允许 有 原文 字符串 以外 的 反 斜杠 存在 于 物理 行 的 其他 位置
另 请参阅   Python   GTK +   3   教程
PEP   362 :   函数 签名 对象
" pb " :   位置 的 比特 数 ； 必须 不 大于   4
当 传入 一个   " ZipInfo "   实例 作为   zinfo _ or _ arcname   形参时 ， 所 使用 的 压缩 方法 将 为 在 给定 的   " ZipInfo "   实例 的   compress _ type   成员 中 指定 的 方法
" logging . handlers "   日志 处理程序
默认 情况 下 ， 全部 模块 都 具有 一个 可用 的   repr ， 但是 你 可以 依据 上述 的 属性 设置 ， 在 模块 的 规格 说明 中 更为 显式 地 控制 模块 对象 的   repr
在   3.6   版 更改 :   接受 一个 类 路径 对象
否则 （ 如   TOS   为 假值 ） ， TOS   会 被 弹出
将 路径   path   拆 分为 一对 ， 即   " ( root ,   ext ) " ， 使   " root   +   ext   path "   ， 其中   ext   为空 或 以 英文 句点 开头 ， 且 最 多 包含 一个 句点
如果 处理程序 决定 调度 一个 事件 ， 则 使用   " emit ( ) "   方法 将 消息 发送到 其 目标
这 意味着 扩展 模块 里 的 所有 符号 都 应该 声明 为   " static "   ， 除了 模块 的 初始化 函数 ， 来 避免 与 其他 扩展 模块 的 命名 冲突 ( 在 段落 模块 方法 表 和 初始化 函数 中 讨论 )
参见   asynchronous   iterator   的 定义
下列 异常 均 为   " OSError "   的 子类 ， 它们 将 根据 系统 错误代码 被 引发
当 使用 某 一种 整数 格式   ( " ' b ' " ,   " ' B ' " ,   " ' h ' " ,   " ' H ' " ,   " ' i ' " ,   " ' I ' " ,   " ' l ' " ,   " ' L ' " ,   " ' q ' " ,   " ' Q ' " )   打包 值   " x "   时 ， 如果   " x "   在 该 格式 的 有效 范围 之外 则 将 引发   " struct . error "
与   "   c "   选项 一样 ， 当前目录 将 被 加入   " sys . path "   的 开头
密码 数据库 中 的 条目 以 元组 对象 返回 ， 属性 对应   " passwd "   中 的 结构 （ 属性 如下 所示 ， 可 参考   " < pwd . h > " ） ：
它 也 可 被 用来 取消 事件 循环 中 的 任务 :
字典 接受 任意 可 哈希 的 值
构建
返回 代表 给定 天 、 秒 和 微秒 数 的   " datetime . timedelta "   对象
返回 分块 的 大小
（ 由   Serhiy   Storchaka   在   bpo   40257   中 贡献 。 ）
" json "   模块 的 参考 包含 对此 的 解释
3.7   版后 已 移除 :   由于 要 支持 使用   " importlib . abc . ResourceReader "   类来 加载 资源 ， 这个   ABC   已经 被弃 用 了
在   3.8   版 更改 :   Added   support   for   " __ aenter __ " ,   " __ aexit __ " ,   " __ aiter __ "   and   " __ anext __ " .
模块 级别 函数
由该 模块 的 默认设置 生成 的   JSON   （ 尤其 是 默认 的   “ 分隔符 ”   设置 值 ） 也 是   YAML   1.0   and   1.1   的 一个 子集
如果 设 为   " 1 " ， 指数 将 附带 打印 大写 的   " E " ； 其他 情况 则 将 使用 小写 的   " e " :   " Decimal ( ' 6.02 e + 23 ' ) "
用来 识别 分配器 域 的 枚举 类
插值 行为 可以 用 通过 提供   interpolation   参数 提供 自定义 处理程序 的 方式 来 定制
实例 中 ， 对于 标签   " < A   HREF   " https : / / www . cwi . nl / " > " ， 这个 方法 将 以 下列 形式 被 调用   " handle _ starttag ( ' a ' ,   [ ( ' href ' ,   ' https : / / www . cwi . nl / ' ) ] ) "
在 遍历 同一个 集合 时 修改 该 集合 的 代码 可能 很难 获得 正确 的 结果
详情 请参阅   http : / / www . ocert . org / advisories / ocert   2011   003 . html
空 元组 可以 直接 被 一对 空 圆括号 创建 ， 含有 一个 元素 的 元组 可以 通过 在 这个 元素 后 添加 一个 逗号 来 构建 （ 圆括号 里 只有 一个 值 的话 不够 明确 ）
该 程序 的 帮助 信息 将 显示   " myprogram . py "   作为 程序 名称 （ 无论 程序 从 何处 被 调用 ） ：
在   3.6   版 更改 :   共享 对象 能够 嵌套
你 提供 的 包名 会 被 导入 ， 它 在 文件系统 中 的 位置 会 被 作为 起始 目录
" a   ixor ( a ,   b ) "   等价 于   " a   ^   b "
简单 语句
如果 需要 可变性 ， 可以 使用 列表 而 不是 元组
上面 显示 的 键 函数 模式 非常 常见 ， 因此   Python   提供 了 便利 功能 ， 使 访问 器 功能 更 容易 ， 更 快捷
参见 :
出于 讨论 的 目的 ， 我们 可以 说 该 日志 记录器 代表 两者 间连接 的 源头 ， 而 处理程序 则 代表 对应 的 目标
对于 通用 字符 指针 来说 也 可能 指向 二进制 数据 ， 必须 要 使用   " POINTER ( c _ char ) "
如果 你 考虑 要 定义 你 自己 的 级别 ， 请参阅 自定义 级别 部分
object _ hook   ， 如果 指定 ， 会 被 每个 解码 的   JSON   对象 的 结果 调用 ， 并且 返回值 会 替代 给定   " dict "
（ 由   Victor   Stinner   在   bpo   39350   中 贡献 。 ）
如果 存储 在   SQLite   中 的 时间 戳 的 小数位 多于   6   个 数字 ， 则 时间 戳 转换器 会 将 该值 截断 至 微秒 精度
支持 迭代 器 的 数据类型
内省
field _ name   本身 以 一个 数字 或 关键字   arg _ name   打头
The   standard   Python   warning   categories   are   available   as   global   variables   whose   names   are   enumerated   at   标准 警告 类别 .
详情 见   PEP   414
bpo   17185 :   在   mock   上 设置   " __ signature __ "   以便   " inspect "   能 获得 签名
" transport . get _ extra _ info ( ) "   请求 传输 的 相关 信息
" NTEventLogHandler "   实例 将 消息 发送到   Windows   NT / 2000 / XP   事件 日志
本 指南 涵盖 了 分发 部分 的 流程
想要 控制 文件 的 打开方式 ， 你 可以 通过 将   openhook   形参 传给   " fileinput . input ( ) "   或   " FileInput ( ) "   来 提供 一个 打开 钩子
特定 于 线程 的 CPU 时钟
另 一个 益处 是 将 形参 标记 为 仅限 位置 形参 将 允许 在 未来 修改 形参名 而 不会 破坏 客户 的 代码
返回 指定   clk _ id   时钟 的 时间
SequenceMatcher   的 示例
本章 描述 的 完整 模块 列表 如下 ：
不 允许 有 同名 的 枚举 成员 :
条件 对象
file   参数 必须 是 一个 具有   " write ( string ) "   方法 的 对象 ； 如果 参数 不 存在 或 为   " None " ， 则 将 使用   " sys . stdout "
名称 应当 是 一个 文本 字符串
将 字节 数据 读入 预先 分配 的 可 写   bytes   like   object   b   ， 并 返回 所 读取 的 字节数
有时 需要 将 模块 导入 语句 移动 到 函数 或类 里面 ， 以 避免 循环 导入 问题
子 类化 对于 添加 和 存储 新 的 名字 域 是 无效 的
exc _ info   包含 当前 异常 信息 的 异常 元组 ， 或者 如果 没有 可用 异常 信息 则 为   " None "
preamble   属性 包含   MIME   文档 开头 部分 的 这些 处于 保护 范围 之外 的 文本
方法 对象
当 立即 遇到 分块 末尾 则 返回 空 字节 串 对象
如果   op   的 类型 为   " PyCallIter _ Type "   则 返回   true
它 也 可以 被 用来 计算 相对 于 一个 非 均值 点 的 二阶 距
再 一次 ， 将   " stdout "   标准 输出 重定向 到   " / dev / null " ， 我 获得 如下 结果 ：
当   " TarFile "   被 打开 用于 读取 时 ， 以   " TarInfo "   对象 的 形式 返回 归档 的 下 一个 成员
返回 具有 指定 文件名 、 函数 名 和 第一行 号 的 新空 代码 对象
没有 权限
将   " type "   关键字 参数 字符串 名称 替换 为 相应 的 类型 对象 （ 例如   int ,   float ,   complex   等 ）
" tempfile "   生成 临时文件 和 目录
这是   " ord ( ) "   的 逆函数
因此 可以 利用   Python   帮助 工具 获取 这些 在线 帮助 信息 :
引发 一个 审计 事件   " winreg . OpenKey / result " ， 附带 参数   " key "
注解 :
设计 和 历史 常见问题
在   Windows   上 添加 了 新 函数   " add _ dll _ directory ( ) "   用于 在 导入 扩展 模块 或 使用   " ctypes "   加载   DLL   时为 本机 依赖 提供 额外 搜索 路径
此 数值 依赖于 海龟 初始 朝向 由   " standard " / " world "   或   " logo "   模式 设置 所 决定 )
虽然 被 称为 函数 ， " list "   实际上 是 一种 可变 序列 类型 ， 详情 请参阅 列表 和 序列 类型   list ,   tuple ,   range
已弃 用 的   Python   行为
子 进程 在 开始 时 实际上 与 父 进程 相同
C   API   中 的 改变
在 这种 情况 下 ， " MyDict "   只有 一个 参数 ， " T "
模块 级 属性
3.5   新版 功能 .
Pack   代码   " " H " "   和   " " I " "   分别 代表 两 字节 和 四 字节 无 符号 整数
Windows 将 返回 以下 之一 ：
另见   " format ( ) "   获取 更 多 信息
应该 打印 这样 的 东西 ：
为了 简化 开发 ， asyncio 还有 一种   debug   模式
请参阅   " loop . run _ in _ executor ( ) "   方法 了解 详情
属性 引用 、 抽取 和 切片 的 删除 会 被 传递 给 相应 的 原型 对象 ； 删除 一个 切片 基本 等价 于 赋值 为 一个 右侧 类型 的 空 切片 （ 但 即便 这 一点 也 是 由 切片 对象 决定 的 ）
从 感兴趣 的 进程 中 收集 数据
此 变量 如果 被 设为 一个 非空 字符串 ， 它 就 相当于 指定   "   d "   选项
IDLE   Python   的   IDE ， “ 集成 开发 与 学习 环境 ” 的 英文 缩写
字符串 和 缓存 区
" http . client "   HTTP   协议 客户端
在 源文件 和 字符串 中 ， 可以 使用 任何 标准 平台 上 的 行 终止 序列   Unix   所用 的   ASCII   字符   LF   ( 换行 ) ,   Windows   所用 的   ASCII   字符 序列   CR   LF   ( 回车 加 换行 ) ,   或者 旧   Macintosh   所用 的   ASCII   字符   CR   ( 回车 )
返回 对应 于 预期 格列 高利 历 序号 的 日期 ， 其中 公元   1   年   1   月   1   晶 的 序号 为   1
邮件 列表 档案 可 在   https : / / mail . python . org / pipermail /   上 找到
总的来说 ， 这 是 个 棘手 的 问题
错误处理
返回值 的 计算 方式 取决于 可 调用 对象 的 类型
命名 元组 实例 没有 字典 ， 所以 它们 要 更 轻量 ， 并且 占用 更 小 内存
" os "   模块 提供 了 许多 与 操作系统 交互 的 函数 :
核心 与 内置
赋值 为 一个   ctypes   类型 来 指定 外部 函数 的 结果 类型
这样 就 允许 定义 可 将 自定义 对象 适配 为 函数 形参 的 适配器
本章 将 详细 介绍 一些 您 已经 了解 的 内容 ， 并 添加 了 一些 新 内容
需要 注意 ， 没有 外部 程序 被 该 函数调用 ， 这 赋予 了 该 函数 可移植性 与 效率
类 属性 也 可以 被 赋值 ， 因此 可以 通过 赋值 来 更改   " MyClass . i "   的 值
参见 示例
如果   stdin   参数 为   " PIPE " ， 此 属性 是 一个 类似   " open ( ) "   返回 的 可 写 的 流 对象
标准 模块
像 所有   distutils   选项 一样 ， 这 可以 通过 命令行 或 配置文件 来 指定
此 函数 会 调用 底层 库中 的   " read _ history ( ) "
任何 后续 的 失败 都 将 被 传播
这个 方法 行为 与   " notify ( ) "   相似 ，   但 并 不 只 唤醒 单一 线程 ， 而是 唤醒 所有 等待 线程
阻塞 线程 直到 内部 变量 为   true
除了 这些   " es " ,   " es # " ,   " et "   and   " et # " .
Action   的 实例 应当 为 可 调用 对象 ， 因此 所有 子类 都 必须 重载   " __ call __ "   方法   ， 该 方法 应当 接受 四个 形参 :
" doctest "   测试 交互性 的 Python 示例
格式 器 对象
例如 :
可选 的   source _ address   参数 可以 为 一个   ( 主机 ,   端口 )   元组 ， 用作 进行   HTTP   连接 的 源地址
3.4   新版 功能 .
一个 脚本 文件 （ 作为 标准 输入 发送给 解释器 或是 作为 命令行 参数 发送给 解释器 的 文件 ） 也 是 代码 块
编写 设置 脚本 的 配置文件
该 对象 将 可 调用   TurtleScreen   方法
low   和   high   边界 默认 为 零 和 一
3.3   新版 功能 .
传入   " None "   作为   " shlex . split ( ) "   函数 的 第一个 参数 的 做法 已 被 弃用
与 平台 相关 的 位置 ：
year   ,   month   和   day   参数 是 必须 的
（ 由 Georg   Brandl   贡献 。 ）
如果 没有 找到 这样 的 选项 ， 启动器 将 枚举 已 安装 的 Python 版本 并 使用 为 主要 版本 找到 的 最新 次要 版本 ， 尽管 不能 保证 ， 但 该 版本 可能 是 该 系列 中 最新 安装 的 版本
如果 值 具有 （ 或 所 包含 的 对象 具有 ） 不 受 支持 的 类型 ， 则 会 引发   " ValueError "   但是 将 向 文件 写入 垃圾 数据
空格 会 被 视为 节 名称 的 一部分 ， 因此   " [   larch   ] "   将 被 读取 为 一个 名称 为   " "   larch   " "   的 节
移 除了   " Py _ UNICODE _ MATCH "
以 字节 表示 的 哈希 算法 的 内部 块 大小
以 整数 形式 返回 内存 缓冲区 地址
SequenceMatcher   对象 接受 三个 数据 属性 :   bjunk   是   b   当中   isjunk   为   " True "   的 元素 集合 ；   bpopular   是 被 启发式 计算 （ 如果 其未 被 禁用 ） 视为 热门 候选 的 非 垃圾 元素 集合 ；   b2j   是 将   b   当中 剩余 元素 映射 到 一个 它们 出现 位置 列表 的 字典
由于 Python 流 具有 自己 的 缓冲 层 ， 因此 将 它们 与   OS   级 文件 描述符 混合 会 产生 各种 问题 （ 例如 数据 的 意外 排序 ）
可能 同时 存在 多个 前置 操作 相同 的 测试 ， 我们 可以 把 测试 的 前置 操作 从 测试代码 中 拆解 出来 ， 并 实现 测试 前置 方法   " setUp ( ) "
别名 和 语言 列表 都 不是 详尽 无遗 的
版权
指示 此 记录器 的 有效 级别
PEP   366 :   从主 模块 显式 相对 导入
Python   的 面向对象 功能 是 在 基于 函数 的 环境 构建 的
就 地 实现   " TOS   TOS1   TOS "
a _ list   所 引用 的 对象 已 被 修改 ， 而 引用 被 修改 对象 的 指针 又 重新 被 赋值 给   " a _ list "
初始值 继承 于 创建 线程 ； 主线 程 不是 守护 线程 ， 因此 主线 程 创建 的 所有 线程 默认 都 是   " daemon "   " False "
参见 :   The   " Py _ EncodeLocale ( ) "   function .
pathname   进行 日志 记录 调用 的 文件 的 完整 路径名
特别 是 对于 欧洲 语言 来说 ， 通常 存在 以下 几种 变体 ：
如果 任务 优先级 发生 改变 ， 你 该 如何 将 其 移至 堆中 的 新 位置 ？
当 遇到 一个   " multipart / related "   时 ， 将 检查   " start "   形参 并且 如果 找到 了 一个 匹配   Content   ID   的 部分 ， 在 查找 候选 匹配 时 只 考虑 它
" GzipFile "   类 的 构造 器 支持   " truncate ( ) "   的 异常 ， 与   file   object   的 大多数 方法 非常 相似
它 包含 代码 ， 文档 以及 指向   Web 上 与 Python 相关 的 页面 的 链接
" ssl "   套 接字 对象 的   TLS / SSL   包装 器
从 归档 中 提取 出 一个 成员 放入 当前工作 目录 ；   member   必须 为 成员 的 完整 名称 或   " ZipInfo "   对象
在   Windows   上 会 调用   Win32   API   函数   " TerminateProcess ( ) "   以 停止 子 进程
" subprocess "   模块 曝出 以下 常数
少量 的 默认 处理程序 已经 设置 ：   " SIGPIPE "   被 忽略 （ 因此 管道 和 套 接字 上 的 写入 错误 可以 报告 为 普通 的   Python   异常 ） 以及 如果 父 进程 没有 更改   " SIGINT "   ， 则 其会 被 翻译成   " KeyboardInterrupt "   异常
PEP   590 :   Vectorcall :   用于   CPython   的 快速 调用 协议
这 意味着 由 后代 日志 记录器 生成 的 事件 将 不会 被 日志 记录器 的 过滤器 设置 所 过滤 ， 除非 该 过滤器 也 已 被 应用 于 后代 日志 记录器
" urllib . response "   urllib   使用 的   Response   类
本章 的 想法 和 原 内容 取自   Fredrik   Lundh   的 帖子 ； 本章 的 具体内容 已经 大幅 修改
" O "   ( object )   [ PyObject   ]   将   Python   对象 传递 不变 （ 其 引用 计数 除外 ， 该 计数 由   1   递增 ）
以下 各节 描述 了 有关 查找 器 和 加载 器 协议 的 更 多 细节 ， 包括 你 应该 如何 创建 并 注册 新 的 此类 对象 来 扩展 导入 机制
这 特别 适用 于 消息 必须 安全 地 在 多线程 间 交换 的 线程 编程
是 的 ， 任何 二进制 浮点数 都 可以 精确 地 表示 为   Decimal   值 ， 但 完全 精确 的 转换 可能 需要 比 平常 感觉 更 高 的 精度 ：
对于 标准 大小 ， 你 可以 使用 适合 你 的 应用 的 任何 其他 整数 格式
请 注意   " get _ matching _ blocks ( ) "   返回 的 最后 一个 元组 总是 只 用于 占位 的   " ( len ( a ) ,   len ( b ) ,   0 ) " ， 这 也 是 元组 末尾 元素 （ 匹配 的 元素 数量 ） 为   " 0 "   的 唯一 情况
返回 一个   " LoggerAdapter "   的 实例 ， 该 实例 的 初始化 使用 了 下层 的   " Logger "   实例 和 一个 字典 类 对象
sminrow   和   smincol   是 源 窗口 的 左上角 坐标 ， 而 其他 变量 则 在 目标 窗口 中 标记 出 一个 矩形
" convert _ arg _ line _ to _ args ( ) "   可 被 重载 以 使用 更 复杂 的 读取 方式
Python   脚本 需要 被 另外 一个 叫做   Python   解释器 的 程序 来 处理
它会 终结 最近 的 外层 循环 ， 如果 循环 有 可选 的   " else "   子句 ， 也 会 跳 过 该 子句
构造函数 接受 一个 将 计时 的 语句 、 一个 用于 设置 的 附加 语句 和 一个 定时器 函数
它 必须 仅 由 绝对路径 而 非 相对路径 组成
字节 顺序 字符   " '   ' "   选择 使用 基于 主机 系统 的 小端 或 大端 排序
2009 年 3 月 16 日 检索 到 的 原始 文件 包含 以下 版权 和 许可 声明 :
一个 可以 注册 到   " SyncManager "   的 类型
默认 情况 下 ，   " timeit ( ) "   暂时 关闭   garbage   collection
不幸 的 是 ， 证明 程序 的 正确性 很大 程度 上 是 经验 性质 的 ， 而且 和   Python   软件 无关
Python 预装 在 大多数 Linux 发行版 上 ， 并 作为 一个包 提供 给 所有 其他 用户
参见 :
在   3.5   版 更改 :   即使 睡眠 被 信号 中断 ， 该 函数 现在 至少 睡眠   secs   ， 除非 信号处理 程序 引发 异常 （ 参见   PEP   475   作为 基本原理 ）
虽然   ConfigParser   对象 也 使用   " OPTCRE "   属性 来 识别 选项 行 ， 但 并 不 推荐 重载 它 ， 因为 这会 与 构造 器 选项   allow _ no _ value   和   delimiters   产生 冲突
有 两个 可 选 只能 用 关键字 的 实参
这是 通过 调用   " POINTER ( ) "   函数 实现 的 ， 它 接收   " ctypes "   类型 为 参数 ， 返回 一个 新 的 类型 :
在   3.6   版 更改 :   所有 形参 现在 都 是 仅限 关键字 参数
如果 听到 “ 哔 ” 提示音 ， 就 说明 支持 行 编辑 ； 请参阅 附录 交互式 编辑 和 编辑 历史 了解 有关 功能键 的 介绍
返回 或 设置 画笔 颜色
（ 由   Steve   Dower   在   bpo   33125   中 贡献 。 ）
参数 :   angle   一个 数值
根据 给定 的 数据 ， 中间 值应落 在   3.5   4.5   分类 之内 ， 并 可 使用 插值法 来 进行 估算 ：
对于 一个 感知 型 对象 而言 ：
除非 特别 说明 ， 否则 所有 标量 项目 均 为 整数
当 调用   " send ( ) "   来 启动 生成器 时 ， 它 必须 以   " None "   作为 调用 参数 ， 因为 这时 没有 可以 接收 值 的   yield   表达式
如果 作用 于类 上 的话 ， 它会 递归 地 作用 于 这个 类 的 所 定义 的 所有 方法 上 （ 但是 对于 超类 或 子类 所 定义 的 方法 不会 生效 ）
（ 由   Serhiy   Storchaka   在   bpo   28286   中 贡献 。 ）
当   " BufferedWriter "   对象 被 关闭 或 销毁 时
一种 方式 是 用 三重 引号 ： " " " " ... " " " "   或   " ' ' ' ... ' ' ' "
演示 和 工具
事实上 你 可以 使用 的 语法分析 程序接口 有 两种 :   " Parser "   API   和 增量 式 的   " FeedParser "   API
这些 值中 的 任何 一个 都 可以 为   " NULL " ， 在 这种 情况 下 将 使用   " None "   作为 对应 属性 的 值
比如 ， 可以 这么 返回 一个 整数 列表 ： 把   " self . count "   设为 0 ， 然后 通过   " count ` ( ) "
default   实参 是 当 可 迭代 对象 为 空时 返回 的 值
配置 函数
将   " PyObject _ GC _ IsTracked ( ) "   和   " PyObject _ GC _ IsFinalized ( ) "   函数 添加 到 公有   API   以 允许 分别 查询   Python   对象 当前 是 正在 被 追踪 还是 已经 被 垃圾 回收 器所 终结
根据 语法 ， 任何 表达式 都 可用 来 表示 一个 参数 ； 最终 算出 的 值会 被 赋 给 对应 的 局部变量
这个 模块 同时 定义 了 以下 常量 ：
异常
" gmtime ( ) " ，   " localtime ( ) "   和   " strptime ( ) "   的 返回值 还 提供 各个 字段 的 属性 名称
你 可以 使用 这些 对象 来 进行 透明 转码 ， 例如 从   Latin   1   转为   UTF   8   以及 反向 转换
密钥 哈希
" make   install "   可以 覆盖 或 伪装   " python3 "   二进制 文件
基类 实现 中 无 任何 实际操作
API   与 特性 的 移除
其 工作 原理 如下 :
获取 指定 域 的 内存 块 分配器
无穷大 是 有 符号 的 （ 仿射 ） 并 可 用于 算术 运算 ， 它们 会 被 当作 极其 巨大 的 不 确定 数字 来 处理
这些 指导 原则 适用 于 任何 你 所要 扩展 的   Python   版本
最早 的 可 表示   " datetime " ， " datetime ( MINYEAR ,   1 ,   1 ,   tzinfo   None ) "
在   3.4 . 3   版 更改 :   增加 了   context
bpo   35259 :   基于   Py _ LIMITED _ API   有 条件 地 声明   " Py _ FinalizeEx ( ) "   ( 3.6   中 新增 )
实例 方法 是   " PyCFunction "   的 包装 器 ， 也 是 将   " PyCFunction "   绑定 到 类 对象 的 一种 新 方式
稳定 的 应用程序 二进制 接口
" return "   语句 会 从 函数 内部 返回 一个 值
什么 是 委托 ？
如果 给定 对象 已 被 垃圾 回收 器 终结 则 返回   " True " ， 否则 返回   " False "
当 队列 中 条目 数量 已经 达到 它 的   maxsize   的 时候 ， 调用   " put _ nowait ( ) "   方法 而 引发 的 异常
此 方法 使得 为   " time "   对象 指定 以 格式化 字符串 字 面值 表示 的 格式化 字符串 以及 使用   " str . format ( ) "   进行 格式化 成为 可能
在 这 两种 情况 下 ， 如果 立即 到达 文件 末尾 ， 则 返回 空 字符串
其中 包括   " absolute _ import " ,   " division " ,   " generators " ,   " generator _ stop " ,   " unicode _ literals " ,   " print _ function " ,   " nested _ scopes "   和   " with _ statement "
协程
这 两种 编码 格式 分别 被 称为   " UTF   32   BE "   和   " UTF   32   LE "
运算符
3.1   新版 功能 .
在   stream   上 打 打印   object   的 格式化 表示 ， 并 附带 一个 换行符
然后 ， 它会 在 转换器 字典 里 查找 那个 类型 注册 的 转换器 函数 ， 并 调用 它
以下 公共 领域 贡献 同时 适用 于   C   哈希 函数 实现 、 扩展 代码 和 本 文档 :
3.3   新版 功能 .
例如   " Element . iter ( ) " :
" join ( ) "   是 字符串 方法 ， 因为 在 使用 该 方法 时 ， 您 告诉 分隔符 字符串 去 迭代 一个 字符串 序列 ， 并 在 相邻 元素 之间 插入 自身
就 地 实现   " TOS   TOS1   /   TOS "
归档 必须 以   " ' w ' " ,   " ' x ' "   或   " ' a ' "   模式 打开
DebuggingServer   对象
如果 在 这个 方法 被 调用 之后 仍然 调用   " feed ( ) "   方法 ， 结果 是 未定义 的
Python   软件 和 文档 的 使用 许可 均 基于   PSF   许可 协议
在   YIQ   空间 中 ， Y   坐标 取值 为   0   和   1   之间 ， 而   I   和   Q   坐标 均 可以 为 正数 或 负数
虽然 这个 转换 是 不 可逆 的 ， 但 它 让   SQL   空 数据 值 转储 到   CSV   文件 更 容易 ， 而 无需 预处理 从   " cursor . fetch   "   调用 返回 的 数据
在 多线程 中 使用 日志
在 运行 时 ， 搜索 路径 可 使用   " reset _ tzpath ( ) "   函数 来 修改
先 将 字符串 的 长度 打包 为 无 符号 整数 ， 再用   " pack _ fstring ( ) "   来 打包 字符串 数据
可 选 参数   sep   ( 默认 为   " ' T ' " )   为 单个 分隔 字符 ， 会 被 放在 结果 的 日期 和 时间 两 部分 之间
注解 :
" Formatter "   类 包含 下列 公有 方法 ：
" textwrap "   文本 自动 换行 与 填充
虽然 语言 规范 描述 不必 规定 如何 发起 调用 语言 解释器 ， 但 对 完整 的   Python   程序 加以 说明 还是 很 有用 的
这 类 事情 只能 用 例子 解释 ， 这里 用 一个 最小化 但 完整 的 的 模块 ， 定义 了 新 的 类型 叫做   " Custom "   在 C 扩展 模块   " custom "   里
在   AIFF   文件 中   ， 压缩 是 无法 实现 的
设置   " default _ factory "   为   " set "   使   " defaultdict "   用于 构建   set   集合 ：
fd   是 文件 描述符 ，   event   是 一个 位 掩码 ， 表示 该 描述符 所 报告 的 事件   " POLLIN "   表示 可以 读取 ， " POLLOUT "   表示 该 描述符 可以 写入 ， 依此类推
在 这种 情况 下 ， 解决方案 是 使用 非 贪婪 的 限定符   "   ? "   、   " + ? "   、   " ? ? "   或   " { m , n } ? "   ， 匹配 为 尽可能少 的 文字
事件 对象
与   " json "   模块 的 比较
顺便 提 一下 ， 如果 你 想要 动态 地 决定 （ 例如 根据 资源 的 可用性 ） 应 使用 哪个 基类 ， 这个 技巧 也 非常 方便
结果 状态   " MaildirMessage "   状态   " unseen "   标签   非   S   标记   " deleted "   标签   T   标记   " answered "   标签   R   标记   " forwarded "   标签   P   标记
一个 包含   pax   全局 标头 的 键值 对 的 字典
填充 一些 文本 到 解析器 中
发布 日期 :   2017   07   23
它 只 在 内部   C   API   ( " pycore _ gc . h " )   中 定义
[   示例   ]
" deque "   对象
fmt   为 文件 的 格式 ， 有效 的 值 如下 :
" 0x02 "   一个 仅限 关键 字形 参 的 默认值 的 字典
确定   object   的 格式化 表示 是否 “ 可 读 ” ， 或 是否 可 被 用来 通过   " eval ( ) "   重新 构建 对象 的 值
创建   Future   和   Task
导入 系统
如果 未指定 ，   则 会 使用   值   ' backslashreplace '
关于   ADPCM   编码 的 详情 请参阅   " lin2adpcm ( ) "   的 描述
代替 ：
如果   Future   为 已 完成 则 返回   " True "
高阶 模块接口
[   脚注   ]
参见 :
退出   newline   模式
如果   maxsize   设 为   " None " ， LRU   特性 将 被 禁用 且 缓存 可 无限 增长
参见 :
line   是 被 执行 的 命令行 ，   stop   是 一个 表示 在 调用   " postcmd ( ) "   之后 是否 终止 执行 的 标志 ； 这 将 作为   " onecmd ( ) "   方法 的 返回值
（   由   Victor   Stinner   在   bpo   40094   中 贡献 。 ）
一个 结构 体 可以 通过 设置   type   字 段 包含 其他 结构 体 或者 自身
这个 方法 是 一个 在   " Cmd "   中 的 存根 ； 塔顶 存在 是 为了 被子 类 覆盖
从 实现 的 角度 来看 ， 这些 是 非常   _ 低 _   级 的 功能
记录器 有 以下 的 属性 和 方法
Connection   对象 允许 收发 可以 序列化 的 对象 或 字符串
可 将 多个 序列 处理 为 单个 序列
通常 来说 是 不合理 的
" await "   " create _ subprocess _ shell ( ) "   运行 一个 shell 命令
提供 了   " __ contains __ ( ) "   方法 的 抽象 基类
如果   filename   是 一个 文件 对象 （ 而 不是 实际 的 文件名 ） ， 则   " " w " "   模式 并 不会 截断 文件 ， 而会 等价 于   " " a " "
几个 例子 :
此表 给出 了 可以 传递 给   " get ( ) "   函数 的 类型 名称 以及 控制器 类 的 相应 实例 化 ， 这些 都 在 此 模块 中 定义
这个 特性 特别 适用 于 运行 时 禁用 硬错误 的 多线程   shell   应用
" locale . getpreferredencoding ( ) "   将 返回   " ' UTF   8 ' "   而 不是 系统 的 编码 格式
AU _ write   对象
下列 方法 与 信息内容 （ 负载 ） 之 访问 与 操控 有关
1 毫秒 会 转换成 1000 微秒
这 与   " ' g ' "   相似 ， 不同之处 在于 它会 使用 当前 区域 设置 来   插入 适当 的 数字 分隔 字符
IDLE   是   Python   所 内置 的 开发 与 学习 环境
如果 语句 体 的 退出 是 由 异常 导致 的 ， 则 其 类型 、 值 和 回溯 信息 将 被 作为 参数传递 给   " __ exit __ ( ) "
引发 审计 事件   " syslog . openlog "   使用 参数   " ident " ,   " logoption " ,   " facility " .
自定义 管理器   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
如果 通过 其他 方式 取消   " something ( ) "   ( 例如 在 其 内部 操作 )   则   " shield ( ) "   也 会 取消
在 某些 情况 下 ， 可以 在 命令 中 包含 版本 限定符 ， 以 指定 命令 将 使用 哪个 Python 版本
在   3.6   版 更改 :   添加 了 可选 的   errors   形参
将   Python   数字 转换 为   C   整型 的 函数 例如   " PyLong _ AsLong ( ) "   以及 带有   " ' i ' "   之类 整型 转换 格式 单元 的 参数 解析 函数 例如   " PyArg _ ParseTuple ( ) "   现在 如果 可能 将会 使用   " __ index __ ( ) "   特殊 方法 而 不是   " __ int __ ( ) "
" open ( ) "   函数 所 返回 的   file   object   类型 取决于 所用 模式
（ 由   Guilherme   Polo   在   bpo   2983   中 贡献 。 ）
参见 :
有如 如 上 例子 中 ， 我们 使用   " Py _ BuildValue ( ) "   来 构造 字典
函数   " PyImport _ AddModule ( ) "   也 会 返回 借用 的 引用 ， 哪怕 可能 会 返回 创建 的 对象 ： 这个 可能 因为 一个 拥有 的 引用 对象 是 存储 在   " sys . modules "   里
考虑一下 这个 :
在 下层 缓冲区 被 分离 后 ， " TextIOBase "   将 处于 不可 用 的 状态
一些 模块 内 置于 解释器 中 ； 它们 提供 对 不 属于 语言 核心 但 仍然 内置 的 操作 的 访问 ， 以 提高效率 或 提供 对系统 调用 等 操作系统 原语 的 访问
第二个 操作数 必须 为 整数
术语   Unix   纪元 秒数 是 指自 国际标准 时间   1970   年   1   月   1   日 零时 以来 经过 的 总 秒数 ， 通常 不 包括 闰秒
执行 单个 测试 的 函数 列表
在 初始化 后 ， Python 程序 可以 更改   " sys . path "
与   " PyStructSequence _ InitType "   相同 ， 但 成功 时 返回   " 0 "   ， 失败 时 返回   "   1 "
如果 提供 了 额外 的 关键字 参数 ， 它们 会 扩展 并 重载   keywords
这是 函数   " debug ( ) "   、   " info ( ) "   、   " warning ( ) "   、   " error ( ) "   和   " critical ( ) "   使用 的 记录器 ， 它们 只 调用 根 记录器 的 同名 方法
返回 指向   object   的 弱 引用 和 代理 的 数量
要 使用 其他 编码 来 解码 文件 ， 请 使用   open   的   " encoding "   参数 :
宽度   If   greater   than   zero ,   specifies   how   much   space ,   in   character   widths ,   to   allocate   for   the   text   label ,   if   less   than   zero ,   specifies   a   minimum   width
配置   " warnings "   模块 以 显示   " ResourceWarning "   警告
如果 被 丢弃 的 空白 字符 占据 了 一个整 行 ， 则 该 整行 将 被 丢弃
"   c "   选项
在   Windows   和   Unix   上 构建 扩展 模块 都 有 两种 方式 ： 使用   " distutils "   包来 控制 构建 过程 ， 或者 全手动 操作
添加 了 便捷 的   " create _ server ( ) "   和   " has _ dualstack _ ipv6 ( ) "   函数 以 自动化 在 创建 服务器 套 接字 时 通常 情况 下 所 必须 的 任务 ， 包括 在 同 一套 接字 中 同时 接受   IPv4   和   IPv6   连接
PEP   218 :   内置 集合 对象
选项   描述   文本   The   textual   label   to   display   for   the   item
下面 是 一个 简单 的 例子 ， 使用   " subdirs "   属性 递归 搜索 两个 目录 以 显示 公共 差异 文件 ：
" RawConfigParser "   具有 默认 的 值   " None "
无论 你 选择 何种 方法 ， 你 都 应当 提供 一个   " repr ( ) "   并且 它 也 需要 隐藏 （ 不 重要 的 ） 值 :
包含 模块 缓冲 I / O 类 使用 的 默认 缓冲区 大小 的 整数
（ 由   Raymond   Hettinger   贡献 。 ）
PEP   308 :   条件 表达式
上面 的 代码 片段 指明 名为   " foo . bar . baz "   的 日志 记录器 应当 关联 到 两个 处理程序 ， 它们 的   ID   是   " h1 "   和   " h2 "
使 其它 装饰 器 起到   " no _ type _ check ( ) "   效果 的 装饰 器
您 可能 需要 提供 管理 凭据 或 批准
比较
shortopts   为 脚本 所 要 识别 的 字母 选项 ， 包含 要求 后缀 一个 冒号   ( " ' : ' " ；   即 与   Unix   " getopt ( ) "   所用 的 格式 相同 )   的 选项
3.8   新版 功能 .
建议 希望 定制 该 文件 的 开发者 在   CPython   的 一个   git   分叉 或 补丁 文件 中 维护 他们 的 更改   ， 就 如 他们 对 源码 树 做 任何 其他 改变 时 一样
3.5   新版 功能 .
变种 与 格式 参数
3.9   新版 功能 .
"   m "   指定 要 分析 的 是 模块 而 不是 脚本
XMLPullParser 对象
请 注意 不 应当 对流 进行 重 定位
在 Python   include 文件 周围 放置 `   extern “ C ” { ... } `   ， 并 在 Python 解释器 调用 的 每个 函数 之前 放置   " extern “ C ” "
通过 敲 下   " import   cgi "   来 开始
构建
它 的 速度 大约 要慢 上 三倍 并且 不会 释放   GIL
支持 的 数据类型
方便 起 见 ，   " python   m   unittest "   与   " python   m   unittest   discover "   等价
如果 给出 了   copy _ function   ， 则 它 必须 为 接受 两个 参数   src   和   dst   的 可 调用 对象 ， 并 将 在   " os . rename ( ) "   无法 使用 时 被 用来 将   src   拷贝到   dst
参见 :
具体 的 类会 有 多种 ： 在 只读 的 二进制 模式 下 ， 它 将 返回   " io . BufferedReader " ； 在 写入 二进制 和 追加 二进制 模式 下 ， 它 将 返回   " io . BufferedWriter " ， 而 在读 / 写 模式 下 ， 它 将 返回   " io . BufferedRandom "
" Decimal "   类型
请 注意 ， 必须 将 初始状态 （ 传入   " lin2adpcm ( ) "   的 状态 ） 发送给 解码器 ， 不能 发送 最终 状态 （ 编码器 返回 的 状态 ）
" email "   包 提供 了 一个 可以 理解 包含   MIME   文档 在内 的 绝大多数 电子邮件 文档 结构 的 标准 语法分析 程序
许多 函数 名 与 特殊 方法 名 相同   ， 只是 没有 双 下划线
" MULTILINE " ,   " M "   多行 匹配 ， 影响   " ^ "   和   " $ "
简单 哈希   ~ ~ ~ ~ ~ ~ ~ ~
通常 非常容易 找到 一个 包含 你 需要 的 字 段 的 例子 ， 然后 改变 值去 适应 你 新 的 类型
但是   ， Python   将 在 运行 时 假定   " . pyc "   文件 是 最新 的 而 完全 不会 将   " . pyc "   与 源文件 进行 验证
这个 方法 在 标签 开始 的 时候 被 调用 （ 例如 ：   " < div   id   " main " > "   ）
返回 浏览器 类型 为   using   指定 的 控制器 对象
不幸 的 是 ， 跟踪 它们 将 创建 一个 会令 其 永久化 的 引用
剪切 复制 选区 至 系统 剪贴板 ， 然后 删除 选区
此 函数 的 主要 目的 是 在   decorator   函数 中 用来 包装 被 装饰 的 函数 并 返回 包装 器
在   3.8   版 更改 :   在   Python   3.8   之前 ， " continue "   语句 不 允许 在   " finally "   子句 中 使用 ， 这 是因为 具体 实现 存在 一个 问题
连接 的 类型 取决于   family   参数 ， 但是 通常 可以 省略 ， 因为 可以 通过   address   的 格式 推导 出来
集合 类型   " set " ,   " frozenset "
调用者 拥有 对象 的 引用 ， 所以 借用 的 引用 生命周期 可以 保证 到 函数 返回
协程 函数   :   定义 形式 为   " async   def "   的 函数 ;
概述
协程 对象
如果 由   offset   给定 了 在   buffer   中 读取数据 的 位置
唯一 必需 的 方法 是   " read ( ) "
源代码 ：   Lib / pdb . py
验证   cert   ( 使用   " SSLSocket . getpeercert ( ) "   所 返回 的 已 解码 格式 )   是否 匹配 给定 的   hostname
现在 想象 一下 这个 正则 与 字符串   " ' abcbd ' "   匹配
3.4   新版 功能 .
如何 通过   " TarFile . extractall ( ) "   使用 生成器 函数 而 非 列表 来 提取 一个   tar   归档 的 子集 :
name   参数 指定 将 被 拷贝 的 数据库 名称 ： 它 必须 是 一个 字符串 ， 其 内容 为 表示 主 数据库 的 默认值   " " main " " ， 表示 临时 数据库 的   " " temp " "   或是 在   " ATTACH   DATABASE "   语句 的   " AS "   关键字 之后 指定 表示 附加 数据库 的 名称
方 差值 较大 表明 数据 的 散布 范围 较大 ； 方 差值 较 小 表明 它 紧密 聚集 于 均值 附近
要 同时 支持   3.8   和 旧版本 ， 请 先 尝试   " pkg   config   python   X . Y   embed   libs "   并 在 此 命令 失败 时 回退 到   " pkg   config   python   X . Y   libs "   ( 即不带   "   embed " )   （ 请 将   " X . Y "   替换 为   Python   版本号 ）
如果 转换 失败 ， 一个   " UnicodeError "   异常 被 引发
如果 锁 被 释放 后 调用 这个 方法 ，   会 引起   " RuntimeError "   异常
下列 函数 可 配置   logging   模块
Python 初始化 配置
发布 版本   源自   年份   所有者   GPL   兼容 ？   0.9 . 0   至   1.2   n / a   1991   1995   CWI   是   1.3   至   1.5 . 2   1.2   1995   1999   CNRI   是   1.6   1.5 . 2   2000   CNRI   否   2.0   1.6   2000   BeOpen . com   否   1.6 . 1   1.6   2001   CNRI   否   2.1   2.0   1.6 . 1   2001   PSF   否   2.0 . 1   2.0   1.6 . 1   2001   PSF   是   2.1 . 1   2.1   2.0 . 1   2001   PSF   是   2.1 . 2   2.1 . 1   2002   PSF   是   2.1 . 3   2.1 . 2   2002   PSF   是   2.2   及 更 高   2.1 . 1   2001   至今   PSF   是
门
3.3   新版 功能 .
" print ( ) "   函数 将 所有 传 进来 的 参数值 打印 出来
" format "   是 整个 格式 字符串 ， 而   " datefmt "   条目 则 是 兼容   " strftime ( ) "   的 日期 / 时间 格式 字符串
某些   data   可以 在 内部 被 缓冲 ， 以便 用于 后续 的   " decompress ( ) "   调用
将 名称 映射 到 嵌套 函数 和 类 描述 器 的 字典
bpo   33127 :   ssl 模块 现在 使用 LibreSSL   2.7 . 1 编译
在   " with "   语句 中 使用 锁 、 条件 和 信号量
核心 与 内置
" finditer ( ) "   方法 将 一个 匹配 对象 的 序列 返回 为 一个   iterator
想要 编写   C   或者   C++   扩展 可以 参考 扩展 和 嵌入   Python   解释器 和   Python / C   API   参考手册
这 可能 会 违反 人类 的 直觉
参见 :   此 错误 被 映射 到 异常   " InterruptedError "
它会 在 发生 了 一个 异常 但   Python   没有 办法 处理 时 被 调用
" i "   ( " int " )   [ int ]   将 一个   C   " int "   整型 转化成   Python   整型 对象
如果 锁为   locked   则 返回   " True "
fullname   必须 是 完全 限定 的 （ 点分 的 ） 模块 名
该 函数 在 调用 过程中将 释放   GIL
修改 字符串
载入 上下文 管理器 的   " __ enter __ ( ) "   以便 后续 使用
有 两种 有效 的 属性 名称 ： 数据 属性 和 方法
格式 错误 的 变量 名称 和 对 不 存在 变量 的 引用 保持 不变
传给 构造函数 的 原始   URL
实现 应当 确保   " 0 "   是 最 常见 的 状态
在 任何 编辑器 下 ， 混合 制表符 和 空格 都 是 一个 坏主意
以下 是 支持 的 特殊 按键 ：
此 格式 是   POSIX.1   2001   pax   格式 的 一个 变种 ， 但 并 不 保持 兼容
现在   " pprint "   能 美化 打印   " types . SimpleNamespace "
如何 等待 排队 的 任务 被 完成 的 示例 ：
在   3.4   版 更改 :   增加 了   compact   形参
它 还 将 加载 器 的 大部分 样板 责任 移交 回 导入 机制 中
在   3.5   版 更改 :   添加 了   " ' x ' "   ( 仅 创建 )   模式
创建 一个 解析器
可以 通过 传递 可 调用 的   opener   来 使用 自定义 开启 器
使用 此 函数 可 在 你 的 应用程序 中 支持 透明 效果
否则 的话 ， 将 对 该值 的 引用 存入 局部 命名 空间 ， 如果 有   " as "   子句 则 使用 其 指定 的 名称 ， 否则 使用 该 属性 的 名称
但是 请 注意 ， 使用 它们 并 不能 保证 跨   Python   版本 的 二进制 兼容性 ， 因此 在 扩展 模块 被 弃用
这种 检查 在 解压缩 时 使用 ， 以 确保 数据 没有 被 破坏
" multiprocessing . shared _ memory "   可 从 进程 直接 访问 的 共享内存
例如 :
[ 1 ]   这种 格式 使用 的 场合 有   Audio   Interchange   File   Format   ( AIFF / AIFF   C )   和   Real   Media   File   Format   ( RMFF )   等
查看   Distinguishing   test   iterations   using   subtests   获取 更 详细 的 信息
[ 图片 ]
子类 还 负责 储存 和 从文件 或 数据库 中 查找   cookies
最 常见 的 提供 颜色 的 终端 很 可能 是   Linux   控制台 ， 采用 了   xterms   配色 方案
美化 输出 :
创建 文档 字符串 字典 并 将 其 写入   filename   指定 的   Python   脚本 文件
将类 数据 以   netrc   文件 的 格式 转储 为 一个 字符串
例如 :
这些 函数 必须 分别 提供 由 基类   " IncrementalEncoder "   和   " IncrementalDecoder "   所 定义 的 接口
致谢
一个 常见 的 约定 是 将 此 列表 放在   " requirements . txt "   文件 中 ：
如果 它 的 参数 是 一个 C 类型   " PyComplexObject "   或者 是 C 类型   " PyComplexObject "   的 子 类型 ， 返回 真
Reader   对象 具有 以下 公开 属性 ：
" cancelled ( ) "   可 被 用来 检测   Task   对象 是否 被 取消
有关 详细信息 ， 请参阅 ： 帮助 和 首选项 下 的 首选项 设置
" SSLError "   的 子类 ， 当 尝试 在   SSL   套 接字 上 执行 操作 时 遇到 系统 错误 时会 被 引发
该 模块 提供 对 Unix 组 数据库 的 访问
如果 选项 字符串 的 第一个 字符 为   " ' + ' " ， 或者 如果 设置 了 环境变量   " POSIXLY _ CORRECT " ， 则 选项 处理 会 在 遇到 非 选项 参数 时 立即 停止
进阶 用法 ： 你 可以 派生   " Template "   的 子类 来自 定义 占位 符 语法 、 分隔符 ， 或 用于 解析 模板 字符串 的 整个 正则表达式
基本 对象
3.9   版后 已 移除 :   Deprecated   in   favor   of   " headers " .
在 交互 模式 下 ， 上 一次 打印 出来 的 表达式 被 赋值 给 变量   " _ "
一个 计数器 工具 提供 快速 和 方便 的 计数
返回 哈希 对象 的 副本 （ “ 克隆 ” ）
当 载入 包含 足够 巨大 / 复杂 条 目的 数据库 时有 可能 导致   Python   解释器 的 崩溃 ， 这是 由于   Python   AST   编译器 有栈 深度 限制
将 反 引号   repr   表达式 替换 为   " repr ( ) "   函数
fixed   如果 该 字体 宽度 被 固定 则 为 1 ， 否则 为 0
如果 该 对象 不是 序列 或 可 迭代 对象 ， 则 会 引发   " TypeError "   并 将   m   作为 消息 文本
海龟 动作
没有 可用 的 缓冲区 空间
在   3.4   版 更改 :   Default   " Request . method "   may   be   indicated   at   the   class   level .
某些 运算 例如 与 整数 相加 、 相减 和 相乘 将会 自动 保留 固定 的 小数位 数
表达式 语句 的 句法 为 :
（ 由   Morehouse   在   bpo   35224   中 贡献 。 ）
例如 目录 条目 所 允许 的 字符 、 文件名 的 长度 、 路径名 的 长度 、 单个 文件 的 大小 以及 文件 的 数量 等等
一些 应用程序 可以 使用   SQLite   作为 内部 数据 存储
字符串 可以 用   " + "   进行 连接 （ 粘到 一起 ） ， 也 可以 用   "   "   进行 重复 :
可以 在 定义   Structure   子类 的 类 语句 之后 再 定义   " _ fields _ "   类 变量 ， 这 将 允许 创建 直接 或 间接 引用 其 自身 的 数据类型 :
根据   Python   DB   API   规格 描述 的 要求 ， " rowcount "   属性   " 当未 在   cursor   上 执行   " executeXX ( ) "   或者 上 一次 操作 的   rowcount   不是 由 接口 确定 时为   1 "
Mock   是 为   " unittest "   而 设计 ， 且 简单 易用
如果 指定 则 必须 为 一个 字符串 ， 它 将 被 用作   " datetime . tzname ( ) "   方法 的 返回值
等价 于   Python   表达式   " o1   < <   o2 "
" select ( ) "   复杂度 为   O （ 最高 文件 描述符 ） ， " poll ( ) "   为   O （ 文件 描述符 数量 ） ， 而   " / dev / poll "   为   O （ 活动 的 文件 描述符 ）
运行 完整 的 单元测试 是 很 慢 的
3.5   新版 功能 .
测试
Smith   撰写 并 实现
" http . cookiejar "   模块 定义 了 用于 自动 处理   HTTP   cookie   的 类
可 选 参数   n   ( 默认 为   " 3 " )   指定 最 多 返回 多少 个 近似 匹配 ；   n   必须 大于   " 0 " .
注解 :
它 并 不 被 设计 为 一个   curses   API   的 完整 指南 ； 如需 完整 指南 ， 请 参见   ncurses   的   Python   库 指南 章节 和   ncurses   的   C   手册 页
Python   X . Y   的 库 之后 被 安装 为   " / usr / local / lib / python   X . Y   "
3.2   新版 功能 .
这 需要 调用函数   " noecho ( ) " ：
将 返回 新创建 文件 所 对应 的 路径
如果 基类 本身 也 派生 自 其他 某个 类 ， 则 此 规则 将 被 递归 地 应用
返回 由 指向   object   的 所有 弱 引用 和 代理 构成 的 列表
" shelve "   Python   对象 持久 化
回调 的 返回值 将 被 忽略
停止 收集 分析 数据 ， 并 在 内部 将 结果 记录 为 当前   profile
注解 :
如果   sort _ keys   是   true （ 默认 为   " False " ） ， 那么 字典 的 输出 会 以键 的 顺序 排序
返回   o1   和   o2   “ 按位 与 ” 的 结果 ， 如果 失败 ， 返回   " NULL "
If   passwd _ mgr   also   provides   " is _ authenticated "   and   " update _ authenticated "   methods   ( see   HTTPPasswordMgrWithPriorAuth   对象 ) ,   then   the   handler   will   use   the   " is _ authenticated "   result   for   a   given   URI   to   determine   whether   or   not   to   send   authentication   credentials   with   the   request
" with "   语句
子类 不 需要 重载 或 扩展   " __ init __ ( ) "   方法
抽象 对象 层
传给 异常 构造 器 的 参数 元组
在   3.6   版 更改 :   除了 字符串 值 ， 也 接受   " Path "   对象 作为   filename   参数
最终 预测值 应为 最大 后验 概率 值
（ 仅   POSIX ）
“ 为什么 我 的 电脑 上 安装 了   Python   ？ ”
3.4   新版 功能 .
根据 其 创建 方式 的 不同 ， 文件 对象 可以 处理 对 真实 磁盘 文件 ， 对 其他 类型 存储 ， 或是 对 通讯设备 的 访问 （ 例如 标准 输入 / 输出   、 内存 缓冲区 、 套 接字 、 管道 等等 ）
参见 :
字符串 可以 很 轻松 地 写入 文件 并 从文件 中 读取 出来
这 两种 方式 会 在 模块 函数 和 常量 一节 中 描述 ， 相应 条目 为   " PARSE _ DECLTYPES "   和   " PARSE _ COLNAMES "   常量
为什么 必须 在 方法 定义 和 调用 中显式 使用 “ self ” ？
下面 是 一个 例子 :
许多   Unix   兼容 的 操作系统 ， 例如   Mac   OS   X   和 一些   Linux   发行版 ， 默认 安装 了 Python ； 它 被 包含 在 基本 安装 套件 中
此 选项 仅为   只读 ， 并且 只能 在 创建 窗口 时 指定
如果 大于   1 ， 则 多余 部分 将 用于 跳过 堆栈 帧 ， 然后 再 确定 要 返回 的 值
" sys "   系统 相关 的 参数 和 函数
如果   completekey   不是   " None "   并且   " readline "   是 可用 的 ，   命令 完成 会 自动 完成
这些 方法 会 被   " datetime "   或   " time "   对象 调用 ， 用来 与 它们 的 同名 方法 相对 应
清空 现有 字典 的 所有 键值 对
如果 输入 由 不 正确 的   uuencode   编码器 生成 ， " decode ( ) "   可能 会 打印 一条 警告 到 标准 错误   ， 这样   Python   可以 从 该 错误 中 恢复
引发 一个 审计 事件   " builtins . breakpoint "   并 附带 参数   " breakpointhook "
Template   的 子类 可以 自定义 分隔符
无法 确定 的 条目 会 被 设为   " ' ' "
它 的 值 可能 被 用来 在 全 系统 范围 内 唯一 地 标识 这个 特定 线程 （ 直到 线程 终结 ， 在 那 之后 该值 可能 会 被   OS   回收 再 利用 ）
我 在   Amoeba   中 处理错误 的 经验 令 我 深刻 地 意识 到 异常 处理 在 编程语言 特性 当中 的 重要 地位
3.9   版后 已 移除 :   Deprecated   in   favor   of   " url " .
" ' __ main __ ' "   是 顶层 代码执行 的 作用域 的 名称
逻辑 操作数
将   fun   指定 的 函数 绑定 到 在 此 海龟 上 释放 鼠标 按键 事件
ury   一个 数值 ,   画布 右上角 的   y   坐标
指令   意义   注释   " % a "   本地化 的 缩写 星期 中 每日 的 名称
构建
Windows 上 的 所有 事件 循环 都 不 支持 以下 方法 :
TarFile   对象
在 之前 版本 中   " PyCF _ ALLOW _ TOP _ LEVEL _ AWAIT "   会 与   " CO _ FUTURE _ DIVISION "   发生冲突
圆括号 、 方括号 或花 括号 以内 的 表达式 允许 分成 多个 物理 行 ， 无需 使用 反 斜杠
如果   p   是 字典 对象 但 不是 字典 类型 的 子 类型 的 实例 ， 则 返回 真
如果 生成 失败 或 找 不到   spec ， 导入 系统 将 使用 模块 中 的 各种 可用 信息 来 制作 一个 默认   repr
例如 ， " 077e010 "   是 合法 的 ， 且 表示 的 数值 与   " 77e10 "   相同
载入 动态 连接 库
返回   x   和   y   的 积
本章 描述 的 模块 提供 了   Unix   操作系统 独有 特性 的 接口 ， 在 某些 情况 下 也 适用 于 它 的 某些 或 许多 衍生 版
如果 你 经常 在 电脑 上 工作 ， 总会 有些 任务 会想 让 它 自动化
以下 是 该 代码 的 运行 结果 ：
此 例程 允许 / 禁止 SQLite 引擎 从 共享 库 加载 SQLite 扩展
数据库
有关   __ main __   的 特殊 事项
如果 终端 支持 所 请求 的 可见 性 ， 则 返回 之前 的 光标 状态 ； 否则 会 引发 异常
将 路径   path   拆 分为 一对 ， 即   " ( head ,   tail ) " ， 其中 ，   tail   是 路径 的 最后 一部分 ， 而   head   里 是 除 最后 部分 外 的 所有 内容
是否 有 办法 将 它们 转换 为 一个 可 识别 的 规范 值 ？
例如 ， 不要 这样 写 :
" ImproperConnectionState "   的 一个 子类
distutils 也 支持 创建 二进制 包 ， 用户 无需 编译器 而 distutils 就 能 安装 扩展
调用者 提供 的 缓冲区 从来 都 不会 被 由   " Py _ BuildValue ( ) "   创建 的 对象 来 引用
设置 焦点 到   TurtleScreen   ( 以便 接收 按键 事件 )
默认值 是   " ' rb ' "
本节 是 Python 发行版 中 收录 的 第三方 软件 的 许可 和 致谢 清单 ， 该 清单 是 不 完整 且 不断 增长 的
Screen   专有 方法 ,   而 非 继承 自   TurtleScreen
3.4   新版 功能 .
这种 格式 是   Python   专属 的 ， 但是 独立 于 特定 的 机器 架构 （ 即 你 可以 在 一台   PC   上 写入 某个   Python   值 ， 将 文件 传到 一台   Sun   上 并 在 那里 读取 它 ）
它 是   " DatabaseError "   的 子类
设置 与 特殊 方法
" nonlocal "   语句 会 使得 相应 的 名称 指向 之前 在 最近 包含 函数 作用域 中 绑定 的 变量
注意   " ArgumentParser "   对象 只能 移除 一个 行为 如果 它 所有 的 选项 字符串 都 被 重写
注解 :
它 可以 是 以下 值 之一 ：
在 生成 该 进程 之前 ， 这 将 是   " None "
在 消除 未 使用 的   " PUT "   操作码 之后 返回 一个 新 的 等效   pickle   字符串
回溯
" c "   ( " bytes "   或者   " bytearray "   长度 为   1 )   [ char ]   将 一个   Python   字节 类型 ， 如 一个 长度 为   1   的   " bytes "   或者   " bytearray "   对象 ， 转化成 一个   C   " char "   字符 类型
模块   " zlib "   支持   gzip   格式 所 需要 的 基本 压缩 模块
返回 分配 给 字符   chr   的 规范 组合 类 作为 整数
与   GPL   不同 ， 所有   Python   许可证 都 允许 您 分发 修改 后 的 版本 ， 而 无需 开源 所 做 的 更改
请参阅   " TextWrapper . wrap ( ) "   方法 了解 有关   " wrap ( ) "   行为 的 详细信息
字符串 表示
用于 创建 子 进程 的 指令
访问 内部 对象
感知 型 和 简单 型 之间 的 区别 不适 用于   " timedelta "   对象
源代码 ：   Lib / http / cookiejar . py
对于 最高 层级 的 函数 和 类 ， 限定 名称 与 对象 名称 一致 :
注解 :
key _ type   描述   " ' filename ' "   文件名   " ' lineno ' "   文件名 和 行号   " ' traceback ' "   回溯
任何 容器 都 可 作为   choices   值 传入 ， 因此   " list "   对象 ， " set "   对象 以及 自定义 容器 都 是 受 支持 的
它 与   " Py _ None "   一样 属于 单例 对象
使用   re . VERBOSE
你 也 可以 使用   " : memory : "   来 创建 一个 内存 中 的 数据库
它 适用 于 在 交互 提示符 下 进行 检测 :
这个 问题 的 第二种 情况 是 借用 的 引用 涉及 线程 的 变种
" formatter "   通用 格式化 输出
这些 值 并 不 被 设计 用来 对外 公开 给 最终用户 ； 对于 面向用户 的 元素 ， 应用程序 应当 使用   CLDR   ( Unicode   通用 区域 数据 存储 库 )   之类 来 获取 更为 用户 友好 的 字符串
3.5   版后 已 移除 :   Use   " Signature . bind ( ) "   and   " Signature . bind _ partial ( ) "   instead .
TypedDict   只 使用 字符串 作为 键
3.3   新版 功能 .
运算   结果   " date2   date1   timedelta "   date2   等于 从   date1   减去   " timedelta . days "   天
( 实际上 ， 前 三个 错误 会 被 解析器 发现 ； 只有 最后 一个 错误 是 由 词法 分析器 发现 的   " return   r "   的 缩进 无法 匹配 弹出 栈 的 缩进 层级 。 )
使 对象 类型 支持 循环 垃圾 回收
如果 此 行为 不 合适 则 要 重载 此 方法
如果   " policy "   明确要求 某些 字段 是 唯一 的 （ 至少 标准 策略 就 有 这么 做 ）   ， 对 这些 字段 在 已有 同 名字 段 的 情况 下 仍然 调用 此 方法 尝试 为 字段名 赋值 会 引发   " ValueError "   异常
" __ anext __ "   必须 返回 一个   awaitable   对象
调试 钩子 现在 也 检查 当   " PYMEM _ DOMAIN _ OBJ "   和   " PYMEM _ DOMAIN _ MEM "   域 的 函数 被 调用 时 ， 全局 解释器 锁 是否 被 持有
窗口 相对 于 屏幕 的 参数 不会 被 更改
3.2   新版 功能 .
在   " __ all __ "   中 所 给出 的 名称 都 会 被 视为 公有 并且 应当 存在
打印 找到 的 不可 回收 对象 的 信息 （ 指 不能 被 回收 器 回收 的 不可 达 对象 ）
检测   filename   字符串 是否 匹配   pattern   字符串 ， 返回   " True "   或   " False "
一个 进程 池 对象 ， 它 控制 可以 提交 作业 的 工作 进程 池
注意 ，   这个 函数 第一个 参数 的 行为 和   " threading . RLock . acquire ( ) "   的 实现 有 几个 不同点 ， 包括 参数 名 本身
解释器 会 将 该 名称 所 指向 的 对象 识别 为 用户 自定义 函数
3.3   新版 功能 :   监听器 对象 现在 支持 了 上下文 管理 协议 见 上下文 管理器 类型
注意 ， 数据 读取 在 内存 中是 带 缓冲 的 ， 因此 如果 数据 量过大 或 不 受 则 不要 使用 此 方法
当 以下 事件 中 的 某 一个 发生 时 ， 这个 目录 应当 与其 内容 一起 被 删除 ：
如果 没有 错误 ， 重新启动   shell   以 清理 环境 ， 然后 执行 模块
由于 前者 是 后者 的 子类 ， 此 改变 是 向 后 兼容 的
" base64 "   Base16 ,   Base32 ,   Base64 ,   Base85   数据编码
库
将 来自   iterable   的 项 添加 到 数组 末尾
存储 的 指针 不是   " NULL "
" shlex . quote ( ) "   函数 可以 被 用来 正确 地 转义 字符串 中 可以 被 用来 构造   shell   命令 的 空白 字符 和 特殊   shell   字符
在   3.2   版 更改 :   Support   for   " load _ tests "   added .
示例
要 注意 搜索 是   O ( log   n )   的 ， 插入 却是   O ( n )   的
class :   timedelta   用法 示例
如果   module   值有 定义 ， 命名 元组 的   " __ module __ "   属性 值 就 被 设置
( 实际上 在 本 文档 中 始终 采用 此 规则 来 定义 词法 和 语法 规则 的 名称 。 )
Python   3.6 . 2   中 的 重要 变化
它们 可以 自由 地 添加 额外 的 关键字 参数 ， 但 只有 在 这里 定义 的 参数 才 会 被   Python   编解码器 注册表 所 使用
如果 有 某个 按键 正在 等待 被 读取 则 返回   " True "
" C   a "   行首
" heapq "   堆 队列 算法
设置 文件 指针 到 指定 位置
使用 为   encoding   注册 的 编解码器 对   obj   进行 解码
这些 选项 以及 所有 其他 选项 在   " Popen "   构造函数 文档 中有 更 详细 的 描述
参数 可以 是 整数 、 浮点数 或 任何 实现 了   " __ abs __ ( ) "   的 对象
如果 没有 这样 的 元素 ， 则 抛出   " ValueError "   异常
创建 一个 共享 的   " threading . RLock "   对象 并 返回 它 的 代理
默认 情况 下 ， 打包 给定   C   结构 的 结果 会 包含 填充 字节 以 使得 所 涉及 的   C   类型 保持 正确 的 对齐 ； 类似 地 ， 对齐 在 解包 时 也 会 被 纳入 考虑
要 获取 插值 ， 请 使用   " ConfigParser " :
例如 ， 如果 你 有 一个 最高 层级 模块 文件   " foo . py " ， 它 又 导入 了 另 一个 模块   " xyz . py " ， 当 你 运行   " foo "   模块   ( 通过 输入 终端 命令   " python   foo . py " ) ， 则 将 为   " xyz "   创建 一个   " . pyc " ， 因为   " xyz "   是 被 导入 的 ， 但 不会 为   " foo "   创建   " . pyc "   文件 ， 因为   " foo . py "   不是 被 导入 的
参数 的 存在 和 类型 取决于 异常 类型
用户 定义 对象
" None ` ` （ 默认值 ） 选择 最 紧凑 的 表达
如果   cancel _ futures   和   wait   均 为   " True " ， 则 执行器 已 开始运行 的 所有   Future   将 在 此 方法 返回 之前 完成
第一个 仅 用作 输入 ， 并且 必须 为   " const   char   " ， 它 指向 一个 以   NUL   结束 的 字符串 表示 的 编码 格式 名称 ， 或者 为   " NULL " ， 这 表示 使用   " ' utf   8 ' "   编码 格式
" unittest . mock "   mock 对象 库
返回   obj   的   C   " long "   表达方式
请 查看   Python   2.3   方法 解析 顺序 了解 自   2.3   版起   Python   解析器 所用 相关 算法 的 详情
工具 / 示例
原始 文件   I / O
模块 级 装饰 器 、 类 和 函数
当   datetime1   的 时间 在   datetime2   之前 则 认为   datetime1   小于   datetime2
要 按 抽象 字符 级别 （ 即 对 人类 来说 更 直观 的 方式 ） 对 字符串 进行 比较 ， 应 使用   " unicodedata . normalize ( ) "
( 默认 :   " True " )   如果 为 真值 ， 则   text   中 所有 的 制表符 将 使用   text   的   " expandtabs ( ) "   方法 扩展 为 空格符
纯 嵌入
可以 调用 前 一 问题 中 介绍 的 函数   " PyRun _ String ( ) "   并 附带 起始 标记 符   " Py _ eval _ input " ； 它会 解析 表达式 ， 对 其 求值 并 返回 结果 值
default   raw   memory   allocator   使用 这些 函数 ： " malloc ( ) " 、   " calloc ( ) " 、   " realloc ( ) "   和   " free ( ) " ； 申请 零 字节 时则 调用   " malloc ( 1 ) "   （ 或   " calloc ( 1 ,   1 ) " ）
" KeyError "   的 引发 则 针对 一般 映射 错误 例如 指定 了 不 正确 的 键
单词 被 定义 为 一个 字母 数字 字符 序列 ， 因此 单词 的 结尾 由 空格 或非 字母 数字 字符 表示
PEP   468 :   保留 关键字 参数 顺序
交互 型 提示
增加 缩进 将 选定 的 行 右移 缩进 宽度 （ 默认 为 4 个 空格 ）
（ 由   Christian   Heimes   和   Mark   Dickinson   贡献 。 ）
在   writer   的 文件 对象 中 ， 写入 一行 字段名 称 （ 字段名 称 在 构造函数 中 指定   ） ， 并 根据 当前 设置 的 变种 进行 格式化
注释 可以 出现 在 一行 的 开头 或者 是 空白 和 代码 的 后边 ， 但是 不能 出现 在 字符串 中间
（ 由   C é dric   Krier   在   bpo   13918   中 贡献 。 ）
如果   Python   没有 以   "   O "   选项 启动 ， 则 此 常量 为 真值
" partial "   对象
否则 返回   " 0 "
" ChainMap "   对象
类 对象
每个 路径 可以 是 绝对 的 或 相对 于 文件 的 位置
你 可以 使用   " nonlocal "   关键字 在 嵌套 作用域 中 执行 类似 的 操作 ：
优先 队列 实现 说明
三角函数
此 方法 先 执行   " unregister ( ) "   后 执行   " register ( ) "
锁 对象 有 以下 方法 ：
字符串 的   " str . format ( ) "   方法 需要 更 多 的 手动 操作
对于 大多数 用户 ， 建议 使用   " cProfile "   ； 这是 一个   C   扩展 插件 ， 因为 其 合理 的 运行 开销 ， 所以 适合 于 分析 长时间 运行 的 程序
（ 由   Mark   Dickinson 在   bpo   4258   贡献 ）
此 异常 是   " UnicodeError "   的 一个 子类
但是 ， 子类 的   " __ init __ ( ) "   方法 需要 调用   " Handler .__ init __ ( ) "
默认 情况 下 ， 只有 最近 的 帧 会 保存 在 跟踪 的 回溯 信息 中
" getche ( ) "   的 宽 字符 版本 ， 返回 一个   Unicode   值
模式   One   of   " determinate "   or   " indeterminate "
这是 完整 的   Python   语法 规范 ， 直接 提取 自 用于 生成   CPython   解析器 的 语法   (   参见   Grammar / python . gram )
名义 性子 类型 区别 于 结构 性子 类型
然后 ， 当 你 尝试 在 字典 中 查找 相同 的 对象 时 ， 将 无法 找到 它 ， 因为 其 哈希 值 不同
字符 编码
使用   " subprocess "   模块
如果   delay   为 真值 ，   则 文件 打开 会 被 推迟 至 第一次 调用   " emit ( ) "   时
bpo   35360 :   更新   Windows   构建 以 使用   SQLite   3.28 . 0 .
Tab   补全 和 编辑 历史
当下 层 迭代 器 完成 时 ， 被 引发 的   " StopIteration "   实例 的   " value "   属性 会 成为   yield   表达式 的 值
" itertools "   为 高效 循环 而 创建 迭代 器 的 函数
发布 日期 :   2017   07   07
Metzener   对于 一种 类似 算法 的 讨论
注解 :
3.5 . 2   新版 功能 .
这 限制 了 可 被 存储 在 其中 的 值 只能 是   " int " ,   " float " ,   " bool " ,   " str "   （ 每条 数据 小于 10M ） ,   " bytes "   （ 每条 数据 小于 10M ） 以及   " None "   这些 内置 类型
幂函数 与 对数函数
Handler   有 以下 属性 和 方法
一个 缩进 不可 使用 反 斜杠 进行 多行 拼接 ； 首个 反 斜杠 之前 的 空格 将 确定 缩进 层次
返回 一个   3   元组 ， 其中 包含 给定 颜色 的   R , G , B   值 ， 它们 必须 介于   " 0 "   ( 无 分量 )   和   " 1000 "   ( 最大 分量 )   之间
如果   kwargs   为   " None "   （ 默认值 ） ， 则 会 使用 一个 空 字典
如果 要 编写 可 用于 任何 python 实现 的 代码 ， 则 应 显式 关闭 该 文件 或 使用   " with "   语句 ； 无论 内存 管理 方案 如何 ， 这 都 有效 ：
包含 文件
Since   Python   3.8 ,   " AsyncMock "   and   " MagicMock "   have   support   to   mock   异步 迭代 器   through   " __ aiter __ "
两个 矩形 都 必须 完全 包含 在 其 各自 的 结构 之内
源代码   :   Lib / email / parser . py
注解 :
如果 想 改变 这种 行为 ， 见   formatter _ class   参数
封存
" ' n ' "   数字
这 就是 所谓 的 “ 部分 函数 应用 ”
检查 进程 的   " exitcode "   以 确定 它 是否 终止
未 创建 文档 的 模块
如果 取消 期间 一个 协程 正在 等待 一个   Future   对象 ， 该   Future   对象 也 将 被 取消
当 嵌入   Python   时 ， 源码 字符串 传入   Python   API   应 使用 标准   C   的 传统 换行符   ( 即   " \ n " ， 表示   ASCII   字符   LF   作为 行 终止 标志 )
修改 XML 文件
3.8   新版 功能 .
（ 由   Anand   B
Event   描述   < < TreeviewSelect > >   Generated   whenever   the   selection   changes
形参为 该 对象 、 要 调用 的 方法 名 、 类似   " Py _ BuildValue ( ) "   所用 的 格式 字符串 以及 要 传给 方法 的 参数值 :
这 适用 于 处理   Web   浏览器 预 开启 套 接字 ， 以便   " HTTPServer "   无限期 地 执行 等待
如果 队列 是 满 的 返回   " True "   ， 否则 返回   " False "
3.6   版后 已 移除 :   OpenSSL   has   deprecated   all   version   specific   protocols
概述
只读 属性
当锁 为   locked   时 ， 将 其设 为   unlocked   并 返回
供   " repr ( ) "   使用 的 递归 实现
其 属性 有 :
本章 描述 了 定义新 对象 类型 时所 使用 的 函数 、 类型 和 宏
静态 DTrace 探针
模块   " termios "   低级 终端 控制 接口
自动 打开 堆栈 查看器 在 未 处理 的 异常 上 切换 自动 打开 堆栈 查看器
在 复杂 的 正则 中 ， 很难 跟踪 组号
执行 语句 体
图片   Specifies   an   image   to   display   in   the   tab
所有 参数 都 是 可选 的
解包 并 返回 可变 长度 字节 流 ， 类似 于   " unpack _ string ( ) "
" ' hours ' " :   以 两个 数码 的   " HH "   格式 包含   " hour "
" time "   对象 支持   " time "   与   " time "   的 比较 ， 当   a   时间 在   b   之前 时 ， 则 认为   a   小于   b
“ 格式 规格 ” 在 格式 字符串 所 包含 的 替换 字 段 内部 使用 ， 用于 定义 单个 值应 如何 呈现   ( 参见 格式 字符串 语法 和 格式化 字符串 字 面值 )
撤销 协程 .
这是 相应 的   C   声明 :
在   3.2   版 更改 :   对此 方法 的 非 整数 输入 会 被 舍入 到 最 接近 的 整数
参考 一个 类似 函数   " functools . reduce ( ) "   ， 它 只 返回 一个 最终 累积 值
[   脚注   ]
访问 自由 变量 的 字节 码 序列 （ 请 注意 这里 所说 的 ‘ 自由 ’ 是 指 在 当前 作用域 中 被 内部 作用域 所 引用 的 名称 ， 或 在 外部 作用域 中 被 此 作用域 所 引用 的 名称
" math . gcd ( ) "   总是 返回   " int "   类型
本 模块 提供 读写   AIFF   和   AIFF   C   文件 的 支持
此 函数 允许 为预 输入 检查 指定 其他 的 文件 描述符
（ 这 在 定义 了   " __ all __ "   时 也 有效 。 ）
容器 抽象 基类
不带 参数 时 ， 显示 可用 的 命令 列表
安全
如果 此参数 为 正值 ， 并且 下层 原始 流 不可 交互 ， 则 可能 发起 多个 原始 读取 以 满足 字节 计数 （ 直至 先 遇到   EOF ）
虽然 可能 使用   " RawConfigParser "   ( 或 使用   " ConfigParser "   并 将   raw   形参设 为 真值 )   以便 实现 非 字符串 值 的   internal   存储 ， 但是 完整 功能 （ 包括 插值 和 输出 到 文件 ） 只能 使用 字符串 值来 实现
其他 常见 模式 有 ： 写入   " ' w ' "   （ 截断 已经 存在 的 文件 ） ； 排它 性 创建   " ' x ' "   ； 追加 写   " ' a ' "   （ 在 一些   Unix   系统 上 ， 无论 当前 的 文件 指针 在 什么 位置 ，   所有 写入 都 会 追加 到 文件 末尾   ）
如果   " foo "   扩展 属于 根包 ， 则 配置 脚本 可以 是 ：
Unix   平台
类 属性 ：
跳过 测试 的 基本 用法 如下 :
如果   name   被 视作 资源 ， 则 返回 True
如果   address   不是 一个 有效 的   IPv4   地址 ， 会 抛出   " AddressValueError "
格式化 程序 使用 用户 可 配置 的 函数 将 记录 的 创建 时间 转换 为 元组
Join   使用 队列 的 进程
Unicode   规范   ( https : / / www . unicode . org / )   旨在 列出 人类 语言 中 用到 的 每个 字符 ， 并 赋予 每个 字符 唯一 的 编码
" StreamWriter "   发送 网络 数据 的 高级 async / await 对象
" code "   模块 提供 了 在   Python   中 实现   read   eval   print   循环 的 功能
使用   " locals ( ) "   来 解析 出 函数 名 :
3.8   新版 功能 .
" ast "   抽象 语法 树
新增 ， 改进 和 弃 用 的 模块
编程语言 支持 通过 以下 几种 方式 来 解构 具体 问题 ：
映射 协议
现在 ， 让 我们 使用 另 一种 的 方式 来 改变 冗长 度
一个 可以 更新 的 映射 列表
使用 简短 的 操作码 描述 来 标注 每 一行
" ( flags   &   0x03 )   0x00 " :   value   按 原样 格式化
此 模块 被   " traceback "   模块 用来 提取 源码 行 以便 包含 在 格式化 的 回溯 中
标准 多项 集中 的 类型 标注 泛型
如果 你 需要 后者 ， 请参阅 本节 中 的   " staticmethod ( ) "
在   3.3   版 更改 :   现在 ， 文件 的   truncate   方法 可 接受 一个   " size "   参数
默认 主机名 为   ' localhost '   但 如果 你 希望 能 从 其他 机器 搜索 该 服务器 ， 你 可能 会 想要 改变 服务器 所 响应 的 主机名
或者 可以 在 命令提示符 或   PowerShell   会话 中 输入   " python "   来 启动
函数
在   3.5   版 更改 :   Added   negative   limit   support .
如果   flushOnClose   指定 为   " False " ， 则 当 处理程序 被 关闭 时 不会 刷新 缓冲区
" secrets "   生成 安全 随机 数字 用于 管理 密码
属性   索引   值   值 （ 如果 不 存在 ）   " scheme "   0   URL 方案 说明符   scheme   parameter   " netloc "   1   网络 位置 部分   空 字符串   " path "   2   分层 路径   空 字符串   " query "   3   查询 组件   空 字符串   " fragment "   4   片段 识别   空 字符串   " username "   用户名   " None "   " password "   密码   " None "   " hostname "   主机名 （ 小写 ）   " None "   " port "   端口号 为 整数 （ 如果 存在 ）   " None "
另 请参阅   " now ( ) " ,   " fromtimestamp ( ) "
Microsoft   Store 包
Writer   对象 具有 以下 公开 属性 ：
安装   Python   模块
使 对象 类型 支持 循环 垃圾 回收
在 小节 内 的 选项 也 是 如此
他 接受 任何 与   Win32   API   的   " LoadLibraryEx "   的 标志 兼容 的 值 作为 参数
返回   " a   @   b "
对 两个 值 执行 数字 比较 并 返回 其中 的 最大值
返回值 是 所 开打 键 的 句柄
表达式 列表
可以 使用 异常 捕获 来 提供   “ goto 结构 ”   ， 甚至 可以 跨 函数调用 工作 的
此 函数 仅 是 出于 历史 原因 而 被 包括 的 ， 因为 所有 现代 软件 终端 模拟器 都 具有 这些 功能
在 我们 收尾 之前 ， 你 也许 希望 告诉 你 的 用户 这个 程序 的 主要 目标 ， 以免 他们 还 不 清楚 :
由于 此 格式 依赖于 当前 区域 设置 ， 因此 对 具体 输出 值 应当 保持 谨慎 预期
这 允许 管理器 中 列表 、 字典 或者 其他 代理 对象 对象 之间 的 嵌套
结果 状态   " BabylMessage "   状态   R   标记 和   O   标记   非   " unseen "   标签   O   标记   " unseen "   标签   D   标记   " deleted "   标签   A   标记   " answered "   标签
一个 设置 多种 日志 选项 的 示例 ， 其中 有 在 日志 消息 中 包含 进程   ID ， 以及 将 消息 写入 用于 邮件 日志 记录 的 目标 设施 等 :
3.2   新版 功能 .
在   3.6   版 更改 :   现在 每条 指令 都 带有 参数 ， 但 操作码   " <   HAVE _ ARGUMENT "   会 忽略 它
它 自   Python   3.8   起 已 被 弃用
Python   的 整型 则 作为 平台 默认 的 C 的   " int "   类型 ， 他们 的 数值 被 截断 以 适应 C   类型 的 整型 长度
接着 看   " B "   的   " __ radd __ ( ) "
" pstats . Stats "   类 从文件 中 读取   profile   结果 ， 并 以 各种 方式 对 其 进行 格式化
" PyEval _ ReInitThreads ( ) "   函数 已 从   C   API   中 移除
" " , " "   的 权 标值
注解 :
创建 并 返回 一个 给定 元组 参数 的 新   " datetime . date "   对象 ， 适合 传给   " datetime . date . fromtimestamp ( ) "
" PyObject _ CallObject ( ) "   是 一个 对 其 参数   " 引用 计数 无关 "   的 函数
如果 您 正在 尝试 构建 Windows 路径名 ， 请 注意 所有 Windows 系统 调用 都 使用 正 斜杠   :
以 不 透明 数字 形式 返回 新 的 绝对 位置
定义 了 以下 函数 ：
" datetime . astimezone ( ) "   的 实现 依赖 此 方法 ， 但 无法 检测 违反 规则 的 情况   ； 确保 符合 规则 是 程序员 的 责任
两个 片段 的 长度 应 相同
另 请 注意 ， 核心 日志 记录 模块 仅 包含 基本 处理程序
如果   n   大于 ` ` 0 ` ` ， 则 从文件 中 读取 不 超过   n   个 字节 ； 可以 返回 行 的 一部分
例如   ， " locale . strxfrm ( ) "   可 用于 生成 一个 符合 特定 区域 排序 约定 的 排序 键
简单 示例
如果   env   不 为   " None " ， 则 必须 为 一个 为 新 进程 定义 了 环境变量 的 字典 ；   这些 用于 替换 继承 的 当前 进程 环境 的 默认 行为
在   3.2   版 更改 :   Added   the   legacy   and   optimize   parameter .
返回 一个 新 的   " StreamHandler "   类
" getcontext ( ) "   函数 会为 每个 线程 访问 不同 的   " Context "   对象
返回 信息 的 主要 内容 类型
为了 使用 一个 自定义 的   " JSONEncoder "   子类 （ 比如 ： 覆盖 了   " default ( ) "   方法 来 序列化 额外 的 类型 ） ，   通过   cls   关键字 参数 来 指定 ； 否则 将 使用   " JSONEncoder "
进程 的 PID
这个 只读 属性 将 提供 上 一次 查询 的 列 名称
搜索 有 序列表
如果   file _ or _ dir   是 一个 普通   Python   源文件 ， 将 检查 其中 的 空格 相关 问题
总体而言 （ 特别 是 在 没有 超量 分配 的 系统 上 ） ， 如果 期望 所有 计算 都 是 精确 的 则 推荐 预估 更 严格 的 边界 并 设置   " Inexact "   陷阱
于 一个   bytes   like   object   调用 此 方法 相当于 先 将 这些 字节 包装 于 一个   " BytesIO "   实例 中 ， 然后 调用   " parse ( ) "   方法
复数 是 以 一对 浮点数 来 表示 的   ， 它们 的 取值 范围 相同
例如 ：
" curses "   模块 为 这些 颜色 定义 了 相应 的 名称 常量 :   " curses . COLOR _ BLACK " ,   " curses . COLOR _ RED "   等等
必须 要 对 任意 精度 算术 适配 上下文
" unittest . mock "   上 手指 南
适当 的 工具 选择 取决于 要 执行 的 任务 （   CPU 密集型 或 IO 密集型 ） 和 偏好 的 开发 风格 （ 事件驱动 的 协作 式 多任务 或 抢占 式 多任务处理 ）
tp _ call   协议
这 也 改变 了   " temp1 "   的 内容
" Type [ Any ] "   等价 于   " Type " ， 因此 继而 等价 于   " type " ， 它 是   Python   的 元类 层级 的 根部
实现   " name   TOS "
将   binhex4   格式 的   ASCII   数据 不 进行   RLE   解压缩 直接 转换 为 二进制 数据
当   " what ( ) "   用 字节 流 调用 时 ， 类 文件 对象 将 是   " None "
参见 :
" asyncio . TimeoutError "   类似   " wait _ for ( ) "   等 函数 在 超时 时候 被 引发
在 主 进程 （ 即使 是 在 工作 进程 中 产生 的 日志 事件 ） 的 日志 记录 机制 中将 直接 使用 恰当 的 配置
如果   p   是 一个   " set "   对象 或   " frozenset "   对象 但 不是 其子 类型 的 实例 则 返回 真值
" PyObject _ INIT ( ) "   和   " PyObject _ INIT _ VAR ( ) "   已 成为 常规 “ 不 透明 ” 函数 以 隐藏 实现 细节
" tkinter . dnd "   模块 为 单个 应用 内部 的 对象 提供 了 在 同一 窗口 中 或 多个 窗口 间 的 拖放 操作 支持
在   " tarfile "   中 字符 转换 的 细节 由   " TarFile "   类 的   encoding   和   errors   关键字 参数 控制
处理函数 成功 删除 时 返回   " True "   ， 没有 删除 时 返回   " False "
传入   " ' strict ' "   将 在 出现 编码 格式 错误 时 引发   " ValueError "   ( 默认值   " None "   具有 相同 的 效果 ) ， 传入   " ' ignore ' "   将 忽略 错误
另 请参阅   " PYTHONDONTWRITEBYTECODE "
警告 :
等价 于   Python   表达式   " ~ o "
在 某些 情况 下 ， 希望 直接 访问 该 缓冲区 而 无需 中间 复制
在 使用 此 例程 之前 ， 必须 使用   " enable _ load _ extension ( ) "   启用 扩展 加载
bar 导入 foo （ 这是 一个 空 操作 （ no   op   ） ， 因为 已经 有 一个 名为 foo 的 模块 ）
下面 会 对 各个 修复器 做 更 详细 的 描述
字符 编码
" dict _ size " :   以 字节 表示 的 字典 大小
创建 该 文件 使用 了 与   " mkstemp ( ) "   相同 的 安全 规则
于 管理器 进程
计算 的 结果 是 一个   32   位 的 整数
缓冲区 接口 的 文档 参见 缓冲 协议
" mkstemp ( ) "   返回 一个 元组 ， 元组 中 第一个 元素 是 句柄 ， 它 是 一个 系统 级 句柄 ， 指向 一个 打开 的 文件 （ 等同于   " os . open ( ) "   的 返回值 ） ， 第二 元素 是 该 文件 的 绝对路径
这 初始化 了 一个 由 阴影 类 使用 的 隐藏 辅助 类
如果 队 列为 空 ， 则 等待 ， 直到 队列 中有 元素
此 方式 可用 来 表示 任意   Unicode   字符
返回 一个 新 的 空 字典 ， 失败 时 返回   " NULL "
pair _ number   的 值 必须 在   " 1 "   和   " COLOR _ PAIRS   1 "   之间
例如 ， CD   质量 的 音频 采样 大小 为   2   字节 （ 16 位 ） ， 使用   2   个 声道 （ 立体声 ）   ， 且 帧 速率 为   44 , 100   帧 / 秒
随机数
设置 此参数 可 使得   SQLite   接口 解析 它 所 返回 的 每 一列 的 列名
包含 文件 、 套 接字 或类 对象 ， 以及 许多 其他 不能 用   Python   字 面值 来 表示 的 对象 都 有 可能 导致 这样 的 结果
替代   shell   管道
如果 你 想 通过   URL   获取 资源 并 保存 某个 临时 的 地方 ， 你 可以 通过   " shutil . copyfileobj ( ) "   和   " tempfile . NamedTemporaryFile ( ) "   函数 :
用 一个 不 存在 的 键 来 取值 则 会 报错
这 允许 此 异常 正确 地 向上 传播 并 导致 解释器 退出
许多   Python   程序员 从来 都 不 使用 这种 私有 变量 名称
下面 列出 的 内置 异常 可 通过 解释器 或 内置 函数 来 生成
应用 匹配
参见 :
每个 现有 的 备份文件 都 会 被 重命名 并 增加 其 后缀 （ 例如 ` ` . 1 ` `   变为 ` ` . 2 ` ` ） ， 而 ` ` . 6 ` ` 文件 会 被 删除 掉
过滤器
" logging . config "   模块 具有 可 调用 属性   " dictConfigClass " ， 其 初始值 设 为   " DictConfigurator "
" base64 "   Base16 ,   Base32 ,   Base64 ,   Base85   数据编码
通过 配置 使用 UTC   ( GMT )   格式化 时间
由于 系统 已经 知道 存在 该类 ， 因而 在 配置 中 ， 给定 的   " target "   只 需为 相应 目标 处理程序 的 的 对象   ID   即可 ， 而 系统 将 根据 该   ID   解析 出 处理程序
3.4   新版 功能 .
使用   " compress ( ) "   和   " decompress ( ) "   来 显示 往复式 的 压缩 ：
关于 再现 性 的 说明
话虽如此 ， 加速 Python 代码 有 很多 技巧
出于 多种 原因 ， 这 确实 是 相当 难 的
3.4   新版 功能 .
predicate   应该 是 一个 可 调用 对象 而且 它 的 返回值 可 被 解释 为 一个 布尔值
库
其 所属 类 以外 的 类 实例 会 被 忽略
" code "   解释器 基类
从 包含 指向   data   的   len   个 字节 的 字节 缓冲区 对应 的 数据流 返回 一个   Python   对象
3.7   新版 功能 .
构建
如果 提供 的话 ， 反汇编 将 作为 文本 写入 提供 的   file   参数 ， 否则 写入   " sys . stdout "
PEP   353 :   使用 ssize _ t 作为 索引 类型
返回 一个   " ZipInfo "   对象 ， 其中 包含 有关 归档 成员   name   的 信息
3.3   新版 功能 .
异常 串连 可 通过 在   " from "   子句 中 指定   " None "   来 显式 地 加以 抑制 :
另 一个 文件 将 在   " sys . path "   范围 内 搜索
" expanduser ( ) "   在   Windows   上 现在 改用   " USERPROFILE "   环境变量 而 不再 使用   " HOME " ， 后者 通常 不会 为 一般 用户 账户 设置
在   3.6   版 更改 :   name   形参 接受 一个   path   like   object
已弃 用 的   C   API   函数 和 类型
3.8   版后 已 移除 :   Old   classes   " ast . Num " ,   " ast . Str " ,   " ast . Bytes " ,   " ast . NameConstant "   and   " ast . Ellipsis "   are   still   available ,   but   they   will   be   removed   in   future   Python   releases
异常
返回 一个   " str "   版本 的   object
接下来 你 应当 去 浏览 一下 其中 的 内容
可以 将   " ctypes "   类型 数据 传入   " pointer ( ) "   函数 创建 指针 :
派生 自 元组 ， 因此 矢量 也 属于 元组 !
sqlite3   模块 由   Gerhard   H ä ring   编写
列表 推导 式 可能 是 最快 的
返回 对象 的 “ 标识 值 ”
用户 代码 可以 引发 内置 异常
参数 :   default _ name   日志 文件 的 默认 名称
" ' help ' "   打印 所有 当前 解析器 中 的 选项 和 参数 的 完整 帮助 信息 ， 然后 退出
bpo   21275 :   修复 KFreeBSD 上 的 套 接字 测试
如果   newline   是 任何 其他 合法 值 ， 则 写入 的 任何   " ' \ n ' "   字符 将 被 转换 为 给定 的 字符串
确定 一个 对象 是 感知 型 还是 简单 型
创建 新 的   zipimporter   实例
它们 应 改为 从   " urllib . parse "   和   " html "   模块 导入
如果   " A "   转回 成 “ 模板 ” 失败 ， 它 将 返回 一个 属于   " __ add __ ( ) "   的 值 ， 我们 需要 避免   " B "   定义 了 一个 更加 智能 的   " __ radd __ ( ) " ， 因此 模板 需要 返回 一个 属于   " __ add __ ( ) "   的   " NotImplemented "
示例 :
结构化 解析 结果
此 函数 执行 成功 时 返回 真值 ， 如果   args   不是 元组 或者 包含 错误 数量 的 元素 则 返回 假值 ； 如果 执行 失败 则 将 设置 一个 异常
主要 差异 包含 ：
这 意味着   Unicode   字符 将 根据 活动 控制台 的 代码 页 进行 编码 ， 而 不是 使用   utf   8
模块 函数
所以 ， 为了 在 屏幕 顶部 显示 一个 反相 的 状态 行 ， 你 可以 这么 编写 ：
当 反汇编 多个 对象 时 ， 保留 各个 反汇编 的 备忘 记录
[ 1 ]   这个 函数 的 接口 已经 在 标准 模块   " os "   里 了 ， 这里 作为 一个 简单 而 直接 的 例子
3.3   新版 功能 .
（ 由   Terry   Jan   Reedy   在   bpo   13802   中 贡献 。 ）   样本 可以 被 修改 以 包括 其他 字符
这些 功能 是 通过 叫做   handlers   和   opener   的 对象 来 提供 的
月份 的 头   CSS   类 （ 由   " formatmonthname ( ) "   使用 ）
解释器 就 像 一个 简单 的 计算器 一样 ： 你 可以 在 里面 输入 一个 表达式 然后 它会 写出 答案
杂项 服务
类型 专属 的 方法 应当 调用   " repr1 ( ) "   来 执行 递归 格式化 ， 在 递归 调用 中 使用   " level   1 "   作为   level   的 值
在   " configparser "   中 ， 映射 接口 的 实现 使用 了   " parser [ ' section ' ] [ ' option ' ] "   标记 法
使 栅栏 处于 损坏 状态
字符   ch   如果 为 空格符 或 制表符 则   ch   就是 可 忽略 的 ， 否则 就是 不可 忽略 的
class   variable   类 变量 在 类 中 定义 的 变量 ， 并且 仅限 在 类 的 层级 上 修改   ( 而 不是 在 类 的 实例 中 修改 )
如果 第二个 参数 存在 ， 它 应该 是 一个 表达式 ， 且 它 的 计算 值为   true   时 断点 才 起 作用
协程 对象   :   调用 协程 函数 所 返回 的 对象
虽然 可以 将 指针 存储 在 共享内存 中 ， 但 请 记住 它 所 引用 的 是 特定 进程 地址 空间 中 的 位置
文件 有 一个 快照 文件
整数 值 将 被 原样 传递
继续 运行 ， 仅 在 遇到 断点 时 停止
Boost   Python 库 （ BPL ， http ： / / www . boost . org / libs / python / doc / index . html   ） 提供 了 一种 从 C   ++ 执行 此 操作 的 方法 （ 即 ， 您 可以 使用 BPL 继承 自 C   ++ 编写 的 扩展 类   ）
当   " Parser "   在 标头 之后 及 第一个 分界 字符串 之前 发现 一些 文本 时   ， 它会 将 这些 文本 赋值 给 消息 的   preamble   属性
请 注意 添加   " PYTHONUTF8   1 "   到 默认 环境变量 将会 影响 你 的 系统 中 的 所有   Python   3.7 +   应用
压缩 过滤器 支持 下列 选项 （ 指定 为 表示 过滤器 的 字典 中 的 附加 条目 ） ：
如果 缩进 等级 为 零 、 负数 或者   " " " "   ， 则 只会 添加 换行符
C 、 Pascal   甚至   Unix   shells   都 是 过程 式 语言
PEP   应当 提供 精确 的 技术 规格 和 所 提议 特性 的 原理 说明
返回 分配 给 字符   chr   的 字符 分解 映射 作为 字符串
但是 ， 请 注意   " LZMAFile "   不是 线程 安全 的 ， 这 与   " bz2 . BZ2File "   不同 ， 因此 如果 你 需要 在 多个 线程 中 使用 单个   " LZMAFile "   实例 ， 则 需要 通过 锁来 保护 它
默认值   1   表示 尽可能 多地 读取 并 解码
" Loader . load _ module ( ) "   的 实现
3.2   新版 功能 .
当 从   ctypes   实例 提取   " value "   属性 时 ， 通常 每次 会 返回 一个 新 的 对象
" callback "   " eof _ received ( ) "   接收 到 EOF 时 被 调用
枚举 成员 名称 的 大小写 因为 枚举 是 被 用来 代表 常量 的 所以 我们 建议 枚举 成员 名称 应 使用 大写 形式 ， 并 将 在 我们 的 示例 中 使用 此种 风格
" asyncio . BufferedProtocol "   已经 晋级 为 稳定   API
ctypes   数据类型 的 通用 实例 变量 :
PEP   389 :   Argparse   命令行 解析 模块
解析   RFC   822   标题 可以 通过 使用   " parser "   模块 中 的 类来 轻松 完成 ：
创建 一个 可以 在   SQL   语句 中 使用 的 用户 自定义 函数 ， 函数 名为   name
构建
本 文档 旨在 概述 在   Microsoft   Windows   上 使用   Python   时应 了解 的 特定 于   Windows   的 行为
" formatter "   条目 指明 此 处理程序 的 格式化 器 的 键 名称
如果 加载 了   " readline "   模块 ， " input ( ) "   将 使用 它 来 提供 复杂 的 行 编辑 和 历史记录 功能
迭代 器 协议
3.8   新版 功能 .
参见   " socket . socket . makefile ( ) "   的 示例
（ 由   Serhiy   Storchaka   在   bpo   29209   中 贡献 。 ）
" assert "   语句
Python   文档 贡献者
3.1   新版 功能 .
第二项 必须 为 一个 整数 ， 可以 表示 附加 状态 信息
这 是因为 当 你 对 作用域 中 的 变量 进行 赋值 时 ， 该 变量 将 成为 该 作用域 的 局部变量   ， 并 在 外部 作用域 中 隐藏 任何 类似 命名 的 变量
环境 配置
另 请参阅 下层 的 函数   " os . chown ( ) "
" __ future __ "   Future   语句 定义
将   start / end   切片 索引 号 根据 指定 的 序列 长度 进行 调整
从 历史 列表 中 移除 指定 位置 上 的 历史 条目
集合 显示
协议 错误 时 引发   " URLError "
数字 字 面值 有 三种 类型 :   整型 数 、 浮点数 和 虚数
源文件 的 字符 编码
从   v   的 整数 部分 返回 一个 新 的   " PyLongObject "   对象 ， 如果 失败 则 返回   " NULL "
用来 帮助   Python   2   /   Python   3   代码 保持 同步 提供   " _ order _ "   属性
源代码 :   Lib / getopt . py
为 此类 定义 可能 包含 一个 名为   " __ init __ ( ) "   的 特殊 方法 ， 就 像 这样 :
为了 保持 重要性   ， 系数 数字 不会 截断 尾随 零
设置   UID   位
核心 与 内置
有 哪些 Python 的 GUI 工具 是 某个 平台 专用 的 ？
使用   " ? "   或   " U + FFFD "   替换   unicode   编码 错误
如果   ob   不是 一个 弱 引用 对象 ， 或者 如果   callback   不是 可 调用 对象 ， " None "   或   " NULL " ， 该 函数 将 返回   " NULL "   并且 引发   " TypeError "
因此 对于 列表 我们 可以 说   " +   "   就是   " list . extend "   的 “ 快捷方式 ” :
" unicode _ internal "   编解码器 已 被 移除
返回 一个 可 调用 的 终结 器 对象 ， 该 对象 将 在   obj   作为 垃圾 回收 时 被 调用
参见 :
从 多个 进程 记录 至 单个 文件
最终 匹配 从   " ' < html > ' "   中 的   " ' < ' "   扩展 到   " ' < / title > ' "   中 的   " ' > ' "   ， 而 这 并 不是 你 想要 的 结果
开发者 也 会 推出 旧版本 的 “ 问题 修正 ” 发布 版 ， 因此 现有 发布 版 的 稳定性 还会 逐步 提升
如果 模块 是 一个   Python   模块 （ 而 非 内置 模块 或 动态 加载 的 扩展 ） ， 加载 器 应该 在 模块 的 全局 命名 空间   ( " module .__ dict __ " )   中 执行 模块 的 代码
密钥 派生 和 密钥 延展 算法 被 设计 用于 安全 密码 哈希
在   3.9   版 更改 :   The   AIX   platform   string   format   now   also   includes   the   technology   level ,   build   date ,   and   ABI   bit   size .
字段名 的 特殊 值 将 保持 未命名 状态
Python   3.6 . 1   正式版
默认 Windows
default   数值   ( 可 选 )
模块 函数
确定性 性能 分析 旨在 反映 这样 一个 事实 ： 即 所有 函数调用   、   函数 返回 和 异常 事件 都 被 监控 ， 并且 对 这些 事件 之间 的 间隔 （ 在此期间 用户 的 代码 正在 执行 ） 进行 精确 计时
" pprint "   模块 提供 了 更加 复杂 的 打印 控制 ， 其 输出 的 内置 对象 和 用户 自定义 对象 能够 被 解释器 直接 读取
参见 :
Future   函数
否则 返回   " None "
详情
字符串 转换 与 格式化
" dbm . dumb "   模块 提供 了 一个 完全 以   Python   编写 的 持久 化 字典 类 接口
最后 一个 类型 的 处理 最为 有趣 ， 因为 简单 地将值 传给   " bool ( ) "   是 没有 用 的 ， " bool ( ' False ' ) "   仍然 会 是   " True "
安装 配置文件 是 在 安装 脚本 和 安装 脚本 命令行 之间 一个 适当 的 折衷 方式 安装 脚本 在 理想 情况 下 应当 不 受 安装者 的 控制   [ 1 ]   而 安装 脚本 命令行 则 在 你 的 控制 范围 之外 且 完全 取决于 安装者 的 选择
返回 一个 存储 在 上下文 对象 中 的 变量 的 迭代 器
TurtleScreen / Screen   方法
命令行
如果 输入 的   data   为空 ， 则 会 引发   " StatisticsError "
" ' w   ' "   打开 一个 未 压缩 的   stream   用于 写入
返回 音频 的 通道 数 （ 单声道 为   1 ， 立体声 为   2 ）
队列 集 被 用于 多个 异步 Task 对象 的 运行 调度 ， 实现 连接池 以及 发布 / 订阅 模式
" queue "   一个 同步 的 队列 类
如果 输出 流 不可 查找 且 在   data   被 写入 之后 写入 的 总 帧 数 与 之前 设定 的 has   been   written   does   not   match   the   previously   set   value   for   nframes   值 不 匹配 将会 引发 错误
该 函数 会 导入   name   模块 ， 有 可能 使用 给定 的   globals   和   locals   来 确定 如何 在 包 的 上下文 中 解读 名称
此 对象 会 在 你 迭代 它 时 基于 所 希望 的 序列 返回 连续 的 项 ， 但 它 没有 真正 生成 列表 ，   这样 就 能 节省 空间
该 可 调用 对象 必须 返回 一个 相对 于 当前目录 的 目录 和 文件名 序列 （ 即 其 第二个 参数 的 子集 ） ； 随后 这些 名称 将 在 拷贝 进程 中 被 忽略
类 定义 是 一条 可 执行 语句
行列式   t11   t22   t12   t21   的 值 不能 为 零 ， 否则 会 出错
然后 我们 得到 ：
最 简单 的 方式 是 输出 到 控制台
记录 流程
" None " :   自动检测 文件格式
有 一些 其他 注意事项 ：
triple   quoted   string   三 引号 字符串 首尾 各带 三个 连续 双引号 （ " ） 或者 单引号 （ ' ） 的 字符串
如果 一个 序列 是 另 一个 的 初始 子 序列 ， 则 较 短 的 序列 就 被 视为 较 小 （ 较 少 ）
" uu "   模块 定义 了 以下 函数 ：
请参阅 函数 定义 了解 有关 参数 列表 的 句法
圆括号 在 只 附带 一个 参数 的 调用 中 可以 被 省略
我 发现 ， 某种 具有   ABC   式 的 语法 而 又 能 访问   Amoeba   系统 调用 的 脚本语言 将 可 满足 需求
" DEVNULL "   表示 使用 特殊 的   " os . devnull "   文件
例如 :
如果 你 只 想 从 一个 感知 型   datetime   对象   dt   移除 时 区 对象 ， 请 使用   " dt . replace ( tzinfo   None ) "
命令行 界面
构建 和   C   API   的 改变
设置 或 返回 当前 的 倾角
核心 与 内置
如果 没有 消息 格式 字符串 ， 则 默认 使用 原始 消息
" integers "   属性 将 是 一个 包含 一个 或 多个 整数 的 列表 ， 而   " accumulate "   属性 当 命令行 中 指定 了   "   sum "   参数 时 将 是   " sum ( ) "   函数 ， 否则 则 是   " max ( ) "   函数
以下 面向 类型 的 宏为 方便 而 提供
在   3.9   版 更改 :   这个 类型 已 从   " char   "   更改
文本 I / O 预期 并 生成   " str "   对象
从 迭代 对象 计数 元素 或者 从 另 一个 映射 对象   ( 或 计数器 )   添加
例如 ， 如果 一个 函数 执行 1 秒 的   CPU   密集型 计算 ， 那么 所有 并发 异步 任务 和   IO   操作 都 将 延迟 1 秒
在   3.9   版 更改 :   此 方法 不会 再 忽略   " EBADF "   错误
如果 你 想 自己 编译 CPython ， 首先 要 做 的 是 获取   source
现在   " PyIndex _ Check ( ) "   总是 被 声明 为 不 透明 函数 以 隐藏 实现 细节 ；   " PyIndex _ Check ( ) "   宏已 被 移除
请 注意 类 是 可 调用 的 （ 调用 类 将 返回 一个 新 的 实例 ） ； 如果 实例 所属 的 类 有   " __ call __ ( ) "   则 它 就是 可 调用 的
它 不 被   " str . encode ( ) "   所 支持 （ 该 方法 只 生成   " bytes "   类型 的 输出 ）
创建   lambda   函数 的 句法 为   " lambda   [ parameters ] :   expression "
" StreamReader "   实例 的 构造 器
（ 由   Victor   Stinner   在   bpo   35345   中 贡献 。 ）
安全
参考
读取 一个 按键 并 将 结果 字符 返回 为 一个 字节 串
不再 支持 的 操作系统
在   3.1   版 更改 :   添加 了   " ' , ' "   选项   ( 另 请参阅   PEP   378   )
编程 常见问题
这 意味着 将 加载 此 目录 里 的 脚本 ， 而 不是 标准 库中 的 同名 模块
"   "   或   " !   "   比较 总是 返回 一个   " bool "   对象 ， 无论 被 比较 的 对象 是 什么 类型 :
在   kwargs   中有 三个 关键字 参数 会 被 检查 :   exc _ info   参数 如果 不为 假值 则 会 将 异常 信息 添加 到 日志 记录 消息
不 使用 第三方 工具 创建 扩展
它 不适 用于 套 接字 等 其他 类型 的 文件 类 对象
此 例程 由   " refresh ( ) "   调用 ， 因此 几乎 从不 需要 手动 调用
许多   asyncio   API   都 被 设计 为 接受 可 等待 对象
" . pyc "   文件 包括 时间 戳 和 源文件 的 大小 ， Python   将 在 运行 时 将 其 与 源文件 的 元 数据 进行 比较 以 确定   " . pyc "   文件 是否 需要 重新 生成
因此 如果 你 错误 地 使用 了   " y . sort ( ) "   并 期望 它 将 返回 一个 经过 排序 的   " y "   的 副本 ， 你 得到 的 结果 将会 是   " None " ， 这 将 导致 你 的 程序 产生 一个 容易 诊断 的 错误
这会 创建 一个 可以 跟随 零个 或 一个 命令行 参数 的 选项
" distutils "   构建 和 安装   Python   模块
由于 两个 变量 都 指向 同一 对象 ， 因此 使用 任何 一个 名称 所 访问 到 的 都 是 修改 后 的 值   " [ 10 ] "
类 的 层次结构
（ 由   Raymond   Hettinger   贡献 。 ）
" binhex "   模块 定义 了 以下 功能 ：
该 构造 器 接受 一个 可选 的 整数 初始化 器 ；   不会 执行 溢出检查
有 的
源代码 :   Lib / asyncio / queues . py
如果 没有 收到 欢迎 消息 ， 就 抛出   " AuthenticationError "   异常
PEP   273   从 ZIP 压缩包 导入 模块 由   James   C
XMLReader   对象
在 介绍 类 之前 ， 我 首先 要 告诉 你 一些   Python   的 作用域 规则
成功 时 返回   " 0 " ， 将   buffer   设 为 内存地址 并 将   buffer _ len   设 为 缓冲区 长度
返回   key   在 映射   mapname   中 的 匹配 结果 ， 如 无 结果 则 会 引发 错误   ( " nis . error " )
" Stats "   类
根据 应用程序 的 需要 ， 信号 可能 会 被 忽略 ， 被 视为 信息 ， 或 被 视为 异常
future   语句 的 目的 是 使得 向 在 语言 中 引入 了 不 兼容 改变 的   Python   未来 版本 的 迁移 更为 容易
同时 存在 于 目录   a   和   b   中 的 文件
3.2   新版 功能 .
" gc "   垃圾 回收 器 接口
使用 属性   attr   添加 字符   ch   ， 并 立即 在 窗口 上 调用   " refresh ( ) "
再次 说明 ， 列表 推导 式 只有 两边 的 括号 不 一样 （ 方括号 而 不是 圆括号 ）
在 适用 于   Linux   的   Windows   子系统 和   QEMU   用户 模拟器 上 ，   使用   " os . posix _ spawn ( ) "   的   " Popen "   构造 器 不会 再 因为 “ 找 不到 程序 ” 这样 的 错误 引发 异常
dest   目标 文件名
小 函数 和   lambda   表达式
如果 键 已经 存在 ， 则 该 函数 打开 已经 存在 的 该键
软件 开发人员 对 他们 的 代码 添加 日志 调用 ， 借此 来 指示 某 事件 的 发生
3.4   新版 功能 :   支持 在   Windows   上 检测 非根 挂载 点
这 可能 导致 其他 进程 在 尝试 使用 该 队列 时 发生 异常
这 将 重复 同样 的 迭代 器   " n "   次 ， 以便 每个 输出 的 元组 具有 第   " n "   次 调用 该 迭代 器 的 结果
阅览 历次   Python   会议 的 日程 纪要 可以 看到 许多 不同 公司 和 组织 所 做 的 贡献
这 允许 新 启动 的   Python   解释器 安全 导入 模块 然后 运行 模块 中 的   " foo ( ) "   函数
搜索 函数 的 注册 目前 是 不 可逆 的 ， 这 在 某些 情况 下 可能 导致 问题 ， 例如 单元测试 或 模块 重载 等
（ 由   Georg   Brandl   在   bpo   14210   中 贡献 ）
由于 默认 的   flags   为   " re . IGNORECASE " ， 模式   " [ a   z ] "   可以 匹配 某些 非   ASCII   字符
当 存在 比 默认 更好 的 参数 分组 概念 时 ， 可以 使用   " add _ argument _ group ( ) "   方法 来 创建 适当 的 分组 :
任何 未 在 下面 列出 的 功能 最好 是 使用 抽象 对象 协议   ( 包括   " PyObject _ CallMethod ( ) " ,   " PyObject _ RichCompareBool ( ) " ,   " PyObject _ Hash ( ) " ,   " PyObject _ Repr ( ) " ,   " PyObject _ IsTrue ( ) " ,   " PyObject _ Print ( ) "   以及   " PyObject _ GetIter ( ) " )   或者 抽象 数字 协议   ( 包括   " PyNumber _ And ( ) " ,   " PyNumber _ Subtract ( ) " ,   " PyNumber _ Or ( ) " ,   " PyNumber _ Xor ( ) " ,   " PyNumber _ InPlaceAnd ( ) " ,   " PyNumber _ InPlaceSubtract ( ) " ,   " PyNumber _ InPlaceOr ( ) "   以及   " PyNumber _ InPlaceXor ( ) " )   来 访问
带 圆括号 的 形式 是 包含 在 圆括号 中 的 可选 表达式 列表
Python   2.3   有 什么 新 变化
基本 异常 类
编译 时 配置
添加 了 新 的 函数   " math . dist ( ) "   用于 计算 两点 之间 的 欧几里得 距离
使用   " os . urandom ( ) "   函数 的 类 ， 用 从 操作系统 提供 的 源 生成 随机数
它 可以 生成 时间 的 最早 日期 取决于 平台
当 找到 一个 匹配 的   except   子句 时 ， 该 异常 将 被 赋值 给 该   except   子句 在   " as "   关键字 之后 指定 的 目标 ， 如果 存在 此 关键字 的话 ， 并且 该   except   子句 体将 被 执行
默认 情况 下 ， 它 返回 一个 空 列表
实例 方法 ：
此外 ， 提供   " ' Z ' "   就 相当于   " ' + 00 : 00 ' "
（ 结果 为 简单 型 对象 。 ）
之前 它 的 行为 取决于 具体 平台 ：   Windows   下会 在 成功 时 返回 非零值 ； 在 失败 时 返回 零
要 连接 多个   " str "   对象 ， 通常 推荐 的 用法 是 将 它们 放入 一个 列表 中 并 在 结尾处 调用   " str . join ( ) "   ：
“ Cell ” 对象 用于 实现 由 多个 作用域 引用 的 变量
工具 / 示例
返回 新建 线程 时 使用 的 堆栈 大小
警告 :
其他 资源
堆 的 大小 不变
一种 非常 常见 的 情况 是 将 日志 事件 记录 到 文件 ， 让 我们 继续 往下 看
使用   " Sniffer "   的 示例 ：
" add _ argument _ group ( ) "   方法 接受   title   和   description   参数 ， 它们 可 被 用来 定制 显示 内容 :
这 将 重复 地 检验 表达式 ， 并且 如果 其值 为 真 就 执行 第一个 子句 体 ； 如果 表达式 值为 假 （ 这 可能 在 第一次 检验 时 就 发生 ） 则 如果   " else "   子句 体 存在 就 会 被 执行 并 终止 循环
" datetime "   基本 的 日期 和 时间 类型
ISO   历法 是 一种 被 广泛 使用 的 格列 高利 历
因此 计算 永远 不会 “ 看到 ” 1 / 10 ： 它 实际 看到 的 就是 上面 所 给出 的 小数 ， 它 所能 达到 的 最佳   754   双 精度 近似值 :
Python 程序 的 书写 是 紧凑 而 易读 的
3.3   新版 功能 .
Python   由 荷兰 数学 和 计算机科学 研究 学会 （ CWI ， 见   https : / / www . cwi . nl /   ）   的   Guido   van   Rossum   于   1990   年代 初 设计 ， 作为 一门 叫做   ABC   的 语言 的 替代品
使用 只 函数 只能 读取   32   位 的 值 ， 无论 本 机   " long "   类型 的 长度 为何
（ 由   Giampaolo   Rodol à   在   bpo   33671   中 贡献
什么 是 类 ？
如果 该 文件 不能 被 打开 ， 则 引发   " OSError "
示例
用户 期望 结果 与 手工 完成 的 计算 相匹配 的 应用程序
当 一个   Future   对象 被 等待   ， 这 意味着 协程 将 保持 等待 直到 该   Future   对象 在 其他 地方 操作 完毕
每当 结果 的 指数 大于   " Emax "   或 小于   " Etiny "   就 会 返回 错误
这 大致 等价 于 :
第二个 形参 不能 是 字符串
如果   member   未 在 归档 中 出现 ， 则 会 引发   " KeyError "
它 仅 在 调用   " initscr ( ) "   之后 才 会 被 定义
使用 命名 空间 解析 XML
默认值 为   " False "
根据 注册 的 给定   encoding   的 编解码器 是否 已 存在 而 返回   " 1 "   或   " 0 "
Differ   示例
如果 可 迭代 对象 的 长度 未 对齐 ， 将 根据   fillvalue   填充 缺失 值
参见 :
" Mailbox "   对象
路径 前 的 句点 将 被 忽略 ， 例如   " splitext ( ' . cshrc ' ) "   返回   " ( ' . cshrc ' ,   ' ' ) "
参数   weightA   和   weightB   是 简单 数字 滤波器 的 参数 ， 默认 分别 为   " 1 "   和   " 0 "
func   是 外部 函数 对象 本身 ， 这样 就 允许 重新 使用 相同 的 可 调用 对象 来 对 多个 函数 进行 检查 或 后续 处理
库
功能 未 实现
安全
请 注意 此参   数 与   filename   是 不 兼容 的 如果 两者 同时 存   在 ， 则 会 引发   " ValueError "
IDLE   也 在 开始菜单 中
基础教程
任何 由   fs   所 指定 的 重复   future   对象 将 只 被 返回 一次
可以 编写 处理 所 选 异常 的 程序
如果 存在 异常 信息 ， 则 会 使用   " traceback . print _ exception ( ) "   来 格式化 并 添加 到 流中
可 选 参数   display   默认 为   " 1 "   并 可 被 设为   " 0 "   来 停止 将 回溯 发送至 浏览器
PEP   544   通过 允许 用户 不必 在 类 定义 中显式 地 标注 基类 来 解决 这一 问题 ，   允许 静态 类型 检查 器 隐含地 认为   " Bucket "   既 是   " Sized "   的 子 类型 又 是   " Iterable [ int ] "   的 子 类型
代表   C   " long   double "   数据类型
在   3.6   版 更改 :   wbits   和   bufsize   可 用作 关键字 参数
所有 start 方法
( 是 的 ， 我们 知道 Boehm   GC 库
" runsource ( ) "   返回   " False "
当 一个 日志 处理器 或   basicConfig ( )   被 调用 时 ， 对   basicConfig ( )   的 后续 调用 会 被 静默 地 忽略
简单 模式
3.3   新版 功能 .
开始 和 结束   curses   应用程序
代表 一个 包含 字节 数据 的   OS   层级 文件 的 原始 二进制 流
pathname   可以 是 绝对路径   ( 如   " / usr / src / Python   1.5 / Makefile " )   或 相对路径   ( 如   " .. / .. / Tools /   /   . gif " ) ， 并且 可 包含   shell   风格 的 通配符
用于 一次性 压缩 和 解压 的   " compress ( ) "   和   " decompress ( ) "   函数
method   表示 压缩算法
模块 内容
如果   o   是 函数 对象   ( 类型 为   " PyFunction _ Type " )   则 返回 真值
大多数 用户 定义 的   " Handler "   子类 都 需要 重载   " emit ( ) "
PEP   409 :   清除 异常 上下文
接受 一个   C   " printf ( ) "   风格 的   format   字符串 和 可变 数量 的 参数 ， 计算结果   Python   字节 串 对象 的 大小 并 返回 参数值 经 格式化 后 的 字节 串 对象
3.6   新版 功能 .
此 名称 会 在 导入 搜索 的 各个 阶段 被 使用 ， 它 也 可以 是 指向 一个 子 模块 的 带点 号 路径 ， 例如   " foo . bar . baz "
