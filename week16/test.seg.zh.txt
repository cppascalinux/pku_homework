以 字节 为 单位 的 普通 文件大小 ； 对于 某些 特殊 文件 则 是 所 等待 的 数据量
3.2   新版 功能 .
在 原始 流 上 通过 单次 调用 读取 并 返回 至多   size   个 字节
信号 是 在 计算 过程 中 出现 的 异常 条件 组
" field " s   可以 选择 使用 普通 的   Python   语法 指定 默认值 :
请 注意 ， " btoa "   实现 总是 填充
在   3.7   版 更改 :   如果 没有 执行 完 ， 会 抛出   " ValueError "   异常 而 不是   " AssertionError "
而且 ， 这个 装饰 器 要求 每个 实例 上 的   " __ dict __ "   是 可变 的 映射
返回   obj   取负 的 结果   ( "   obj " )
Python   会 自动 进行 内存 管理 （ 对 大多数 对象 进行 引用 计数 并 使用   garbage   collection   来 清除 循环 引用 ）
从 只读 的   " dbm "   数据库   ( " dbm . dumb " ,   " dbm . gnu "   或   " dbm . ndbm " )   删除 键 将 会 引发   " error "   ( " dbm . dumb . error " ,   " dbm . gnu . error "   或   " dbm . ndbm . error " )   而 不是   " KeyError "
都 会 给出 一个 可 调用 对象 ， 使得   " taxes ( 10e6 )   0.3   10e6   +   2 " .
请 注意 ， 代码 信息 字符串 的 确切 内容 是 高度 依赖于 实现 的 ， 它们 可能 会 在   Python   VM 或 Python 版本 中 任意 更改
mmap   引用 将 相对 于 从文件 开头 的 偏移
等价 与   Python   语句   " o1   &   o2 "
（ 由   Antoine   Pitrou   在   bpo   9260   中 贡献 。 ）
如果 为 数字 ， 则 它 指向 一个 位置 参数 ， 而 如果 为 关键字 ， 则 它 指向 一个 命名 关键字 参数
本章 中 的 函数 与   Python 对象 交互 ， 无论 其 类型 ， 或 具有 广泛 类 的 对象 类型 （ 例如 ， 所有 数值 类型 ， 或 所有 序列 类型 ）
文件类型   安装 目录   模块   "   userbase   \ Python   XY   \ site   packages "   脚本   "   userbase   \ Python   XY   \ Scripts "   数据   "   userbase   "   C   头文件   "   userbase   \ Python   XY   \ Include { distname } "
asyncio   Future   不能 兼容   " concurrent . futures . wait ( ) "   和   " concurrent . futures . as _ completed ( ) "   函数
将 字节 码 计数器 的 值 设为   target
早 最 的 可 表示   " time " ,   " time ( 0 ,   0 ,   0 ,   0 ) "
" urllib . robotparser "   robots . txt   语法分析 程序
示例 :   " compile ( ) "   的 模拟
" fromfile _ prefix _ chars   "   参数 默认 为   " None " ， 意味着 参数 不会 被 当作 文件 对待
引发 一个 审计 事件   " winreg . QueryValue " ， 附带 参数   " key " ,   " sub _ key " ,   " value _ name "
但 注意 在 对 赋值 操作 求值 时 ， 右侧 会 先于 左侧 被 求值
文本 流 的 基类
bpo   29572 :   更新 Windows   构建 和 OS   X 安装程序 以 使用 OpenSSL   1.0 . 2k
如果 日期 解析 成功 ，   " parsedate ( ) "   将 返回 一个 九 元组 ， 可 直接 传递 给   " time . mktime ( ) " ； 否则 返回   " None "
Emacs   用户 将 高兴 地 了解 到   Emacs   具有 非常 好 的   Python   模式
初始化 函数 必须 返回 模块 对象 给 其 调用者 ， 这样 它 就 可以 被 插入 到   " sys . modules "   中
这 将 会 将   " . pyc "   文件 写入 与   " foo . py "   相同 位置 下 的   " __ pycache __ "   子目录   （ 或者 你 也 可以 通过 可 选 参数   " cfile "   来 重载 该 行为 ）
在   " importlib "   的   find _ and _ load   函数 被 调用 后 被 触发
让 我们 开始 吧 ！
输入 中 的 行 结束符 可以 为   " ' \ n ' " ,   " ' \ r ' "   或   " ' \ r \ n ' " ， 在 返回 给 调用者 之前 它们 会 被 统一 转写 为   " ' \ n ' "
目标 由   handler   类 提供
这里 是 一些 示例 :
解压缩   data   ( 一个   bytes   like   object   ) ， 返回 字节 串 形式 的 解压缩 数据
name   会 被 忽略 仅 保留 用于 向下兼容
自定义 默认 的 Python 版本
返回 代理 对象 的 内部 字符串 表示
第三组 输出 并 不 理想
从 Python3.2 起 ， 已经 声明 了 一个 API 的 子集 ， 以 确保 稳定 的 ABI
数值 参数 会先 转换 为 相同 类型 ，   结果 也 为 转换 后 的 类型
十进制 数 包括 特殊 值 ， 例如   " NaN "   代表 “ 非 数字 ” ， 正 的 和 负 的   " Infinity " ， 和   "   0 "
若 你 需要 执行 不能 被 作为 模块 导入 的 测试 文件 ， 你 需要 直接 执行 该 测试 文件
" f "   ( " float " )   [ float ]   将 一个   C   " float "   单精度 浮点数 转化 为   Python   浮点数 类型 数字
" getopt ( ) "   函数 将 在 遇到 非 选项 参数 时 立即 停止 处理 选项
它们 的 目的 是 保证 在 极端 情况 下 的 一致 行为 ， 而 标准   C   的 函数 则 不然
（ 由   Antoine   Pitrou   在   bpo   5506   中 贡献 。 ）
宏 版本 的 C 函数   " PyList _ GetItem ( ) "   ， 没有 错误 检测
Python   中 的   " for "   语句 与 你 在   C   或   Pascal   中 所用 到 的 有所不同
将   capsule   内部 的 上下文 指针 设 为   context
向   " update ( ) "   输入 字符串 对象 是 不 被 支持 的 ， 因为 哈希 基于 字节 而 非 字符
加载 器 仍然 在 导入 期间 被 使用 ， 但 负担 的 任务 有所 减少
而   beta   版 更为 稳定 ， 它会 保留 现有 的 接口 ， 但 也 可能 增加 新 的 模块 ， release   candidate   版则 会 保持 冻结 状态 不会 再 进行 改变 ， 除非 有 重大 问题 需要 修正
" permutations ( ) "   的 代码 也 可 被 改写 为   " product ( ) "   的 子 序列 ， 只要 将 含有 重复 元素 （ 来自 输入 中 同一 位置 的 ） 的 项 排除
如果 文件 已 存在 但 使用 了 排 它性 创建 模式 （   " ' x ' "   ） ， 现在 会 触发   " FileExistsError "
所以 ， 我们 的 回调 函数 要 接收 两个 整数 指针 ， 返回 一个 整数
不同 的 类型 可以 定义 不同 的 方法
每个 通道 的 每个 帧 包含 一次 采样
足够 现代 的 readelf 命令 可以 打印 元 数据 ：
PEP   384 :   定义 稳定 的 ABI
这 可以 被 用于 在 电子邮件 或 其他 非 二进制 环境 中 安全 地 交换 数据 值
标注 值 可以 作为 函数 对象 的   " __ annotations __ "   属性 中以 对应 形参 名称 为键 的 字典 值 被 访问
如果 出现 问题 ， 应先 将 立体声 片段 拆 分为 两个 单声道 片段 ， 之后 再 重组
标准 库 简介   — —   第二 部分
使用   UTF   8   和   ascii   编解码器 解码 短   ASCII   字符串 现在 会 加快 大约   15%
在   IDLE   编辑器 窗口 中 增加 了 可选 的 行号
一个 更 现实 的 例子 如下 所示 :
如果 在 查找 过程 中 发生 错误 ， 返回 '   '   1   '   ' ， 如果 没有 发生 错误 ， 无论 是否 找到 值 ， 都 返回 '   '   0   '   ' ，
除非 使用   "   with   system   libmpdec "   配置 了 构建 ， 否则   " _ decimal "   模块 都 是 用 包含   libmpdec   库 的 拷贝 构建 的
每个 月 包含 了   4 到 6 周 ， 每周 包含 1   7 天
手动 的 实现 方式 请 查阅   " 扩展 与 嵌入 "   文档 来 入门
在   3.2   版 更改 :   " DeprecationWarning "   is   now   ignored   by   default   in   addition   to   " PendingDeprecationWarning " .
结构 成员 名称 没有 保留 前缀
相应 语法 如下 :
返回 一个 纯   ctypes   数组 ,   或者 在 此 之上 经过 同步器 包装 过 的 进程 安全 的 对象 ， 这 取决于   lock   参数 的 值 ， 除此之外 ， 和   " RawArray ( ) "   一样
Windows 上 单调 时钟 的 分辨率 大约 为   15.6   毫秒
一方面 ， 要求   " global "   表示 已 分配 的 变量 可以 防止 意外 的 副作用
如果   Task   对象 被 取消   ， 此 方法 会 引发 一个   " CancelledError "   异常
在   3.3   版 更改 :   " IOError "   代替   " OSError "   被 引发
注意 这里 创建 （ 或 被 重写 ） 的 名为   " x "   的 变量 在 for 循环 后 仍然 存在
RFC   具体 说明 了 在   JSON 对象 里 的 名字 应该 是 唯一 的 ， 但 没有 规定 如何 处理 JSON   对象 中 的 重复 名称
如果 他们 不 记得 列表 有 哪些 方法 ， 他们 这以 这样 做 :
通过 在   " . pyc "   扩展名 之前 添加   " . opt   2 "   来 扩展 已 编译 文件   (   bytecode   )   的 文件名   ( 参见   PEP   488   )
由于 元组 是 不可 变 的 ， 因此 操作 的 赋值 部分 会 引发 错误
返回值 为 一个 被   " gmtime ( ) "   或   " localtime ( ) "   返回 的   " struct _ time "
使用 数据 类 ，   如果 此 代码 有效 :
你 永远 不 应 修改 或 删除 这些 内容 ， 因为 它们 由   Apple   控制 并 由   Apple   或 第三方 软件 使用
IBM 的 通用 十进制 算术 规范 ，   The   General   Decimal   Arithmetic   Specification .
如果 海龟 显示 返回   " True " ， 如果 海龟 隐藏 返回   " False "
C   函数调用 机制 会 保证 传给   C   函数 的 参数 列表   ( 本 示例 中为   " args " )   绝不会 为   " NULL "   实际上 它会 保证 其 总是 为 一个 元组   [ 4 ]
文本 变量   Specifies   a   name   whose   value   is   linked   to   the   widget   value
返回   Unicode   字符串   unistr   的 正常 形式   form
从   RawTurtle   派 生出 子类   " Turtle "   ( 别名 :   " Pen " ) ， 该类 对象 在   " Screen "   实例 上 绘图 ， 如果 实例 不 存在 则 会 自动 创建
用户 定义 的 类 可以 定义 为泛 型 类
（ 由   Stefan   Behnel   在   bpo   28238   中 贡献 。 ）
如果   user   不 为   " None " ， 则   setreuid ( )   系统 调用 将 于子 进程 执行 之前 在 下级 进程 中 进行
此 函数 执行 实际 的 格式化 操作
保留 用于 各种 具体 实现 专属 的 选项
" _ order _ "   用于   Python   2 / 3   代码 以 确保 成员 顺序 一致 （ 类 属性 ， 在 类 创建 期间 会 被 移除 ）
如果   address   不 表示 有效 的   IPv4   或   IPv6   网址 ， 或者 网络 设置 了   host   比特 位 ， 则 会 引发   " ValueError "
如果 某个 对象 应当 支持 给定 的 操作 但 尚未 提供 相应 的 实现 ，   所 要 引发 的 适当 异常 应为   " NotImplementedError "
这是 一些   Windows   下 的 例子
此 模块 中 定义 的 异常 都 继承 自   " SubprocessError "
args   会透 传给 这个 类 的 构造函数
在   3.7   版 更改 :   添加 了   defaults   参数 和   " _ field _ defaults "   属性
这是   " date . fromisoformat ( ) "   的 逆 操作
另 请 参见 函数   " dirname ( ) "   和   " basename ( ) "
bpo   19450 :   更新 Windows 和 OS   X 安装程序 以 使用 SQLite   3.8 . 11
许多 类 喜欢 创建 带有 特定 初始状态 的 自定义 实例
例如 ， 给定 一个 名为   " foo "   的 记录器 ， 名称 为   " foo . bar "   、   " foo . bar . baz "   和   " foo . bam "   的 记录器 都 是   " foo "   子项
可 在   printf   风格 的 字符串 格式化 部分 找到 更 多 信息
与 Python 中 的 所有 的 其它 对象 一样 ， 旧 的 对象 只有 在 它们 的 引用 计数 为 0 之后 才 会 被 回收
文件 可能 已 存档
尽可能 尝试 让   reference   匹配   fragment   的 一部分 （   fragment   应较 长 ）
默认值   " False "   表示 使用   UTC
切片 对象 也 会 在 使用 扩展 索引 语法 时 被 生成
如果 没有 给出   objects   ， 则   " print ( ) "   将 只 写入   end
当 关键字 是 简单 字符串 时 ， 有时 直接 通过 关键字 参数 来 指定 键值 对 更 方便
安装 Python 后 ， 您 可以 通过 Windows 中 的 “ 程序 和 功能 ” 工具 添加 或 删除 功能
asyncio   定义 了   " AbstractChildWatcher "   抽象 基类 ， 子 监视器 必须 要 实现 它 ，   并 具有 四种 不同 实现 :   " ThreadedChildWatcher "   ( 已 配置 为 默认 使用 ) ,   " MultiLoopChildWatcher " ,   " SafeChildWatcher "   和   " FastChildWatcher "
请 注意 此参数 与   filename   或   stream   不 兼容   — —   如果 两者 同时 存在 ， 则 会   引发   " ValueError "
该 基准 测试 脚本 以 纳秒 为 单位 显示 时间
返回   Future   对象 已 绑定 的 事件 循环
这 可以 用于 定义 一个 新 形状 或 一个 复合 形状 的 多个 组成部分
如果   start   不是 0   ， 跳过   iterable   中 的 元素 ， 直到 到达   start   这个 位置
其 功能 与   C   " sizeof "   运算符 相同
返回 当前 进程 存活 的 子 进程 的 列表
更 多 信息 请 查看 有关 它们 的 文档
要 获取 格式 指令 的 完整 列表 请参阅   strftime ( )   和   strptime ( )   的 行为
3.9   新版 功能 .
PEP   587   增加 了 一个 新 的   C   API   用来 配置   Python   初始化 ， 提供 对 整个 配置 过程 的 更 细致 控制 以及 更好 的 错误报告
以下 示例 将 pi 舍入 到 小数点 后 三位 :
在   3.8   版 更改 :   文件名 形参 支持   path   like   object
如果   DST   已 启用 则 将 差值 作为 一个   " timedelta "   对象 返回 （ 参见   " utcoffset ( ) "   了解 详情 ）
" tkinter . font "   Tkinter   字体 封装
bpo   33184 :   在 MacOS 安装程序 中将 OpenSSL 更新 为 1.1 . 0h
值   " 0 "   代表 使用   " PyArg _ ParseTuple ( ) "   的 陈旧 变量
（ 由   Berker   Peksag   在   bpo   22389   中 贡献 。 ）
不过 也 可能 会 返回   " NotImplemented " ， 如果 比较 目标 具有   " timetuple ( ) "   属性 的话
它 不 应该 调用 某个   " PyErr _   ( ) "   函数 这 类 函数 已经 被   g   调用 过 了
loggers   对应 的 值 将 是 一个 字典 ， 其中 每个 键 是 一个 日志 记录器 名称 而 每个 值则 是 一个 描述 如何 配置 相应   Logger   实例 的 字典
新增 ， 改进 和 弃 用 的 模块
" " ; " "   的 权 标值
（ 参阅   bpo   35810   和   bpo   40217   了解 更 多 信息 。 ）
Python   中 的 大 文件 支持 会 在   " off _ t "   的 大小 超过   " long "   且   " long   long "   至少 与   " off _ t "   一样 大时 被 启用
这 相当于 指定   "   X "   " pycache _ prefix   PATH "   选项
同样 的 方式 ， 字典 可 使用   "   "   操作符 来 提供 关键字 参数 :
由 队列 的 消费者 进程 使用
如果 某个 生成器 代码 直接 或 间接 地 引发 了   " StopIteration " ， 它会 被 转换 为   " RuntimeError "   ( 并 将   " StopIteration "   保留 为 导致 新 异常 的 原因 )
返回 历史 列表 的 当前 项数
如果   size   为 负值 或   " None " ， 则 读取 至   EOF
在   3.6   版 更改 :   添加 了   " ' _ ' "   选项   ( 另 请参阅   PEP   515   )
如果 可能 ， 在 默认 浏览器 的 新页面 （ “ 标签 ” ） 中 打开   url   ， 否则 等效于   " open _ new ( ) "
记住 ， 如果 子 进程 中 的 代码 尝试 访问 一个 全局变量 ， 它 所 看到 的 值 （ 如果 有   ） 可能 和 父 进程 中 执行   " Process . start "   那一刻 的 值 不 一样
在 调用 测试 脚本 时 添加   "   v "   参数 使   " unittest . main ( ) "   显示 更为 详细 的 信息   ， 生成 如 以下 形式 的 输出 :
该 函数 在 调用 过程中将 不会 释放   GIL
与 标准   C   不同 ， 所有 无法 识别 的 转义序列 将 原样 保留 在 字符串 中 ， 也就是说 ，   反 斜杠 会 在 结果 中 保留
将   n   设 为   100   以 使用 百分位 ， 即 给出   99   个 分隔 点来 将   data   分隔 为   100   个 大小 相等 的 组
类似 于   " DELETE _ NAME "   但会 删除 一个 全局变量
" % c "   本地化 的 适当 日期 和 时间 表示
对 两个 值 执行 忽略 正负号 的 数字 比较
在   3.7   版 更改 :   Python   only   explicitly   guaranteed   that   it   preserved   the   declaration   order   of   keyword   only   parameters   as   of   version   3.7 ,   although   in   practice   this   order   had   always   been   preserved   in   Python   3 .
该 模块 由   John   J
对于   " INSERT "   或   " REPLACE "   以外 的 操作 或者 当   " executemany ( ) "   被 调用 时 ， " lastrowid "   会 被 设为   " None "
所有者 具有 写入 权限
" pipes "   终端 管道 接口
" random "   模块 还 提供   " SystemRandom "   类 ， 它 使用 系统 函数   " os . urandom ( ) "   从 操作系统 提供 的 源 生成 随机数
如果 路径   path   包含 盘符 ， 则   drive   将 包含 冒号 及 冒号 前面 的 所有 内容
当 把   " None "   以外 的 对象 作为 第三个 参数 传入 时 ， 这些 导入 器 将 总是 返回   " None "
成功 时 返回 新 的 集合 ， 失败 时 返回   " NULL "
显示 刚 发生 的 语法错误
" _ generate _ next _ value _ ( ) "   方法 定义 必须 在 任何 其他 成员 之前
另 请参阅   " int ( ) "   将 十六进制 字符串 转换 为 以   16   为 基数 的 整数
format   是 归档 格式 ： 为   " zip "   ( 如果   " zlib "   模块 可用 ) ,   " tar " ,   " gztar "   ( 如果   " zlib "   模块 可用 ) ,   " bztar "   ( 如果   " bz2 "   模块 可用 )   或   " xztar "   ( 如果   " lzma "   模块 可用 )   中 的 一个
将 带有 文件名 输入 的 二进制 文件 转换 为 binhex 文件 输出
在   o   支持 的 情况 下该 操作 会 原地 完成
由于 foo 中 的 最后 一个 语句 为   " x "   分配 了 一个 新值 ， 编译器 会 将 其 识别 为 局部变量
AM ,   PM   ( en _ US ) ;   am ,   pm   ( 1 ) ,   ( de _ DE )   ( 3 )   " % M "   补零 后 ， 以 十进制 数 显示 的 分钟
3.2   新版 功能 .
当 被 用于 引用 模块 时 ，   完整 限定 名称 意 为 标示 该 模块 的 以点 号 分隔 的 整个 路径 ， 其中 包含 其 所有 的 父包 ， 例如   " email . mime . text " :
列表 属于   mutable   对象 ， 这 意味着 你 可以 改变 它 的 内容
此   decorator   装饰 器 生效 于类 或 函数 上
在   3.4   版 更改 :   增加 了 对   input   关键字 参数 的 支持
选项   描述   orient   One   of   " horizontal "   or   " vertical "
如果 调用 引发 了 一个 异常 ， 这个 方法 也 会 引发 同样 的 异常
（ 由   Victor   Stinner   在   bpo   38500   中 贡献 。 ）
windll   不会 通过 这样 的 魔法 手段 来 帮 你 决定 选择 哪 一种 函数 ， 你 必须 显式 的 调用   " GetModuleHandleA "   或   " GetModuleHandleW " ， 并 分别 使用 字节 对象 或 字符串 对象 作 参数
在 解析 命令 行时 ， " parse _ args ( ) "   会 检测 多种 错误 ， 包括 有 歧义 的 选项 、 无效 的 类型 、 无效 的 选项 、 错误 的 位置 参数 个数 等等
虽然 不太 常用 ， 但 这个 函数 在 安装 共享 模块 时 还是 很 有用 的 ， 特别 是 当 一些 用户 可能 没有 权限 在 包含 源代码 的 目录 中写 字节 码 缓存 文件 时
如果 要 继续 解压缩 则 这个 字节 串 必须 被 传给 对   " decompress ( ) "   的 后续 调用
和   " st2list ( st ,   line _ info ,   col _ info ) "   相同
导入 系统 仅会 在 重 加载 期间 传入 一个 目标 模块
就 地 实现   " TOS   TOS1   ^   TOS "
PEP   495   消除 本地 时间 的 歧义   PEP   由   Alexander   Belopolsky   和   Tim   Peters   撰写 ， 由   Alexander   Belopolsky   实现
3.9   版后 已 移除 .
" loop . run _ until _ complete ( ) "   运行 一个 期程 / 任务 / 可 等待 对象 直到 完成
默认 的 文件 模式 为   " ' r ' " ， 表示 以 读取 模式 打开 文件
如果 了解 以下 选项 ：
default _ section   ， 默认值 :   " configparser . DEFAULTSECT "   ( 即 :   " " DEFAULT " " )
" modulefinder . py "   也 可以 作为 脚本 运行 ， 给出   Python   脚本 的 文件名 作为 参数   ， 之后 将 打印 导入 模块 的 报告
参数 必须 是   " PyDateTime _ Time "   包括 其子 类 的 实例
PEP   487 :   自定义 类 创建
PEP   525 :   异步 生成器
" importlib "   " import "   的 实现
namespace   用于 获取 属性 的 对象
如果 你 需要 确定 是否 引发 了 异常 但 不 打算 处理 它 ， 则 可以 使用 更 简单 的   " raise "   语句 形式 重新 引发 异常
键 函数 不 需要 直接 依赖于 被 排序 的 对象
当   " Generator "   写出   MIME   消息 的 纯 文本 表示 形式 时 ， 如果 它 发现 消息 具有   preamble   属性 ， 它 将 在 标头 及 第一个 分界 之间 区域 写出 这些 文本
如果 你 安装 了   py . exe   启动器 ， 你 将 可以 使用   " py "   命令
如果 设置 了 此 变量 ， Python   将 不会 把   " 用户   site   packages   目录 "   添加 到   " sys . path "
这个 类 封装 了 列表 对象
重要 例外 ： 如果 使用者 请求 的 缓冲区 没有   " PyBUF _ FORMAT "   标志 ，   " format "   将 设置 为   " NULL " ， 但   " itemsize "   仍 具有 原始 格式 的 值
这 是因为   " __ main __ "   被 初始化 的 方式 依赖于 发起 调用 解释器 所 附带 的 旗标 和 其他 选项
如果 传递 的 是 一个 异常 类 ， 它 将 通过 调用 没有 参数 的 构造函数 来 隐式 实例 化 :
引发 一个 审计 事件   " builtins . input "   附带 参数   " prompt "
返回   " b   in   a "   检测 的 结果
（ 由   Ray   Allen   在   bpo   9523   中 建议 。 ）
rounding   选项 应为   Rounding   Modes   小节 中 列出 的 常量 之一
返回 具有 指定   year ,   month ,   day ,   hour ,   minute ,   second ,   microsecond   和   fold   属性 的   " datetime . datetime "   对象
就 地 操作 就 像 二元 操作 ， 因为 它们 删除 了 TOS 和 TOS1 ， 并 将 结果 推 回到 堆栈 上 ，   但是 当 TOS1 支持 它 时 ， 操作 就 地 完成 ， 并且 产生 的 TOS 可能 是 （ 但 不 一定 ）   原来 的 TOS1
有关 描述 器 的 方法 的 更 多 信息 ， 请参阅 实现 描述 器 或 描述 器 使用指南
" urllib . error "   urllib . request   引发 的 异常 类
如果 异步 生成器 引发 任何 其他 异常 ， 它会 被 传播 给 可 等待 对象 的 调用者
表示   Python   整数 对象 的   " PyObject "   子 类型
在 缺失   " os . lstat ( ) "   的 平台 上 等同于   " exists ( ) "
对   output   的 别名 ， 对应 的 有   " stderr "
如果 给定 了   fileobj   ， 它 应当 是 一个   binary   file   ， 并会 从中 读取   " tarinfo . size "   个 字节 添加 到 归档
即使 在 不 启用   UTF   8   模式 时 ， Windows   版 的   Python   也 会 在 以下 情况 中 默认 使用   UTF   8 ：
返回 由   " Task "   包装 的 协程 对象
参数 :   fun   一个 函数 ， 调用 时 将 传入 两个 参数 表示 在 画布 上 点击 的 坐标
Requires   Expression   解释   "   1.0 "   Only   version   " 1.0 "   is   compatible   " > 1.0 ,   !   1.5 . 1 ,   < 2.0 "   Any   version   after   " 1.0 "   and   before   " 2.0 "   is   compatible ,   except   " 1.5 . 1 "
与   " importlib . import _ module ( ) "   不同 ， 这是 一个 日常   Python   编程 中 不 需要 用到 的 高级 函数
注意 你 只能 在 迭代 器中 顺序 前进 ； 没有 获取 前 一个 元素 的 方法 ， 除非 重置 迭代 器   ， 或者 重新 复制 一份
Python 如何 管理 内存 ？
请参阅 在 Windows 上 使用   Python   了解 更 多 信息
在 舍入 之前 指数 低于   " Emin "
默认 情况 下 ， " ArgumentParser "   对象 使用   " sys . argv [ 0 ] "   来 确定 如何 在 帮助 消息 中 显示 程序 名称
" multiprocessing "   中 的 代理 类 并 没有 提供 任何 对于 代理 值 比较 的 支持
为什么 lambda 表达式 不能 包含 语句 ？
第一行 应该 是 对象 目的 的 简要 概述
检测 字符 值 是否 在   7   位   ASCII   集 范围 内
在 当前 实现 中 ， 内置 变量   " __ debug __ "   在 正常 情况 下 为   " True " ， 在 请求 优化 时为   " False "   ( 对应 命令行 选项 为   "   O " )
" scheduler "   实例 拥有 以下 方法 和 属性 ：
在   3.6   版 更改 :   " fromtimestamp ( ) "   可能 返回   " fold "   值设 为   1   的 实例
然后 运行 GDB ：
相比之下 ， 路径 条目 查找 器 在 某种意义 上 说 是 基于 路径 的 查找 器 的 实现 细节 ， 实际上 ， 如果 需要 从   " sys . meta _ path "   移除 基于 路径 的 查找 器 ， 并 不会 有 任何 路径 条目 查找 器 被 发起 调用
在   Python   3.2   中 ， 引入 了 一种 新 的 配置 日志 记录 的 方法 ， 使用 字典 来 保存 配置 信息
由于 简单 型   " datetime "   对象 会 被 许多   " datetime "   方法 当作 本地 时间 来 处理 ， 最好 是 使用 感知 型 日期 时间 对象 来 表示   UTC   时间
派生类 定义 的 执行 过程 与 基类 相同
请 记住 ， 如果 您 正在 操作 的 节点 具有 子 节点 ， 则 必须 先 转换 其子 节点 或 为 该 节点 调用   " generic _ visit ( ) "   方法
这 对 访问 需要 小 段 数据   — —   cookies   的 网站 很 有用 ， 这些 数据 由   Web   服务器 的   HTTP   响应 在 客户端 计算机 上 设置 ， 然后 在 以后 的   HTTP   请求 中 返回 给 服务器
如果 指涉 对象 无法 序列化 ， 则 会 抛出 一个 异常
等价 于   Python   语句   " o1   +   o2 "
虽然 它 目前 会 被 解读 为 真值 ， 但 将 同时 发出   " DeprecationWarning "
Windows   2000 （ 变更 集 e52df05b496a ）
独立 于 其 类别 ， 每个 具体 流 对象 也 将 具有 各种 功能 ： 它 可以 是 只读 ， 只 写 或 读写
返回   Unicode   码位 为 整数   i   的 字符 的 字符串 格式
使用   universal   newlines   作为 文本 字符串 被 返回 ， 将 所有 可 识别 行 分割 符 翻译成   " ' \ n ' "   字符
此 函数 仅 包括 规范 时 区 名称 而 不 包括 “ 特殊 ” 时区 如 位于   " posix / "   和   " right / "   目录 下 的 时区 或   " posixrules "   时 区
如果 一个 查找 器 实现 了   " invalidate _ caches ( ) " ， 那么 它会 被 调用 来 执行 那个 无效 过程
在 你 使用 它 之前 ， 你 需要 安装   Mark   Hammond   的   Python   Win32   扩展
在   Windows   上 ， " os . readlink ( ) "   现在 能够 读取 目录 连接
数字 类型   " int " ,   " float " ,   " complex "
在   3.5   版 更改 :   当 系统 调用 被 某个 信号 中断 时 ， Python   现在 会 重试 系统 调用 ， 除非 该 信号 的 处理程序 引发 了 其它 异常   ( 原理 参见   PEP   475   )   而 不是 引发   " InterruptedError "
此 函数 不会 改变 对   v   的 引用
请 注意 ， 即使 对于 小 的   " len ( x ) " ，   x   的 排列 总数 也 可以 快速增长 ， 大于 大多数 随机数 生成器 的 周期
bpo   33078 :   修复 在 OSX 平台 因为 依赖 sem _ getvalue 而 导致 的 失败
在   3.3   版 更改 :   引发   " OverflowError "   而 不是   " ValueError " ， 如果 时间 戳 数值 超出 所在 平台   C   " gmtime ( ) "   函数 的 支持 范围 的话
等价 于   " p . readline ( [ n ] ) "   ， 这个 函数 从 对象   p   中 读取 一行
移植 到   Python   3.1
如果   size   参数 为 负值 或 被 省略 ， 则 读取 所有 字节 直到 分块 末尾
使用   " list "   作为   " default _ factory " ， 很 轻松 地 将 （ 键值 对 组成 的 ） 序列 转换 为 （ 键 列表 组成 的 ） 字典 ：
下面 是 一个 在子 进程 中 修改 多个 ctypes 对象 的 例子
当 对象 销毁 时会 自动 调用
如果   follow _ symlinks   为 假值 且   src   为 符号 链接 ， 则   dst   也 将 被 创建 为 符号 链接
3.8   新版 功能 .
一个   classmethod ， 可以 将 一个 类型 或者 可 调用 对象 注册 到 管理器 类
低 层级   API   索引
堆 是 通过 数组 来 实现 的 ， 其中 的 元素 从   0   开始 计数 ， 对于 所有 的   k   都 有   " a [ k ]   <   a [ 2   k + 1 ] "   且   " a [ k ]   <   a [ 2   k + 2 ] "
如果   data   为空 ， 则 将 引发   " StatisticsError "
PEP   352 :   异常 作为 新型 的 类
仅限   Windows ： 设置 调用 线程 中 系统   " LastError "   变量 的   ctypes   私有 副本 的 当前 值为   value   并 返回 原来 的 值
它 需要 一个 特殊 的 构建 选项   " CALL _ PROFILE "   而 该 选项 在   Python   3.7   中 已 被 移除
在   " ' single ' "   或   " ' eval ' "   模式 编译 多行 代码 字符串 时 ， 输入 必须 以 至少 一个 换行符 结尾
一条 语句 可以 是 一个   expression   或 某个 带有 关键字 的 结构 ， 例如   " if " 、 " while "   或   " for "
返回值 为   " ( pid ,   fd ) "
以   " list ( ) "   的 形式 从   " robots . txt "   返回   " Sitemap "   形参 的 内容
为了 找到 对象 及其 文档 内容 ， " pydoc "   会 导入 文档 所在 的 模块
这使 你 可以 在 生成 的 替换 字符串 中 合并 原始 文本 的 部分 内容
在   " sizeof ( int )   sizeof ( long ) "   的 平台 上 它 是   " c _ ulong "   的 一个 别名
当然 ， 这里 描述 的 方法 可以 概括 ， 例如 临时 附加 日志 记录 过滤器
例如 ， 下面 是 如何 迭代 遍历 字典 并 按 keys   排序 :
返回 当   " timezone "   实例 被 构造 时 指定 的 固定值
如果 没有   " __   init __ ( ) "   方法 生成 ， 那么   " __ post _ init __ ( ) "   将 不会 被 自动 调用
即使 在 交互 模式 下 也 不 显示 版权 和 版本信息
在   3.3   版 更改 :   过去 触发 的   " IOError " ， 现在 是   " OSError "   的 别名
例如 ， " FileType ( ' w ' ) "   可 被 用来 创建 一个 可 写 文件 :
它 带有 许多 系统 调用 和 库 以及 多种 窗口 系统 的 接口 ， 并且 能 用   C   或   C++   来 进行 扩展
输出 结果 会 像 这样 :
所有 词法 分析 将 使用 此 编码 ， 包括 语义 字符串 、 注释 和 标识符
这是   " ImportError "   的 子类 ， 因此 ， 也 可以 捕获 为   " ImportError "
关闭   " dumbdbm "   数据库
这 对于 别名 很 有用
当设 为   " always "   时 ， 所有 基于 哈希 值 的   " . pyc "   文件 ， 不论是 已 选定 还是 未 选定 的 都 将 根据 其 对应 的 源文件 进行 验证
要 映射 匿名 内存 ， 应 将   1   作为   fileno   和   length   一起 传递
" x   is   not   y "   会 产生 相反 的 逻辑值
由于 下载 的 初始 安装包 中未 包含 Python 的 某些 可 选 功能 ， 如果 选择 安装 这些 功能 可能 需要 Internet 连接
成功 时 返回 一个 新 的 元组 对象 ， 长度 为   len   ， 失败 时 返回 ` ` NULL ` `
引发 一个 审计 事件   " winreg . DisableReflectionKey " ， 附带 参数   " key "
预定 义 的 清理 操作
canvheight   正 整型 数 ， 以 像素 表示 画面 的 新 高度 值
模式   意义   "   "   匹配 所有   " ? "   匹配 任何 单个 字符   " [ seq ] "   匹配   seq   中 的 任何 字符   " [ ! seq ] "   匹配 任何 不 在   seq   中 的 字符
此处 的 正式 句法 中 存在 一点 歧义 ： 任何 形似 表达式 列表 的 东西 同样 也 会 形似 切片 列表 ， 因此 任何 抽取 操作 也 可以 被 解析 为 切片
字体 样本 现在 包括 一组 非 拉丁 字符 以便 用户 能 更好 地 查看 所 选 特定 字体 的 效果
返回 时间 间隔 包含 了 多少 秒
该 数据 不可 通过 任何 方式 来 修改 ， 除非 是 刚 使用   " PyBytes _ FromStringAndSize ( NULL ,   size ) "   创建 该 对象
函数调用 经常 被 期望 为 默认值 创建 新 的 对象
在 其它 所有 情况 下 返回   0
" collapse _ rfc2231 _ value ( ) "   会 将 此 返回 为 一个   unicode   字符串
这些 序列 可以 包含 在 字符 类中
这 适用 于 任何 具有 方法 的 对象   — —   不论是 内置 方法 还是 用户 自定义 方法
在   3.3 . 3   版 更改 :   此 函数 现在 遵循   RFC   6125   ,   6.4 . 3   小节 ， 它 不会 匹配 多个 通配符   ( 例如   "
将   prefix   添加 到   text   中 选定 行 的 开头
向   " ACCESS _ READ "   内存 映射 赋值 会 引发   " TypeError "   异常
作为   tzinfo   参数 被 传给   " time "   构造 器 的 对象 ， 如果 没有 传入 值则 为   " None "
如何 在   Python   中 对接   C   ++   对象 ？
简而言之 ， 你 可以 用 以下 代码 使用 扩展 模块 初始化   Python   解释器
3.4   新版 功能 :   The   "   o "   command   line   option .
" l "   ( " int " )   [ long   int ]   将 一个   C   " long   int "   长 整型 转化成   Python   整型 对象
为什么   22   / /   10 返回   3 ？
" biginteger "   " double "   或   " float "   " float "
" class "   条目 是 可选 的
为 给定 的   encoding   获取 一个   " StreamReader "   工厂 函数
在   3.6   版 更改 :   Added   policy   keyword   only   parameter .
用于 生成 子 进程 和 运行 shell 命令 的 工具包
例如   " / usr / bin / python2.7   32 "   将 请求 使用   32   位   python   2.7
实例 内容 初始化 设置 为   seq   的 copy
注意 例子 中 某行 中 出现 第二个 提示符 意味着 你 必须 键入 一个 空白行 ； 这是 用来 结束 多行 命令 的
Ctrl   键 组合 的 键 名称 则 是 一个 两 字节 的 字节 串 对象 ， 它 由 插入 符   ( " b ' ^ ' " )   加 对应 的 可 打印   ASCII   字符 组成
你 可以 用 模块 名 访问 这些 函数 :
（ 否则   " importlib . reload ( ) "   将 无法 正确 工作 。 ）   如果 该 名称 模块 不 存在 于   " sys . modules "   中 ， 加载 器 必须 创建 一个 新 的 模块 对象 并 将 其 加入   " sys . modules "
当 运行 后 ， 你 会 看到 控制台 如下 所示
" xdrlib "   编码 与 解码   XDR   数据
text   字符串 来自 于 底层 库中   " rl _ attempted _ completion _ function "   回调 函数 的 第一个 形参
网络 和 进程 间通信
这个 方法 将 返回 当   " postcmd ( ) "   方法 返回 一个 真值
当 记录器 决定 实际 记录 事件 时 ， 从 记录 消息 创建   " LogRecord "   实例
句法 和 词法 解析 的 描述 采用 经过 改进 的   BNF   语法 标注
恢复 执行 之后   yield   表达式 的 值 取决于 恢复 执行 所用 的 方法
与 其他 运算 不同 ， 量化 永不 信号 下溢 ， 即使 结果 不 正常 且 不 精确
（ 这 只 适用 于 具有   " lineno "   和   " col _ offset "   属性 的 节点
在 布尔运算 中 使用   " NotImplemented "   已 被 弃用 ， 因为 它 几乎 必定 是 不 正确 的 富 比较 运算符 实现 的 结果
创建 一个 迭代 器 ， 只要   predicate   为 真 就 从 可 迭代 对象 中 返回 元素
这里 的 情况 不够 清晰 ， 一些 不太 常用 的 例程 是 例外 的   " PyTuple _ GetItem ( ) "   ，   " PyList _ GetItem ( ) "   ，   " PyDict _ GetItem ( ) "   ，   " PyDict _ GetItemString ( ) "   都 是 返回 从 元组 、 列表 、 字典 里 借用 的 引用
如果 流是 以 文本 模式 打开 的 ， 则   input   必须 为 字符串
( " len ( result ) "   将 等于   " size " 。 )
" StreamHandler "   类 位于 核心   " logging "   包 ， 它 可 将 日志 记录 输出 发送到 数据流 例如   sys . stdout   ,   sys . stderr   或 任何 文件 类 对象 （ 或者 更 精确 地说 ， 任何 支持   " write ( ) "   和   " flush ( ) "   方法 的 对象 ）
如果 引用 已 不 存在 ， 则 调用 引用 对象 将 返回   " None " :
在   3.9   版 更改 :   The   " show _ alloc _ count "   field   has   been   removed .
类似 地 ， 这些 构造函数 也 适用 于 任意 可 迭代 的   Python   对象
" getstate ( ) "   和   " setstate ( ) "   方法 如果 被 调用 则 引发   " NotImplementedError "
该 方法 不能 删除 带有 子项 的 键
此 函数 生成 的 文件 对象 有 一个 额外 的 方法 — — " rollover ( ) " ， 可以 忽略 文件大小 ， 让 文件 立即 写入 磁盘
bpo   31392 :   更新 Windows   构建 以 使用 OpenSSL   1.1 . 0f
规定 这种 默认 行为 的 原因 是 缺少 与 一致性 比较 类似 的 固定值
实现 者 需要 注意 使 相等 的 数字 相等 并 拥有 同样 的 值
这 使得 该 函数 相比 使用   " self . index "   和   " self . data "   这种 实例 变量 的 方式 更 易 编写 且 更为 清晰
Python   3.0   有 什么 新 变化
返回 后者 表示 元 路径 搜索 应当 继续 ， 而 引发 异常 则 会 立即 终止 搜索
在 原始 流 被 分离 之后 ， 缓冲区 将 处于 不可 用 的 状态
这个 命名 约定 告诉 测试运行 者 类 的 哪些 方法 表示 测试
如果 给出 了 参数   logdir   ， 则 回溯 会 被 写入 文件
否则 的话 ， " raise "   会 将 第一个 表达式 求值 为 异常 对象
这个 钩子 给予 其他 日期 对象 类型 实现 混合 类型 比较 的 机会
（ 由   Raymond   Hettinger   贡献 ， 参见   rationale 。 ）
若 要 使用 这个 宏 ， 必须 把   " tp _ traverse "   的 参数 命名 为   visit   和   arg
类 实例 方法 :   调用 相应 的 用户 自定义 函数 ， 向 其 传入 的 参数 列表 会 比 调用 的 参数 列表 多 一项 ： 该 实例 将 成为 第一个 参数
在   3.1   版 更改 :   Added   the   ability   to   use   " assertRaises ( ) "   as   a   context   manager .
这 意味着 日志 记录器 实例 不 需要 在 应用 的 不同 部分 间 传递
将   " parsedate _ tz ( ) "   所 返回 的   10   元组 转换 为 一个   UTC   时间 戳 （ 相距   Epoch   纪元 初始 的 秒数 ）
而且 ， 由于 这个   0.1   无法 精确 表示   1 / 10   的 值 而 这个   0.3   也 无法 精确 表示   3 / 10   的 值 ， 使用   " round ( ) "   函数 进行 预先 舍入 也 是 没用 的 :
Dbm   对象 的 行为 类似 于 映射 （ 字典 ） ， 区别 在于 其键 和 值 总是 被 存储 为 字节 串
对象 的 引用 计数 不会 增加
PEP   3112 :   字节 字 面值
在 调试器 的 控制 下 运行 程序 的 典型 用法 是 :
3.1   新版 功能 :   Added   under   the   name   " assertRegexpMatches " .
" abc "   模块 还 支持 下列 旧式 装饰 器 :
如果 缩进 等级 为 零 、 负数 或者   " " " "   ， 则 只会 添加 换行符
函数 接受 并 返回 一个 字符串 ， 注释 像 下面 这样 :
与 标准   C   memset   库函数 相同 ： 将 位于 地址   dst   的 内存 块 用   count   个 字节 的   c   值 填充
PEP   3106   改造   dict . keys ( ) ,   . values ( )   和   . items ( )   PEP   written   by   Guido   van   Rossum
" 使用   Urwid   的 控制台 应用程序 " :   一场 演示 使用   Urwid   编写 应用程序 的   PyCon   CA   2012   演讲 的 视频
在   3.8   版 更改 :   " yield "   和   " yield   from "   在 隐式 嵌套 的 作用域 中 已 被 禁用
检测 作为 跳转 目标 的 原始 编译 后 字节 码 字符串   code   中 的 所有 偏移量 ， 并 返回 这些 偏移量 的 列表
提供 了   " __ aiter __ "   方法 的 抽象 基类
" NormalDist "   示例 和 用法
返回 可 迭代 对象 中 最大 的 元素 ， 或者 返回 两个 及 以上 实参 中 最大 的
" tkinter . colorchooser "   颜色 选择 对话框
而且 记录 在 文件 中 的 消息 格式 需要 包含 时间 戳 ， 打印 在 控制台 的 不 需要
3.4   新版 功能 .
3.8   新版 功能 .
返回   code   依据   tableB.2   ( 配合   NFKC   使用 的 大小写 转换 映射 )   所 映射 的 值
" collections "   模块 提供 了 一种   " deque ( ) "   对象 ， 它 类似 于 列表 ， 但 从 左端 添加 和 弹出 的 速度 较 快 ， 而 在 中间 查找 的 速度 较慢
有关   Python   命令行 解析 更 细致 的 介绍 ， 请参阅   argparse   教程
几乎 没有 必要 创建 这些 文档
在   3.6 . 1   版 更改 :   Added   support   for   default   values ,   methods ,   and   docstrings .
这 等价 于   Python   表达式   " list ( o ) "
Python   对象 和 其他 内部 缓冲区 的 堆 空间 分配 是 由   Python   内存 管理器 按 需 通过 本 文档 中 列出 的   Python / C   API   函数 进行 的
返回值 是 一个 数 ， 为 纪元 秒数 （ 参见   " time "   模块 ）
如果 未指定   ， 这些 字符串 默认 为空
3.3   版后 已 移除 :   Use   " importlib . util . find _ spec ( ) "   instead   unless   Python   3.3   compatibility   is   required ,   in   which   case   use   " importlib . find _ loader ( ) "
新 的   encoding / decoding   帮助 函数 :
文本 数据   二进制 数据   decode   encode   format   isdecimal   isnumeric
它 将 由   " _ ctypes "   扩展   dll   所 导出 的   DllGetClassObject   函数 来 调用
Because   of   the   PEP   342   changes   described   in   section   PEP   342 :   生成器 的 新 特性 ,   it ' s   now   possible   for   " gi _ frame "   to   be   " None " .
如果 最后 读取 的 行 来自   " sys . stdin "   则 返回   " True " ， 否则 返回   " False "
在 语义上 等价 于 :
（ 由   Raymond   Hettinger   在   bpo   35892   中 贡献 。 ）
该 插件 基于   " lsprof "   ， 由   Brett   Rosen   和   Ted   Chaotter   贡献
DictWriter   对象 具有 以下 公开 方法 ：
bpo   35360 :   更新 macOS 安装程序 以 使用 SQLite   3.28 . 0 .
这个 非公有 类 是 所有   ctypes   数据类型 的 共同 基类
这 可以 是 导出 程序 底层 物理 内存 块 中 的 任何 位置
堆 最 有趣 的 特性 在于 最小 的 元素 总是 在 根 结点 ： " heap [ 0 ] "
errors   如果 此 关键字 参数 与   filename   一同 被 指定 ， 则   该值 会 在 创建   FileHandler   时 被 使用 ， 因而 也 会 在   打开 输出 文件 时 被 使用
在 其他 情况 下 返回值 必须 为 一个   " timedelta "   对象 ， 其 取值 严格 限制 于   "   timedelta ( hours   24 ) "   和   " timedelta ( hours   24 ) "   之间 （ 差值 的 幅度 必须 小于 一天 ）
filename   应为 文件系统 中 某个 文件 或 目录 的 路径
( b )   当读 到 写 有 len ( X ) 的 代码 时 ， 就 知道 它 要求 的 是 某件 东西 的 长度
" 1   <   day   <   指定 年 月 的 天数 " ,
3.2   新版 功能 :   nosigint   参数
此 函数 用于 处理   info   ( 一个 包含   " sys . exc _ info ( ) "   返回 结果 的   3   元组 )   所 描述 的 异常 ， 将 其 回溯 格式化 为 文本 并 将 结果 作为 字符串 返回
能够 匹配 不同 的 字符 集合 是 正则表达式 可以 做 的 第一件 事 ， 这 对于 字符串 可用 方法 来说 是 不 可能 的
使用 内置 函数   " getattr ( ) "
" FORMAT _ XZ " :   " . xz "   容器 格式
Python   3.6 . 4   中 的 重要 变化
如上所述 ， 在 进行 并发 编程 时 ， 通常 最好 尽量避免 使用 共享 状态
类 引入 了 一些 新 语法 ， 三种 新 对象 类型 和 一些 新 语义
可 使用 必须 保存 状态 的   " StreamWriter "   作为 编解码器 以便 高效 地 进行 编码
（ 在 早期 版本 中 这 将 引发   " ValueError " 。 ）
可惜 的 是 ， 对于 我们 的 脚本 获得 的 新 能力 ， 我们 的 帮助 输出 并 没有 提供 很多 信息 ， 但 我们 总是 可以 通过 改善 文档 来 修复 这一 问题 （ 比如 通过   " help "   关键字 参数 ）
如果   PRNG   未 使用 足够 的 数据 作为 随机 种子 或者 如果 当前   RAND   方法 不 支持 该 操作 则 会 引发   " SSLError "
在   3.6   版 更改 :   " __ package __ "   预期 与   " __ spec __. parent "   具有 相同 的 值
" TextWrapper "   还 提供 了 一些 公有 方法 ， 类似 于 模块 层级 的 便捷 函数 ：
3.9   版后 已 移除 :   " builtins . dict "   now   supports   " [ ] "
__ qualname __   设为 与 函数 名称 相同 的 值
在   3.3   版 更改 :   Accept   " crypt . METHOD _   "   values   in   addition   to   strings   for   salt   .
epoch   是 时间 开始 的 点 ， 并且 取决于 平台
函数参数 列表 中 的 斜杠 表示 在 它 之前 的 形参 是 仅限 位置 形参
为了 避免 这种 情况 ， 你 需要 将值 保存 在 lambdas 的 局部变量 中 ， 这样 它们 就 不 依赖于 全局 ` ` x ` `   的 值
一般地说 ，   " isinstance ( ) "   和   " issubclass ( ) "   不 应该 和 类型 一起 使用
如果 绝对 确实 地 需要 立即 退出 （ 例如 在 调用   " os . fork ( ) "   之后 的 子 进程 中 ） 则 可 使用   " os ._ exit ( ) " .
通过 在 函数 体中 的 某处 添加 赋值 语句 ， 导致 以前 正常 工作 的 代码 被 修改 而 得到   UnboundLocalError   会 令人 感到 意外
" return "   会 离开 当前 函数调用 ， 并 以 表达式 列表   ( 或   " None " )   作为 返回值
" select "   等待   I / O   完成
有关   " __ path __ "   语义 的 更 多 细节 将 在下文 中 给出
当 发起 调用 时 将   blocking   参数 设 为 真值 ， 则 执行 与 无 参数 调用 时 一样 的 操作 ， 然后 返回   " True "
这一 特性 能够 被 用于 实现 自定义 解码器
控制 出现 在 字 段 中 的 引号 字符 本身 应 如何 被 引出
在   " f   methodcaller ( ' name ' ) "   之后 ， 调用   " f ( b ) "   将 返回   " b . name ( ) "
However ,   as   this   migration   is   currently   still   incomplete ,   the   legacy   versions   of   those   guides   remaining   available   as   安装 Python 模块 （ 旧版 ）   and   分发   Python   模块 （ 遗留 版本 ） .
bpo   22591 :   放弃 对   MS   DOS   的 支持 ， 尤其 是   DJGPP   编译器 （ GCC 的 MS   DOS 端口 ）
创建 一个 实现 了 双向 转换 的   " StreamRecoder "   实例 :   encode   和   decode   工作 于 前端   —   对 代码 可见 的 数据 调用   " read ( ) "   和   " write ( ) " ， 而   Reader   和   Writer   工作 于 后 端   —   stream   中 的 数据
它 可能 比 您 自己 的 基于 字典 的 自定义 方法 甚至 基于   db _ row   的 解决方案 更好
交互式 编辑 和 编辑 历史
对于 将 简单 名称 作为 赋值 目标 的 情况 ， 如果 是 在 类 或 模块 作用域 中 ， 标注 会 被 求值 并 存入 一个 特殊 的 类 或 模块 属性   " __ annotations __ "   中 ， 这是 一个 将 变量 名称 （ 如为 私有 会 被 移除 ） 映射 到 被 求值 标注 的 字典
3.7   新版 功能 .
在   3.3   版 更改 :   导入 系统 已 被 更新 以 完全 实现   PEP   302   中 的 第二阶段 要求
可 选 参数   context   是 要 在 回溯 中 的 当前 源码 行 前后 显示 的 上下文 行 数 ； 默认 为   " 5 "
bpo   22644 :   OpenSSL 的 捆绑 版本 已 更新 到 1.0 . 1j
3.6   版后 已 移除 :   SSLv3   is   deprecated
这个 函数 对象 包含 对 当前 全局 命名 空间 的 引用 ， 作为 函数 被 调用 时所 使用 的 全局 命名 空间
当前 光标 位置 将 保持 不变
（ 由   Pierre   Glaser   和   Olivier   Grisel   在   bpo   35900   中 贡献 。 ）
" getkey ( ) "   将 做 同样 的 事 但是 会 把 整数 转换 为 字符串
这 也 会 影响 到 在 具体 实现 中 （ 直接 或 间接 地 ） 使用 了   " datetime . timedelta "   算术 运算 的 返回 类型 ， 例如   " astimezone ( ) "
由   " Manager ( ) "   返回 的 管理器 对象 控制 一个 服务 进程 ， 该 进程 保存 Python 对象 并 允许 其他 进程 使用 代理 操作 它们
在   3.4   版 更改 :   恢复   " rot13 "   别名
假设 你 有 这样 一个 类 :
从   population   中 选择 替换 ， 返回 大小 为   k   的 元素 列表
此 函数 接受 一个 输入 源 和 一个 可选 的 基准   URL   并 返回 一个 经过 完整 解析 可 供 读取 的   " InputSource "
" _ Py _ AddToAllObjects ( ) "   ( " Py _ TRACE _ REFS "   构建 专属 )
属性   索引   值   值 （ 如果 不 存在 ）   " url "   0   URL   with   no   fragment   空 字符串   " fragment "   1   片段 识别   空 字符串
必须 作为 一个 海龟 绘图 程序 的 结束 语句
这 不是 一个 真正 的 操作码
如果 已 更改 ， 则 会 刷新 并 关闭 现有 流 然后 重新 打开 文件 ， 这 通常 是 将 记录 输出 到 文件 的 先导 操作
bpo   36176 :   修复   IDLE   自动 补全 和   calltip   悬浮 窗 的 颜色
例如 ， " openlog ( ) "   将 在 首次 调用   " syslog ( ) "   时 被 调用 （ 如果   " openlog ( ) "   还 未 被 调用 过 ） ， 并且   ident   和 其他   " openlog ( ) "   形 参会 被 重置 为 默认值
制作 字典 的 浅层 复制 可以 使用   " dict . copy ( ) "   方法 ， 而 制作 列表 的 浅层 复制 可以 通过 赋值 整个 列表 的 切片 完成 ， 例如 ， " copied _ list   original _ list [ : ] "
3.3   新版 功能 .
依赖于 具体 的 回调 函数 ， 你 还要 提供 一个 参数 列表 到   " PyEval _ CallObject ( ) "
如果   UTC   时差 不 确定 则 返回   " None "
如果 此 函数 返回   0   则 对象 无法 被 垃圾 回收 器 追踪
使用   GZIP   压缩 二进制 字符串 示例 ：
更 多 相关 的 函数 ， 参见   " datetime "   和   " time "   模块
指明 最 快速 的 压缩 方法 （ 较 低 压缩率 ）
如果 级别 为 预定 义 的 级别   " CRITICAL " ,   " ERROR " ,   " WARNING " ,   " INFO "   或   " DEBUG "   之一 则 你 会 得到 相应 的 字符串
舍入 到 一个 整数
toaddrs   应当 为 字符串 列表
该 构造 器 接受 一个 整数 地址 ， 或者 一个 字节 串 对象
让 我们 修复 那个   bug ：
一个 数字 形式 的 错误 编号 ， 用于 表示 验证 错误
在   " sizeof ( long )   sizeof ( int ) "   的 平台 上此 类型 是   " c _ long "   的 一个 别名
类似 地 ，   compresslevel   如果 给出 也 将 覆盖 构造 器
" x   <   y "   和   " not   x   >   y "   ( 对于 完全 排序 )
从流 中 读取 并 返回 所有 字节 直到   EOF ， 如 有 必要 将 对流 执行 多次 调用
" register ( ) "   属性 将 返回 启用 了 装饰 器 堆栈 、 封存 的 未 装饰 函数 ， 并会 为 每个 变量 单独 创建 单元测试 :
当   " add _ argument ( ) "   通过   " action   ' store _ const ' "   或   " action   ' append _ const "   调用 时
此 函数 会 由   " import "   语句 发起 调用
3.2   新版 功能 .
比较 应该 是 对称 的
在   3.3   版 更改 :   添加   " yield   from   < expr > "   以 委托 控制流 给 一个 子 迭代 器
以下 例子 会 打印 出 一封 具有 多 部分 结构 之 信息 的 每个 部分 的   MIME   类型
3.9   版后 已 移除 :   Passing   " None "   for   s   will   raise   an   exception   in   future   Python   versions .
这仅 适用 于 未 提供   "   o "   的 情况
另 请参阅 :   The   Single   UNIX   Specification ,   Version   2 ,   Other   Environment   Variables .
使用 一个 正整数 会 让 每 一层 缩进 同样 数量 的 空格
在 苹果 系统 上 使用   Python
" Enum "   类 和 成员 的 布尔值   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
如果   flag   为   " False " ， 则 效果 与 调用   " noqiflush ( ) "   相同
一个 实现 加载 器 检查 模块 可选 的   PEP   302   协议 的   loader   的 抽象 基类
通常 ， 通过 导入 使用 的 许多 模块 也 提供 命令行 界面 或 自检 ， 并且 只 在 检查   " __ name __ "   之后 ， 才 执行 之后 的 代码   :
（ 由   Ross   Light   在   bpo   4285   中 贡献 。 ）
在   3.6   版 更改 :   " StreamRequestHandler . wfile "   also   supports   the   " io . BufferedIOBase "   writable   interface .
如果 打印 出类 对象 的 “ 标识 ” ， 问题 的 本质 就 会 明确 ：
" codecs "   编解码器 注册 和 相关 基类
3.9   新版 功能 .
一个二维 矢量 类 ， 用来 作为 实现 海龟 绘图 的 辅助 类
" collections . abc . Sized "   的 别名
如果 这个 迭代 器 消耗 完毕 ， 就 用   " popleft ( ) "   将 其 从 对列 中移 去 ； 否则 ， 就 通过   " rotate ( ) "   将 它 移到 队列 的 末尾
如果   Future   已 取消   ， 方法 会 引发 一个   " CancelledError "   异常
返回 从 数字 或 字符串   x   生成 的 浮点数
对于 整数 ， 结果 和   " ( a   / /   b ,   a   %   b ) "   一致
SHAKE   算法 不 限制 最大 长度
输入 编码 应当 是   UTF   8   ，   UTF   16   或者   UTF   32
" HTTPException "   的 一个 子类
3.7   新版 功能 .
PEP   371 :   多任务处理 包 .
如 你 所见 ， 我们 可以 把 配置 解析器 当作 一个 字典 来 处理
如果 其值 为 零 ， 则 会 等待 直到   " release ( ) "   并 调用 并 返回   " True "
" namespace "   将 由   " parse _ args ( ) "   返回 的   " Namespace "   对象
在   3.2   版 更改 :   允许 使用 字符串 作为   indent   而 不再 仅仅 是 整数
它 是 仅 有 的 存储状态 ， 可以 被 修改
如果 不 希望 如此 ， 可 考虑 改用   " heappushpop ( ) "
作为   decorator   :   使用 :
从   iterable   所 定义 的 数据 集中 返回 前   n   个 最大 元素 组成 的 列表
虽然 他们 没有 在 下面 列出 ， 这个 模块 仍然 支持 Python   2 . x 系列 的 这个 模块 下以   " camelCase "   （ 驼峰 法 ） 命名 的 方法 和 函数
如果 数组 为 空则   initializer   会 被 省略 ， 否则 如果   typecode   为   " ' u ' "   则 它 是 一个 字符串 ， 否则 它 是 一个 数字 列表
文件 类 对象 可以 像 普通 文件 一样 在   " with "   语句 中 使用
为   " PyObject _ NewVar ( ) "   所 分配 对象 重新 调整 大小
mview   必须 是 一个   memoryview   实例
bpo   40979 :   重构   typing . rst ， 将 超过   70   个类 、 函数 和 装饰 器 组织 至 新 的 子 小节
" chunk "   读取   IFF   分块 数据
其 主要 缺点 在于   pidfds   是   Linux   专属 的   ， 并且 仅 在 较 近 版本 的 核心 （ 5.3 + ） 上 可用
binary   file   二进制 文件   file   object   能够 读写 字节 类 对象
" await "   " start _ server ( ) "   启动 TCP 服务
对于 仅 有 ASCII 编码 的 模块 名 ， 函数 必须 是   " PyInit _ < modulename > "   ， 将   " < modulename > "   替换 为 模块 的 名字
一个 演示 如何 使用   " _ ignore _ "   属性 的 例子 :
obj   参数 必须 支持 单段 字符 缓冲 接口
首先 我们 设置 文本 为 以 换行符 结尾 的 单行 字符串 构成 的 序列 （ 这样 的 序列 也 可以 通过 文件 类 对象 的   " readlines ( ) "   方法 来 获取 ） ：
修改 此 字典 不会 影响 由   " execv ( ) " ,   " popen ( ) "   或   " system ( ) "   所 传入 的 字符串 环境 ； 如果 你 需要 修改 环境 ， 请 将   " environ "   传给   " execve ( ) "   或者 为   " system ( ) "   或   " popen ( ) "   的 命令 字符串 添加 变量 赋值 和   export   语句
这 类似 于   " now ( ) " ， 但 返回 的 是 当前   UTC   日期 和 时间 ， 类型 为 简单 型   " datetime "   对象
" pickle "   Python   对象 序列化
在 本例 中 ， " Vector "   和   " list [ float ] "   将 被 视为 可 互换 的 同义词 ：
argument   是 包含 有   action   的 位置 参数 的 序列
" tkinter . PhotoImage "   类 现在 具有   " transparency _ get ( ) "   和   " transparency _ set ( ) "   方法
一旦 被 唤醒 ，   " wait ( ) "   方法 重新 获取 锁 并 返回
3.3   新版 功能 :   该 模块 曾 是   " collections "   模块 的 组成部分
该 算法 与   ZIP   文件 校验 和 一致
新 的 编码 为 ：
此 模块 提供 了   Unix   shell   风格 的 通配符 ， 它们 并 不 等同于 正则表达式 （ 关于 后者 的 文档 参见   " re "   模块 ）
如果 省略   buffer _ size   则 使用 默认 的   " DEFAULT _ BUFFER _ SIZE "
此 方法 仅 保留 用作 向下兼容 ， 应 避免 在 新 代码 中 使用
3.8   新版 功能 :   strict _ timestamps   仅限 关键字 参数
删除   MAX _ PATH   限制
参数 :   stampid   一个 整型 数 ， 必须 是 之前   " stamp ( ) "   调用 的 返回值
在   3.8   版 更改 :   如果 可用 将 使用   " __ index __ ( ) "
属性   含义   " A _ ALTCHARSET "   备用 字符集 模式   " A _ BLINK "   闪烁 模式   " A _ BOLD "   粗体 模式   " A _ DIM "   暗淡 模式   " A _ INVIS "   不 可见 或 空白 模式   " A _ ITALIC "   斜体 模式   " A _ NORMAL "   正常 属性   " A _ PROTECT "   保护模式   " A _ REVERSE "   反转 背景色 和 前景色   " A _ STANDOUT "   突出 模式   " A _ UNDERLINE "   下划线 模式   " A _ HORIZONTAL "   水平 突出 显示   " A _ LEFT "   左高亮   " A _ LOW "   底部 高亮   " A _ RIGHT "   右高亮   " A _ TOP "   顶部 高亮   " A _ VERTICAL "   垂直 突出 显示   " A _ CHARTEXT "   用于 提取 字符 的 位 掩码
仅限   Windows ： 此 函数 是 一个 允许 使用   ctypes   实现 进程 内   COM   服务 的 钩子
在   3.4   版 更改 :   当 方法 被 调用 的 时候 ， 方法 返回 是   " None "   而 不是   " NotImplemented "
可 选 参数   map01   不是   " None "   时   ， 它 的 值 指定   1   的 映射 目标   ( I   或   l ) ， 当   map01   非   " None "   时 ，   0   总是 被 映射 为   O
表达式 语句 用于 计算 和 写入 值 （ 大多 是 在 交互 模式 下 ） ， 或者 （ 通常 情况 ） 调用 一个 过程   ( 过程 就是 不 返回 有 意义 结果 的 函数 ； 在   Python   中 ， 过程 的 返回值 为   " None " )
类似 地 ， 如果   str   开头 和 结尾 都 是 尖角 括号 ， 这 对 尖角 括号 会 被 去除
包含 该 可 调用 对象 的 模块 将 被 导入 ， 随后 该 可 调用 对象 将 由   " sys . breakpointhook ( ) "   的 默认 实现 来 运行 ， 后者 自身 将 由 内置 的   " breakpoint ( ) "   来 调用
这样 的 命令 将 被 隐藏 直到 别名 被 移除
" sequence3 "   会 对 每个   " sequence1 "   和   " sequence2 "   的 元素 对 开始 遍历
adobe   控制 输入 序列 是否 为   Adobe   Ascii85   格式   ( 即 附加   < ~   和   ~ > )
在   3.8   版 更改 :   " exists ( ) " 、 " lexists ( ) " 、 " isdir ( ) " 、 " isfile ( ) " 、   " islink ( ) "   和   " ismount ( ) "   现在 遇到 系统 层面 上 不可 表示 的 字符 或 字节 的 路径 时 ， 会 返回   " False " ， 而 不是 抛出 异常
由于 帮助 字符串 支持   %   formatting ， 如果 你 希望 在 帮助 字符串 中 显示   " % "   字 面值 ， 你 必须 将 其 转义 为   " %% "
" collections . abc "   容器 的 抽象 基类
参见 依赖于 具体 平台 的 高效 拷贝 操作 一节
在 函数 以外 ， 局部 作用域 将 引用 与 全局 作用域 相一致 的 命名 空间 ： 模块 的 命名 空间
一种 是 使用 冻结 工具 ， 它 包含 在 Python 源代码 树   " Tools / freeze "   中
如果   " eq "   和   " frozen "   都 是   true ， 默认 情况 下   " dataclass ( ) "   将 为 你 生成 一个   " __ hash __ ( ) "   方法
Python   2.1   有 什么 新 变化
提升 这些 类型 对象 引用 计数 的 操作 已 从   " PyType _ GenericAlloc ( ) "   移至 更 低 层级 的 函数   " PyObject _ Init ( ) "   和   " PyObject _ INIT ( ) "
" encodings . idna "   模块 还 实现 了   nameprep   过程 ， 该 过程 会 对 主机名 执行 特定 的 规范化 操作 ， 以 实现 国际域名 的 大小写 不 敏感 特性 与 合并 相似 的 字符
如果 生成器 引发 任何 其他 异常 ， 它会 被 传播 给 调用者
增加 了   " PyFrame _ GetCode ( ) "   函数 ： 获取 帧 代码
返回 一个 指向 可 写 内存地址 的 指针
此 特性 可以 减少 反 斜杠 的 使用 ， 以 方便 地 将 很长 的 字符串 分成 多个 物理 行 ， 甚至 每 部分 字符串 还 可 分别 加 注释 ， 例如 :
这里 有 一个 很小 但 很 现实 的 例子 :
此 例程 注册 回调
返回 一个 元素   " ( bits ,   linkage ) " ， 其中 包含 可执行文件 所 使用 的 位 架构 和 链接 格式 信息
例如   " err . object [ err . start : err . end ] "   会 给出 导致 编解码器 失败 的 特定 无效 输入
" loop . add _ reader ( ) "   和   " loop . add _ writer ( ) "   只 接受 套 接字 处理 回调 函数 (   如 管道 、 文件 描述符 等 都 不 支持 )
如果 操作系统 提供 随机 源 ， 则 使用 它们 而 不是 系统 时间 （ 有关 可用性 的 详细信息 ， 请参阅   " os . urandom ( ) "   函数 ）
它们 只能 包含   ASCII   字符 ； 字节 对应 数值 在 128 及 以上 必须 以 转义 形式 来 表示
nargs   命令行 参数 应当 消耗 的 数目
执行 完成 后 ， Shell   将 保留 焦点 并 显示 提示
如果 函数 失败 ， 则 引发 一个   " OSError "   异常
在   3.5   版 更改 :   添加 了 可选 的   key   和   reverse   形参
3.8   新版 功能 .
它们 都 使用 特定 领域 的 语言 ， 允许 用户 编写 脚本 ， 其中 ：
此 模块 中 其他 异常 的 基类
" strftime "   " strptime "   用法   根据 给定 的 格式 将 对象 转换 为 字符串   将 字符串 解析 为 给定 相应 格式 的   " datetime "   对象   方法 类型   实例 方法   类 方法   方法   " date " ;   " datetime " ;   " time "   " datetime "   签名   " strftime ( format ) "   " strptime ( date _ string ,   format ) "
此 行为 由 下列 处理程序 属性 控制 :
（ 由   Josh   Rosenberg   在   bpo   35712   中 贡献 。 ）
如果   s   被 不 正确 地 填写 ， 一个   " binascii . Error "   错误 将 被 抛出
timeout   单位 为 秒 （ 一般 为 浮点数 ） ， 默认 为   " None " ， 即 永不 超时
例如 ， 如果 一个 分隔 点落 在 两个 样本 值   " 100 "   和   " 112 "   之间 距离 三分之一 的 位置 ， 则 分隔 点 的 取值 将 为   " 104 "
也 可以 嵌套 列表   ( 创建 包含 其他 列表 的 列表 ) ,   比如说 :
" multiprocessing . SimpleQueue "   类 新增 了   " close ( ) "   方法 用来 显式 地 关闭 队列
返回 与 函数 对象   op   关联 的 代码 对象
参数 :   angle   一个 数值   ( 可 选 )
日志 记录 级别 的 数值 在 下表中 给出
当未 设置   " __ file __ "   时 也 可以 设置   " __ cached __ "
如果   path   指向 的   " 现有 "   目录 条目 是 一个 符号 链接 ， 则 返回   " True "
另外 ，   stderr   可设 为   " STDOUT " ， 表示 应用程序 的 标准 错误 数据 应 和 标准 输出 一同 捕获
经过   uuencoded   编码 的 文件 将 具有 指定   name   和   mode   作为 解码 该 文件 默认 结果 的 标头
3.9   新版 功能 :   向下 移植 到   3.7   和   3.8
注意 ， 这个 装饰 器会 影响   PEP   412   键 共享 字典 的 操作
Python   程序 也 可以 通过   " raise "   语句 显式 地 引发 异常
在   3.7   版 更改 :   实现 了 递归 反汇编 并 添加 了   depth   参数
对象 就 像是 颗 小 胶囊 ， 包裹 着 内部 状态 和 随之而来 的 能 让 你 修改 这个 内部 状态 的 一组 调用 方法 ， 以及 由 正确 的 状态 变化 所 构成 的 程序
本 函数 实现 了 标准 的   " . mo "   文件 搜索算法
假设 您 有 一个 对象   " x "   并且 想要 改变 其中 一个 方法 的 行为
文件 现在 禁止 继承
在 大多数 时候 你 只 需要   " tkinter "   就 足够 了 ， 但 也 有 一些 额外 的 模块 可供使用
子类 应 确保 从 重写 的   " close ( ) "   方法 中 调用 此 方法
在   3.5   版 更改 :   Added   support   for   the   context   management   protocol   to   the   " FieldStorage "   class .
如果 你 想 学习 更 多   Python ， 看看   Beginner ' s   Guide   to   Python .
每个 子 解释器 现在 都 拥有 它们 自己 的 调用 日程 列表
如果   divisor   为空 ， 这个 方法 返回 零 并 设置   " errno "   为   " EDOM "
" BufferedIOBase "   在   " IOBase "   的 现有 成员 以外 还 提供 或 重载 了 下列 数据 属性 和 方法 :
在 运行 时 ， 语句   " Derived   NewType ( ' Derived ' ， Base ) "   将   " Derived "   设 为 一个 函数 ， 该 函数 立即 返回 您 传递 它 的 任何 参数
比如 ， 大写字母   A   的 字形 ， 是 斜 向 的 两笔 和 水平 的 一笔 ， 而 具体 的 细节 取决于 所 使用 的 字体
在   3.1 . 3   版 更改 :   " MANIFEST "   files   start   with   a   comment   indicating   they   are   generated
具体 示例 参见 示例
因此 ， 一个 完整 的 线程 实现 需要 对 C 的 线程 支持
在   Python   编解码器 注册表 中 查找 编解码器 信息 ， 并 返回 一个   " CodecInfo "   对象 ， 其 定义 见下文
" ' store _ const ' "   动作 通常 用 在 选项 中来 指定 一些 标志
参考   " threading "   模块 的 文档
如果   numeric _ owner   为   " True " ， 则 将 使用 来自   tarfile   的   uid   和   gid   数值 来 设置 被 提取 文件 的 所有者 / 用户组
类型 构造 器   " list ( seq ) "   可 将 任意 序列 或 可 迭代 对象 转换 为 具有 相同 排列 顺序 的 相同 条 目的 列表
值 必须 属于 受 支持 的 类型
在   3.6   版 更改 :   dir   参数 现在 可 接受 一个 路径 类 对象   (   path   like   object   )
3.4   版后 已 移除 :   使用   " exec _ module ( ) "   来 代替
filemode   如果 指定 了   filename   ， 则 用 此 模式 打开 该 文件
在   3.6   版 更改 :   允许 在 字 面值 中 使用 下划线 进行 分组
在   3.4   版 更改 :   Added   support   for   24   bit   samples .
使用   " from   future _ builtins   import   map "   禁用 这个 修复器
" EnumMeta "   元类 负责 提供   " __ contains __ ( ) " ,   " __ dir __ ( ) " ,   " __ iter __ ( ) "   及其 他 方法 以 允许 用户 通过   " Enum "   类来 完成 一般 类 做 不到 的 事情 ， 例如   list ( Color )   或   some _ enum _ var   in   Color
此 架构 支持 用户 定义 对象 作为 处理程序 、 过滤器 和 格式化 器
平均值 以及 对 中心 位置 的 评估
" PyTypeObject "   的 实例 代表 一个   Python   元组 类型 ， 这 与   Python   层面 的   " tuple "   是 相同 的 对象
如果   d   为 感知 型 ，   d   会 通过 减去   " d . utcoffset ( ) "   来 标准化 为   UTC   时间 ， 并 返回 该 标准化 时间 所 对应 的   " time . struct _ time "
如果 你 要 分发 一组 模块 ， 特别 是 它们 不 在 特定 的 包中 ， 你 可以 在 配置 脚本 中 使用   " py _ modules "   选项 单独 指定 它们
对于 一次性 解压缩 ， 请 改用   " decompress ( ) "   函数
操作 在 传输 端点 上不受 支持
在   3.2   版 更改 :   在 之前 的   " configparser "   版本 中 行为 匹配   " strict   False "
举个 例子 ， 这样 的 代码 块 ：
设置 垃圾 回收 器 的 调试 标识 位
如果   newline   是   " ' ' "   或   " ' \ n ' " ， 则 不 进行 翻译
如果 你 想要 编写 可 包含 于   CPython   的   C   代码 ， 你 必须 遵循 在   PEP   7   中 定义 的 指导 原则 和 标准
" update _ wrapper ( ) "   可以 与 函数 之外 的 可 调用 对象 一同 使用
请 注意   " ' @ ' "   和   " '   ' "   之间 的 区别 ： 两个 都 使用 本 机 字节 顺序 ， 但 后者 的 大小 和 对齐 方式 是 标准化 的
依次 查询 过滤器 ， 直到 其中 一个 返回 假值 为止
如果 为   " True " ， 则 忽略 定界符 之后 的 空格
此种 对象 适用 于 实现 队列 和 广度 优先 树 搜索 :
3.1   新版 功能 .
" ' r   xz ' "   打开 一个   lzma   压缩   stream   用于 读取
当 需要 再次 调试 时 ， 只 需要 改变 日志 记录器 或 处理器 的 过滤 等级 即可
在   Windows   上 ，   args   序列 会 被 转换 为 可 使用 以下 规则 来 解析 的 字符串 （ 对应 于   MS   C   运行 时所 使用 的 规则 ） :
NumPy   风格 ： 形状 和 步幅
由于 赋值 只是 创建 了 对象 的 引用 ， 因此 在 调用者 和 被 调用者 的 参数 名称 之间 没有 别名 ， 所以 本身 是 没有 按 引用 调用 的
3.4   新版 功能 .
3.9   版后 已 移除 :   " builtins . tuple "   now   supports   " [ ] "
如果 带有 行号 ， 则 继续 运行 ， 直到 行号 大于 或 等于 该行 号 时 停止
此 函数 会 “ 窃取 ” 对   o   的 引用 ， 并 丢弃 对 元组 中 已 在 受 影响 位置 的 条 目的 引用
不幸 的 是 ， 这 是 不 安全 的 ， 因为 在 调用   " mktemp ( ) "   与 随后 尝试 创建 文件 的 进程 之间 的 时间 里 ， 其他 进程 可能 会 使用 该 名称 创建 文件
构建 和   C   API   的 改变
解释器 实例 将会 识别 命令 名称   " foo "   当且 仅 当 它 有 方法   " do _ foo ( ) "
UTF   8   是 一种   8   位 编码 ， 这 意味着 在   UTF   8   中 没有 字节 顺序 问题
工作日 的   CSS   类 在 上个月 或 下个月 发生
target   是 由   " run ( ) "   方法 调用 的 可 调用 对象
数字 值 在 存储 时会 将 最低 位 字节 放在 开头
文本 与 二进制 数据
通知 日志 记录 系统 在 实例 化 日志 记录器 时 使用   klass   类
在   3.9   版 更改 :   If   the   timeout   parameter   is   set   to   be   zero ,   it   will   raise   a   " ValueError "   to   prevent   the   creation   of   a   non   blocking   socket .
For   porting   C   extensions   to   Python   3.0 ,   please   see   将 扩展 模块 移植 到   Python   3 .
在   3.3   版 更改 :
3.8   新版 功能 .
更 令人费解 的 是 ， 在 其他 配置 相同 的   Windows   系统 上   ， Python   却 可以 工作 得 很 好
"   . pyd "   文件 和   DLL   文件 相同 吗 ？
名称 在 最高 层级 命名 内 的 解析 是 通过 全局 命名 空间 ， 也 就是 包含 该 代码 块 的 模块 的 命名 空间 ， 以及 内置 命名 空间 即   " builtins "   模块 的 命名 空间
在   3.3   版 更改 :   曾经 是   " IOError "   被 引发 而 不是   " OSError "
（ 由   Raymond   Hettinger   提议 ， 由   Dong   hee   Na   实现 ， 并 由   Vinay   Sajip   在   bpo   33897   中 完成 审核 。 ）
garbage   collection   垃圾 回收 释放 不再 被 使用 的 内存空间 的 过程
" Logger . addFilter ( ) "   和   " Logger . removeFilter ( ) "   可以 添加 或 移除 记录器 对象 中 的 过滤器
用 Python 编写 的 应用程序 并不一定 要求 用户 了解 这一 事实
帮助 消息 将 不 包括 父 解析器 或 同级 解析器 的 消息
在   3.7   版 更改 :   " setup "   now   warns   when   " classifiers " ,   " keywords "   or   " platforms "   fields   are   not   specified   as   a   list   or   a   string .
就 地 实现   " TOS   TOS1   +   TOS "
Proxy   对象 不是   hashable   对象 ， 无论 被 引用 对象 是否 可 哈希 ； 这 可 避免 与 它们 的 基本 可变 性质 相关 的 多种 问题 ， 并 可 防止 它们 被 用作 字典 键
在   3.4   版 更改 :   Updated   to   take   advantage   of   the   module   spec   feature   added   by   PEP   451
（ 可以 使用 类 定义 自己 的 对象 类型 和 方法 ， 请参阅 类   ） 示例 中 的 方法   " append ( ) "   是 为 列表 对象 定义 的 ； 它会 在 列表 的 最后 添加 一个 新 的 元素
这是 一个 标志 ， 默认 为   true
生成 的   " __ init __ ( ) "   代码 将 调用 一个 名为   " __ post _ init __ ( ) "   的 方法 ， 如果 在 类 上 已经 定义 了   " __ post _ init __ ( ) "
在   3.3   版 更改 :   Updated   to   be   based   directly   on   " importlib "   rather   than   relying   on   the   package   internal   PEP   302   import   emulation .
指明 一个 新 进程 不会 继承 调用 方 进程 的 错误模式 的   " Popen "   " creationflags "   形参
返回 一个 元组 的 迭代 器 ， 其中 的 第   i   个 元组 包含 来自 每个 参数 序列 或 可 迭代 对象 的 第   i   个 元素
如果 异步 生成器 没有 产生 下 一个 值 就 退出 ， 则 将 由 该 可 等待 对象 引发   " StopAsyncIteration "   异步
在   Unicode   中 ， 支持 某些 字符 ， 这些 字符 通常 与 其他 字符 统一
两个 字符串 的 元组 ： 第一个 是 本地 非 DST 时区 的 名称 ， 第二个 是 本地 DST 时区 的 名称
该值 项 不 可以 是   " None " ， 同时 键 也 不 可以 有 子项
对于 这种 使用 场景 ， 日志 包 提供 了   " RotatingFileHandler " :
将   data   分隔 为 具有 相等 概率 的   n   个 连续 区间
" a   irshift ( a ,   b ) "   等价 于   " a   > >   b "
钩 方法 只 在 命令 调度 完成 后 执行
用   " quantize ( ) "   方法 舍入 到 固定 数量 的 十进制 位
它 可以 做 如下 事情 ：
迭代 器 生成 一系列   " Instruction "   ， 命名 为 元组 ， 提供 所 提供 代码 中 每个 操作 的 详细信息
默认值 为   " False "
如 不 指定 任何 矩阵 元素 ， 则 返回 以 4 元素 元组 表示 的 变形 矩阵
可用性   ：   Windows 、   Linux 、   Unix   系统 支持   " CLOCK _ THREAD _ CPUTIME _ ID "
" pass "   是 一个 空 操作 当 它 被 执行 时 ， 什么 都 不 发生
如果   new   为   2 ， 则 尽可能 打开 新 的 浏览器 页面 （ “ 标签   ” ）
context   和   numlines   均 是 可选 关键字 参数
这 将 忽略 注册表 和 环境变量 中 列出 的 路径 ， 并 忽略   " site "   ， 除非 列出   " import   site "
adpcmfrag   是   ADPCM   编码 的 片段 ， 每个 字节 打包 了   2   个   4   比特 值
Python   3.9   是 最后 一个 提供 这些   Python   2   向下兼容 层 的 版本 ， 以 给予   Python   项目 维护者 更 多 时间 来 组织 移除   Python   2   支持 并 添加   Python   3.9   支持
这会 使用 条 目的 名称 ： 目录 应当 总是 以   " / "   结尾
阅读 本 教程 可能 会 增强 您 对 使用 Python 的 兴趣 您 应该 热衷于 应用 Python 来 解决 您 的 实际 问题
每个 实例 都 有 一个 名称 ， 它们 在 概念 上 以点 （ 句点 ） 作为 分隔符 排列 在 命名 空间 的 层次结构 中
在   3.3   版 更改 :   从 工厂 函数 变为 类
这 类似 于 在线 程 局部 存储 中 每个 执行 线程 可以 具有 不同 的 变量值
将 SQLite   值 转换 为 自定义 Python   类型
运算符   " < " ,   " > " ,   "   " ,   " >   " ,   " <   "   和   " !   "   将 比较 两个 对象 的 值
如果   " finally "   子句 执行 了   " return " ,   " break "   或   " continue "   语句 ， 则 被 保存 的 异常 会 被 丢弃 :
" typing "   类型 标注 支持
" % w "   十进制 数   [ 0 ( 星期日 ) , 6 ]   表示 的 周 中日
此 变量 如果 被 设为 一个 非空 字符串 ， 它 就 相当于 指定   "   u "   选项
返回 上下文 对象 中 的 所有 变量 的 列表
" debuglevel "   会 被 传给 任何 新创建 的   " HTTPResponse "   对象
返回 一个   " NTEventLogHandler "   类 的 新 实例
关闭 关闭 当前 窗口 （ 如果 未 保存 则 询问 ）
（ 由   Batuhan   Taskaya   在   bpo   39638   中 贡献 。 ）
通常 有 四种 形式
此 模块 提供 了 使用   bzip2   压缩算法 压缩 和 解压 数据 的 一套 完整 的 接口
类型 标注 可 被 用于 第三方 工具   ， 比如 类型 检查 器 、 集成 开发 环境 、 静态 检查 器 等
如果 栈 信息 可用 ， 它 将 被 添加 在 异常 信息 之后 ， 如 有 必要 请 使用   " formatStack ( ) "   来 转换 它
别名 会 递归 地 应用 到 命令行 的 第一个 单词 ； 行内 的 其他 单词 不会 受 影响
" timeit "   测量 小 代码 片段 的 执行 时间
此类 方法 可 构造 一个   " Fraction "   来 表示   flt   的 精确 值 ， 该 参数 必须 是 一个   " float "
索引   值   " 0 "   Year   ( >   1980 )   " 1 "   月 （ 1 为 基数 ）   " 2 "   月份 中 的 日期 （ 1 为 基数 ）   " 3 "   小时 （ 0 为 基数 ）   " 4 "   分钟 （ 0 为 基数 ）   " 5 "   秒 （ 0 为 基数 ）
这些 信息 在   " parse _ args ( ) "   调用 时 被 存储 和 使用
当 直接 应用 于   " multipart / related "   时 ， 将 返回 包含 除根 部分 之外 所有 相关 部分 的 迭代 器 （ 即 由   " start "   形参所 指向 的 部分 ， 或者 当 没有   " start "   形参 或   " start "   形参 不能 匹配 任何 部分 的   Content   ID   时则 为 第一 部分 ）
（ 由   Serhiy   Storchaka   在   bpo   22578   中 贡献 。 ）
" BZ2File "   还 提供 了 以下 方法 ：
kwargs   是 目标 调用 的 关键字 参数 字典
一般来说 你 的 代码 应该 没有 必要 “ 知道 ” 特定 值 的 名称
在 此 情况 下 ， 用户 自定义 类型 可 通过 提供   " __ class _ getitem __ ( ) "   类 方法 来 支持 抽取 操作
此 旗标 是 与   " S _ ISGID "   共享 的 ： 文件 / 记录 锁定 会 针对 未 设置 分组 执行 位   ( " S _ IXGRP " )   的 文件 强制执行
返回   o   的 按位 取反 后 的 结果 ， 如果 失败 ， 返回   " NULL "
preexec _ fn   ,   pass _ fds   ,   cwd   和   start _ new _ session   形参未 设置   ；
在   3.9   版 更改 :   如果 所有权 重均 为 负值 则 将 引发   " ValueError "
一元 算术 和 位 运算
特定 于   Mac   OS   X   的 更改 ： Mac   OS   X
等价 于   Python   表达式   "   o "
在   3.2   版 更改 :   raw   ,   vars   和   fallback   都 是 仅限 关键字 参数 ，   以 防止 用户 试图 使用 第三个 参数 作业 为   fallback   回退 值 （ 特别 是 在 使用 映射 协议 的 时候 ）
更 多 时候 ， 构建 一个 扩展 会 复杂 的 多 ， 需要 额外 的 预 处理器 定义 和 库
构建 和   C   API   的 改变
3.2   新版 功能 .
结果 错误 吗 ？
成功 时 返回 结果 ， 在 失败 时 抛出 一个 异常 并 返回   NULL
（ 由   Serhiy   Storchaka   在   bpo   31860   中 贡献 。 ）
" BadZipFile "   的 别名 ， 与 旧版本   Python   保持 兼容性
同样 ， 哪怕 只有 很小 的 可能 ， 遇到 说 不同 语言 的 人 阅读 或 维护 代码 ， 也 不要 在 标识符 中 使用 非 ASCII 字符
用于   PYTHON   2.0   的   BEOPEN . COM   许可 协议
是否 启用 行 缓冲
代理 对象 代理 了 指涉 对象 的 一系列 方法 调用 ( 虽然 并 不是 指涉 对象 的 每个 方法 都 有 必要 被 代理 )
当 某些 属性 既 需要 读取 又 需要 设置 时 ， 类 还 必须 定义   " __ setattr __ ( ) "   方法 ， 并且 这样 做 必须 小心谨慎
此 方法 将 返回 起始 键
返回   x   的 副本 ， 符号 设 为   0
对于 更 进阶 的 用例 ， 也 可以 使用 底层 的   " Popen "   接口
元组 的 第一项 是 字段名 称 ， 第二项 指明 字 段 类型 ； 它 可以 是 任何   ctypes   数据类型
在   3.9   版 更改 :   Slots   in   " PyBufferProcs "   in   may   be   set   in   the   unlimited   API .
Python   现在 可以 针对   Windows   10   ARM64   进行 编译
定义 在 文件 中 起始 位置 的 行号
" xml . dom . minidom "   不会 扩展 外部 实体 ， 只是 简单 地 返回 未 扩展 的 实体
name   可以 为 任意 类型 的 文件 （ 目录 、 fifo   、 符号 链接 等等 ）
一个 使用 内在 字节 缓冲区 的 二进制 流
引发 一个 审计 事件   " winreg . ConnectRegistry " ， 附带 参数   " computer _ name " ,   " key "
在 C 中 调用 Python 函数
如果 要求 更 多 输入 则 返回值 为   " True " ， 如果 行已 按 某种 方式 被 处理 则 返回值 为   " False "   ( 这 与   " runsource ( ) "   相同 )
内置 函数   " help ( ) "   会 发起 调用 交互式 解释器 的 在线 帮助 系统 ， 该 系统 使用   " pydoc "   在 终端 上 生成 文本 形式 的 文档 内容
使用   19   个形 参将会 相当 繁琐
上述 模块 层级 的 便捷 函数 均 委托 给 根 日志 记录器 ， 它们 会 调用   " basicConfig ( ) "   以 确保 至少 有 一个 处理程序 可用
但是 ， 在 调用   " func "   时 ， 例如 ：
还有 下面 这些 属性 可用 ， 他们 的 名称 以 下划线 开头 ， 以 避免 和 导出 函数 重名 :
跨平台 兼容性 注释 :   由于 非   UNIX   平台 上 文本编辑 器 本身 的 特性 ， 在 一个 源文件 中 混合 使用 制表符 和 空格符 是 不明智 的
reverse   参数 仍然 保持 排序 稳定性 （ 因此 具有 相等 键 的 记录 保留 原始 顺序 ）
3.6   版后 已 移除 :   It   is   deprecated   to   create   a   " SSLSocket "   instance   directly ,   use   " SSLContext . wrap _ socket ( ) "   to   wrap   a   socket .
在   3.2   版 更改 :   添加 了 对 thread . lock ， threading . Lock 和 代码 对象 的 支持
语句   " import   spam . ham "   的 结果 将 为 以下 调用 :
在   3.2   版 更改 :   在 之前 的 版本 中 ， 不 允许 关键字 参数 ， 并且 要求 必须 有   ident
因此 返回 的 字节 对象 的 长度 是   data   的 两倍
" dbm "   Unix   " 数据库 "   接口
默认 情况 下   ， 使用   " time . localtime ( ) "   ； 要 为 特定 格式化 程序 实例 更改 此项 ， 请 将 实例 的   " converter "   属性 设置 为 具有 相同 签名 的 函数   " time . localtime ( ) "   或   " time . gmtime ( ) "
如果 一个 默认 值域 必须 跟 其他 没有 默认值 的 域 在 一起 出现 ，   defaults   就 应用 到 最 右边 的 参数
" doctest "   和   " unittest "   这 两个 模块 包含 了 用于 编写 单元测试 的 框架 ， 并 可 用于 自动测试 所 编写 的 代码 ， 验证 预期 的 输出 是否 产生
3.3   新版 功能 .
仅限 位置 形参 可 通过 在 函数 定义 的 形参 列表 中 它们 之后 包含 一个   " / "   字符 来 定义 ， 例如 下面 的   posonly1   和   posonly2   :
要 获取 格式 指令 的 完整 列表 ， 请参阅   strftime ( )   和   strptime ( )   的 行为
3.5   新版 功能 :   命令行 选项   "   locals "
因此 ， 实现 多任务 协作 的 首选 方法 是 将 所有 对 资源 的 请求 集中 到 一个 线程 中 ， 然后 使用   " queue "   模块 向 该 线程 供应 来自 其他 线程 的 请求
从   Python   3.4   开始 ， " __ del __ ( ) "   方法 不会 再 阻止 循环 引用 被 作为 垃圾 回收 ，   并且 模块 全局变量 在   interpreter   shutdown   期间 不会 被 强制 设 为   " None "
导入 解析 默认 使用 内置 的   " __ import __ ( ) "   函数 来 执行 导入
默认 情况 下 ， 当 发出   " continue "   命令 时 ， Pdb   将 为   SIGINT   信号 设置 一个 处理程序 （ SIGINT   信号 是 用户 在 控制台 按   " Ctrl   C "   时 发出 的 ）
如果   visit   返回 非零值 ， 则 该值 应当 被 立即 返回
" ZoneInfo "   的   " repr "   是 由 具体 实现 定义 的 并且 不 一定 会 在 不同 版本 间 保持稳定 ， 但 它 保证 不会 是 一个 有效 的   " ZoneInfo "   键
这种 情况 适合 定义 一个 空类 :
虽然 头字 段 的 存储 和 获取 都 是 保留 其 原始 大小写 的 ， 但是 字段名 的 匹配 是 大小写 不 敏感 的
将   " os . getcwdu ( ) "   重命名 为   " os . getcwd ( ) "
基本上 所有 这些 西方 和 许许多多 其他 的 配方 都 可以 通过   Python   Package   Index   上 的   more   itertools   项目 来 安装 :
" ' store _ true ' "   and   " ' store _ false ' "   这些 是   " ' store _ const ' "   分别 用作 存储   " True "   和   " False "   值 的 特殊 用例
" zip ( iterA ,   iterB ,   ... ) "   从 每个 可 迭代 对象 中 选取 单个 元素 组成 列表 并 返回 :
TZ   搜索 路径 也 可 在 运行 时 使用   " reset _ tzpath ( ) "   函数 来 配置
（ 要 知道 当 重新 加载 一个 模块 的 时候 ， 那些 属性 某 部分 可以 改变 ） ：
设置   " Future "   关联 工作 的 结果 给   " Exception "   exception
" dircmp "   类如   " filecmp . cmp ( ) "   中 所 描述 的 那样 对 文件 进行   shallow   比较
阻塞 函数 （   " Lock . acquire ( ) " ,   " RLock . acquire ( ) " ,   " Condition . wait ( ) " ,   ... ） 中形 参   timeout   允许 的 最大值
要 避免 这种 情况 ， 这些 类 需要 在 实例 撤销 分配 期间 在 类型 对象 上 调用   Py _ DECREF
（   请参阅 安装   Python   模块 指南 以 了解   " pip "   的 完整 文档 。 ）
现在 ， 在 左 递归 规则 中 检查 错误 ， 以 避免 此类 错误 没有 得到 及时处理 ， 并 在 其他 地方 出现 长距离 崩溃 的 情况
add   " True "   或   " False "   如为   " True "   则 将 添加 一个 新 绑定   ， 否则 将 取代 先前 的 绑定
如果   address   是   " None "   , 则 允许 和 任意 主机 的 请求 建立 连接
以下 示例 与 我们 之前 的 正则 看起来 相同 ， 但 省略 了 正则 字符串 前面 的   " ' r ' "
如果 想仅 接受 长 选项 ， 则   shortopts   应为 一个 空 字符串
（ 由   Joannah   Nanjekye   在   bpo   36475   中 贡献 。 ）
所有 的 异常 ， "   "   和   " !   "   ，   都 是 抽象 的
在   3.6   版 更改 :   接受 一个 类 路径 对象 用于   path   和   paths
3.6   版后 已 移除 :   OpenSSL   has   deprecated   all   version   specific   protocols
简单 用法 ： 检查 Docstrings 中 的 示例
这个 标记 表示 一个 Python 函数 的 执行 已经 开始
模块 命名 空间 中 的 名称 重新 指向 任何 新 的 或 更改 后 的 对象
注意 ： 要 创建 一个 空集合 你 只能 用   " set ( ) "   而 不能 用   " { } " ， 因为 后者 是 创建 一个 空 字典 ， 这种 数据结构 我们 会 在 下 一节 进行 讨论
3.9   版后 已 移除 :   " collections . abc . ValuesView "   now   supports   " [ ] "
默认 算法 将   " DEBUG " ,   " INFO " ,   " WARNING " ,   " ERROR "   和   " CRITICAL "   映射 到 等价 的   syslog   名称 ， 并 将 所有 其他 级别 名称 映射 到   ' warning '
返回 小于 给定 操作数 的 上下文 中 可 表示 的 最大 数字 （ 或者 当前 线程 的 上下文 中 的 可 表示 的 最大 数字 如果 没有 给定 上下文 ）
返回值   used _ key   与   " get _ value ( ) "   的   key   形参 具有 相同 的 含义
返回 定义 字体 的 名字
返回 函数 对象   op   的 参数 默认值
3.3   新版 功能 .
3.4   新版 功能 .
"   s "   指定   " sort _ stats ( ) "   排序 值 之一 以 对 输出 进行 排序
多个 宏 和 函数 的 实现 细节 现在 已 被 隐藏 :
" COMPARE _ OP "   用于 富 比较
3.5   新版 功能 .
PyTypeObject   的   " tp _ print "   空位 已 被 移除
例如   " splitdrive ( " / / host / computer / dir " ) "   返回   " ( " / / host / computer " ,   " / dir " ) "
字母 大小写 都 可以 ， 例如 ， “ inf ” 、 “ Inf ” 、 “ INFINITY ” 、 “ iNfINity ”   都 可以 表示 正 无穷大
此 函数 对于 递归 对象 总是 返回   " False "
文件 是 压缩 存储 的 （ Mac   OS   X   10.6 + ）
返回   " Field "   对象 的 元组 ， 用于 定义 此 数据 类 的 字 段
当待 执行 的   future   对象 完成 执行 后 向 执行者 发送 信号 ， 它 就 会 释放 正在 使用 的 任何 资源
此 类型 并 不 被   C   编译器 广泛支持 ： 在 一台 典型 的 机器 上 ， 可以 使用   unsigned   short   进行 存储 ， 但 不会 被 用于 数学 运算
此 函数 通常 会 在 需要 使用 自定义 日志 记录器 行为 的 应用程序 实例 化 任何 日志 记录器 之前 被 调用
现在 推导 式 中 的   " for   y   in   [ expr ] "   会 与 简单 赋值 语句   " y   expr "   一样 快速
3.1   新版 功能 .
返回 参数 的 平方根 精确 到 完整 精度
将 信号   signal   发送给 子 进程
" modulo "   必须 不为 零且 至多 有   ' precision '   位
如果 该值 为 一个 整数 ， 它 将 被 原样 传递
通常 是   " c _ byte "   的 一个 别名
原始 的 包 规格 说明 仍然 可以 查阅 ， 但 在 撰写 该 文档 之后 许多 相关 细节 已 被 修改
创建 一个 共享 的   " list "   对象 并 返回 它 的 代理
另 请参阅   " total _ ordering ( ) "   装饰 器
指示 此 记录器 是否 将 处理 级别 为   level   的 消息
key   一个 字符串 :   键   ( 例如   " a " )   或键标   ( 例如   " space " )
此 方法 在 接收 到 数据 前 将 一直 阻塞
sinfo :   与   " traceback . print _ stack ( ) "   所 提供 的 类似 的 栈 回溯 信息 ， 显示 调用 的 层级 结构
请 注意 所有 这些 函数 都 应 返回   C   " int " ， 当然 这 也 不是 绝对 的 ， 因此 你 必须 分配 正确 的   " restype "   属性 以 使用 这些 函数
参数 必须 是   " PyDateTime _ Date "   包括 其子 类   ( 例如   " PyDateTime _ DateTime " )   的 实例
这样   " tzinfo "   子类 的 方法 应当 准备 好 接受   dt   参数值 为   " None "   或是   " datetime "   类 的 实例
BZIP2   压缩 方法 的 数字 常数
面向对象 程序 会 操作 一组 对象
如果   " os . chmod   in   os . supports _ follow _ symlinks "   为   " True " ， 则   " copystat ( ) "   可以 修改 符号 链接 的 权限 位
Unix   syslog   库 例程
在 你 能 使用 你 的 新 写 的 扩展 之前 ， 你 还 需要 做 两件 事情 ： 使用   Python   系统 来 编译 和 链接
如果 为   2 ， 则 推入   " slice ( TOS1 ,   TOS ) " ； 如果 为   3 ， 则 推入   " slice ( TOS2 ,   TOS1 ,   TOS ) "
bpo   33127 :   ssl 模块 现在 使用 LibreSSL   2.7 . 1 编译
更 多 详情 参见 元类
如果 将 一个 字节 串 对象 指定 为 第一个 参数 ， 则 将 使 缓冲区 大小 比其 长度 多 一项 以便 数组 的 最后 一项 为 一个   NUL   终结符
自定义 默认 的 Python 版本
" break "   语句 ， 和   C   中 的 类似 ， 用于 跳出 最近 的   " for "   或   " while "   循环 .
（ 由   Guilherme   Polo ,   Cheryl   Sabella   和   Terry   Jan   Reedy   在   bpo   1612262   中 贡献 。 ）
当前 版本 并 不会 这样 做
为什么   " id ( ) "   的 结果 看起来 不是 唯一 的 ？
提示 ： 如果 你 想要 为 特定 的 小节 指定 默认 的 值 ， 请 在 读取 实际 文件 之前 使用   " read _ dict ( ) "
它 能 识别 正负号 :
3.6   新版 功能 .
大致 相当于 生成器 表达式 中 的 嵌套循环
如果 你 希望 有 较 小 的 日志 ，   你 必须 自行 传入 包含 你 想要 在 事件 日志 中 使用 的 消息 定义 的   . dll   或   . exe   名称 ）
需要 注意 的 是 ， 列表 的 长度 必须 为 7
3.9   新版 功能 .
此 模块 提供 了 它 实现 一种 基本 配置 语言   " ConfigParser "   类 ， 这种 语言所 提供 的 结构 与   Microsoft   Windows   INI   文件 的 类似
这些 库 可以 帮助 你 进行   Python   开发 ： 调试器 使 你 能够 逐步 执行 代码 ， 分析 堆栈 帧 并 设置 中断点 等等 ， 性能 分析器 可以 运行 代码 并 为 你 提供 执行 时间 的 详细 数据   ， 使 你 能够 找出 你 的 程序 中 的 瓶颈
将 此 模块 中 定义 的 常量 的 数值 映射 回 名称 字符串 的 字典 ， 允许 生成 更加 人类 可读 的 解析 树 表示
这 对于 将 附加 信息 关联 到 引用 的 情况 最为 适用 ， 但 也 可以 被 用于 在 调用 中 插入 额外 处理 来 提取 引用
等价 于   Python   语句   " o1   o2 "
这 允许 对 普通 的   " try " ... " except " ... " finally "   使用 模式 进行 封装 以 方便 地 重用
当 读取 到   EOF   时 ， 则 触发   " EOFError "
该 模块 定义 了 四个 词典 ，   " html5 " 、   " name2codepoint " 、   " codepoint2name " 、   以及   " entitydefs "
由于 禁用 了 陷阱 ， 此 上下文 适用 于 希望 结果 值为   " NaN "   或   " Infinity "   而 不是 引发 异常 的 应用
" B "   ( " int " )   [ unsigned   char ]   将 一个   C   " unsigned   char "   无 符号 字符 型 转化成   Python   整型 对象
" sqlite3 "   SQLite   数据库   DB   API   2.0   接口 模块
" HTMLParser "   实例 有 下列 方法 ：
3.5   新版 功能 .
如果   dnd _ accept   不 存在 或是 返回   None ， 则 将 转至父 控件 中 搜索
这个 C 类型   " PyObject "   的 子 类型 代表 一个   Python   复数 对象
bpo   41341 :   在   " get _ type _ hints "   中 对   " typing . ForwardRef "   递归 求值
prog   程序 的 名称 （ 默认 ： " sys . argv [ 0 ] " ）
字节 码 还 会 缓存 在   " . pyc "   文件 中 ， 这样 第二次 执行 同一 文件 时 速度 更 快 （ 可以 免去 将 源码 重新 编译 为 字节 码 ）
调用   " emit ( ) "   期间 遇到 异常 时 ， 应从 处理器 中 调用 此 方法
此 函数 会 设置 或 清除 底层 库 的   " rl _ completion _ display _ matches _ hook "   回调 函数
若 要 锁定 锁 ， 线程 调用 其   " acquire ( ) "   方法 ； 一旦 线程 拥有 了 锁 ， 方法 将 返回
返回 的 字符串 永远 按照   " email . utils . unquote ( ) "   方法 去除 引号
根据 流是 二进制 流 （ 产生 字节 ） 还是 文本 流 （ 产生 字符串   ） ， 行 的 定义 略有不同
" patch ( ) "   装饰 器 便于   " Mock "   对象 临时 替换 特定 模块 中 的 类
Python   语言 参考 给出 了 更 正式 的 语言 定义
许多 其他 语言 没有 这样 的 结构 ， 因此 不 熟悉   Python   的 人 有时 会 选择 使用 一个 数字 计数器 :
返回 的 行 不 包含 末尾 的 换行符
3.2   新版 功能 .
构建 和   C   API   的 改变
返回 由 十六进制 字符串   hexstr   表示 的 二进制 数据
有 一个 特殊 情况 ， 分派 始于 字符   " ' ? ' "   的 行到 方法   " do _ help ( ) "
" termios "   POSIX   风格 的   tty   控制
此 方法 可 在   " close ( ) "   之前 的 任何 时候 被 调用
3.3   新版 功能 .
3.8   新版 功能 .
默认 为   " 9 "
Since   Python   3.8 ,   " AsyncMock "   and   " MagicMock "   have   support   to   mock   异步 上下文 管理器   through   " __ aenter __ "   and   " __ aexit __ "
返回 一个 字典 ， 字典 内 含有 函数 、 方法 、 模块 或类 对象 的 类型 提示
也 可 在   https : / / docs . python . org / 3 / download . html   获取 PDF 、 纯 文本 以及 可 下载 的   HTML   版本
在   3.1   版 更改 :   添加 了 对   object _ pairs _ hook   的 支持
" encodings . utf _ 8 _ sig "   带 BOM 签名 的 UTF   8 编解码器
对于 失效 的 符号 链接 ，   也 返回   " True "
幂 运算符 与 附带 两个 参数 调用 内置   " pow ( ) "   函数 具有 相同 的 语义 ： 结果 为 对 其 左 参数 进行 其右 参数 所 指定 幂次 的 乘方 运算
在   3.6   版 更改 :   所有 的 可选 参数 现在 是   keyword   only   的 了
这 三个 变量 是   Python   中   " sys . exc _ info ( ) "   的 结果 在   C   中 的 对应物 （ 请参阅   Python   库 参考 的   " sys "   模块 部分 ）
在 最 简单 的 情况 下 ， 选项 和 它 的 值 是 作为 两个 单独 参数 传入 的 :
指针 不可 为   " NULL "
如果 为 假值 ， 超长 单词 不会 被 分开 ， 因而 某些 行 的 长度 可能 会 超过   " width "
" pass "   会 被 静默 地 忽略 :
保护 一个 可 等待 对象 防止 其 被   " 取消 "
3.8   新版 功能 .
" tkinter "   Tcl / Tk 的 Python 接口
默认 实现 仅 返回   " record .__ dict __ "
避免 混淆 已有 的 分析   import   语句 并 查找   import   的 模块 的 工具
分隔符 位置 默认 从 输出 的 右端 开始 计数 ，   如果 你 希望 从 左端 开始 计数 ， 请 提供 一个 负 的   bytes _ per _ sep   值
当 缓冲区 对于 所有 挂 起 数据 而言 太 小时 ；
当 条目 添加 到 队列 的 时候 ， 未 完成 任务 的 计数 就 会 增加
输入 参数 的 完整性检查 被 添加 到 框架 创建 中
PEP   553 :   内置 的   " breakpoint ( ) "
失败 时 返回 非零值 并 设置 一个 异常
我们 刚刚 引入 了 又 一个 新 的 关键字   " default "
可能 的 值 列表 如下
3.5 . 4   新版 功能 .
" stringprep "   配置 的 一个 例子 是   " nameprep " ， 它 被 用于 国际化 域名
添加 另外 两行 :
不 返回   " ClassVar "   或   " InitVar "   的 伪字段
在   3.2   版 更改 :   " . pdbrc "   现在 可以 包含 继续 调试 的 命令 ， 如   " continue "   或   " next "
返回 一个 子 窗口 ， 其 左上角 位于   " ( begin _ y ,   begin _ x ) " ， 并且 其 宽度 / 高度 为   ncols   /   nlines
这里 的 格式 说明符 微 语言 与   " str . format ( ) "   方法 所 使用 的 微 语言 一致
下列 函数 会 在 行 缓冲区 上 操作
这 对于   WAVE   音频文件 是 必须 的
[ 1 ]   存在 一个 例外
当 一个 对象 的 引用 计数 降 为 零时 ， 所 分配资源 将 被 释放
有 许多 可 选择 的 教程 和 书籍
当 一个   generator   或   coroutine   被 关闭 时 将 被 引发 ； 参见   " generator . close ( ) "   和   " coroutine . close ( ) "
此外 ， " Fraction "   还 具有 以下 属性 和 方法 ：
如果 省略   buffer _ size   则 使用 默认 的   " DEFAULT _ BUFFER _ SIZE "
其他 图形用户界面 （ GUI ） 包
了解 它们 对于 理解 错误 的 传递 方式 是 非常 重要 的
所有 内置 的   Python   异常 都 有 对应 的 预 声明   C   对象 ， 例如   " PyExc _ ZeroDivisionError " ， 你 可以 直接 使用 它们
一些 不 遵循 标准 的 消息 在 其 内部 关于 它 是否 为   multipart   类型 前后 不 一
PEP   492   使用   async   和   await   语法 实现 协程
key   :   用于 密钥 哈希 的 密钥 （ 对于   BLAKE2b   最长   64   字节 ， 对于   BLAKE2s   最长   32   字节 ）
与 单个 XML 元素 及其 子 元素 的 交互 是 在   " Element "   级别 完成 的
为 给定 的   encoding   获取 一个   " StreamWriter "   工厂 函数
key   指定 带有 单个 参数 的   key   function   ， 用于 从 每个 输入 元素 中 提取 比较 键
返回 一对   " ( n ,   d ) "   整数 ， 表示 给定 的   " Decimal "   实例 作为 分数 、 最简 形式 项 并 带有 正 分母 :
顶级 非 对象 ， 非 数组 值
类似 于   " sorted ( itertools . chain (   iterables ) ) "   但 返回 一个 可 迭代 对象 ，   不会 一次性 地 将 数据 全部 放入 内存 ， 并 假定 每个 输入 流都 是 已 排序 的 （ 从小到大 ）
本章 中 描述 的 模块 实现 了 加密 性质 的 各种 算法
" add _ argument ( ) "   的   " type "   关键词 参数 允许 任何 的 类型 检查和 类型转换
当   exec _ module ( )   被 实现 的 时候 ， 导入 机制 关心 的 是   load _ module ( )   所有 其他 的 责任
表达式 将 从 左 至 右 被 求值
在 之前 版本 中   " continue "   语句 不 允许 在   " finally "   子句 中 使用 ， 这 是因为 具体 实现 存在 一个 问题
3.5   新版 功能 .
返回 包含 这 两个 信息 的 一个 元组   ； 如若 解析 失败 ， 则 返回 一个二元 组   " ( ' ' ,   ' ' ) "
要 使用 这个 模块 ， 必须 先 创建 一个   " Connection "   对象 ， 它 代表 数据库
3.8   新版 功能 :   请参阅   PEP   572   了解 有关 赋值 表达式 的 详情
Python   2.5   有 什么 新 变化
将 环境变量   " TERM "   的 值 截短 至   14   个 字节 ， 作为 字节 串 对象 返回
特别 地 ， 包含 在 提供 给 内置   " exec ( ) "   函数 字符串 或 代码 对象 中 的   " global "   语句 并 不会 影响 包含 该 函数调用 的 代码 块 ， 而 包含 在 这种 字符串 中 的 代码 也 不会 受到 包含 该 函数调用 的 代码 中 的   " global "   语句 影响
例如 ， 你 可能 希望 起始 在 函数 中 记录 调试 事件 ， 如果 函数 执行 完成 且 没有 错误 ， 你 不 希望 输出 收集 的 调试信息 以 避免 造成 日志 混乱 ， 但 如果 出现 错误 ， 那么 你 希望 所有 调试 以及 错误 消息 被 输出
future   语句 在 编译 时会 被 识别 并 做 特殊 对待 ： 对 核心 构造 语义 的 改变 常常 是 通过 生成 不同 的 代码 来 实现
返回   a   和   b   按位 或 的 结果
和 其他 编程语言 相比 ， Python   用 非常少 的 新 语法 和 语义 将类 加入 到 语言 中
为 编号 是   bpnumber   的 断点 指定 一系列 命令
" ' w : bz2 ' "   打开 用于   bzip2   压缩 的 写入
如果 有 第二个 实参   sentinel   ， 那么   object   必须 是 可 调用 的 对象
返回 之前 在 名称   name   之下 注册 的 错误处理 方案
默认 情况 下 ， 会 使用 当前 区域 的 编码 格式   ( 参见   " locale . getpreferredencoding ( ) " )
要 避免 任务   " 取消 " ， 可以 加上   " shield ( ) "
创建 记住 键值 最后 插入 顺序 的 有序 字典 变体 很 简单
注意 ，   " logging "   模块 本身 并 没有 使用 进程 间 共享 的 锁 ， 所以 来自 于 多个 进程 的 日志 可能 （ 具体 取决于 使用 的 日志   handler   类型 ） 相互 覆盖 或者 混杂
如果 将 此 环境变量 设为 非空 字符串 ， 则 启用   Python   开发 模式 ， 引入 在 默认 情况 下 启用 会 导致 开销 过大 的 运行 时 检查
内置 的 配置 对应 以下 的   turtle . cfg :
Emin   和   Emax   字 段 给定 指数 所 允许 的 外部 上限
此 模块 中 的 功能 可能 无法 处理 纪元 之前 或 将来 的 远期 日期 和 时间
在   3.3   版 更改 :   返回 一个   " io . BufferedReader "   对象
这 是 为 保持 与 规范 描述 的 兼容性 而 加入 的
如果   “ ob ”   是 一个 引用 或者 一个 代理 对象 ， 则 返回 一个   true
如果   " tzinfo "   为   " None " ， 则 返回   " None " ， 否则 返回   " self . tzinfo . dst ( self ) " ， 并且 在 后者 不 返回   " None "   或者 一个 幅度 小于 一天 的   " timedelta "   对象 时 将 引发 异常
日志 （ 从   3.2   开始 ） 为 这 两种 格式化 方式 提供 了 更 多 支持
" configparser "   配置文件 解析器
这一 章节 详细 介绍 了   " set "   和   " frozenset "   对象 的 公共   API
Python   具有   ' with '   语句 ， 它 能 将 一个 代码 块 的 执行 包装 起来 ， 在 进入 和 退出 代码 块 时 调用 特定 的 代码
3.2   新版 功能 .
已弃 用 的   Python   模块 、 函数 和 方法
如果   stdin _ read   发出   EOF   信号 则 控制 终端 就 不能 再 与 父 进程 或子 进程 进行 通信
返回 具有 指定   hour ,   minute ,   second ,   microsecond   和   fold   属性 的   " datetime . time "   对象
转换 为 字符串 ， 如果 需要 指数 则 会 使用 工程 标注 法
3.6 . 1   版后 已 移除 :   如果   " Py _ LIMITED _ API "   设置 为 小于   " 0x03050400 "   或   " 0x03060000 "   与   " 0x03060100 "   之间 的 值 （ 不 包括 边界 ） 则   " PySlice _ GetIndicesEx ( ) "   为 已弃 用 的 函数
仅 支持   Linux   Kernel   4.5   或 更 高 版本
而 一个   Task   对象 会 等待 一个   Future   对象 完成 ， 该 事件 循环 会 运行 其他   Task 、   回调 或 执行   IO   操作
当然 ， 它 必须 是 数字 、 字符串 或者 二进制 字符串 :
PEP   343 :   " with "   语句
说明 页面 将 记录 任何 具体 问题 ， 并 提供 所有 函数 、 属性 以及 可用   " ACS _   "   字符 的 完整 列表
其他 库 模块 可以 提供 额外 的 方式 来 创建 文本 或 二进制 流
如果 字符串 中有 单引号 而 没有 双引号 ， 该 字符串 外将加 双引号 来 表示 ， 否则 就加 单引号
混合 了 非   " Enum "   类型 （ 例如   " int " ,   " str "   等 ） 的   " Enum "   成员 会 按 所 混合 类型 的 规则 被 求值 ； 在 其他 情况 下 ， 所有 成员 都 将 被 求值 为   " True "
这是   " FORMAT _ ALONE "   和   " FORMAT _ RAW "   的 默认值 （ 也 是 唯一 可 接受 的 值 ）
在   3.7   版 更改 :   Added   the   "   invalidation   mode "   option .
指令   意义   示例   注释   " % a "   当地 工作日 的 缩写
使用 整数 相当 简洁 方便 （ 并 由   Functional   API   默认 提供 ） ， 但 并 不 强制 要求 使用
冻结   gc   所 跟踪 的 所有 对象   — —   将 它们 移至 永久 代并 忽略 所有 未来 的 集合
列表 方法 示例 ：
对 Python   语言 核心 进行 的 小 改动 ：
（ 如果   " cProfile "   在 您 的 系统 上 不可 用 ， 请 使用   " profile "   。 ）
如果 省略 了   imag   ， 则 默认值 为 零 ， 构造函数 会 像   " int "   和   " float "   一样 进行 数值 转换
" SelectSelector "   只 被 用于 等待 套 接字 事件 ： 它 支持 套 接字 且 最 多 支持 512 个套 接字
请 记住 ， 使用   " from   package   import   specific _ submodule "   没有 任何 问题 ！   实际上 ， 除非 导入 的 模块 需要 使用 来自 不同 包 的 同 名子 模块 ， 否则 这是 推荐 的 表示法
此 方法 不 执行 任何 操作
使用   " with "   语句 的 同一个 示例 :
默认 文件名 为   " ~ / . history "
如果   wait   为   " True "   则 此 方法 只有 在 所有 待 执行 的   future   对象 完成 执行 且 释放 已 分配 的 资源 后 才 会 返回
只读 属性 按照 将要 运行 的 顺序 返回 即将 发生 的 事件 列表
虽然 人们 在 其他 应用 中 嵌入   Python   的 做法 早已有之 ， 但 嵌入   Python   的 过程 没有 编写 扩展 模块 那样 方便 直观
如果 发生 溢出 ， 较长 的 采样 将 被 截断
假定 人群 的 偏好 没有 发生 改变 ， 那么   Python   演讲 的 会议厅 不 超出 其 容量 上限 的 可能性 是 多少 ？
与   " clock _ settime ( ) "   相似 ， 但 设置 时间 为 纳秒
" rlcompeleter "   通过 补全 有效 的   Python   标识符 和 关键字 定义 了 一个 适用 于   " readline "   模块 的 补全 函数
将   Unicode   代码 点 映射 到   HTML   实体 名称 的 字典
一个 小 众 市场 是 在 不 运行   X   server   的 小型 或 嵌入式   Unix   上
内存 会 被 初始化 为 零
把 颜色 从 HLS 值 转为 RGB 值
使用   key   作为 键 将   val   插入 到 字典   p
要 了解 如何 处理 形状 请 参看   Screen   方法   " register _ shape ( ) "
在   3.3   版 更改 :   " OSError "   is   raised   instead   of   " IOError " ,   now   an   alias   of   the   former .
（ 由   Anthony   Sottile   在   bpo   36264   中 贡献 。 ）
舍入 选项 包括   " ROUND _ CEILING "   、   " ROUND _ DOWN "   、   " ROUND _ FLOOR "   、   " ROUND _ HALF _ DOWN " ,   " ROUND _ HALF _ EVEN "   、   " ROUND _ HALF _ UP "   、   " ROUND _ UP "   以及   " ROUND _ 05UP " .
嵌套   JSON   对象 和 数组 的 最高 水平
" email . message " :   表示 一 封电子邮件 信息
在   Unix   和   Windows   上 ， 将 参数 中 开头 部分 的   " ~ "   或   " ~ user "   替换 为 当前 用户 的 家 目录 并 返回
如果 参数 列表 有 问题 ，   " PyArg _ ParseTuple ( ) "   函数 通常 会 引发   " PyExc _ TypeError "
仅限   Windows   only ： 返回 的 函数 原型 会 创建 使用   " stdcall "   调用 约定 的 函数 ， 但 在   Windows   CE   上   " WINFUNCTYPE ( ) "   则 会 与   " CFUNCTYPE ( ) "   相同
3.7   新版 功能 .
const   被 一些   action   和   nargs   选择 所 需求 的 常数
此 函数 会 迭代   msg   的 所有 子 部分 ， 只 返回 其中 与   maintype   和   subtype   所 指定 的   MIME   类型 相匹配 的 子 部分
应当 重 写成 这样 ：
类似 的 ， 如果   full ( )   返回   " False "   也 不 保证 后续 调用 的   put ( )   不 被 阻塞
许多 程序 可能 只 需要 这 一个 窗口 ， 但 你 可能 希望 把 屏幕 分割 为 多个 更 小 的 窗口 ， 来 分别 重绘 或者 清除 它们
format   控制 用于 写入 的 归档 格式
distutils   的   " bdist _ msi "   命令 现在 已 被 弃用 ， 请 改用   " bdist _ wheel "   ( wheel   包 )
标头 的 字 段 为 ：
" binhex "   对 binhex4 文件 进行 编码 和 解码
这 在 错误 返回值 校验 和 自动 抛出 异常 等 方面 比较 有用
此 方法 作为 一个 钩子 提供 ， 允许 子类 修改 将 对象 转换 为 字符串 的 方式
返回 一个 字典 ， 其 元素 为   key   到   value   的 映射 使得   " match ( key ,   mapname )   value "
结合 位置 参数 和 可选 参数
3.9   新版 功能 .
它们 应当 使用 高 加密 强度 的 单向 （ 不可 恢复 ） 哈希 函数 来 加盐 并 生成 哈希 值
这些 类型 的 对象 支持 通过   " pickle "   模块 进行 高效 的 封存
每个 实体 多次 引用 另 一个 实体 ， 最终 实体 定义 包含 一个 小 字符串
在   3.2   版 更改 :   允许 使用 字符串 作为   indent   而 不再 仅仅 是 整数
改变 了 的 Python   API
当 海龟 转向 时 图像 形状 不会 转动 ， 因此 无法 显示 海龟 的 朝向 !
替换 标准 导入 系统
object   也 是 任何   new   style   class   的 最 顶层 基类 名
被 分配 的 内存空间 预留 了   TYPE   结构 加   type   对象 中   " tp _ itemsize "   字 段 提供 的   size   字段 的 值
如何 找到 未定义 的 g ++ 符号 __ builtin _ new 或 __ pure _ virtual ？
通常 你 可以 重新 组织 已有 的 函数 来 组成 新 的 程序 ， 然后 为 当前 的 工作 写 一些 特殊 的 函数
这个 模块 提供 了 一个 装饰 器 和 一些 函数 ， 用于 自动 添加 生成 的   special   method   s   ， 例如   " __ init __ ( ) "   和   " __ repr __ ( ) "   到 用户 定义 的 类
哈希 按 其 地址 （ 对象 ID ） 列出
这 允许 应用程序 生成   URL   或 文件系统 安全 的   Base64   字符串
如果 元 路径 查找 器 知道 如何 处理 指定 名称 的 模块 ， 它 将 返回 一个 说明 对象
返回 一个   " RotatingFileHandler "   类 的 新 实例
确定   code   是否 属于   tableC.2 . 1   ( ASCII   控制字符 )
在   3.4   版 更改 :   " pydoc "   现在 会 使用   " inspect . signature ( ) "   而 非   " inspect . getfullargspec ( ) "   来 从 可 调用 对象 中 提取 签名 信息
元素 会 按 首次 出现 的 顺序 返回
用以 节约 高 开销 或 I / O 函数 的 调用 时间
" struct "   将 字节 串 解读 为 打包 的 二进制 数据
如果   ndigits   被 省略 或 为   " None " ， 则 返回 最 接近 输入 值 的 整数
举例来说   ， reST   文档 中 类似   doctests   的 示例 也 可以 使用 这个 选项 进行 重构
（ 请 注意 ， 省略 启动器 也 会 省略 文件 关联 ， 并且 仅 在 全局 安装 包含 启动器 时才 建议 用于 每 用户 安装 。 ）
Python   3.5 . 4   的 显著 变化
如果   domain   为   " None " ， 则 返回 当前 的 全局 域   ， 不 为   " None "   则 将 全局 域 设置 为   domain   ， 并 返回 它
对于   switch 语句 语法 已经 有 了 一些 建议 ， 但 尚未 就 是否 以及 如何 进行 范围 测试 达成 共识
setuptools   （ 在 很大 程序 上 ） 是 作为   " distutils "   的 取代 者 ， 于   2004   年 首次 发布
3.2   新版 功能 .
内存 块 被   " 禁止 字节 "   包围 （   " FORBIDDENBYTE "   ： 字节   " 0xFD "   ）
使用   " subprocess "   模块 替换 旧 函数
C   变量 也 可 被 声明 为   " PyObject   "   类型
对于 定义 了   " __ contains __ ( ) "   方法 的 用户 自定义 类 来说 ， 如果   " y .__ contains __ ( x ) "   返回 真值 则   " x   in   y "   返回   " True " ， 否则 返回   " False "
要 将 对象 设为 可 拖放 ， 你 必须 为 其 创建 启动 拖放 进程 的 事件 绑定
如果   delay   为 真值 ， 则 会 将 文件 打开 延迟 到 首次 调用   " emit ( ) "   的 时候
prefix   、   suffix   和   dir   的 含义 与 它们 在   " mkstemp ( ) "   中 的 相同
正常 工作 ， 但是 以下 代码
3.3   新版 功能 .
这个 类 提供 了 一些 可以 读取 、 解析 和 回答 关于   url   上 的   " robots . txt "   文件 的 问题 的 方法
RFC   要求 使用   UTF   8   ，   UTF   16   ， 或   UTF   32   之一 来 表示   JSON   ， 为了 最大 互通性 推荐 使用   UTF   8
这里 有 一个   Python   2 . x   的 源码 文件 ， " example . py " ：
与   " ' e ' "   相似 ， 不同之处 在于 它 使用 大写字母   ' E '   作为 分隔 字符
在   3.3   版 更改 :   增加 了   handlers   参数
（ 由   Lum í r   ' Frenzy '   Balhar   在   bpo   40495   中 贡献 。 ）
在   Python   3.8   中 这种 情况 会 更少 发生
命名 元组 尤其 有 用于 赋值   " csv "   " sqlite3 "   模块 返回 的 元组
" profile "   和   " cProfile "   模块 参考
" parse _ args ( ) "   方法 在 此会 谨慎 行事 ： 位置 参数 只有 在 它们 看起来 像 负数 并且 解析器 中 没有 任何 选项 看起来 像 负数 时 才能 以   "   "   打头
3.8   新版 功能 .
" curses "   终端 字符 单元 显示 的 处理
终结 器 也 可以 被 直接 调用
请参阅   " setLogRecordFactory ( ) "   了解 有关 如何 调用 该 工厂 方法 的 更 多 信息
非 数据 描述 器为 把 函数 绑定 为 方法 的 通常 模式 提供 了 一种 简单 的 机制
如果 指定 的 值 为   " True " ， 配置 会 按照 增量 配置 部分 所 描述 的 方式 来 处理
每个 模块 都 有 它 自己 的 私有 符号表 ， 该表 用作 模块 中 定义 的 所有 函数 的 全局 符号表
asyncio :   在 各 Transport 类中 添加 了   set _ protocol   /   get _ protocol   方法
另 一个 有用 的 资源 是   MacPython   wiki   ：
举个 例子 ， 假设   " foo "   和   " bar "   模块 属于   " foobar "   包 ， 排布 源文件 树 的 一种 方式 是 ：
虽然 直接 使用   " distutils "   正在 逐步 淘汰 ， 但 它 仍然 为 当前 的 打包 和 分发 基础架构 奠定 了 基础 它 不仅 仍然 是 标准 库 的 一部分 ， 而且 它 的 名称 还 以 其他 方式 存在   （ 例如 用于 协调 Python 包装 标准 开发 的 邮件 列表 的 名称 ）
fromfile _ prefix _ chars   当 需要 从文件 中 读取 其他 参数 时 ， 用于 标识 文件名 的 前缀 字符 集合 （ 默认值 ： " None " ）
返回 窗口 高度 和 宽度 的 元组   " ( y ,   x ) "
" collections "   模块 中 抽象 基类 的 别名 ， 例如   " collections . abc . Mapping "   的 别名   " collections . Mapping "   会为 向下兼容 最后 保留 一个 发行版
因为 在   CPython 中 ， 这是 对象 的 内存地址 ， 所以 经常 发生 在 从 内存 中 删除 对象 之后 ， 下 一个 新创建 的 对象 被 分配 在 内存 中 的 相同 位置
如果   newline   具有 任何 其他 合法 的 值 ， 则 输入 行将 仅 由 给定 的 字符串 结束 ， 并且 行 结束符 会不加 转写 即 返回 给 调用者
在 文件 的 顶部 导入 模块
可变性 是 一个 复杂 的 属性 ， 取决于 程序员 的 意图 ，   " __ eq __ ( ) "   的 存在 性 和 行为 ， 以及   " dataclass ( ) "   装饰 器中   " eq "   和   " frozen "   标志 的 值
Python   标准 库 非常 庞大 ， 所 提供 的 组件 涉及 范围 十分 广泛 ， 正如 以下内容 目录 所 显示 的
在   3.9   版 更改 :   增加 了   encoding   和   errors   参数
在 等待   I / O   操作 时 能够 处理   Tk   事件 吗 ？
它们 目前 有着 相同 的 主 菜单 ， 但是 默认 标题 和 上下文 菜单 不同
此 函数 可能 会 打开 大量 的 文件 ， 因为 确定 时 区 路径 上 某个 文件 是否 为 有效 时区 的 最佳 方式 是 读取 开头 位置 的 “ 魔术 字符串 ”
Python   API   的 变化
所有 这些 编程 环境 都 提供 语法 高亮 ， 自动 缩进 以及 在 编写 代码 时 使用 交互式 解释器 等 功能
但是 当 第   2   个 模块 想 从 第   1   个 模块 中 获取 一个 名称   ( " from   module   import   name " )   并且 导入 位于 顶层 时 ， 就 会 出错
此 方法 的 参数 可以 是 任何 遵循 序列 规则 的 对象 ， 包括 您 自己 定义 的 任何 新 的 类
注意 打印 时 关键字 参数 的 顺序 保证 与 调用函数 时 提供 它们 的 顺序 是 相匹配 的
3.4   新版 功能 .
交互式 编辑 和 编辑 历史
随后 此 修改 将 应用 于 放置 到 该 窗口 中 的 每个 字符
In   addition   to   the   following   quick   reference ,   the   例子   section   provides   at   a   glance   insight   into   the   meaning   and   use   of   " PyTypeObject " .
当 没有 可用 行时 将 返回 一个 空 列表
每个 可 调用 对象 或是 返回 可 处理 路径 条 目的   path   entry   finder   ， 或是 引发   " ImportError "
" curses "   模块 定义 了 以下 函数 ：
指明 一个 新 进程 不会 关联 到 任务 的   " Popen "   " creationflags "   形参
需要 注意 的 是 ， 调用   " __ hash __ ( ) "   和   " __ eq __ ( ) "   方法 产生 的 异常 不会 被 抛出
正如 你 所 期望 的 那样 ， 还有 一个 模块 级   " re . split ( ) "   函数
足够 复杂 或是 巨大 的 字符串 可能 导致 Python 解释器 的 崩溃 ， 因为 Python 的   AST 编译器 是 有 栈 深 限制 的
" ctime ( ) "   不会 使用 区域 设置 信息
输出 字符串 将 并 不 包括 时 区 信息 ， 无论 输入 的 是 感知 型 还是 简单 型
" fast   copy "   意味着 拷贝 操作 将 发生 于 内核 之中 ， 避免 像 在   " " outfd . write ( infd . read ( ) ) " "   中 那样 使用 用户 空间 的 缓冲区
" tty "   终端 控制 功能
请 不要 在 此 函数 中 使用   " stdout   PIPE "   或   " stderr   PIPE "
最先 搜索 的 最 内部 作用域 包含 局部 名称
PEP   302   新 导入 钩子
这 可能 会 造成 问题 ， 因为 因特网 和 大多数   Unix   系统 包括   WSL   ( Windows   Subsystem   for   Linux )   广泛 使用   UTF   8
类似 于   " DICT _ UPDATE "   但 对于 重复 的 键会 引发 异常
" argparse "   将会 确保 互斥 组中 只有 一个 参数 在 命令行 中 可用 :
返回 一个 对应 于   " date . isoformat ( ) "   和   " datetime . isoformat ( ) "   所 提供 的 某 一种   date _ string   的   " datetime "   对象
" abstractmethod ( ) "   可 被 用于 声明 特性 属性 和 描述 器 的 抽象 方法
解析器 层级 默认值 在 需要 多 解析器 时会 特别 有用
"   X   dev "   选项 现在 在   " io . IOBase "   析构 函数 中 记录   " close ( ) "   异常
参数 必须 是   " PyDateTime _ Delta "   包括 其子 类 的 实例
Unicode   对象 都 被 通过   " ' utf   8 ' "   编码 转化成   C   字符串
" nargs "   命名 参数 关联 不同 数目 的 命令行 参数 到 单一 动作
把 它 看作 是 销毁 旧 元组 并 创建 一个 新元 组 ， 只会 更 有效
该 方法 返回 一个 形似   " parseaddr ( ) "   返回 的 二元 组 的 列表
当 使用   " pickle "   在   Python   进程 间 传输 大量 数据 以 充分发挥 多核 或 多 机处理 的 优势 时 ， 非常 重要 一点 是 通过 减少 内存 拷贝 来 优化 传输 效率 ， 并 可能 应用 一些 定制 技巧 例如 针对 特定 数据 的 压缩
Sun   音频 硬件 等 使用 该 编码
此 字典 具有 以下 字符串 作为 键 ：
于   " EmailMessage "   对象 而言 ，   requote   参数 已 被 弃用
如果 模块 具有   " __ spec __ "   属性 ， 其中 的 规格 信息 会 被 用来 生成   repr
默认 状态 下 ， 相当于   " int ( num _ str ) "
可以 出现 在   future   语句 之前 行 只有 :
从   Content   Type   头字 段 中 完全 移 去 给定 的 参数
引发 一个 审计 事件   " ctypes . dlsym " ， 附带 参数   " library " ,   " name "
已弃 用 的 函数 和 变量
类似 于   " escape ( ) " ， 但 还 会 对   data   进行 处理 以 将 其 用作 属性 值
浮点数 和 小 数值 可用 的 表示 类型 有 ：
当 启用 调试 时 ， 要 执行 的 命令 会 被 打印 出来 ， 并且 会 给予 终端   " set   x "   命令 以 输出 更 详细 的 信息
什么 是 负数 序号 ？
Mac   OS   X   返回 ：
完整 的 签名 为 :
查找 器 的 任务 是 确定 是否 能 使用 其 所知 的 策略 找到 该 名称 的 模块
" ' mtime ' "   ( 必 选项 ) :   一个 表示 源码 修改 时间 的 整数 或 浮点数 ；
终结 和 内存 释放
有些 时候 （ 例如 ： 使用   parents ） ， 重写 旧 的 有 相同 选项 字符串 的 参数 会 更 有用
bpo   35502 :   修复 了 构建 树未 完成 的 情况 下   " xml . etree . ElementTree . TreeBuilder "   中 的 引用 泄漏 （ 特别 是 在 解析   XML   期间 引发 错误 的 时候 ）
写入 给定 的   bytes   like   object   b   ， 并 返回 写入 的 字节数   ( 总是 等于   b   的 字节 长度 ， 因为 如果 写入 失败 则 会 引发   " OSError " )
通常 称作 “ 平均数 ” ， 尽管 它 指示 诸多 数学 平均数 之一
当 类似   " [ ( 10 ,   20 )   ( 30 ,   40 ) ] "   这样 在 代码 中少 了 一个 逗号 时 ， 编译器 将 显示   " SyntaxWarning "   并 附带 更 有 帮助 的 提示
现在   " POP3 "   和   " POP3 _ SSL "   当 它们 的 构造 器所 给定 的 超时 参数 为 零以 防止 创建 非 阻塞 套 接字 时会 引发   " ValueError "
" GetoptError "   的 别名 ； 用于 向 后 兼容
在 所有 符合   POSIX   标准 的 平台 上 ， 闰秒 都 会 从 总 秒数 中 被 扣除
获取 子 进程 监视器 对象
不 推荐 重新 加载 " " sys " ， " __ main __ " ， " builtins "   和 其它 关键 模块
在   3.6   版 更改 :   " type "   的 子类 如果 未 重载   " type .__ new __ " ， 将 不再 能 使用 一个 参数 的 形式 来 获取 对象 的 类型
返回 参数 的 绝对值
提供 多次 撤销 操作 、 Python   语法 高亮 、 智能 缩进 、 函数调用 提示 、 自动 补全 等 功能 的 多窗口 文本编辑 器
新增 了   " Turtle . shearfactor ( ) " ,   " Turtle . shapetransform ( ) "   和   " Turtle . get _ shapepoly ( ) "   方法
这 与   Python   在 字符串 文字 中 用于 相同 目的 的 相同 字符 的 使用 相冲突
（ 由   Nadeem   Vawda   在   bpo   5863   中 贡献 。 ）
用于   PYTHON   3.9 . 0   的   PSF   许可 协议
See   section   教程   for   an   example .
这些 安装程序 主要 用于 每个 用户 单独 安装 Python 时 ， 添加 核心 解释器 和 库
" traceback "   打印 或 检索 堆栈 回溯
最终用户 通常 不 希望   " 1.1   +   2.2 "   如 二进制 浮点数 表示 那样 被 显示 为   " 3.3000000000000003 "
此 函数 会 猜测 各种 简单 数据库 模块 中 的 哪 一个 是 可用 的   " dbm . gnu " ,   " dbm . ndbm "   还是   " dbm . dumb "   应该 被 用来 打开 给定 的 文件
类 提供 了 一种 组合 数据 和 功能 的 方法
asynchronous   iterable   异步 可 迭代 对象 可 在   " async   for "   语句 中 被 使用 的 对象
关键字 参数   :   在 函数调用 中 前面 带有 标识符 （ 例如   " name   " ） 或者 作为 包含 在 前面 带有   "   "   的 字典 里 的 值 传入
附带 参数 运行 命令
将 字 段 的 数组 嵌入 到 相同 的 内存 分配 中 可以 减少 内存 分配 的 次数 ， 这 提高 了 内存 分配 的 效率
在   3.8   版 更改 :   添加 了 可选 的   initial   形参
在   3.5   版 更改 :   an   error   is   raised   for   invalid   keys .
如果 路径 条目 不 存在 于 缓存 中 ， 基于 路径 的 查找 器会 迭代   " sys . path _ hooks "   中 的 每个 可 调用 对象
编写 函数 式 风格 程序 时 ， 你 会 经常 需要 很小 的 函数 ， 作为 谓词 函数 或者 以 某种 方式 来 组合 元素
3.4   版后 已 移除 :   使用   " find _ spec ( ) "   来 代替
" Server "   额外 拥有 一个   " address "   属性
3.3   新版 功能 .
在 最新 版本 的   Windows   中 ， 此 限制 可 被 扩展 到 大约   32 , 000   个字符
解码   Base32   编码 过 的   bytes   like   object   或   ASCII   字符串   s   并 返回 解码 过 的   " bytes "
如果 你 没有 使用   " with "   关键字 ， 那么 你 应该 调用   " f . close ( ) "   来 关闭 文件 并 立即 释放 它 使用 的 所有 系统资源
如果 当前 上下文 引用 了   zip   文件 内 的 一个 文件 或 目录 则 返回   " True "
" getpass "   便携式 密码 输入 工具
这个 模块 提供 许多 强大 而 灵活 的 功能
相当于   " del   a [ : ] "
" Py _ UNICODE _ strlen " :   使用   " PyUnicode _ GetLength ( ) "   或   " PyUnicode _ GET _ LENGTH "
创建 并 返回 一个 新 的 事件 循环 对象
调用   " ContextVar . get ( ) "   时 ， 如果 上下文 中 没有 找到 此 变量 的 值 ， 则 返回 可选 的 仅 命名 参数   default
（ 函数 一旦 定义 其 参数 默认值 就 会 被 计算 ； 因此 ， 当 列表 或 字典 这 类 可变 对象 被 用作 默认值 时 ， 将会 被 所有 未指定 相应 空位 参数值 的 调用 所 共享 ； 这种 情况 通常 应当 避免 。 ）   如果 任何 一个 未 填充 空位 没有 指定 默认值 ， 则 会 引发   " TypeError "   异常
致力于 提供 比 Python 库 参考 帮助 更 详尽 的 文档
请 注意 出现 在 行尾 的 空格 与 制表符 总是 会 被 编码 ， 具体 描述 见   RFC   1521
参数 :   pen   一个 包含 部分 或 全部 下列 键 的 字典
如果 样本 大小 大于 总体 大小 ， 则 引发   " ValueError "
如果 什么 都 没 发生 ，   或是 回显 了   " ^ P " ， 说明 不 支持 行 编辑 ； 你 只能 用 退格 键 从 当前 行中 删除 字符
类 属性 可 被 用作 实例 属性 的 默认值 ， 但 在 此 场景 下 使用 可变 值 可能 导致 未 预期 的 结果
当 在 写入 数据 时 使用   " surrogateescape "   错误 处理程序 时 ， 这些 私有 代码 点将 被 转 回到 相同 的 字节 中
活动 代码 （ 包括 从 导入 值 初始化 的 全局变量 ）
将 产生 如下 输出 （ 注意 最 开始 的 换行 没有 包括 进来 ） :
在   C   中 ， 你 可以 将 一个 类型 强制 转换 为 另 一个
" s   "   ( " str "   or   bytes   like   object   )   [ Py _ buffer ]   这个 表达式 既 接受   Unicode   对象 也 接受 类 字节 类型 对象
在   3.2   版 更改 :   Allow   the   use   of   named   arguments .
css   为 层叠 样式表 的 名字
如果 方法 失败 ， 则 引发 一个   " OSError "   异常
bpo   34080 :   修复 了 编译器 在 标记 化 过程 中 引发 一些 不 常见 错误 时 内存 泄漏 的 问题
这个 例子 匹配 单词   " section "   后 跟 一个 用   " { " ， " } "   括 起来 的 字符串 ， 并 将   " section "   改为   " subsection "
另见   Tim   Peters   对   O ' Reilly   出版 的   Python   Cookbook   中 “ 算法 ” 章节 的 介绍
目录 和 文件 操作
文件 的 内容 、 所有者 和 分组 将 不受 影响
基础 异常 类 是   " URLError "
一个 提供 对 不可 查找 的   " RawIOBase "   原始 二进制 流 的 高层 级 访问 的 缓冲 二进制 流
" __ import __ ( ) "   的 返回值 会 被 用于 执行   " import "   语句 的 名称 绑定 操作
如果 没有 任何 参数 为 浮点 型 的 情况 下 ， 则 转换 和 标准化 过程 将 是 完全 精确 的 （ 不会 丢失 信息 ）
注 :   如果 启动   IDLE   时 使用 了   "   n "   开关   ( 无子 进程 ) ，   " turtle . cfg "   中此 数值 应设 为   " True "
解锁 指定 的 字节 数据 ， 该 对象 必须 在 之前 被 锁定
该   API   在   C++   中 同样 可用 ， 但 为 简化 描述 ， 通常 将 其 称为   Python / C   API
prefix _ chars   可 选 参数 的 前缀 字符 集合 （ 默认值 ： '   ' ）
关于 命名 空间 的 重要 一点 是 ， 不同 命名 空间 中 的 名称 之间 绝对 没有 关系 ； 例如 ， 两个 不同 的 模块 都 可以 定义 一个   " maximize "   函数 而 不会 产生 混淆 模块 的 用户 必须 在 其 前面 加上 模块 名称
基于 路径 的 查找 器
这个 对象 的 其他 字 段 不会 被 影响
支持 的 时钟 名称 和 读取 其值 的 相应 函数 是 ：
请参阅   " import "   语句 了解 名称 绑定 操作 的 更 多 细节
3.7   新版 功能 .
如果 未 提供   t   ， 则 使用 由   " localtime ( ) "   返回 的 当前 时间
预定 义 了 许多 浏览器 类型
3.7   新版 功能 .
Python   是 一种 高层 级 的 多用途 编程语言 ， 可 用于 解决 许多 不同 门类 的 问题
这个 类 实例 的 行为 与   " CDLL "   类似 ， 只不过 不会 在 调用函数 的 时候 释放   GIL   锁 ， 且 调用 结束 后 会 检查   Python   错误码
如果   futrue   在 完成 前 被 取消 则   " CancelledError "   将 被 触发
count   形参 默认 为   " None "   ， 导致 循环 仅 在 所有 通道 关闭 时 终止
你 也 可以 通过 传入 目录 名称 将 一个   tar   归档 提取 到 不同 的 目录 :
许多 包 也 可以 通过   setuptools   扩展 或   pip   包装 器 安装 ， 请参阅   https : / / pip . pypa . io /
下面 是 另 一个 可能 和 预期 有 偏差 的 例子 :
提取 扩展 函数 的 参数
当 一个 线程 退出 而 另外 一个 线程 被 创建 ， 线程 标识符 会 被 复用
可以 提供   " None "   作为   fallback   值
它 具有 允许 以 几种 不同 方式 将 任务分配 到 工作 进程 的 方法
如果 路径   path   是 挂载 点   （ 文件系统 中 挂载 其他 文件系统 的 点 ） ， 则 返回   " True "
此 方法 使得 为   " date "   对象 指定 以 格式化 字符串 字 面值 表示 的 格式化 字符串 以及 使用   " str . format ( ) "   进行 格式化 成为 可能
这样   J   的 最佳 可能 值 就是 经过 舍入 的 商 :
返回 包含 一个 对象 的 可 打印 表示 形式 的 字符串
弹 出   TOS   并 将 其 委托 给 它 作为   generator   的 子 迭代 器
The   new   " " , " "   format   specifier   described   in   PEP   378 :   千位 分隔符 的 格式 说明符 .
异常 会 在 错误 被 检测 到 的 位置 引发   ， 它 可以 被 当前 包围 代码 块 或是 任何 直接 或 间接 发起 调用 发生 错误 的 代码 块 的 其他 代码 块 所 处理
创建 和 管理 事件 循环 ， 以 提供 异步   API   用于   " 网络化 " ,   运行   " 子 进程 " ， 处理   " OS   信号 "   等等 ;
参数 :   width   如为 一个 整型 数值 ， 表示 大小 为 多少 像素 ， 如为 一个 浮点 数值 ， 则 表示 屏幕 的 占 比 ； 默认 为 屏幕 的   50%
如果 参数 为 一个 元组 ， 它 不会 创建 副本 而是 返回 同一 对象   ， 因此 如果 你 不 确定 某个 对象 是否 为 元组 时 也 可 简单 地 调用   " tuple ( ) "
环境变量   " PYTHONMALLOC "   可 被 用来 配置   Python   所 使用 的 内存 分配器
这 相当于   Python   表达式   " value   in   o "
它 需要 Windows   10 ， 但 可以 安全 地 安装 而 不会 破坏 其他 程序
" xml . etree . ElementTree " ：   ElementTree   API ， 一个 简单 而 轻量级 的 XML 处理器
这样 就 可以 不 改变 形式 直接 传递
" run ( ) "   的 返回值 ,   代表 一个 进程 已经 结束 .
这会 执行 一次   " screen . reset ( ) "
例如 调用 某个 文件 对象 的   " seek "   方法 并 传入 参数   10 ,   0   ( 假定 文件 对象 的 指针 为   " f " ) :
当   " abstractmethod ( ) "   与 其他 方法 描述符 配合 应用 时 ， 它 应当 被 应用 为 最 内层 的 装饰 器 ， 如 以下 用法 示例 所示 :
定义 在 文件 中 起始 位置 的 行号
" ast . parse ( ) "   函数 具有 一些 新 的 旗标 ：
接下来 的 图像 类型 是 可 识别 的 ， 返回值 来自   " what ( ) " ：
多次 调用   " getLogger ( ) "   具有 相同 的 名称 将 返回 对 同一 记录器 对象 的 引用
3.7   新版 功能 .
" 类 "   是 通过 执行 类 语句 创建 的 特定 对象 类型
不像 一些 其他 的   popen   功能 ， 此 实现 绝不会 隐式 调用 一个 系统   shell
你 可以 传入 字符串 或者 整数   — —   如果 传入 的 是 字符串 ， 则 会 使用 内部 的 映射 字典 将 其 转换 为 整数
当 垃圾 回收 器 检测 到 该 对象 在 循环 引用 中 时 ， 此 方法 会 被 调用
相当于   " put ( item ,   False ) "
从 返回 的 文件 类 对象 的   " name "   属性 中 可以 检索 到 文件名
如果   value   是 一个   " tuple "   ， 它 应该 有 三个 组件 ， 一个 符号 （   " 0 "   表示 正数 或   " 1 "   表示 负数 ） ， 一个 数字 的   " tuple "   和 整数 指数
这些 序列 并 不 必须 同样 长 ， 因为 它们 会 从左往右 开始 遍历 ， 而 不是 同时 执行
生成   n   个 随机 字节
参见 依赖于 具体 平台 的 高效 拷贝 操作 一节
对外 公开 了   Linux   专属 的   " signal . pidfd _ send _ signal ( ) "   用于 向 使用 文件 描述符 而 非   pid   的 进程 发送 信号
该 模块 定义 了 操作 HTML 的 工具
与 在 模块 导入 中 可能 的 错误 相关 的 警告 的 基类
bpo   10945 :   正式 取消 对 在 非 Windows 系统 上 创建   bdist _ wininst   安装程序 的 支持
对于 解包 操作 ， 结果 字节 对象 总是 恰好 具有 指定 数量 的 字节
对 它 的 调用 应 被 替换 为   " PySlice _ Unpack ( ) "   和   " PySlice _ AdjustIndices ( ) "   的 组合 ， 其中
如果 这个 方法 返回   " False "   那么   " Future "   已 被 取消 ， 即   " Future . cancel ( ) "   已 被 调用 并 返回   " True "
引发 一个 审计 事件   " winreg . DeleteKey " ， 附带 参数   " key " ,   " sub _ key " ,   " access "
（ 由   Antoine   Pitrou   在   bpo   32430   中 贡献 。 ）
此 函数 会 调用 底层 库中 的   " add _ history ( ) "
" PYTHONHASHSEED "   允许 你 为 哈希 种子 密码 设置 一个 固定值
也 会 将   " next ( ) "   方法 重命名 为   " __ next __ ( ) "
注意 可以 使用 管理器 对象 创建 同步 原语 ， 参考 管理器
工程 标注 法 的 指数 是   3   的 倍数
此 模块 的 反 序列化 器 引发   " ValueError "   当 存在 初始   BOM   标记
这 段 变种 的 代码 展示 了 如何 使用 特定 的 日志 记录 配置 例如 ` ` foo ` ` 记录器 使用 了 特殊 的 处理程序 ， 将   " foo "   子系统 中 所有 的 事件 记录 至 一个 文件   " mplog   foo . log "
无 状态 的 编码 和 解码
如果   isjunk   被 省略 或 为   " None " ， " find _ longest _ match ( ) "   将 返回   " ( i ,   j ,   k ) "   使得   " a [ i : i + k ] "   等于   " b [ j : j + k ] " ， 其中   " alo   <   i   <   i + k   <   ahi "   并且   " blo   <   j   <   j + k   <   bhi "
除了   headersonly   默认 为   " True " ， 其他 与   " BytesParser "   类 完全 一样
因为   " yield "   很多 时候 会 返回   " None " ， 所以 你 应该 总是 检查 这个 情况
用法 示例 :   " datetime "
本 模块 标准化 了 一个 快速 、 高效 利用 内存 的 核心 工具集 ， 这些 工具 本身 或 组合 都 很 有用
发布 你 的 扩展 模块
实例 属性 （ 只读 ） ：
3.2   新版 功能 .
创建 一个 迭代 器 ， 如果   predicate   为 true ， 迭代 器 丢弃 这些 元素 ， 然后 返回 其他 元素
发生 的 任何 混合 运算 都 将 通过 在 上下文 旗标 中 设置   " FloatOperation "   来 静默 地 记录
没有 指定 时则 隐含地 赋值 为   " False "
DTrace   和   SystemTap   探测 支持
要 在 所有 Python 版本 和平 台上 生成 相同 的 数值 ， 请 使用   " crc32 ( data )   &   0xffffffff "
每个 数据 类 都 转换 为 其字 段 的 字典 ， 如   " name :   value "   对
我们 所 做 的 是 指定 所谓 的 位置 参数
typecode _ or _ type   指明 了 返回 的 对象 类型 :   它 可能 是 一个   ctypes   类型 或者   " array "   模块 中 每个 类型 对应 的 单 字符 长度 的 字符串
如果   stdin   参数 非   " PIPE " ，   此 属性 为   " None "
第二步 赋值 则 不加 处理
2 :   " raise   TOS1   from   TOS "   ( 在   " TOS1 "   上 引发 异常 实例 或 类型 并 将   " __ cause __ "   设 为   " TOS " )
因此 ， 在 将 执行 的 代码 传递 给   " exec ( ) "   之前   ， 可以 通过 将 自己 的   " __ builtins __ "   字典 插入 到   globals   中来 控制 可以 使用 哪些 内置 代码
" logging "   Python   的 日志 记录 工具
此 行为 现在 已 与   C   词法 分析器 的 内部 行为 相匹配
为了 简化 和 标准化 错误处理 ， 编解码器 可以 通过 接受   errors   字符串 参数 来 实现 不同 的 错误处理 方案
在 这个 例子 中 ，   encoding   ,   errors   和   newline   三个 参数 一定 不要 设置
感谢 众多 在   Guido   指导 下 工作 的 外部 志愿者 ， 使得 这些 发布 成为 可能
返回 永久 代中 的 对象 数量
class :   date   用法 示例
运行 此 脚本 时 ， 应 看到 以下 输出 ：
use _ errno   参数 如果 设置 为   true ， 可以 启用 ctypes 的 机制 ， 通过 一种 安全 的 方法 获取 系统 的   " errno "   错误码
在   3.8   版 更改 :   " patch ( ) "   now   returns   an   " AsyncMock "   if   the   target   is   an   async   function .
下 一行 :   " Ordered   by :   standard   name "   ， 表示 最 右边 列中 的 文本 字符串 用于 对 输出 进行 排序
读写   " gzip " ,   " bz2 "   和   " lzma "   解压 的 归档 要求 相应 的 模块 可用
卸载 将 删除 该 已 安装 Python 程序 中 的 所有 软件包 ， 但 不会 删除 任何 虚拟环境
" contextlib . AbstractAsyncContextManager "   的 泛型 版本
成功 时 ， 返回 对象   o   中 的 键 的 列表
所以 ， 在 上面 的 例子 中 ， 旧 的   "   f /   foo "   行为 回合   "   f "   行为 保持 一样 ,   因为 只有   "   foo "   选项 字符串 被 重写
后续 的 自增 操作 建立 起 对 每个 字母 的 计数
不同 与 其他   asyncio   函数 ， 此 函数 要求 显式 地 传入   loop   参数
在   FreeBSD   上 使用   " closefrom ( ) "   优化 了   " subprocess "   模块
不是 包 的 模块 不 应该 具有   " __ path __ "   属性
有些 语言 具有 这样 的 结构 :
新增 和 改进 的 模块
" $ arg2 "   :   " ( const   char   ) "   函数 名 ， 使用   " user _ string ( $ arg2 ) "   访问
显然 改变   LogRecord   时 需要 相当 小心 ， 但 将 上下文 信息 注入 日志 确实 是 被 允许 的   ( 参见 使用 过滤器 传递 上下文 信息 )
source   可以 是 常规 的 字符串 、 字节 字符串 ， 或者   AST   对象
文件 不能 被 更改
很多 扩展 模块 提供 了 新 的 函数 和 类型 供 Python 使用 ， 但 有时 扩展 模块 里 的 代码 也 可以 被 其他 扩展 模块 使用
一个 位域 ， 用于 确定 属性   " STARTUPINFO "   是否 在 进程 创建 窗口 时 使用
" % x "   本地化 的 适当 日期 表示
3.1   新版 功能 .
形参 必须 不 为   " NULL "
（ 由   Nir   Aides   在   bpo   1625   中 贡献 。 ）
当 发起 调用 导入 机制 时 ， Python   会 实现 多种 策略 来 搜索 指定 名称 的 模块
你 不必 创建 模式 对象 并 调用 其 方法 ； " re "   模块 还 提供 了 顶级 函数   " match ( ) " ，   " search ( ) " ， " findall ( ) " ， " sub ( ) "   等等
注意 第二种 方法 稍微 容易 一些
对于 日期 对象   d   ,   " str ( d ) "   等价 于   " d . isoformat ( ) "
我们 首先 要 了解 最 简单 的 正则表达式
举例来说 ， 一个 接受 文件夹 目录 返回 所有 文件夹 中 的   XML   文件 的 函数 ；   或是 一个 接受 文件名 ， 然后 返回 文件 内容 的 函数 ， 都 可以 应用 在 很多 不同 的 场合
生成器 表达式 会 返回 一个 迭代 器 ， 它 在 必要 的 时候 计算结果 ， 避免 一次性 生成 所有 的 值
消息 机制 包含 ：   " Pipe ( ) "   ( 可以 用于 在 两个 进程 间 传递 消息 ) ， 以及 队列 ( 能够 在 多个 生产者 和 消费者 之间 通信 )
" importlib . abc "   — —   关于 导入 的 抽象 基类
在   3.4   版 更改 :   Added   " readline ( ) "   and   " readlines ( ) "   support
与   " PyMem _ Realloc ( ) "   相同 ， 但 内存 块 的 大小 被 调整 为   " ( n   sizeof ( TYPE ) ) "   字节
在   3.4   版 更改 :   The   " __ file __ "   attribute   is   no   longer   set   on   the   module .
可用 来 从 内部 数据结构 被 压平 的 数据 中 提取 相关 字 段 （ 例如 一个 多行 报告 ， 它 的 名称 字 段 出现 在 每 三行 上 ）
" calendar "   日历 相关 函数
" x "   或   " y "   至少 有 一个 不为 零
实现   " TOS   TOS1   / /   TOS "
一种 解决 方法 是 将 程序 与   Tcl   和   Tk   库 一同 发布 ， 并且 在 运行 时 使用 环境变量   " TCL _ LIBRARY "   和   " TK _ LIBRARY "   指向 他们 的 位置
name   or   flags   一个 命名 或者 一个 选项 字符串 的 列表 ， 例如   " foo "   或   "   f ,   foo "
你 可以 通过 交互式 实验   " re "   模块 来 了解 这 一点
host   可以 为   " host : port "   的 形式 ， 如果 你 需要 使用 指定 端口号 的话
返回 以 当前 字体 格式化 时 文本 将 在 指定 显示 上 占用 的 空间 量
它 是 在   " punycode "   编码 格式 和   " stringprep "   的 基础 上 构建 的
这个 方法 会 恢复 执行 生成器 的 代码 ， 然后   " yield "   表达式 返回 特定 的 值
就 地 实现   " TOS   TOS1   TOS "
使用 此 控制器 处理 的 浏览器 显示   url
3.6   版后 已 移除 :   请 使用   " asyncio "   替代
一个   module   内 的   Python   代码 通过   importing   操作 就 能够 访问 另 一个 模块 内 的 代码
当 执行   " yield "   表达式 时 ， 生成器 会 输出   " i "   的 值 ， 就 像   " return "   表达式 一样
PEP   285 :   布尔 类型
这是 接受 二进制 数据 的 推荐 方法
" ArgumentParser "   对象 包含 将 命令行 解析 成   Python   数据类型 所 需 的 全部 信息
其他 发起 调用 导入 系统 的 机制   ( 例如   " importlib . import _ module ( ) " )   可能 会 选择 绕过   " __ import __ ( ) "   并 使用 它们 自己 的 解决方案 来 实现 导入 机制
将 所有 旗标 重置 为   " 0 "
在 开头 添加 一个 新 的 动作
" PyStructSequence _ GetItem ( ) "   的 宏 版本
当   " try "   子句 中 发生 异常 时 ， 将 启动 对 异常 处理器 的 搜索
该 源代码 将 可 在 大多数   UNIX   类 平台 上 直接 编译 并 运行
在   3.6   版 更改 :   _ factory   默认 为 策略   " message _ factory "
Python   中 的 字符串 不能 被 修改 ， 它们 是   immutable   的
（ 由   Victor   Stinner   在   bpo   35471   中 贡献 。 ）
如果 语句 体 的 退出 是 由 异常 导致 的 ， 并且 来自   " __ exit __ ( ) "   方法 的 返回值 为 假 ， 则 该 异常 会 被 重新 引发
另 一个 用例 是 在 不 需要 形参 名称 时 排除 关键字 参数
" Popen "   如果 执行 失败 会 引发 一个 异常
否则 ，   " malloc ( ) "   和   " free ( ) "
如果 返回 一个 假值 ， 则 处理器 将 不会 发出 记录
此 模块 同时 支持 二进制 和   XML   plist   文件
" plistlib "   模块 ： 属性 列表 解析器
可 使用 的 值 和 默认值   ， 请 参照   " open ( ) "   的 文档
（ 2 ⁻ ¹ ⁰ ⁷ ⁴   这个 数值 是 等于   " math . ulp ( 0.0 ) "   的 未经 正规化 的 最小 正 浮点数 。 ）
发出 此 销毁 请求 后 ， 共享内存 块 可能 会 、 也 可能 不会 立即 销毁 ， 且 此 行为 在 不同 操作系统 之间 可能 不同
在 每个 线程 的   " run ( ) "   方法 被 调用 前 ，   func   会 被 传递 给   " sys . setprofile ( ) "
注意 通过   " nargs   '   ' "   来 实现 多个 位置 参数 通常 没有 意义 ， 但是 多个 选项 是 可能 的
你 也 可以 为 你 的 模块 定义 一个 唯一 的 新 异常
长 描述 中有 问题 的 地方 ， 通过 使用   " docutils "   解析器 ， " check "   能 进行 删除 ：
例如 ， 在   2016   年 春季 时钟 向前 调整 时 ， 我们 得到 :
此 模块 可 协助 脚本 解析   " sys . argv "   中 的 命令行 参数
但是 ， " _ fields _ "   类 变量 必须 在 类型 第一次 被 使用 （ 创建 实例 ， 调用   " sizeof ( ) "   等等 ） 之前 进行 定义
如果 类 是 你 自己 编写 的 ， 这 将 是 一个 很 好 的 方式
请 注意 可以 通过 指定   " tzinfo   None "   来 从 一个 感知 型   datetime   创建 一个 简单 型   datetime   而 不必 转换 日期 和 时间 数据
返回 系统 的 发布 版本信息 ， 例如   " ' # 3   on   degas ' "
以   " _ Py "   打头 的 名称 是 供   Python   实现 内部 使用 的 ， 不应 被 扩展 编写者 使用
" nis "   Sun   的   NIS   ( 黄页 )   接口
它 可以 处理 使用   ZIP64   扩展 （ 超过   4   GB   的   ZIP   文件 ） 的   ZIP   文件
" most _ common ( ) "   方法 在 值 需要 排序 的 时候 用
在   " PyStructSequence _ Desc "   的   " fields "   数组 中 的 索引 确定 了 结构 序列 描述 的 是 哪个 字 段
类似 地 ， 如果 给定 了   compresslevel   ， 它 将 会 覆盖 构造 器
检测   ASCII   空白 字符 ； 包括 空格 或 水平 制表符
在   3.4   版 更改 :   " __ wrapped __ "   属性 现在 总是 指向 被 包装 的 函数 ， 即使 该 函数 定义 了   " __ wrapped __ "   属性
PEP   343   " with "   语句   PEP   written   by   Guido   van   Rossum   and   Nick   Coghlan ;   implemented   by   Mike   Bland ,   Guido   van   Rossum ,   and   Neal   Norwitz
如果 给出 了   copy _ function   ， 它 必须 是 一个 将 被 用来 拷贝 每个 文件 的 可 调用 对象
编解码器 作者 还 需要 定义 编解码器 将 如何 处理 编码 和 解码 错误
此 方法 会 由   " Shelve . sync ( ) "   方法 来 调用
已弃 用 的   Python   模块 、 函数 和 方法
返回 一个 列表 对象 ， 其 内容 与 序列 或 可 迭代 对象   o   相同 ， 失败 时 返回   " NULL "
如果 父 进程 中 的 某些 对象 被 垃圾 回收 会 导致 资源 释放 ， 这 就 变得 很 重要
你 可以 传递 给 语法分析 程序 一个 字节 串 、 字符串 或者 文件 对象 ， 语法分析 程序 会 返回 给 你 对应 于 该 对象 结构 的 根   " EmailMessage "   实例
当 缓冲区 使用 完后 调用者 需要 调用   " PyBuffer _ Release ( ) "
没有 公共 构造 器
如果   type   声明 这个 对象 参与 循环 垃圾 检测 ， 那么 这个 对象 会 被 添加 进 垃圾 检测 的 对象 集中
3.1   新版 功能 .
然后 ， 不同 的 应用 将 可以 使用 不同 的 虚拟环境
这种 方式 更 常见 ， 也 和   CPython   的 可执行文件 处理 它 自己 的 冗长 度 参数 的 方式 一致 （ 参考   " python   help "   的 输出 ） ：
如果 你 运行   myapp . py   ， 你 应该 在   myapp . log   中 看到 ：
将 一个   " long "   整数   value   以   marshal   格式 写入   file
Shell   菜单 （ 仅   window   编辑器 ）
（ 由   Steve   Dower   在   bpo   37351   中 贡献 。 ）
没有 所 需 类型 的 消息
通常 只有 在 带有 小数 的 情况 下 ， 此类 转换 的 结果 中才 会 出现 小数点 符号
如果 需要 ， 则 会 使用 下面 用户 定义 对象 所 描述 的 机制 来 创建 一个 实例 ； 否则 ， 会 使用 上下文 来 确定 要 实例 化 的 对象
" % W "   十进制 数   [ 00 , 53 ]   表示 的 一年 中 的 周数 （ 星期一 作为   ( 3 )   一周 的 第一天 ） 作为
请参阅   Python   初始化 配置 获取 详细 文档
具体来说 ， 事件 循环 需要 知道 子 进程 何时 退出
在   3.4   版 更改 :   The   handshake   method   also   performs   " match _ hostname ( ) "   when   the   " check _ hostname "   attribute   of   the   socket ' s   " context "   is   true .
（ 如果 程序 将 正常 运行 而 不是 冻结 ， 则 可以 省略   " freeze _ support ( ) "   行 ）
它们 不会 被 解析器 所 生成 且 不会 被   Python   3   中 的 代码生成 器所 接受
( 鼠标 ,   键盘 )   paint   超极 简 主义 绘画 程序   " onclick ( ) "   当鼠标 点击   peace   初级 技巧   海龟 :   外观 与 动画   penrose   非周期性 地 使用 风筝 和 飞镖 形状 铺   " stamp ( ) "   印章   满 平面   planet _ and _ moon   模拟 引力 系统   复合 开关 ,   " Vec2D "   类   round _ dance   两 两 相对 并 不断 旋转 舞蹈 的 海龟   复合 形状 ,   clone   shapesize ,   tilt ,   get _ shapepoly ,   update   sorting _ animate   动态 演示 不同 的 排序 方法   简单 对齐 ,   随机化   tree   一棵   ( 图形化 的 )   广度 优先 树   ( 使   " clone ( ) "   克隆   用 生成器 )   two _ canvases   简单 设计   两块 画布 上 的 海龟   wikipedia   一个 来自 介绍 海龟 绘图 的 维基百科   " clone ( ) " ,   " undo ( ) "   文章 的 图案   yinyang   另 一个 初级 示例   " circle ( ) "   画圆
准备 类 命名 空间
" pickletools "   pickle   开发者 工具集
"   add   suffix "   选项 接受 一个 字符串 ， 用来 作为 后缀 附加 在 输出 文件名 后面 的 后面
" PyEval _ InitThreads ( ) "   和   " PyEval _ ThreadsInitialized ( ) "   函数 现已 被弃 用 并 将 在   Python   3.11   中 被 移除
( 默认 :   " 70 " )   自动 换行 的 最大 行 长度
这 条 规则 有 例外 ； 一些 字符 是 特殊 的   metacharacters   ， 并且 不 匹配 自己
否则 ， 当   " date "   对象 与 不同 类型 的 对象 比较 时 将 会 引发   " TypeError " ， 除非 是   "   "   或   " !   "   比较
当 执行 在 等待 异步 生成器 的 方法 返回 下 一个 对象 后 恢复 时 ， 该 函数 可以 从原 状态 继续 进行 ， 就 仿佛   yield   表达式 只是 另 一个 外部 调用
它们 保留 符号 是 为了 让 运算 结果 能以 更 高 的 精度 传递
3.2   新版 功能 .
传递 处理程序 用于 特定 目标 的   " LogRecord "   实例
在   3.4   版 更改 :   该 属性 名称 自 被 引入 起即 存在 于   CPython   中 ， 但 在   Python   3.4   之前 并未 正式 指明 ， 因此 可能 不 存在 于 某些 平台 上
而且 ， 对象 值 并 不 要求 具有 特定 的 构建 方式 ， 例如 由 其 全部 数据 属性 组成 等
模块   " logging "   日志 记录 模块 的   API   参考
此 模块 的 内容 对 需要 操作   " pickle "   的   Python   核心 开发者 来说 很 有 用处 ； " pickle "   的 一般 用户 则 可能 会 感觉   " pickletools "   模块 与 他们 无关
下列 函数 会 使用   " fileinput . input ( ) "   所 创建 的 全局 状态 ； 如果 没有 活动 的 状态 ， 则 会 引发   " RuntimeError "
" winreg "   Windows   注册表 访问
最后 ，   type   确定 了 数据 应 如何 呈现
这些 块 的 大概 数量 可以 由   chunksize   指定 正整数 设置
PEP   3112 :   字节 字 面值
数字 和 数学 模块
如果 原始 对象 仍然 存活 ， 则 可以 通过 调用 引用 对象 来 检索 原始 对象 ； 如果 引用 的 原始 对象 不再 存在 ， 则 调用 引用 对象 将 得到   " None "
如果   tracemalloc   被 禁用 则 返回   "   2 " ， 否则 返回   " 0 "
已 压缩 数据 的 大小
可以 是 一个   " str "   类 的 实例 ， 或者 一个   " Charset "   类
包装 器 确保   str   [   size   1 ]   在 返回 时 始终 是   " ' \ 0 ' "
请 注意 ， 与 C 结构 不同 ， 月份 值 是   [ 1 , 12 ]   的 范围 ， 而 不是   [ 0 , 11 ]
它 重载 了 一个 方法 并 添加 了 一个 可写 的 实例 变量
如果 替换 了   "   p "   引用 的 对象 ， 则 原始 的   "   p "   将 被 销毁
其 默认值 为 八进制 数   " 0o666 "   ( 并 将 被 当前 的   umask   所 修改 )
然而 ， 如果 需要 深度 写 和 删除 ， 也 可以 很 容易 的 通过 定义 一个 子类 来 实现 它
" Future "   是 一种 特殊 的 低 层级 可 等待 对象 ， 表示 一个 异步 操作 的 最终 结果
HTTPS   支持 仅 在 编译   Python   时 启用 了   SSL   支持 的 情况 下 （ 通过   " ssl "   模块   ） 可用
通常 它会 被 反复 调用 ， 直到 引发   " OSError "   异常 ， 这 说明 已经 没有 更 多 的 可用 值 了
当 一个 数据库 被 多个 连接 访问 的 时候 ， 如果 其中 一个 进程 修改 这个 数据库 ，   在 这个 事务 提交 之前 ， 这个   SQLite   数据库 将会 被 一直 锁定
（ 由   Victor   Stinner   在   bpo   12049   中 贡献 。 ）
由于 特定 类型 特别 是   " float "   的 实现 ， 在 某些 空闲 列表 中 并非 所有 项 都 会 被 释放
实例 具有 下列 方法 和 属性 :
返回 一个 迭代 器 ， 其中 每个 元素 将 重复 出现 计 数值 所 指定 次
一般来说 ， 你 不 应该 修改 它 ， 但 并 不 强制 要求 只读 访问
CPython   中 的   " float "   类型 使用 C语言 的   " double "   类型 进行 存储
class :   date   用法 示例
将 所有 陷阱 重置 为 零   " 0 "
返回   shell   风格   pattern   转换成 的 正则表达式 以便 用于   " re . match ( ) "
解包 方法 的 形式 为   " unpack _ type ( ) " ， 并且 不 接受 任何 参数
此未 记入 文档 的 行为 被 视为 是 一个 错误 ， 并 在   Python   3.4   中 被 移除 ， 但 又 在   3.4 . 2   中 被 恢复 以 保持 向下 兼容性
如果 设置 为空 字符串 （ 默认值 ） ， 则 为 父   控件 继承 光标
这 对 只读 和 非 阻塞 流 不起作用
" site "   — —   指定 域 的 配置 钩子
标注 的 存在 不会 改变 函数 的 语义
一个 脚本 的 主 模块 总是 被 命名 为   " __ main __ "
例如 ， " list ( ( 1 ,   2 ,   3 ) ) "   产生   " [ 1 ,   2 ,   3 ] "   而   " list ( ' abc ' ) "   产生   " [ ' a ' ,   ' b ' ,   ' c ' ] "
用于 协程 对象 的 C 结构 体
你 可以 直接 创建   " TarInfo "   对象 ， 或是 使用   " gettarinfo ( ) "   来 创建
一个 特殊 的 问题 是 构造 包含 0 个 或 1 个 元素 的 元组 ： 为了 适应 这种 情况 ， 语法 有 一些 额外 的 改变
在 我们 开始 调用函数 前 ， 我们 必须 先 了解 作为 函数参数 的   " ctypes "   数据类型
PEP   3107   函数 标注 最初 的 函数 标注 规范 说明
此 异常 是   " UnicodeError "   的 一个 子类
pydoc   p   1234   将 在   1234   端口 上 启动   HTTP   服务 ，   允许 你 在 你 喜欢 的   Web   服务器 中 通过   " http : / / localhost : 1234 / "   浏览 文档 内容
不过   2to3   的 支持 库   " lib2to3 "   是 一个 很 灵活 通用 的 库 ， 所以 还 可以 编写 你 自己 的   2to3   修复器
基于   num   创建 一个 新   Decimal   实例 但 使用   self   作为 上下文
启动器 最初 是 在   PEP   397   中 指定 的
请 注意 ， 不会 执行 退出 处理程序 和   finally 子句 等
指令   意义   示例   注释   " % G "   带有 世纪 的   ISO   8601   年份 ， 表示 包   0001 ,   0002 ,   ... ,   2013 ,   ( 8 )   含 大部分   ISO   星期   ( " % V " )   的 年份   2014 ,   ... ,   9998 ,   9999
这个 特例 已 被 弃用 ， 因为 现在 当   " staticmethod ( ) "   装饰 器 应用 于 抽象 方法 时 它 会 被 正确 地 标识 为 抽象 的 :
如果 你 没有 使用 原始 字符串 ， 那么   Python   会 将   " \ b "   转换 为 退格 ， 你 的 正则 不会 按照 你 的 预期 匹配
右手边 的 表达式 是 从左到右 被 求值 的
bpo   33127 :   ssl 模块 现在 使用 LibreSSL   2.7 . 1 编译
关于 正则表达式 的 最 完整 的 书 几乎 肯定 是 由   O ' Reilly   出版 的   Jeffrey   Friedl   的   Mastering   Regular   Expressions
第三个 参数 必须 为 指向 一个 整数 的 指针 ； 被 引用 的 整数 将 被 设为 输出 缓冲区 中 的 字节数
" email . errors " :   异常 和 缺陷 类
bpo   34631 :   在 Windows 安装程序 中将 OpenSSL 更新 为 1.1 . 1c
" IncrementalEncoder "   类 用来 对 一个 输入 进行 分步 编码
然后 ， 它 将 用 Python 编写 的 模块 的 字节 码 转换 为 C 代码 （ 可以 使用 编组 模块 转换 为 代码 对象 的 数组 初始化 器 ） ， 并 创建 一个 定制 的 配置文件 ， 该 文件 仅 包含 程序 中 实际 使用 的 内置 模块
对于 非   Unix   平台 ， 或者 当   Unix   上 有 远程 浏览器 时 ， 控制 过程 不会 等待 用户 完成 浏览器 ， 而是 允许 远程 浏览器 在 显示 界面 上 维护 自己 的 窗口
然后 ， 调用函数   " endwin ( ) "   来 将 终端 还原 到 它 的 原始 操作 模式 ：
" await "   " loop . sock _ sendall ( ) "   发送数据 到   " socket "
这会 在 十进制 位 的 左边 保留 至多   3   个 数码 ， 并 可能 要求 添加 一至 两个 末尾 零
" datetime "   模块 提供 了 各种 日期 和 时间 对象
在 当前 路径 上 发起 调用   " ZipFile . open ( ) "
在   3.2   版 更改 :   rest   parameter   added .
如果 要 使用   " filter ( ) "   例程 ， 它 必须 在 调用   " initscr ( ) "   之前 被 调用
在   o1   支持 的 前提 下该 操作 将 原地 执行
将 在 标准 输出 中 打印
用来 描述 一个   arena   分配器 的 结构 体
返回 片段 中 所有 采样 值 的 最大 绝对值
在   Python   3   中应 避免 使用 这些 函数 ， 因为 它们 返回 的 是 编码 后 的 字节 串
由   " site "   模块 添加 的 常量
现在 我们 将   " Row "   插入 :
required   是否 必须 要 提供 子 命令 ， 默认 为   " False "   ( 在   3.7   中 新增 )
如果   Future   已经 完成 则 抛出 一个   " InvalidStateError "   错误
在   3.4   版 更改 :   The   defaultTest   parameter   was   changed   to   also   accept   an   iterable   of   test   names .
文件 菜单   （ 命令行 和 编辑器 ）
将 指定 的   option   从 指定 的   section   中 移除
如果   logging . raiseExceptions   为   " True "   （ 开发 模式 ） ， 则 会 打印 一条 消息 “ 无法 找到 记录器   X . Y . Z   的 处理程序 ”
引发 此 异常 以 提示 来自 下层   SSL   实现 （ 目前 由   OpenSSL   库 提供 ） 的 错误
如果 指定 了   credentials   ， 它 应当 为 包含   userid   和   password   的 二元 组 ， 该 元组 将 被 放入 使用   Basic   验证 的   HTTP   ' Authorization '   标头 中
下列 异常 可以 适当 地被 引发 :
应 在   " turtle "   作为 某个 程序 的 一部分 的 时候 使用
请 注意 在 最后 一种 情况 中   " __ main __.__ spec __ "   总是 为   " None " ，   即使 文件 从技术上 说 可以 作为 一个 模块 被 导入
因此 ， 指涉 对象 可以 包含 代理 对象
在 这些 情况 下 ， 你 最好 编写   Python   代码 来 进行 处理 ； 虽然   Python   代码 比 精心设计 的 正则表达式 慢 ， 但 它 也 可能 更 容易 理解
返回 数据 缓冲区 中 的 当前 解包 位置
3.6   新版 功能 .
" os "   函数 :   " fchdir ( ) " ,   " fchmod ( ) " ,   " fchown ( ) " ,   " fdatasync ( ) " ,   " fstat ( ) " ,   " fstatvfs ( ) " ,   " fsync ( ) " ,   " ftruncate ( ) " ,   " mkfifo ( ) " ,   " mknod ( ) " ,   " open ( ) " ,   " posix _ fadvise ( ) " ,   " posix _ fallocate ( ) " ,   " pread ( ) " ,   " pwrite ( ) " ,   " read ( ) " ,   " readv ( ) " ,   " sendfile ( ) " ,   " wait3 ( ) " ,   " wait4 ( ) " ,   " wait ( ) " ,   " waitid ( ) " ,   " waitpid ( ) " ,   " write ( ) " ,   " writev ( ) " ;
字典 主要 的 操作 是 使用 关键字 存储 和 解析 值
一种 方法 是 使用   "   W "   " default "   命令行 选项
当在源 文本 中 遇到 语法错误 时 由   " netrc "   类 引发 的 异常
例如 ， 要 写 一个 支持 完整   " Set "   API   的 类 ， 只 需要 提供 下面 这 三个 方法   ：   " __ contains __ ( ) " ,   " __ iter __ ( ) "   和   " __ len __ ( ) "
" pyclbr "   Python   模块 浏览器 支持
" OrderedDict "   对象 和 其他 的   " Mapping "   的 相等 测试 ， 是 顺序 敏感 的 字典 测试
如果 切片 列表 包含 至少 一个 逗号 ， 则 键 将 是 一个 包含 切片 项 转换 的 元组 ； 否则 的话 ， 键 将 是 单个 切片 项 的 转换
3.9   版后 已 移除 :   " collections . abc . MutableMapping "   now   supports   " [ ] "
在   3.4   版 更改 :   The   " file "   attribute   is   automatically   closed   upon   the   garbage   collection   of   the   creating   " FieldStorage "   instance .
PEP   393 :   灵活 的 字符串 表示
Python 在 Windows 上 的 常见问题
" aclose ( ) "   /   " asend ( ) "   /   " athrow ( ) "   的 并行 运行 现在 已 被 禁止 ， 且   " ag _ running "   现在 会 反映 异步 生成器 的 实际 运行 状态
See   the   弃用   section   for   a   list   of   methods   that   should   be   replaced   and   their   replacements .
提供 了 一个 名为   UniCurses   的 移植 版本
" PyArg _ ParseTuple ( ) "   函数 及其 参数 的 文档 在 提取 扩展 函数 的 参数
这样 ， 长时间 运行 的 应用程序 的 日志 记录 的 详细 程度 可 随 时间 改变 而无须 停止 并 重新启动 应用程序
返回 消息 的 信封 头
元类 负责 接受 上述 三个 参数 并 创建 相应 的 类
在   3.9   版 更改 :   函数 可 使用 任何 有效 的   " assignment _ expression "   来 装饰
该 方法 永远 返回   " None "
在   3.5   版 更改 :   Added   support   for   passing   file   descriptor   to   this   function .
当 模块 不是 包时 ， 对于 最高 层级 模块   " __ package __ "   应该 设为 空 字符串 ， 对于 子 模块 则 应该 设 为 其父 包名
此 基类 用于 创建 可 使用 按位 运算符 进行 组合 而 不会 丢失 其   " IntFlag "   成员 资格 的 枚举 常量
当 将 病毒 扫描 配置 为 监视 文件系统 中 所有 读取 行为 时 ， 一些 杀毒 扫描 程序 会 导致 两个 数量级 的 启动 开销
如果   self   已 死亡 则 返回   " None "
在   Python   3   中 不 鼓励 使用 此 标志 ， 因为 语言 环境 机制 非常 不 可靠 ， 它 一次 只 处理 一个 “ 文化 ” ， 它 只 适用 于   8   位 语言 环境
仅 在 进程 执行 时 递减 间隔 计时器 ， 并 在 到期 时 发送   SIGVTALRM
创建 一个   BaseManager   对象
" types . CodeType "   在 构造 器 的 第二个 位置 新增 了 一个 形参   (   posonlyargcount   )   以 支持 在   PEP   570   中 定义 的 仅限 位置 参数
" io "   处理 流 的 核心 工具
该 类型 将 指示 类型 检查 器该 变量 或者 函数参数 的 值 等价 于 提供 的 字面 量 （ 或者 提供 的 几个 字面 量 的 其中 之一 ）
退出 对话 回到 文件名 ,   如果 有 的话 .
Modula   3   是   Python   中 异常 机制 所用 语法 和 语义 ， 以及 其他 一些 语言 特性 的 最初 来源
当有 脚本 被 作为 首个 参数 传入 或 使用 了   "   c "   选项 时 ， 在 执行 脚本 或 命令 之后 进入 交互 模式 ， 即使 是 在   " sys . stdin "   并 不是 一个 终端 的 时候
从栈 顶 对象 解析   " __ aenter __ "   和   " __ aexit __ "
首先 创建 一个   " spammodule . c "   文件
花 括号 或   " set ( ) "   函数 可以 用来 创建 集合
3.3   新版 功能 .
后 两个 函数 在   n   值较 小时 性能 最好
如果 指定 了   callback   ,   它 必须 是 一个 接受 单个 参数 的 可 调用 对象
在 MacOS 上 ， 通过 在 应用程序 菜单中选择 首选项 来 打开 配置 对话框
值   Specifies   the   list   of   values   to   display   in   the   drop   down   listbox
Python   3   是   Python   的 未来 ， 但   Python   2   仍 处于 活跃 使用 阶段 ， 最好 让 您 的 项目 在 两个 主要 版本 的 Python   上 都 可用
Python   源码 发布 包 的   Tools / demo /   目录 包含 了 一些 使用 此 模块 所 提供 的   curses   绑定 的 示例 程序
此 格式 需要 两个 参数
可选 的   file   参数 指向 发送 回溯 的 位置 ； 它 默认 为   " sys . stderr "
对于 在 其他 情况 下 实际 不可 变 的 高 计算资源 消耗 的 实例 特征 属性 来说 该 函数 非常 有用
参数 解释 同   " debug ( ) "
当 只有 一个 可 迭代 对象 参数 时 ， 它 将 返回 一个 单元 组 的 迭代 器
条件 变量 遵循 上下文 管理 协议   ： 使用   " with "   语句 会 在 它 包围 的 代码 块 内 获取 关联 的 锁
在   3.6   版 更改 :   接受 一个 类 路径 对象
asyncio   被 用作 多个 提供 高性能   Python   异步 框架 的 基础 ， 包括 网络 和 网站 服务   ， 数据库 连接 库 ， 分布式 任务 队列 等等
返回 小于   x   的 最大 数字 表示 形式
通常 来说 ， Capsule 用于 暴露 C   API ， 其 名字 应该 遵循 如下 规范 ：
使用   Python / C   API   有 两个 基本 的 理由
某些 命令行 参数 应当 从 一组 受限 值中 选择
发布 日期 :   2018   03   13
用于 创建对象 的 宏 ：
使用 自定义 的 数据类型 调用函数
将   Future   标记 为 完成 并 设置 一个 异常
" transport . write _ eof ( ) "   在 冲洗 已 缓冲 的 数据 后 关闭 传输 和 发送 EOF
3.8   新版 功能 .
现在 ， 来 做 一些 更 有用 的 事情 ：
计算   deque   中 元素 等于   x   的 个数
如此 之外 ， 此 属性 被 忽略
" urllib "   是 一个 收集 了 多个 涉及   URL   的 模块 的 包 ：
3.7   新版 功能 .
对于 一个 用户 自定义 类 的 实例   x ， " dir ( x ) "   将 返回 一个 按 字母 顺序 排序 的 包含 实例 属性 和 方法 及其 类 所 定义 的 属性 名称 的 列表
" fillcolor ( colorstring ) "   设置 填充 颜色 为   colorstring   指定 的   Tk   颜色 描述 字符串 ， 例如   " " red " " 、 " " yellow " "   或   " " # 33cc8c " "
bpo   32505 :   如果 数据 类 的 成员 变量 的 类型 为 Field ， 但 没有 类型 注解 ， 则 引发   TypeError
以下 是 此 函数 的 示例 ：
对于 混合 操作数 类型 ， 适用 双目 算术 运算符 的 规则
Python 在 Windows 上 的 常见问题
" CTRL _ C _ EVENT "   和   " CTRL _ BREAK _ EVENT "   可 被 发送给 创建 时 设置 了   creationflags   形参且 其中 包括   " CREATE _ NEW _ PROCESS _ GROUP "   的 进程
使用   " TextCalendar "   类 的   " formatmonth ( ) "   以 多行 字符串 形式 返回 月份 日历
除了   " int "   和   " float " ， Python 也 支持 其他 类型 的 数字 ， 例如   " Decimal "   或者   " Fraction "
因此 ， 有 必要 避免 内存 泄漏 ， 通过 代码 规范 会 策略 来 最小化 此类 错误
要 获取 错误报告 请 改用   " PyObject _ GetItem ( ) "
返回 一个 代理 对象 ， 它会 将 方法 调用 委托 给   type   的 父类 或 兄弟 类
字符串 字 面值 由 以下 词法 定义 进行 描述 :
将   asyncio   logger   的 日志 级别 设置 为   " logging . DEBUG " ， 例如 ， 下面 的 代码 片段 可以 在 应用程序 启动 时 运行 :
控件 状态 是 无关 状态 标志 的 位图 .
" ProcessPoolExecutor "   会 使用   " multiprocessing "   模块 ， 这 允许 它 绕过 全局 解释器 锁 但 也 意味着 只 可以 处理 和 返回 可 封存 的 对象
方法 可以 通过 与 普通 函数 相同 的 方式 引用 全局 名称
使用   encoding   ,   errors   ,   newline   ,   line _ buffering   和   write _ through   的 新 设置 来 重新配置 此 文本 流
Text   和   CDATASection   对象
The   following   example   shows   how   the   命令行 接口   can   be   used   to   create   an   executable   archive   from   a   directory   containing   Python   code
请 使用 专门 方法 例如   " selection _ set ( ) "   来 改变 选择
编码 需要 使用 一个 来自   " urllib . parse "   库 的 函数
[   线程 / 进程 池   ]
PEP   328 :   多行 导入
根据 标准 ， " decimal "   模块 提供 了 两个 现成 的 标准 上下文   " BasicContext "   和   " ExtendedContext "
请 使用   " sys . byteorder "   来 检查 你 的 系统 字节 顺序
Python 程序员 只 需要 处理 特定 需要 处理 的 错误 异常 ； 未 处理 的 异常 会 自动 传递 给 调用者 ， 然后 传递 给 调用者 的 调用者 ， 依此类推 ， 直到 他们 到达 顶级 解释器 ， 在 那里 将 它们 报告 给 用户 并 伴随 堆栈 回溯
框架 总是 从 按 从 旧 到 新 排序
Python   3.3   有 什么 新 变化
如果 该 对象 不 为   bytes   对象 则 会 引发   " TypeError "
用   Python   进行   Curses   编程
另 请 参见   " time ( ) "   方法
Microsoft   Foundation   Classes   ( MFC )   用户界面
" 0x08 "   一个 包含 用于 自由 变量 的 单元 的 元组 ， 生成 一个 闭包
请 注意 字符 源会 使用 字符串 的 “ 正常 ” 表示 形式   ： 如果 表示 中 需要 用到 转义序列 ， 在 缩短 表示 时 它们 可能 会 被 破坏
当   " PYTHONTZPATH "   包含 将 被 过滤 掉 的 无效 组件 ， 例如 一个 相对路径 时 引发
以下 是 一些 如何 使用   " email "   包来 读取 、 写入 和 发送 简单 电子邮件 以及 更 复杂 的 MIME 邮件 的 示例
任何 形参 都 可以 带有 标注 ， 甚至   "   identifier "   或   "   identifier "   这样 的 形参 也 可以
我 的 程序 太慢 了
要 明确 地 触发 通常 域 特定 的 添加 ， 调用函数   " site . main ( ) "
每个 具体 类 都 有 个 属性   " _ fields " ,   用来 给出 所有 子 节点 的 名字
stmt   和   setup   参数 也 可以 使用 不带 参数 的 可 调用 对象
它 为 由 调用者 提供 的   " Py _ buffer "   结构 赋值
（ 由 Benjamin   Peterson   和   Georg   Brandl   实现 。 ）
在   3.4   版 更改 :   如果 没有 设置   " __ loader __ " ， 会 引起   " ValueError "   异常   ， 就 像 属性 设置 为   " None "   的 时候 一样
" marshal "   内部   Python   对象 序列化
用于   mode   参数 的 标识 值
如果   x   定义 了   " __ int __ ( ) " ， " int ( x ) "   将 返回   " x .__ int __ ( ) "
它 是 一个 内置 调试器 的 可 嵌入 IDE
如果 一个 对象 定义 了   " __ set __ ( ) "   或   " __ delete __ ( ) " ， 则 它 会 被 视为 数据 描述 器
向 生成器 传递 值
" curses . panel "   curses   的 面板 栈 扩展
filename   参数 为 数据库 文件 的 主 名称 （ 不带 任何 特定 扩展名 ）
当 与   " strptime ( ) "   方法 一起 使用 时 ， " % f "   指令 可 接受 一至 六个 数码 及 左边 的 零 填充
（ 由   Antoine   Pitrou   以及 其他 一些 参与者 在   bpo   4753   中 贡献 。 ）
以下 示例 显示 了 各种 缩进 错误 :
如果   args   是 一个 字符串 ， 此 字符串 指定 将 通过   shell   执行 的 命令
使用   "   p "   来 为 已 转换 过   print   语句 的 代码运行 修复器
代表 一个 分块 的 类
2 )   在 所有 调用 外面 加锁
3.8   新版 功能 :   The   xml _ declaration   and   default _ namespace   parameters .
返回 码以 如下 方式 处理 转写 :
更 多 详情 可 参阅   PEP   366
每次 在 访问 数据库 中 某个 表 的 某 一列 的 时候 ， 这个 回调 对象 将会 被 调用
在   3.8   版 更改 :   Previously ,   a   nonzero   value   was   returned   on   success ;   zero   was   returned   on   error   under   Windows
空 字符串 根本 不 匹配 ，   因为   " + "   表示 “ 一次 或 多次重复 ”
此 模块 定义 了 以下 异常 ：
遇到 过多 的 符号 链接
你 可以 省略   m   或   n   ;   在 这种 情况 下 ， 将 假定 缺失 值 的 合理 值
例如 ， 如果   " PY _ VERSION _ HEX "   被 置 为   " 0x030401a2 " ,   其 包含 的 版本信息 可以 通过 以下 方式 将 其 作为 一个 32 位 数字 来 处理 ：
也 可能 在 海龟 绘图 程序 中 使用
该 模块 的 设计 基于   Java 的 线程 模型
给定   " ' string '   %   values " ， 则   " string "   中 的   " % "   实例 会以 零个 或 多个   " values "   元素 替换
在 机器 学习 问题 中 也 经常 会 出现 正态分布
返回 最小 的   " int "   " >   self "
请 注意 这种 情况 是 二进制 浮点数 的 本质 特性 ： 它 不是   Python   的 错误 ， 也 不是 你 代码 中 的 错误
3.5   新版 功能 .
此 算法 的 目的 仅为 验证 数据 的 正确性 ， 不 适合 作为 通用 散列 算法
调试 菜单 （ 仅   window   编辑器 ）
如果   classinfo   是 类型 对象 元组 （ 或 由 其他 此类 元组 递归 组成 的 元组 ） ， 那么 如果   object   是 其中 任何 一个 类型 的 实例 就 返回   " True "
callback   回调 一个 作为 参数 被 传入 以 用以 在 未来 的 某个 时刻 被 调用 的 子 例程 函数
正则表达式 中 的 不是 在 字符 类中 的 空格 将 被 忽略
" multiprocessing "   基于 进程 的 并行
如果 条件 为 真 ， 则 只 执行   " x ++ "   语句 ， 但 缩进 会 使 你 认为 情况 并非如此
全部 函数 列表 可以 参考   operator   模块 的 文档
这 可以 用于 更 方便 地 检测 一个 对象 是否是 代理 ， 而 不必 依赖于 两种 代理 对象 的 名称
上面 脚本 的 一个 变种 ， 仍然 在 主 进程 中 记录 日志 ， 但 使用 一个 单独 的 线程 :
参见 下面 的 第   6   步
这种 情况 下 生成器 表达式 会 更 受 青睐
在 生产者 这 一方面 ， 该 类型 的 协议 可以 导出 一个 “ 缓冲区 接口 ” ， 允许 公开 它 的 底层 缓冲区 信息
它 需要 像 引用 计数 一样 处理 任何 其他 对象
在   3.5   版 更改 :   从   Python   3.6   开始 ， 当 定义 了   " exec _ module ( ) "   的 时候 ， 这个 方法 将 不会 是 可选 的
在 协程 函数 体 之外 使用   " async   with "   语句 将 引发   " SyntaxError "
3.3   新版 功能 .
在   Python   解释器 中有 一个 重要 的 惯例 ： 当 一个 函数 出错 时 ， 它 应当 设置 异常 条件 并 返回 错误 值 （ 通常 为   " NULL "   指针 ）
这个 模块 提供 了 堆 队列 算法 的 实现 ， 也 称为 优先 队列 算法
您 不能 匿名 提交 一份 错误报告
3.5   新版 功能 .
3.3   新版 功能 .
其余 的 挑战 主要 包括 找到 挂 起 的 任务 并 修改 其 优先级 或 将 其 完全 移除
参见 :   " pathlib "   模块 提供 高级 路径 对象
如果 目标 为 一个 抽取 项 ： 引用 中 的 原型 表达式 会 被 求值
查找 一个 模块 ， 如果 有 必要 还会 加载 并 初始化 模块
在   " Handler "   子类 的   " emit ( ) "   方法 中 发生 的 其他 异常 被 传递 给 它 的   " handleError ( ) "   方法
上面 显示 的 参数 只是 常见 的 一些
在   3.3   版 更改 :   为 异类 文件系统 添加 了 显式 的 符号 链接 处理 ， 以便 使 它 适应   GNU   的   mv   的 行为
对于 对象 调用 方法 ， 可以 通过 使用   " getattr ( ) "   内置 检索 具有 特定 名称 的 方法 来 进一步 简化 ：
这样 的 设计 使得 你 可以 指定 包含 多个 潜在 配置文件 位置 的 可 迭代 对象 （ 例如 当前目录 、 用户 家 目录 以及 某个 系统 级 目录 ） ， 存在 于 该 可 迭代 对象 中 的 所有 配置文件 都 将 被 读取
3.7   新版 功能 .
从 输入 流 读取 所有 行 并 将 其 作为 一个 行 列表 返回
在   OSX   10.3   上 ， 它 是   RTLD _ GLOBAL   ， 其余 系统 上 是   RTLD _ LOCAL
Future   对象 有时 会由库 和 某些   asyncio   API   暴露 给 用户 ， 用作 可 等待 对象 :
这些 函数 是 线程 安全 的 ， 不 需要 持有 全局 解释器 锁
Unix   V7   中   " S _ IRUSR "   的 同义词
这 等价 于   Python   表达式   " callable (   args ) "
线程 与 中断 奇怪 地 交互 ： " KeyboardInterrupt "   异常 可能 会 被 任意 一个 线程 捕获
请 注意 所有 这些 函数 都 是 检测 根据 你 传入 的 字符串 的 字符 所 生成 的 码位 值 ； 它们 实际上 完全 不会 知晓 本机 的 字符 编码 格式
" ' w ' "   只 写 模式
运行 菜单 （ 仅   window   编辑器 ）
用作 字节 码 优化 器 的 占位 符
随着   Python   2.7   标准 库 的 老化 ， 有效 地 利用   Python   包 索引 （ 直接 或 通过 重新 分发者 ） 对   Python   2   用户 来说 变得 更加 重要
（ 由   David   Cuthbert   和   Jordan   Chapman   在   bpo   32117   中 贡献 。 ）
新 的 格式 语法 还 支持 新增 的 不同 选项 ， 将 在 以下 示例 中 说明
请 注意 一个   pickler   对象 或   " pickle . Pickler "   的 子类 的   " dispatch _ table "   属性 也 可以 被 用来 声明 归约 函数
将 非   " multipart "   或   " multipart / related "   转换 为   " multipart / alternative " ， 将 任何 现有 的   Content   标头 和 载荷 移入   " multipart "   的 （ 新加 ） 首 部分
“ Konqueror ”   是   Unix   的   KDE   桌面环境 的 文件 管理器 ， 只有 在   KDE   运行 时才 有 意义
...   只 为 当前 用户 安装 软件包 ？
字符串 和 字节 串字 面值
当 一个 操作 耗尽 内存 但 情况 仍 可 （ 通过 删除 一些 对象 ） 进行 挽救 时 将 被 引发
请勿 直接 导入 此 模块
常数   意义   " KQ _ FILTER _ READ "   获取 描述符 ， 并 在 有 数据 可读 时 返回   " KQ _ FILTER _ WRITE "   获取 描述符 ， 并 在 有 数据 可写 时 返回   " KQ _ FILTER _ AIO "   AIO   请求   " KQ _ FILTER _ VNODE "   当 在   fflag   中 监视 的 一个 或 多个 请求 事件 发生 时   返回   " KQ _ FILTER _ PROC "   监视 进程 ID 上 的 事件   " KQ _ FILTER _ NETDEV "   观察 网络设备 上 的 事件 [ 在 Mac   OS   X 上 不可 用 ]   " KQ _ FILTER _ SIGNAL "   每当 监视 的 信号 传递 到 进程 时 返回   " KQ _ FILTER _ TIMER "   建立 一个 任意 的 计时器
确切 信息 请 查阅 文档
使用   " object "   示意 一个 值 可以 类型 安全 地 兼容 任何 类型
将 有效 数据编码 为经 转换 的 可 打印 形式 ， 并 将   Content   Transfer   Encoding   标头 设置 为   " quoted   printable "   [ 1 ]
请 注意 这些 缺陷 会 在 问题 被 发现 时 加入 到 消息 中 ， 因此 举例来说 ， 如果 某条 嵌套 在   multipart / alternative   中 的 消息 具有 错误 的 标头 ， 该 嵌套 消息 对象 就 会 有 一条 缺陷 ， 但 外层 消息 对象 则 没有
第   0   天是 星期天
我们 可以 看看 迭代 器 常常 用到 的 函数 的 更 多 细节
不要 在 表达式 中 使用   " yield "   的 值 ， 除非 你 确定   " send ( ) "   是 唯一 的 用来 恢复 你 的 生成器 函数 的 方法
PSF   的 主页 是   https : / / www . python . org / psf /
参数 必须 是 类型 ， 而且 必须 至少 有 一个 参数
在   " getch ( ) "   被 调用 之前 只能 推送 一个   ch
[ 1 ]   因为   "   "   比   "   "   有 更 高 的 优先级 ,   所以   "   3   2 "   会 被 解释 成   "   ( 3   2 ) "   ， 因此 结果 是   "   9 "
要 选择 特定 版本 ， 请 添加   "   Version   3 . x . y "
word   为 一个 指定 目标 近似 匹配 的 序列 （ 通常 为 字符串 ） ，   possibilities   为 一个 由 用于 匹配   word   的 序列 构成 的 列表 （ 通常 为 字符串 列表 ）
这些 函数 也 适用 于 检测 有关 未 被   " os . path "   处理 的 信息 ，   例如 检测 块 和 字符 设备 等
" parser . items ( ) "   兼容 映射 协议 （ 返回   section _ name   ,   section _ proxy   对 的 列表 ， 包括   DEFAULTSECT ）
为了 保持 向 后 兼容性 ， 枚举 值 也 以 常量 形式 出现 在   " http . client "   模块 中 ，
" zipimporter "   是 用于 导入   ZIP   文件 的 类
此 监视器 会 在 收到   " SIGCHLD "   信号 时 通过 显式 地 轮询 每个 进程 来 避免 干扰 其他 代码生成 的 进程
" __ import __ ( ) "   函数   " import "   语句 是 这个 函数 的 语法 糖
检测   sibling   imports ， 并 将 其 转换成 相对   import
正如 你 猜 到 的 一样 ， 我们 正要 一步 一步 详细 介绍 各种 处理程序
如果 第二个 操作数 为 正值 则 向 左 移位 ； 否则 向 右 移位
如果 类 方法 在 其 所属 类 的 派生类 上 调用 ， 则 该 派生类 对象 会 被 作为 隐含 的 第一个 参数 被 传入
当   o1   支持 时 ， 这个 运算 直接 使用 它 储存 结果
Python   行为 的 改变
尝试 删除 从未 注册 过 的 文件 描述符 将 被 安全 地 忽略
" BufferedRWPair "   实现 了   " BufferedIOBase "   的 所有 方法 ， 但   " detach ( ) "   除外 ， 调用 该 方法 将 引发   " UnsupportedOperation "
如果   n   为   " None "   则 删除 全部 印章 ，   如果   n   >   0   则 删除 前   n   个 印章 ， 否则 如果   n   <   0   则 删除 后   n   个 印章
在 上面 的 例子 里 ， " ConfigParser "   的   interpolation   设 为   " BasicInterpolation ( ) " ， 这会 将   " % ( home _ dir ) s "   求解 为   " home _ dir "   的 值   ( 在 这里 是   " / Users " )
如果   op   对象 的 类型 实现 了   GC   协议 且   op   目前 正 被 垃圾 回收 器 追踪 则 返回   1 ，   否则 返回   0
" ConnectionResetError "   和   " BadStatusLine "   的 一个 子类
CookieJar   和   FileCookieJar   对象
不会 再有 任何 隐式 的 导入 机制   — —   整个 导入 系统 都 通过   " sys . meta _ path "   暴露 出来
这 可能 导致 以下 矛盾 行为 :
PEP   338 :   将 模块 作为 脚本 执行
（ 请 注意   "   64 "   选项 仅 适用 于   Python   3.7   或 更 高 版本 中 包含 的 启动器 。 ）
为什么 Python 对 某些 功能 （ 例如 list . index ( ) ） 使用 方法 来 实现 ， 而 其他 功能 （ 例如 len ( List ) ） 使用 函数 实现 ？
将   " builtins   .__   build _ class __ ( ) "   推 到 堆栈 上
如果 你 不 想要 插值 ， 你 可以 使用   " ConfigParser ( interpolation   None ) "
所有 滚动 操作 将 在 此 区域 中 进行
等待 子 进程 被 终止
线程 是 一种 对于 非 顺序 依赖 的 多个 任务 进行 解 耦 的 技术
使用 与 版本 无关 的 工厂 函数 创建   address / network / interface   对象 时 ， 任何 错误 都 将 报告 为   " ValueError "   ， 带有 一般 错误 消息 ， 只是 说 传入 的 值 未 被 识别 为 该 类型 的 对象
速度 依然 很快 ，   因为 倾向 于 使用 “ 矢量化 ” 构件 来 取代 解释器 开销 大 的   for   循环 和   generator
" tarfile "   模块 可以 用来 读写   tar   归档 ， 包括 使用   gzip ,   bz2   和   lzma   压缩 的 归档
此外 ， 还 用于   " zip ( ) "   来 添加 序列号
我 还 曾 在   CWI   的   Amoeba   分布式 操作系统 部门 工作
在 目录   a   和   b   中 无法 比较 的 文件
如果 在 构建 之间 不 保留 文件 ， 许多 CI 系统 将 自动 执行 此 操作
绑定   fun   指定 的 函数 到 鼠标 点击 屏幕 事件
因为   strptime   没有 表示 毫秒 的 占位 符 ， 毫秒 值 使用 了 另外 的 格式 字符串 来 添加   " ' % s , % 03d ' "   这 两个 格式 字符串 代码 都 是 写 死 在 该 方法 中 的
它 与   " EmailMessage "   相似 ， 不同之处 在于 当   " set _ content ( ) "   被 调用 时 不会 添加   MIME   Version   标头 ， 因为 子 部分 不 需要 有 它们 自己 的   MIME   Version   标头
C++   通过 声明 来 做到 这 一点 ， 但是   Python   没有 声明 ， 仅仅 为了 这个 目的 而 引入 它们 会 很 可惜
在 其它 应用程序 嵌入   Python
通常 字典 方法 都 可 用于   " Counter "   对象 ， 除了 有 两个 方法 工作 方式 与 字典 并不相同
add   " True "   或   " False "   如为   " True "   则 将 添加 一个 新 绑定   ， 否则 将 取代 先前 的 绑定
" token "   与 Python 解析 树 一起 使用 的 常量
如果 我们 有 一个 不可 变 对象   ( " str " ,   " int " ,   " tuple "   等等 ) ， 所有 指向 它 的 变量 都 将 显示 相 同样 的 值 ， 但 凡是 会 改变 这个 值 的 操作 将 总是 返回 一个 新 对象
比如说 ， 数据   a   ，   b   ，   c   的 调和 均值 等于   " 3 / ( 1 / a   +   1 / b   +   1 / c ) "
（   timeout   ,   input   ,   check   和   capture _ output   除外 ）
0   TargetDir   安装 目录   基于 InstallAllUsers 选择   DefaultAllUsersTargetDir   为 所有 用户 安装 时 的 默认 安装 路径   " % ProgramFiles% \ Python   X . Y "   或   " % ProgramFiles ( x8   6 ) % \ Python   X . Y "   DefaultJustForMeTargetDir   仅为 当前 用户 安装 时 的 默认 安装 路径   " % LocalAppData% \ Programs \   PythonXY "   或   " % LocalAppDa   ta% \ Programs \ PythonXY   32 "   或   " % LocalAppData% \ Progra   ms \ PythonXY   64 "   DefaultCustomTargetDir   UI 中 显示 的 默认 自定义 安装 目录   （ 空 ）   AssociateFiles   如果 还 安装 了 启动器 ， 则 创建 文件 关联
如果 两个 操作数 都 是 感知 型且 具有 不同 的   " tzinfo "   属性 ， " a   b "   操作 的 效果 就 如同   a   和   b   首先 被 转换 为 简单 型   UTC   日期 时间
如果 在 编译 时 请求 优化 ，   当前 代码生成 器 不会 为   assert   语句 发出 任何 代码
" x   not   in   s "   返回   " x   in   s "   取反 后 的 值
诊断 消息 将 使用   " print ( ) "   函数 写入 到 标准 输出
所有 内置 的 非 系统 退出 类 异常 都 派生 自 此类
" find _ spec ( ) "   接受 两个 参数 ， 即 要 导入 模块 的 完整 限定 名称 ， 以及 （ 可选 的 ）   目标 模块
这个 对象 只是 出于 调试 目的 而 对外 公开 ； 绝对 不要 修改 此 字典 的 内容
这 可 被 用来 控制 该 方法 所 产生 的 部分 格式 效果 ， 因为 指定 的   policy   将 被 传递 给   " BytesGenerator "
后续 轮换 时间 的 计算 则 仅 在 轮换 发生 时 执行 ， 而 只有 当 提交 输出 时 轮换 才 会 发生
3.2   新版 功能 .
让 用户 指定 的 命令行 参数 优先 于 环境变量 ， 优先 于 默认值 的 例子
重要 警告 ：   默认值 只会 执行 一次
将   item   的 值 加入   heap   中 ， 保持 堆 的 不变性
钩 方法 在 命令行   line   被 解释 之前 执行 ， 但是 在 输入 提示 被 生成 和 发出 后
正如 我们 在 上面 所 看到 的 ， 相关 的   API   相当 直观
其他 语言 ， 如 ObjectPascal 、 Delphi 和 C++   使用 静态 类型 ， 因此 可以 毫不含糊 地 知道 分配 给 什么 成员
在 创建 可能 引发 多个 不同 错误 的 模块 时 ， 通常 的 做法 是 为 该 模块 定义 的 异常 创建 基类   ， 并 为 不同 错误 条件 创建 特定 异常 类 的 子类 :
" WeakMethod "   包含 特别 代码 用来 重新 创建 绑定 方法 ， 直到 对象 或 初始 函数 被 销毁 :
例如   " GzipFile "   之类 的 文件 就 属于 这种 情况
传输 端点 未 连接
3.5   新版 功能 :   The   SMTPUTF8   extension   (   RFC   6531   )   is   now   supported .
序列 对象 通常 可以 与 相同 序列 类型 的 其他 对象 比较
类 定义 就是 对类 对象 的 定义   ( 参见 标准 类型 层级 结构 一节 ) :
converters   ， 默认值 :   不 设置
当 传递 给   " Popen "   构造函数 时 ， 这些 句柄 必须 暂时 地能 被   " os . set _ handle _ inheritable ( ) "   继承 ， 否则   " OSError "   将 以   Windows   error   " ERROR _ INVALID _ PARAMETER "   ( 87 )   抛出
" cmd "   支持 面向 行 的 命令 解释器
还有 一些   tar   格式 的 其他 变种 ， 它们 可以 被 读取 但 不能 被 创建 :
锁 必须 已经 被 获取 过 ， 但 不 一定 是 同一个 线程 获取 的
如果 脚本 必须 修改 共享 位置 ， 则 需要 安装 完整 安装程序
如果 给出   arcname   则 它 将 为 归档 中 的 文件 指定 一个 替代 名称
日志 级别 小于   level   将 被 忽略
它 在 变种 注册表 中 的 名称 是   " ' excel ' "
如果 多个 线程 被 阻塞 ， 等待 锁 被 解锁 ， 一次 只有 一个 线程 能 抢 到 锁 的 所有权
如 指定   timeout   ( float   或   int   类型 )   则 它 将 被 用于 控制 返回 之前 等待 的 最长 秒数
TurtleScreen / Screen   方法 及 对应 函数
现在 你 需要 让   " sqlite3 "   模块 知道 你 从 数据库 中 选取 的 其实 是 一个点 对象
在   3.6   版 更改 :   接受 一个 类 路径 对象
" ' r ' "   格式 码 指定 了 标准 函数   " repr ( ) "   格式
在   3.3   版 更改 :   移 除了   strict   参数
一些 应用程序 可以 使用   SQLite   作为 内部 数据 存储
" b "   ( " int " )   [ unsigned   char ]   将 一个 非负 的   Python   整型 转化成 一个 无 符号 的 微 整型 ， 存储 在 一个   C   " unsigned   char "   类型 中
" OrderedDict "   之间 的 相等 测试 是 顺序 敏感 的 ， 实现 为   " list ( od1 . items ( ) )   list ( od2 . items ( ) ) "
zipfile   模块 的 提取 操作 可能 会 由于 下面 列出 的 障碍 而 失败
" argparse "   模块 提供 了 一种 更 复杂 的 机制 来 处理 命令行 参数
返回 文件 描述符   fd   的 文件 句柄
此   Enum   类 装饰 器 可 确保 只 将 一个 名称 绑定 到 任意 一个 值
这样 做会 使 导入 器 的 命名 空间 变得 混乱 ， 并且 使得 连接器 更 难以 检测 未定义 的 名称
默认 情况 下 ，   prefix   会 被 添加 到 所有 不是 只 由 空白符 （ 包括 任何 行 结束符   ） 组成 的 行
字 段 宽度 通常 为 2 ， 除了   " % j "   ， 它 是 3
" set _ boundary ( ) "   方法 永远 都 会 在 必要 的 时候 为   boundary   添加 引号
" EnumMeta "   会 负责 确保 最终   " Enum "   类中 的 各种 其他 方法 是 正确 的   ( 例如   " __ new __ ( ) " ,   " __ getnewargs __ ( ) " ,   " __ str __ ( ) "   和   " __ repr __ ( ) " )
而 其他 字符串 字 面值 总是 一个 常量 ， 格式化 字符串 字 面值 实际上 是 会 在 运行 时 被 求值 的 表达式
" pydoc "   文档 生成器 和 在线 帮助 系统
本 章节 目标 是 提供 一个 各种 你 可以 实现 的 类型 方法 及其 功能 的 简短 介绍
本 文档 记录 " ssl " 模块 的 对象 和 函数 ； 更 多 关于 TLS , SSL , 和 证书 的 信息 ， 请参阅 下方 的 “ 详情 ” 选项
输出 显示 在   shell   窗口 中
Unix   和   Windows   之间 的 差异
如果 在 要求 新 的 未 解压缩 输入 之前   " decompress ( ) "   方法 可以 提供 更 多 的 解压缩 数据 则 为   " False "
发布 日期 :   2017   03   21
我 怎样 将   Python   嵌入 一个   Windows   程序 ？
3.4   版后 已 移除 :   Use   " importlib . util . module _ from _ spec ( ) "   instead .
" email . message " :   表示 一 封电子邮件 信息
请 注意 大多数 父 解析器 会 指定   " add _ help   False "
" print ( ) "   函数 会 生成 可读性 更强 的 输出 ， 即 略去 两边 的 引号 ， 并且 打印 出 经过 转义 的 特殊字符 :
（ 在   Python   中 ， 方法 这个 术语 并 不是 类 实例 所 特有 的 ： 其他 对象 也 可以 有 方法
此 自动 导入 可以 通过 使用 解释器 的   "   S "   选项 来 屏蔽
将   ctx   设 为 当前 线程 的 当前 上下文
PEP   528   将 Windows 控制台 编码 更 改为 UTF   8   PEP   由   Steve   Dower   撰写 并 实现
自然语言 描述 :   两种 字 面值 都 可以 用成 对 单引号   ( " ' " )   或 双引号   ( " " " )   来 标示 首尾
在   3.5   版 更改 :   In   earlier   Python   versions ,   the   " SSLSocket . send ( ) "   method   returned   zero   instead   of   raising   " SSLWantWriteError "   or   " SSLWantReadError " .
对于 列表 中 的 每个 条目 ， 先 打包 一个 无 符号 整数   " 1 " ， 再 添加 列表 中 数据 的 值
我们 不 保证 哪个   PGO   任务 集能 产生 更快 的 构建
请 注意 在 此情   况下   " i1   i2 "
XXX   ( import _ machinery . rst )   是否 要 专门 增加 一节 来 说明 模块 和 包 的 属性 ，   也许 可以 扩展 或 移植 数据模型 参考 页 中 的 相关 条目 ？
一个 绕过 构造 器 缓存 的 替代 构造 器
3.7   新版 功能 .
有关 该 主题 的 更 多 信息 请 参见 专门 的 文档 章节
以下 是 如何 将 上述 MIME 消息 解压缩 到 文件目录 中 的 示例 ：
在   3.4   版 更改 :   探索性 测试 支持 命名 空间 包 （   namespace   packages   ）
这个 模块 提供 了 创建 、 读取 、 写入 、 添加 及 列出   ZIP   文件 的 工具
为了 对 这些 概念 做 一 演示 ， 请 看 以下 定义   ABC   的 示例 ：
你 可以 给   " foo "   传递 一个 参数 ， 如果 为   true   ， 它 将 在 ERROR 和   CRITICAL 级别 记录 ， 否则 ， 它 只 在 DEBUG 、 INFO 和 WARNING 级别 记录
PEP   3119   引入 抽象 基类   PEP   written   by   Guido   van   Rossum   and   Talin
返回 一个 布尔值 ， " True "   或者   " False "
mode   参数 可以 是 内置   " open ( ) "   函数 所 接受 的 任意 二进制 模式 ； " ' b ' "   会 被 自动 添加
默认 文件名 为   " ~ / . history "
此 机制 通过 设置 对象 模型 （ 包括   " dict "   等 重要 内置 类型 ） 针对 并发 访问 的 隐式 安全 简化 了   CPython   实现
另 一个 有用 的 函数 是   " PyErr _ SetFromErrno ( ) "   ， 仅 接受 一个 异常 对象 ， 异常 描述 包含 在 全局变量   " errno "   中
3.2   新版 功能 .
如果 启动 程序运行 时 没有 明确 的 Python 版本 ， 并且 虚拟环境 （ 使用 标准 库 创建   " venv "   模块 或 外部   " virtualenv "   工具 ） 处于 活动状态 ， 则 启动 程序 将 运行 虚拟环境 的 解释器 而 不是 全局 的
( 更 多 需求 请 联系   glingl @ aon . at )
在 隔离 模式 下   " sys . path "   既 不 包含 脚本 所在 目录 也 不 包含 用户 的   site   packages   目录
这会 导入   Python   API （ 如果 你 喜欢 ， 你 可以 在 这里 添加 描述 模块 目标 和 版权 信息 的 注释 )
CPython   implementation   detail :   此表是 根据   CPython   文档 生成 的 ， 可能 无法 表示 其他 实现 所 引发 的 事件
" concurrent . futures "   启动 并行任务
找到 并 返回 一个   " Fraction "   使得 其值 最 接近   " self "   并且 分母 不 大于   max _ denominator
客户端 模块 必须 在 其 初始化 函数 里 按 顺序调用 函数   " import _ spam ( ) "   ( 或 其他 宏   ) 才能 访问 函数   " PySpam _ System ( ) "
构建 和   C   API   的 改变
返回 或 设置 画笔 的 属性 ， 以 一个 包含 以下 键值 对 的   " 画笔 字典 "   表示 :
注意 ， 如果 一个 可 选 参数 没有 被 使用 时 ， 相关 变量 被 赋值 为   " None " ， 在 此例 中是   " args . verbosity " ， 这 也 就是 为什么 它 在   " if "   语句 中 被 当作 逻辑 假
PEP   278 :   通用 换行 支持
在   Windows   上将 参数 列表 转换 为 一个 字符串
移植 到   Python   3.3
如果 你 想要 创建 一个 新 的   ZIP   归档 ， 请 在   "   c "   选项 后 指定 其 名称 然后 列出 应当 被 包含 的 文件名 :
在   3.5   版 更改 :   添加 了   stdout   和   stderr   属性
如果 键 不 存在 ， 它会 和 值   defaultobj   一起 插入 并 返回   defaultobj
在   3.7   版 更改 :   不要 在 运行 时内 从 联合 类型 中 移除 显式 说明 的 子类
可以 使用   C++   语言 创建 自己 的 函数 吗 ？
一会 讨论   " PyMODINIT _ FUNC "   作为 函数 返回 类型 的 用法
指向 创建 此   token   的   " ContextVar "   对象
如果   move   为   True   ， 画笔 会 移动 到 文本 的 右下角
3.8   新版 功能 :   添加 了   " 451   UNAVAILABLE _ FOR _ LEGAL _ REASONS "   状态 码
点状 的 名称 没有 使得 它 父包 或 模块 隐式 地 导入 ， 因为 它 需要 加载 它们 并且 可能 不 需要
以下 是 使用 字典 的 一些 简单 示例
将 某个 键 的 所有 属性 写入 注册表
如果 未找到 该 属性 ， 则 引发   " ImportError "
3.9   新版 功能 .
（ 由   Alex   Gr ö nholm   在   bpo   36999   中 贡献 。 ）
在 循环 结束 时 ，   " x "   的 值 是   " 4 "   ， 所以 所有 的 函数 现在 返回   " 4   2 "   ， 即   " 16 "
如果 给定 了 可选 的   members   ， 它 必须 为   " getmembers ( ) "   所 返回 的 列表 的 一个 子集
如果   " PyZipFile "   的   optimize   形参为   " 0 " ,   " 1 "   或   " 2 " ， 则 限 具有 相应 优化 级别   ( 参见   " compile ( ) " )   的 文件 会 被 添加 到 归档 ， 并 在 必要 时 进行 编译
如果 发生 的 异常 和   " except "   子句 中 的 类 是 同一个 类 或者 是 它 的 基类 ， 则 异常 和   except   子句 中 的 类 是 兼容 的 （ 但 反过来 则 不 成立 列出 派生类 的   except   子句 与 基类 不 兼容 ）
设置 海龟 模式   ( " standard " ,   " logo "   或   " world " )   并 执行 重置
本 对象 包含 一个 名为   " default _ factory "   的 属性 ， 构造 时 ， 第一个 参数 用于 为 该 属性 提供 初始值 ， 默认 为   " None "
在 其他 情况 下 ， 则 返回 级别 字符串   ' Level   % s '   %   level
文档 字符串 可以 自定义 ， 通过 直接 赋值 给   " __ doc __ "   属性 :
如果   TOS   为 假值 ， 则 将 字节 码 计数器 的 值 设为   target
3.5   新版 功能 :   增加 了 对   " is _ authenticated "   的 支持
" " > " "   的 权 标值
对 内存 块 的 跟踪 进行 筛选
默认 初始   CRC   为 零
Python   3.7 . 6   中 的 重要 变化
与 地址 一样 ， 可以 通过 直接 调用 类 构造函数 而 不是 使用 工厂 函数 来 强制 创建 特定 类型 的 网络
" xdrlib "   编码 与 解码   XDR   数据
由 服务器返回 的 状态 码
3.5   新版 功能 .
C 函数   " PyByteArray _ Size ( ) "   的 宏 版本
教程 信息 和 更 多 高级 用法 的 讨论 ， 请参阅
供应 的 动作 有 ：
增加 对象   o   的 引用 计数
发布 日期 ：   2016   09   12
其中   alpha   版 是 早期 发布 的 测试版 ， 它 的 接口 并未 最终 确定 ； 在 两个   alpha   发布 版本 间 出现 接口 的 改变 并 不 意外
utf   32   解码器 将 不再 解码 与 代理 码位 相对 应 的 字节 序列
我 还 会 使用   Modula   3   的 术语 ， 因为 其 面向对象 的 语义 比   C++   更 接近   Python ， 但 我 预计 少有 读者 听说 过 它 。 ）
在 寻找 已 安装 的   Python 解释器 之前 ， 此 表单 将 搜索 可执行文件   " PATH "   以 获取 Python 可执行文件
3.3   新版 功能 .
如果 你 已经 达到 纯   Python   允许 的 限制 ， 那么 有 一些 工具 可以 让 你 走 得 更 远
确定   code   是否 属于   tableC.1 . 1   ( ASCII   空白 字符 )
虽然 以下 介绍 的 方法 存在 有效 的 用例 ， 但 对于 新 项目 仍 建议 采用 映射 协议 访问
以下 代码 通常 应当 在 交互 会话 期间 从 用户 的   " PYTHONSTARTUP "   文件 自动 执行
返回 月 ， 从 0 到 12 的 整数
Deprecated   since   version   3.8 ,   will   be   removed   in   version   3.10 :   loop   形参
请 改用   " async   with   lock "
如果 你 从   IDLE   内部 调用   getpass ， 输入 可能 是 在 你 启动   IDLE   的 终端 中而非 在   IDEL   窗口 本身 中 完成
它 通常 是 一个 共享 库 （ 或   DLL   ） ， 但 在 某些 情况 下 也 可能 被 静态 链接 到   Python   解释器
在 C   ++ 中 ， 你 会 这样 写
在 无 延迟 模式 下 ， 如果 没有 输入 则 引发 一个 异常
" queue "   一个 同步 的 队列 类
该 指针 被 初始化 为 指向   " struct   _ frozen "   数组 ， 以   " NULL "   或者   0   作为 结束 标记
创建 一个 新类 意味着 创建 一个 新 的 对象 类型   ， 从而 允许 创建 一个 该 类型 的 新 实例
实现 了 如下 定义 在 协程 对象 :   里 的 方法 ：   " send ( ) " ， " throw ( ) "   和   " close ( ) "
在 这 一 表达方式 中 ， 字符串   “ Python ”   可能 看起来 像是 这样 ：
" HTTPException "   的 一个 子类
显示 前 10 项
跳转 到 文件 / 行   Look   on   the   current   line
为了 使用 混入 类为 集合 添加 哈希 能力 ， 可以 同时 继承   " Set ( ) "   和   " Hashable ( ) "   类 ， 然后 定义   " __ hash __   Set ._ hash "
默认 交互式 解释器 的 替代品
与 警告 模块 集成
使用 模块 级别   " re . sub ( ) "   函数 时 ， 模式 作为 第一个 参数传递
" PyUnicode _ EncodeMBCS ( ) " :   使用   " PyUnicode _ AsMBCSString ( ) "   或   " PyUnicode _ EncodeCodePage ( ) "   ( 和   " CP _ ACP "   code _ page )
当 不再 存在 对键 的 强 引用 时 ， 字典 中 的 条目 将 被 丢弃
上面 的 例子 定义 了 一个 只读 特征 属性 ； 你 也 可以 通过 适当 地 将 一个 或 多个 下层 方法 标记 为 抽象 的 来 定义 可 读写 的 抽象 特征 属性 :
比较 应该 是 可 传递 的
举例来说 ， 如果   object   or   type   的   " __ mro __ "   为   " D   >   B   >   C   >   A   >   object "   并且   type   的 值 为   " B " ， 则   " super ( ) "   将会 搜索   " C   >   A   >   object "
Python 的   lambda 表达式 不能 包含 语句 ， 因为 Python 的 语法 框架 不能 处理 嵌套 在 表达式 内部 的 语句
增加 了   " curses . get _ escdelay ( ) " ,   " curses . set _ escdelay ( ) " ,   " curses . get _ tabsize ( ) "   以及   " curses . set _ tabsize ( ) "   函数
在   3.5   版 更改 :   使得 这个 方法 变成 静态 的
此 函数 总是 会 成功 执行
等价 于   Python   表达式   " o1   |   o2 "
如果 没有 异常 发生 ， 则 跳 过   except   子句 并 完成   " try "   语句 的 执行
调用 此 方法 将 显示 相应 窗口 ， 等待 用户 进行 选择   ， 并 将 选择 的 颜色   ( 或   " None " )   返回 给 调用者
参数   memLevel   指定 内部 压缩 操作 时所 占用 内存大小
如果 你 不 希望 以 换行符 终止 ， 你 可以 将 处理程序 类 实例 的   " terminator "   属性 设为 空 字符串
如果   offset   为   " timedelta ( 0 ) " ， 则 名称 为 “ UTC ” ， 否则 为 字符串   " UTC ± HH : MM " ， 其中   ±   为   " offset "   的 正负 符号 ，   HH   和   MM   分别 为 表示   " offset . hours "   和   " offset . minutes "   的 两个 数码
通过 在   " . pyc "   扩展名 之前 添加   " . opt   1 "   来 扩充 已 编译 文件   (   bytecode   )   的 文件名   ( 参见   PEP   488   )
查询 终端 的 尺寸
语句 解释 及 变量 编译
它 提供 函数   " setup ( ) "   （ 该 函数 被   setup   脚本 调用 ）
使用 这些 编码 格式 的 其他 别名 可能 会 导致 更慢 的 执行 速度
可选 的   casefold   是 一个 指定 小写 字幕 是否 可 接受 为 输入 的 标志
这个 字段 会 被 添加 在 已有 字 段 列表 的 结尾处
" except "   子句 会 依据 实例 的 类来 选择 ： 它 必须 引用 实例 的 类 或是 其 所属 的 基类
C   可 调用 外部 函数 的 基类
问题 跟踪 在 追踪 系统 上 参与 问题 改进 的 过程 概述
如果 为   true   ， ,   " cmdloop ( ) "   使用   " input ( ) "   先是 提示 并且 阅读 下 一个 命令 ； 如果 为   false   ，   " sys . stdout . write ( ) "   和   " sys . stdin . readline ( ) "   被 使用
如果   obj   为 真值 则 返回   " True " ， 否则 返回   " False "
（ 由   Hye   Shik   Chang   贡献 。 ）
在   Py3.0   中 ，   cmp   参数 被 完全 删除 （ 作为 简化 和 统一 语言 努力 的 一部分 ， 消除 了 丰富 的 比较 与   " __ cmp __ ( ) "   魔术 方法 之间 的 冲突 ）
数字 类型   int ,   float ,   complex   描述 了 浮点 类型
成功 时 返回 对象   o   中键 的 数量 ， 失败 时 返回   "   1 "
这 意味着 通过 在 你 的 模块 末尾 添加 这些 代码 :
引发 一个   " tempfile . mkstemp "   审计 事件 ， 附带 参数   " fullpath "
（ 表达式 列表 为 一个 元组 ， 除非 其中 只有 一项 。 ）
原始 的   " sys . meta _ path "   规格 说明 见   PEP   302   ， 后续 的 扩展 说明 见   PEP   420
注意   " Type [ C ] "   是 协变 的 ：
如果 为 硬 链接 则 返回   " True "
这种 情况 下 生成 的 迭代 器 ， 每次 迭代 调用 它 的   " __ next __ ( ) "   方法 时 都 会 不带 实参 地 调用   object   ； 如果 返回 的 结果 是   sentinel   则 触发   " StopIteration " ， 否则 返回 调用 结果
a   和   b   必须 为 相同 的 类型 ： 或者 是   " str "   ( 仅限   ASCII   字符 ， 如   " HMAC . hexdigest ( ) "   的 返回值   ) ， 或者 是   bytes   like   object
这篇 文档 只有 在   https : / / setuptools . readthedocs . io / en / latest / setuptools . html   上 的   " setuptools "   文档 独立 涵盖 此处 包含 的 所有 相关 信息 之前 ， 才 会 单独 保留
（ 由   Victor   Stinner   在   bpo   40286   中 贡献 。 ）
它 通常 比 创建 一个 新 字典 和 多次 调用   " update ( ) "   要 快 很多
MRO   参见   method   resolution   order
打个比方 ， 如果 你 的 程序 在 一个 窗口 内 显示 一些 文本 然后 清楚 了 这个 窗口 ， 那么 这些 原始 文本 不 需要 被 发送 ，   因为 它们 甚至 不曾 能 被 看见
这 一章 简要 介绍 了 如何 使用   Microsoft   Visual   C++   创建   Python   的   Windows   扩展 模块 ， 然后 再 提供 有关 其 工作 机理 的 详细 背景 信息
它会 首先 执行 一条   " COMMIT "   语句 ， 再 执行 以形 参 方式 获取 的   SQL   脚本
在 默认 情况 下 ， 会 打印 堆栈 回溯 然后 该 线程 将 退出 （ 但 其他 线程 会 继续 运行 ）
创建 一个 共享 的   " threading . BoundedSemaphore "   对象 并 返回 它 的 代理
对于 所有 内置 异常 都 是 如此 ， 但 对于 用户 定义 的 异常 则 不 一定 如此 （ 虽然 这是 一个 有用 的 规范 ）
名称 改写 有助于 让 子类 重载 方法 而 不 破坏 类内 方法 调用
否则 ， 将 比较 文件 的 内容
其中 的 可选项   " sign "   可以 为   ' + '   或   '   '   并且   " numerator "   和   " denominator "   ( 如果 存在 )   是 十进制 数码 的 字符串
在   3.8   版 更改 :   关键 字形 参   mode   和   openhook   现在 是 仅限 关键 字形 参
此 模块 包含 一此 能 以 二进制 格式 来 读写   Python   值 的 函数
请 参考 你 的 系统 文档 了解 有关 如何 使用 这些 终端 控制 接口 的 更 多 信息
如果 没有 元素 的话 ，   就 引发 一个   " IndexError "
将 字符串   u   中 的   Unicode   数字 序列 转换 为   Python   整数 值
请 注意 如果 你 的 服务器 不是 在   UDP   端口   514   上 进行 侦听 ， 则   " SysLogHandler "   可能 无法 正常 工作
最终 的 路径 组成部分
类 定义 代码 块 以及 传给   " exec ( ) "   和   " eval ( ) "   的 参数 是 名称 解析 上下文 中 的 特殊 情况
Python   作用域 和 命名 空间
在 一个 模块 内部 ， 模块 名 （ 作为 一个 字符串 ） 可以 通过 全局变量   " __ name __ "   的 值 获得
ADPCM   编码 是 一种 自 适应 编码方案 ， 其中 每个   4   比特 数字 是 一个 采样 值 与 下 一个 采样 值 之间 的 差 除以 （ 不定 的 ） 步长
这 主要 是 用于 内省 ， 但 也 可 用于 额外 的 加载 器 专用 功能 ， 例如 获取 关联 到 加载 器 的 数据
如果 提供 了   validator   ， 它 必须 是 一个 函数
3.3   新版 功能 .
如果 你 想 知道 两个 变量 是否 指向 相同 的 对象 ， 你 可以 使用   " is "   运算符 ， 或 内置 函数   " id ( ) "
两个 数字 参数 将 先 被 转换 为 相同 类型
此 小写 不 考虑 当前 区域 设置 ； 如果 你 还 设置 了   " LOCALE "   标志 ， 则 将 考虑
用于 创建 数组 的 类型 码 字符
如果 为 true ， 则 此 字 段 包含 在 生成 的   " __ hash __ ( ) "   方法 中
因此 ， 对于   " [ loggers ] "   小节 中 名为   " log01 "   的 日志 记录器 ， 相应 的 配置 详情 保存 在   " [ logger _ log01 ] "   小节 中
装饰 器 使用 一个 记录器 作为 参数 ， 并 在 调用 被 装饰 的 函数 期间 附加 一个 内存 处理程序
首先 ， 这是 一个 简单 的 回调 ， 它会 显示 传入 的 值 :
如果   p   是 一个   " frozenset "   对象 或者 是 其子 类型 的 实例 则 返回 真值
此外 还 将 消耗 更少 的   CPU   周期
下面 是 将 会 引发 错误 的 （ 可能 不 完整 的 ） 条件 列表 :
返回 对应 于 给定   ASCII   字符 的   8   比特 位 字符 （ 字符 比特 值会 与   0x80   进行 按位 或 运算 ）
将   objects   打印 到   file   指定 的 文本 流 ， 以   sep   分隔 并 在 末尾 加上   end
参数   level   为 压缩 等级 ， 是 整数 ， 可 取值 为   " 0 "   到   " 9 "   或   "   1 "
3.4   版后 已 移除 :   Use   " importlib . util . cache _ from _ source ( ) "   instead .
这种 名称 在 类 定义 中 使用 时 ， 会以 一种 混合 形式 重写 以 避免 在 基类 及 派生类 的   " 私有 "   属性 之间 出现 名称 冲突
打包 固定 长度 不 透明 数据流 ， 类似 于   " pack _ fstring ( ) "
" itertools . combinations ( iterable ,   r ) "   返回 一个 迭代 器 ， 它 能 给出 输入 迭代 器中 所 包含 的 元素 的 所有 可能 的   r   元 元组 的 组合
buffering   的 含义 与 内置   " open ( ) "   函数 中 的 相同
返回 第一个 操作数 添加 第二个 值 的 指数 后 的 结果
" xmlrpc . client . ServerProxy "   现在 支持 可选 的   headers   关键字 参数 作为 随同 每次 请求 发送 的   HTTP   标头 序列
除了   NEWLINE ,   INDENT   和   DEDENT ， 还 存在 以下 类别 的 形符 :   标识符   ,   关键字   ,   字 面值   ,   运算符 以及 分隔符
操作 名称 可以 根据 需要 进行 缩写   ( 例如   "   Wi " ,   "   Wd " ,   "   Wa " ,   "   We " ) ， 解释器 将会 把 它们 解析 为 适当 的 操作 名称
花 括号 和 其中 的 字符 （ 称为 格式 字 段 ） 将 替换 为 传递 给   " str . format ( ) "   方法 的 对象
过滤器 会 被 依次 使用 ， 直到 其中 一个 返回 假值 为止
启用   Python   开发 模式 时会 显示 此 警告
Python   是 通过 引用 计数 和 一个 能够 检测 和 打破 循环 引用 的 循环 垃圾 回收 器来 执行 垃圾 回收 的
请参阅 新手 指南 以 获取 针对   Python   编程 初学者 的 信息 ， 包括 教程 的 清单
预期 它 与   " __ spec __. parent "   具有 相同 的 值
请 使用   " iter ( x ) "   或   " list ( x ) "   替代   " x . getchildren ( ) "   并用   " x . iter ( ) "   或   " list ( x . iter ( ) ) "   替代   " x . getiterator ( ) "
[   缓冲 流 协议   ]
模板 字符串 的 一个 主要 用例 是 文本 国际化   ( i18n ) ， 因为 在 此 场景 下 ， 更 简单 的 语法 和 功能 使得 文本 翻译 过程 比 使用   Python   的 其他 内置 字符串 格式化 工具 更为 方便
这 将 出现 在 我们 的 对象 的 默认 文本 表示 形式 和 某些 错误 消息 中 ， 例如 :
在   Python   3.5   之前 ， 这 三个 函数 组成 了   subprocess   的 高阶   API
但是 出于 历史 原因 ， 有时 也 会 在 整数 超出 要求 范围 的 情况 下 引发   OverflowError
返回 一个 迭代 器 ， 迭代 器 的 内容 与   " itermonthdates ( ) "   类似 为   year   年   month   月 的 日期 ， 但 不受   " datetime . date "   范围 的 限制
该 实例 使用 电子邮件 的 发件人 、 收件人 地址 和 主题 行 进行 初始化
它们 必须 是 具有 与   Codec   的   " encode ( ) "   和   " decode ( ) "   方法 相同 接口 的 函数 或 方法   ( 参见   Codec   接口 )
还有 一个   " patch . dict ( ) "   用于 在 一定 范围 内 设置 字典 中 的 值 ， 并 在 测试 结束 时 将 字典 恢复 为 其 原始 状态 ：
尽管 许多 对象 原生 支持 使用   with   语句 ， 但 有些 需要 被 管理 的 资源 并 不是 上下文 管理器 ， 并且 没有 实现   " close ( ) "   方法 而 不能 使用   " contextlib . closing "
发生 错误 时 ， 将 设置 适当 的 异常   ( " EOFError " ,   " ValueError "   或   " TypeError " )   并 返回   " NULL "
有关 枚举 成员 最 有趣 的 特点 是 它们 都 是 单例 对象
函数 发生 错误 时 抛出   " error "   异常
更改 CPython 版本 时 ， DTrace 脚本 可能 会 停止 工作 或 无法 正常 工作 而 不会 发出 警告
它 使用   HMAC   作为 伪 随机 函数
RPM   " . spec "   文件 配置 或 选项   bdist _ rpm   选项   默认值   发布 版本   " release "   " 1 "   组织   " group "   " Development / Libraries "   供应商   " vendor "   （ 同 上 ）   打包   " packager "   ( none )   提供   " provides "   ( none )   需求   " requires "   ( none )   冲突   " conflicts "   ( none )   淘汰   " obsoletes "   ( none )   Distribution   " distribution _ name "   ( none )   构建 要求   " build _ requires "   ( none )   Icon   " icon "   ( none )
缩进 宽度 调整 打开 一个 对话框 以 更改 缩进 宽度
" doctest "   测试 交互性 的 Python 示例
" LogRecords "   会 从 队列 中 被 移除 ， 并 被 传递 给 句柄 进行 处理
（ 由   Alexander   Belopolsky   在   bpo   1686487   中 贡献 。 ）
模块   " spwd "   针对 影子 密码 数据库 的 接口 ， 与 本 模块 类似
创建 一个 迭代 器 ， 使用 从 可 迭代 对象 中 获取 的 参数 来 计算 该 函数
其他 返回 类型 可以 通过 设置 函数 对象 的   " restype "   属性 来 指定
准确 来说 ， 此 方法 返回 的 是   " get _ content _ type ( ) "   方法 所 返回 的 形如   maintype / subtype   的 字符串 当中 的   maintype   部分
在   3.4   版 更改 :   引发   " ImportError "   而 不是   " NotImplementedError "
您 也 可以 这么 理解 切片 ： 将 索引 视作 指向 字符 之间   ， 第一个 字符 的 左侧 标为   0 ， 最后 一个 字符 的 右侧 标为   n   ， 其中   n   是 字符串 长度
Supporting   Python   3 :   An   in   depth   guide   中 的   Migrating   C   extensions   这 一章 ， 这 本书 介绍 了 如何 从   Python   2   迁移 到   Python   3 ， 包括 指导 读者 如何 移植 扩展 模块
如下 例子 展示 了 这些
当 发现 可回收 对象 时 打印信息
" configparser "   花费 了 很大 力气 来 为 尽量 大 范围 的 可用   INI   样式 提供 支持
在   3.2   版 更改 :   msg   may   be   a   byte   string .
参见 :   PEP   3151   重写   OS   和   IO   异常 的 层次结构
这 就是 一个 自定义 对象 所 包含 的
有关 For   a   reference   example   of   a   终结 器 方法 的 参考 示例 请 查看   Lib / asyncio / base _ events . py   中 实现 的   " asyncio . Loop . shutdown _ asyncgens "
win   amd64   ( 在   AMD64 ,   aka   x86 _ 64 ,   Intel64 ,   和   EM64T 上 的 64 位   Windows   )
结果 状态   " mboxMessage "   或   " MMDFMessage "   状态   " unseen "   序列   非   R   标记   " replied "   序列   A   标记   " flagged "   序列   F   标记
一个 用于 包装   " create _ subprocess _ exec ( ) "   and   " create _ subprocess _ shell ( ) "   函数 创建 的   OS   进程 的 对象
即便 是 符号 是 全局 可见 的 ，   你 要 调用 的 模块 也 可能 尚未 加载
以 名称 列表 的 形式 返回 成员
为了 获得 更 高 的 内存 利用效率 ， 当 一个 胜者 晋级 时 ， 我们 会用 较 低 层级 的 另 一条 目来 替代 它 ， 因此 规则 变为 一个 单元 和 它 之下 的 两个 单元 包含 三个 不同 条目 ， 上方 单元 “ 胜过 ” 了 两个 下方 单元
在   3.4   版 更改 :   不再 抽象 并且 提供 一个 具体 的 实现
类 可以 通过 定义   " __ repr __ ( ) "   方法 来 控制 此 函数 为 它 的 实例 所 返回 的 内容
以   " import "   开始 的 行 （ 跟着 空格 或   TAB ） 会 被 执行
如果 包装 器 函数 自身 缺少 在   updated   中 命名 的 任何 属性 则 仍 将 引发   " AttributeError "
它 默认 为   " locale . getpreferredencoding ( False ) "
这些 垃圾 过滤 函数 可 加快 查找 差异 的 匹配 速度 ， 并且 不会 导致 任何 差异 行 或 字符 被 忽略
编码   bytes   like   object   s   ， 使用 标准   Base64   字母表 并 返回 编码 过 的   " bytes "
" multiprocessing "   包 主要 复制 了   " threading "   模块 的 API
请 阅读   " find _ longest _ match ( ) "   方法 的   isjunk   形参 的 描述 了解 详情
注册 可 调用 的 适配器
（ 由   Dong   hee   Na   在   bpo   39259   中 贡献 。 ）
将 一个 新 字典 对象 推入 栈顶
在 习惯 了 阅读 和 编写 某种 特定 风格 的 代码 之后 ， 当 阅读 （ 或 被 要求 编写 ） 另 一种 风格 的 代码 时 通常 都 会 令人 感觉 有点 不 舒服 ）
返回 一个 在 语句 块 执行 完成 时 关闭   things   的 上下文 管理器
本 指南 旨在 帮助 您 了解 如何 最好 地 同时 支持   Python   2   和   3
" select "   函数 :   " devpoll . poll ( ) " ,   " epoll . poll ( ) " ,   " kqueue . control ( ) " ,   " poll . poll ( ) " ,   " select ( ) " ;
此 行为 现在 已 被 弃用
每个 具体 类 的 实例 对 它 每个 子 节点 都 有 一个 属性 ， 对应 类型 如 文法 中 所 定义
然后 Python 将 以   "   v "   选项 启动
[ 2 ]   作为 函数 体 的 第一条 语句 出现 的 字符串 字 面值 会 被 转换 为 函数 的   " __ doc __ "   属性 ， 也 就是 该 函数 的   docstring
设置 海龟 形状 为   name   指定 的 形状 名 ， 如 未指定 形状 名则 返回 当前 的 形状 名
（ 由   Tal   Einat   在   bpo   1529353   中 贡献 。 ）
2to3   包含 在 标准 库中 ， 模块 名为   " lib2to3 " ； 并 提供 一个 独立 入口 点   " Tools / scripts / 2to3 "
如果 设 为 一个 非空 字符串 ， 则 不 使用 新 的 控制台 读取器 和 写入 器
第一步 是 确认 是否 有 重复 的 报告
由于 一个 疏忽 ， 之前 的   Python   版本 会 错误 地 接受 以下 语法 :
“ 描述符 ” 是 描述 对象 的 某些 属性 的 对象
高阶 函数 接受 一个 或 多个 函数 作为 输入 ， 返回 新 的 函数
如果 非空 ，   close _ fds   必须 为   true
代理 对象 是   " BaseProxy "   派生类 的 实例
有时候   C   函数 接口 可能 由于 要往 某个 地址 写入 值 ， 或者 数据 太大 不 适合 作为 值 传递 ， 从而 希望 接收 一个 指针 作为 数据 参数 类型
异常 是 中断 代码 块 的 正常 控制 流程 以便 处理错误 或 其他 异常 条件 的 一种 方式
这 是因为 第   1   个 模块 中 的 名称 还 不可 用 ， 因为 第   1   个 模块 正在 忙 着 导入 第   2   个 模块
攻击 不如 递归 情况 有效 ， 但 它 避免 触发 禁止 深度 嵌套 实体 的 解析器 对策
即使 模块 名称 超出 了 作用域 ， 模块 也 可能 在   " sys . modules "   中 可用
" __ spec __ "   也 会 在   " __ main __ "   模块 作为 执行 某个 目录 ， zip   文件 或 其它   " sys . path "   条 目的 一部分 加载 时 被 填充
多数 编码 都 小于 127 ， 或者 255 ， 所以 很多 空间 都 是   " 0x00 "
" Py _ DTSF _ ADD _ DOT _ 0 "   表示 确保 返回 的 字符串 看起来 不 像是 一个 整数
3.4   新版 功能 .
首先 ， 它 从 上下文 管理器 加载   " __ exit __ ( ) "   并 将 其 推入 到 堆栈 以供 以后 被   " WITH _ CLEANUP _ START "   使用
（ 由   Andrew   Svetlov   在   bpo   34793   中 贡献 。 ）
3.4   新版 功能 :   filterfunc   形参
但是 ， 允许 两个 枚举 成员 有 相同 的 值
[ 1 ]   出现 这样 的 限制 是 由于 通过 这些 操作 执行 的 代码 在 模块 被 编译 的 时候 并 不可 用
参数 :   stretch _ wid   正 数值
还 请 留意 ， 无论 在 什么 情况 下 ， 消息 当中 的 任何 信封 头字 段 都 不会 包含 在 映射 接口 当中
错误处理 通过 与 流式 读取器 和 写入 器所 定义 的 相同 方式 来 完成
这 允许 你 将 通常 为 红色 的   1   号 颜色 改成 紫色 或 蓝色 或者 任何 你 喜欢 的 颜色
此后 再 引用   " a "   时会 报错 （ 直到 另 一个 值 被 赋 给 它 ）
基于   Python   callable   创建 一个   C   可 调用函数 （ 回调 函数 ）
增加 了   " CLD _ KILLED "   和   " CLD _ STOPPED "   作为   " si _ code "
返回 一个 实现   " AbstractEventLoop "   接口 的 事件 循环 对象
周 列表 的 元素 是 由 表示 日期 的 数字 和 表示 星期 几 的 数字 组成 的 元组
" ElementTree "   模块 中   " ElementTree "   和   " Element "   等 类 的   " getchildren ( ) "   和   " getiterator ( ) "   方法 已 被 移除
" init "   、   " repr "   、   " eq "   、   " order "   、   " unsafe _ hash "   和   " frozen "   的 值 与 它们 在   " dataclass ( ) "   中 的 含义 相同
3.8   新版 功能 .
缩写 UTC 不是 错误   ， 而是 英语 和 法语 之间 的 妥协
不过 ， 在 交互式 编译器 中 为了 节省 打字 可以 这么 用
PEP   489   Multi   phase   extension   module   initialization   PEP   由   Petr   Viktorin   ,   Stefan   Behnel   和   Nick   Coghlan   撰写 ， 由   Petr   Viktorin   实现
如果 参数 是 一个   " PyCapsule "   则 返回   True
使用 任意 值 作为   xbar   可能 导致 无效 或 不 可能 的 结果
3.4   新版 功能 .
实现   " del   name "   ， 其中   namei   是 代码 对象 的   " co _ names "   属性 的 索引
给 一个 事件 循环 绑定 监视器
" wave "   读写 WAV 格式文件
指明 一个 新 进程 将 不会 继承 其父 控制台 的   " Popen "   " creationflags "   形参
该 文字 前 可以 有   " + "   或   "   "   （ 中间 不能 有 空格 ） ， 前后 可以 有 空格
提供 了   " __ aiter __ "   和   " __ anext __ "   方法 的 抽象 基类
结构 体 和 联合 中 的 位域
nuget . org 是 一个 精简 的 Python 环境 ， 用于 在 没有 全局 安装 Python 的 系统 的 持续 集成 和 构建
3.3   新版 功能 .
例如 ， 当 一个 析 构器 在 垃圾 回收 时   ( " gc . collect ( ) " )   所 引发 的 异常
细节 将 稍后 说明
version   指明 文件格式 的 版本
如果 字符串 是 对象 的 属性 之一 的 名称 ， 则 返回   " True " ， 否则 返回   " False "
" urllib . request "   打开 和 读取   URL
请参阅   Python   开发者 指南 了解 详情
静态   Web   内容 的   LRU   缓存 示例 :
path   entry   finder   路径 入口 查找 器 任一 可 调用 对象 使用   " sys . path _ hooks "   ( 即   path   entry   hook   )   返回 的   finder   ， 此种 对象 能 通过   path   entry   来 定位 模块
比如说 ， 为了 支持 任意 迭代 器 ， 你 可以 像 这样 实现 默认设置 :
" ' spawn ' "   和   " ' forkserver ' "   启动 方法 当前 不能 在 Unix 上 和 “ 冻结 的 ” 可 执行 内容 一同 使用 （ 例如 ， 有 类似   PyInstaller   和   cx _ Freeze   的 包 产生 的 二进制 文件 ）
zip   :   ZIP   文件 （ 只有 在 相应 模块 可用 时 才能 解包 压缩文件 ）
使用   Python / C   API   所 需要 的 全部 函数 、 类型 和 宏 定义 可 通过 下面 这 行 语句 包含 到 你 的 代码 之中 ：
Mailcap   条目 可以 包含 形 如   " % { foo } "   的 命名 形参 ， 它 将 由 名为   ' foo '   的 形参 的 值 所 替换
iterator   迭代 器 用来 表示 一连串 数据流 的 对象
在 这种 情况 下 ， 请 检查 你 应当 为域 套 接字 所 使用 的 地址   — —   它 依赖于 具体 的 系统
如果 你 不 想要 在 后续 调用 之间 共享 默认值 ， 你 可以 这样 写 这个 函数 :
这个 “ 更新 日志 ” 是   Misc / NEWS . d   目录 下 文件 构建 的   HTML   版本 ， 它 包含 了 对 当前   Python   版本 进行 的 所有 重要 的 更改
这样 可以 防止 具有 通常 名称 例如   " string "   的 目录 在 无意 中 隐藏 稍后 在 模块 搜索 路径 上 出现 的 有效 模块
你 可以 使用   " update ( ) "   方法 向 这个 对象 输入 字节 类 对象   ( 通常 是   " bytes " )
移除 所有 元素 ， 使 其 长度 为 0 .
对于   " ' f ' " ,   " ' d ' "   和   " ' e ' "   转换 码 ， 打包 表示 形式 将 使用   IEEE   754   binary32 ,   binary64   或   binary16   格式   ( 分别 对应 于   " ' f ' " ,   " ' d ' "   或   " ' e ' " ) ， 无论 平台 使用 何种 浮点 格式
如果 运算 数为 零 将 返回   " Decimal ( '   Infinity ' ) "   并且 产生   the   " DivisionByZero "   标志
除了 所有   NaN   信号 之外 ， 此 操作 与   " compare ( ) "   方法 相同
（ 由   Samuel   Colvin   在   bpo   35800   中 贡献 。 ）
例如 ， 设置 每周 的 第一天 为 星期天
已 编译 的   Struct   对象 支持 以下 方法 和 属性 ：
有关 变种 和 格式 设置 参数 的 完整 详细信息 ， 请 参见 变种 与 格式 参数 部分
旧 接口 只 支持 标准 的   Base64   字母表 ， 并且 按照   RFC   2045   的 规范 每   76   个字符 增加 一个 换行符
" global "   语句 必须 位于 所有 对 其 所 指定 名称 的 使用 之前
返回   Decimal   实例   num   的 一个 副本
args   和   kwargs   与 传给   " vformat ( ) "   的 一样
如果 协程 已 成功 完成 或 被 取消 ， 这 将 返回 一个 空 列表
Deprecated   since   version   3.8 ,   will   be   removed   in   version   3.10 :   loop   形参
3.2   新版 功能 .
" logging . handlers "   模块 日志 记录 模块 附带 的 有用 处理器
返回   o1   左移   o2   个 比特 后 的 结果 ， 如果 失败 ， 返回   " NULL "
如果 在 执行   try   子句 时 发生 了 异常 ， 则 跳 过 该 子句 中 剩下 的 部分
Python   语言 参考 描述 了   Python   语言 的 具体 语法 和 语义 ， 这份 库 参考 则 介绍 了 与   Python   一同 发行 的 标准 库
释放器   ( " tp _ dealloc "   句柄 )   应当 在   " tp _ traverse "   句柄 所 使用 的 任何 字 段 失效 之前 为 对象 调用 此 函数
此外 ， 还 可以 设置 建议 的 最大 字符   width
" pprint "   模块 提供 了 “ 美化 打印 ” 任意   Python   数据结构 的 功能 ， 这种 美化 形式 可用 作对 解释器 的 输入
例如 ， 使用   " collections . Mapping "   而 不是   " collections . abc . Mapping "   自   2012   年 发布 的   Python   3.3   开始 即会 引发   " DeprecationWarning "
移植 到   Python   2.4
它会 被   " vformat ( ) "   用来 将 字符串 分解 为 文本 字 面值 或 替换 字 段
检测 堆栈 中 的 第二个 值 是否 为 匹配   TOS   的 异常 ， 如果 不是 则 会 跳转
请参阅   PEP   570   了解 详情
" wave "   读写 WAV 格式文件
返回 对应 于 给定 字符 的 控制字符 （ 字符 比特 值会 与   0x1f   进行 按位 与 运算 ）
所有 标准 的   Python   编解码器 都 定义 并 实现 了 以下 字符串 值 ：
即使 所 请求 的 内存 全部 只 用于 内部 的 、 高度 特定 的 目的 ，   将 所有 的 内存 请求 交给   Python   内存 管理器 能 让 解释器 对 其 内存 占用 的 整体 情况 有 更 准确 的 了解
它们 可以 自由 地 添加 额外 的 关键字 参数 ， 但 只有 在 这里 定义 的 参数 才 会 被   Python   编解码器 注册表 所 使用
通过   " from _ float ( ) "   或   " create _ decimal _ from _ float ( ) "   进行 显式 转换 则 不会 设置 旗标
对满 的   " Queue "   对象 ， 调用 非 阻塞 的   " put ( ) "   ( or   " put _ nowait ( ) " )   时 ，   引发 的 异常
例如 ， 使用   " optionxform ( ) "   的 默认 实现   （ 它会 将 选项 名称 转换 为 小写 形式 ） 时 ， 值   " foo   % ( bar ) s "   和   " foo   % ( BAR ) s "   是 等价 的
列表 中 的 每个 条目 必须 为 包含 形参 名称 的 字符串 、 等于号   ( " '   ' " )   以及 形参 的 值
这里 是 如何 添加 一个 计算 域和定 宽 输出 打印 格式 :
请 确认 启动 新 的 Python   解释器 ， 不要 在 上 一个 环境 中 继续 操作 :
用户 定义 的 泛型 类型
由 队列 使用者 控制
3.2   新版 功能 .
" unittest "   单元测试 框架
在   Unix   中 ， 只 存在 一种 库 文件   ( " . a " ) ， 它 包含 来自 多个 对象 文件   ( " . o " )   的 代码
" FileType "   工厂 类 用于 创建 可 作为   " ArgumentParser . add _ argument ( ) "   的   type   参数 传入 的 对象
" QueueListener "   非常简单 ： 向 其 传入 一个 队列 和 一些 处理 句柄 ， 它会 启动 一个 内部 线程 来 监听 从   " QueueHandlers "   ( 或 任何 其他 可用 的   " LogRecords "   源 )   发送 过来 的   LogRecords   队列
如果   turtleshape   为 多边形 ， 该 多边形 轮廓 也 以 新 设置 的 画笔 颜色 绘制
3.8   新版 功能 .
添加 新 的 发布 类型
与   " struct . calcsize ( ) "   调用 非   " NULL "   " format "   的 值 相同
此 函数 会 “ 偷走 ” 一个 对   item   的 引用 并 丢弃 一个 对 列表 中受 影响 位置 上 的 已有 条 目的 引用
" % H "   十进制 数   [ 00 , 23 ]   表示 的 小时 （ 24 小时 制 ）
指定 任何 内容 都 会 导致 错误
如果 传入 负 的   timeout   ， 相当于 无限期 等待
如果   base   是   " 0 "   ，   str   将 使用 整型 数字 面值 定义 来 解释 ； 在 这种 情况 下 ， 一个 非零 的 十进制 数中 的 前导 零会 引发 一个   " ValueError "
3.7   新版 功能 .
该 数字 通常 并 不 代表 下层 二进制 存储 中 对应 的 字节数
如果   allow _ nan   是   true ， 则 使用 它们 的   JavaScript   等价 形式 （ " NaN " 、 " Infinity "   和   "   Infinity " ）
以下 代码 片段 会 获取 当前 上下文 的 拷贝 并打印 设置 到 其中 的 所有 变量 及其 值 :
你 可以 通过 使用   " register _ archive _ format ( ) "   注册 新 的 格式 或 为 任何 现有 格式 提供 你 自己 的 归档 器
上下文 的 舍入 模式 将 被 使用
" xml . etree . ElementTree "   模块 提供 了 实现   C14N   2.0   的 新 函数   " – xml . etree . ElementTree . canonicalize ( ) "
3.3   新版 功能 .
" cmath "   关于 复数 的 数学 函数
key   为 某个 已经 打开 的 键 ， 或者 预定 义 的   HKEY _   常量 之一
此 基类 用于 创建 枚举 常量 可 使用 按位 运算符 进行 组合 而 不会 丢失 其   " Flag "   成员 资格 的 枚举 常量
调用   callback   时 ， Future   对象 是 它 的 唯一 参数
然而 ， 会 有 一些 特定 类型 的 优化 以便 减少 垃圾 回收 器 在 简单 实例   （ 如 只 含有 原子 性 的 键 和 值 的 字典 ） 上 的 消耗
各种 枚举 有何 区别 ？
keyword   argument   关键字 参数 参见   argument
元 路径 查找 器 可 使用 任何 策略 来 确定 它 是否 能 处理 指定 名称 的 模块
如果 未找到 翻译 ， 则   n   为   1   时 返回   singular   ， 为 其他 数时 返回   plural
上面 的 字符串 takes   24   bytes   compared   to   the   6   bytes   needed   for   an   ASCII   representation
如果 给定 了 可选 的   members   ， 则 它 必须 为   " getmembers ( ) "   所 返回 的 列表 的 一个 子集
新增 的 语法   " :   "   可 在 表达式 内部 为 变量 赋值
打印 一段 简短 描述 ， 说明 应当 如何 在 命令行 中 发起 调用   " ArgumentParser "
把 颜色 从 YIQ 值 转为 RGB 值
可 选 参数 :   an   argument   that   follows   an   option ,   is   closely   associated   with   that   option ,   and   is   consumed   from   the   argument   list   when   that   option   is
" TZPATH "   可 使用 环境变量 进行 配置
" lib2to3 "   模块 可能 会 在 未来 的   Python   版本 中 被 移出 标准 库
首要 的   API   方法
例如 在   Python   解释器 中 输入 :
tag   值为 字符串 ， 其 含义 如下 ：
" ctypes "   允许 创建 一个 指向   Python   可 调用 对象 的   C   函数
实现 笔记 ： 一些 混入 （ Maxin ） 方法 比如   " __ iter __ ( ) " ,   " __ reversed __ ( ) "   和   " index ( ) "   会 重复 调用 底层 的   " __ getitem __ ( ) "   方法
抽象 文法 目前 定义 如下
PythonWin   是 一个   Windows   专属 的   IDE
如果   replace   为   " False "   （ 默认值 ） ， 该头 字 段 会 被 移动 到 所有 头字 段 的 末尾
如果 未指定   mode   ， 则 会 使用   " ' a ' "
关键 字形 参 也 被 称为 命名 形参
信号量 对象 管理 一个 原子 性 的 计数器 ， 代表   " release ( ) "   方法 的 调用 次数 减去   " acquire ( ) "   的 调用 次数 再 加上 一个 初始值
030712.345216   " % Z "   时 区 名称 （ 如果 对象 为 简单 型 则 为 空   ( 空 ) ,   UTC ,   GMT   ( 6 )   字符串 ）
新增 的 第六个 可 选 元素 是 签名 为   " ( obj ,   state ) "   的 可 调用 对象
你 可以 使用   " next ( ) "   内置 函数 来 调用   " __ next __ ( ) "   方法   ； 这个 例子 显示 了 它 的 运作 方式 :
当   filename   是 一个 文件 对象 时 ，   它 的 默认值 是   " None "
返回   Task   对象 的 异常
" codeop "   模块 提供 了 可以 模拟 Python 读取 执行 打印 循环 的 实用程序 ， 就 像 在   " code "   模块 中 一样
以上 对象 的 跨 类型 一致性 比较 结果 将 是 不 相等 ， 跨 类型 次序 比较 将 引发   " TypeError "
module   模块 此 对象 是   Python   代码 的 一种 组织 单位
如果 通过   " dump ( ) "   marshal   了 一个 包含 不 受 支持 类型 的 对象 ， " load ( ) "   将 为 不可   marshal   的 类型 替换   " None "
后 一种 方式 还会 添加 一些 手工 编写 或 内置 具名 元组 所 没有 的 额外 方法
未来 的   Python   版本 中 还 将 定义 更 多 此类 名称
传输 可以 发送数据 ( TCP 和 Unix 链接 ， 管道 等 )
该 上下文 管理器 是   reentrant
编码   input   文件 的 内容 并 将 转换 后 可 打印 的 数据 结果 写入   output   文件
这是 控制 日志 记录 输出 详细 程度 的 基本 机制
在 读取 任何 文件 头 信息 前 ， 初始值 为   " None "
不过 ， mailcap   文件 在 大多数   Unix   系统 上 都 受到 支持
" b "   ( " int " )   [ char ]   将 一个   C   " char "   字符 型 转化成   Python   整型 对象
在   Windows   上 ， 默认 的 事件 循环   " ProactorEventLoop "   支持 子 进程 ， 而   " SelectorEventLoop "   则 不 支持
将   name   与   dialect   关联 起来
对于 整数 表示 类型   " ' b ' " ,   " ' o ' " ,   " ' x ' "   和   " ' X ' " ， 将 为 每   4   个 数位 插入 一个 下划线
许多   API   函数 在 你 嵌入 或是 扩展   Python   这 两种 场景 下 都 能 发挥作用 ； 此外 ，   大多数 嵌入   Python   的 应用程序 也 需要 提供 自定义 扩展 ， 因此 在 尝试 在 实际 应用 中 嵌入   Python   之前 先 熟悉 编写 扩展 应该 会 是 个 好 主意
现在 假设 我们 想要 存储   " datetime . datetime "   对象 ， 但 不是 表示 为   ISO   格式 ， 而是 表示 为   Unix   时间 戳
调用 这个 构造函数 时 ， 必需 带有 关键字 参数
例如 ， 当 把   " a "   赋值 给   " s "   时 ， 即使   " s "   被 声明 为   " str "   类型 ， 在 运行 时 接收 到 的 是   " int "   值 ， 静态 类型 检查 器 也 不会 报错
如果 函数调用 中 出现 了   "   expression "   句法 ， " expression "   必须 求值 为 一个   mapping   ， 其 内容 会 被 当作 是 额外 的 关键字 参数
另 请参阅   " ZoneInfo . key "   中 的 提示性 说明
无法 解析 为 内部 或 外部 对象
抽象 基类 可以 通过 从   " ABC "   派生 来 简单 地 创建 ， 这 就 避免 了 在 某些 情况 下会 令人 混淆 的 元类 用法 ， 例如 ：
尝试 根据   RFC   2822   的 规则 解析 一个 日期
返回 当前 调试 标识 位
函数 执行 完毕 退出 也 会 返回   " None "
你 可以 从   OpenCSW   获取 、 安装 及 使用 各种 版本 的 Python
当 一个 协程 通过   " asyncio . create _ task ( ) "   等 函数 被 打包 为 一个 任务   ， 该 协程 将 自动 排入 日程 准备 立即 运行 :
根据 不同 的 平台 ，   " multiprocessing "   支持 三种 启动 进程 的 方法
可选项   fp   是 一个 作为 打印输出 目标 的 文件 类 对象
整型 数字 面值 的 长度 没有 限制 ， 能 一直 大到 占 满 可用内存
" contextlib . AbstractContextManager "   的 泛型 版本
类型 的 名字 上 一章 提到 过 的 ， 会 出现 在 很多 地方 ， 几乎 全部都是 为了 诊断 目的
当 传入 一个   " datetime "   对象 来 回应   " datetime "   方法 时 ， " dt . tzinfo "   与   self   是 同一 对象
比如 我们 可以 知道   " echo "   是 一个 位置 参数 ， 但 我们 除了 靠 猜 或者 看 源代码 ， 没法 知道 它 是 用来 干什么 的
在 之前 的 版本 中则 会 引发   " RuntimeError "
在 一个 函数 内部 执行 的   " " def " "   语句 会 定义 一个 局部 函数 并 可 被 返回 或 传递
（ 由   Rafik   Draoui   和   Serhiy   Storchaka   在   bpo   10395   中 贡献 。 ）
exc _ value   :   异常 值 ， 可以 是   " None " .
阻塞 至 队列 中 所有 的 元素 都 被 接收 和 处理完毕
DLL   的 实际 使用
字符串 会 打印 不带 引号 的 内容 ,   并且 在 参数 项 之间 会 插入 一个 空格 ,   这样 你 就 可以 很 好 的 把 东西 格式化 ,   像 这样 :
" SSLError "   的 子类 ， 当   SSL   连接 被 突然 终止 时会 被 引发
您 可以 下载 最新 版本 的 源代码 ， 也 可以 直接 提取 最新 的   clone
以下 列表 描述 了 最 主要 内置 类型 的 比较 行为
以下 示例 使用 一个   TurtleScreen   实例   " screen "   和 一个   Turtle   实例   turtle :
这是 一个   " PyTypeObject "   实例 ， 表示   Python   " frozenset "   类型
从 内置 类型   " bool " ,   " int " ,   " float " ,   " complex "   和 标准 库 的 一些 类中移 除了   " __ str __ "   实现
这是   " FORMAT _ XZ "   的 默认值
" await "   " loop . create _ connection ( ) "   打开 一个 TCP 链接
参数 解释 同   " debug ( ) "
对于 子类 来说 同样 是 正确 的
如果 遇到 无效 的   JSON   数字 则 可以 使用 它 引发 异常
如果   " logging . disable ( logging . NOTSET ) "   被 调用 ， 它 将 在 实际上 移除 这个 重载 的 级别 ， 因此 日志 记录 输出 会 再次 取决于 单个 日志 记录器 的 有效 级别
Tcl   及   Tk   工具集 由   Tcl   发明者   John   Ousterhout   所著 的 书籍
传递 给 这些 函数 的 附加 参数 必须 是 由 格式化 字符串 确定 的 变量 的 地址 ； 这些 都 是 用来 存储 输入 元组 的 值
提示 ：   " exec ( ) "   函数 支持 动态 执行 语句
" Modules / Setup . dist "   与   " Modules / Setup "   两者 的 共存 已 被 移除
这是 一些 常见 任务 的 快速 解答 或 相关 链接
使用   " communicate ( ) "   而 非   " . stdin . write " ，   " . stdout . read "   或者   " . stderr . read "   来 避免 由于 任意 其他   OS   管道 缓冲区 被子 进程 填满 阻塞 而 导致 的 死锁
标准 库 简介   — —   第二 部分
另 一个 常见 任务 是 找到 模式 的 所有 匹配 项 ， 并用 不同 的 字符串 替换 它们
将 使用 此 名称 创建 适当 的 注册表 条目
它们 具有 与   Function   对象 相同 的 属性 以及 两个 额外 属性
键 对象 是 使用   " PyUnicode _ FromString ( key ) "   创建 的
因此 ， 您 还 可以 使用 命令行 选项 执行 脚本 ， 请参阅 命令行 文档
事件 循环 使用 协同 日程 调度 :   一个 事件 循环 每次 运行 一个   Task   对象
width   ( 默认 为 3 )   用于 规定 每 一行 显示 的 月份 数量
获取 当前 使用 的 文件 过滤器 .
新 的 文档 格式 ： 使用   Sphinx   的   reStructuredText
初始 调用 应 传入   " None "   作为   state
只有 当   " daylight "   非 零时 才 使用 它
之前 对   " add _ argument ( ) "   的 调用 决定 了 哪些 对象 被 创建 以及 它们 如何 被 赋值
请参阅 该书 了解 在 预期 格利 高利 历 序列 与 许多 其他 历法 系统 之间 进行 转换 的 算法
defusedxml   是 一个 纯   Python   软件包 ， 它 修改 了 所有 标准 库   XML   解析器 的 子类   ， 可以 防止 任何 潜在 的 恶意 操作
导入 机制 调用   " importlib . abc . Loader . exec _ module ( ) "   方法 并 传入 一个 参数 来 执行 模块 对象
" distutils "   构建 和 安装   Python   模块
在   3.6   版 更改 :   在 使用   " ' r ' "   模式 创建 的   ZipFile   或 已 关闭 的   ZipFile   上 调用   " writestr ( ) "   将 引发   " ValueError "
使用 这些 方法 而 不是   " assert "   语句 是 为了 让 测试运行 者 能 聚合 所有 的 测试 结果 并 产生 结果 报告
如果   iterable   是 另 一个 数组   ， 它 必须 具有 完全相同 的 类型 码 ； 否则 将 引发   " TypeError "
" configparser "   配置文件 解析器
一个 不 相关 但 很 好 用 的 函数 ， 它 接受 一个 时间 元组 例如   " time "   模块 中 的   " gmtime ( ) "   函数 的 返回 并 返回 相应 的   Unix   时间 戳值 ， 假定   1970   年 开始 计数 ，   POSIX   编码
该 构造 器 接受 一个 可选 的 浮点数 初始化 器
之前 它 仅 支持   2   D   的 情况
解析 命名 或 数字 形式 的 字符 引用 ， 并 把 他们 转换 到 正确 的 字符 （ 注意 ： 这   3   种 转义 都 是   " ' > ' "   ） :
如果 字 段 用于 比较 ， 则 应 在   hash   中 考虑 该字段
attrs   参数 是 一个   " ( name ,   value ) "   形式 的 列表 ， 包含 了 所有 在 标记 的   " < > "   括号 中 找到 的 属性
" pprint "   模块 为 一些 函数 添加 了   sort _ dicts   形参
如果 给出 了 可选 的 第二个 参数   xbar   ， 它 应当 是   data   的 均值
Decimal   也 可以 使用 一些 数学 函数 ：
引发 一个   " tempfile . mkdtemp "   审计 事件 ， 附带 参数   " fullpath "
该 函数 会 调用 底层 库中 的   " rl _ insert _ text ( ) " ， 但会 忽略 其 返回值
装饰 器 的 常见 例子 包括   " classmethod ( ) "   和   " staticmethod ( ) "
如果   encoding   或   errors   参数 被 指定 或者   universal _ newlines   参数 为   " True " ， 此流 为 文本 流 ， 否则 为 字节 流
当给 指针 类型 的 对象   " c _ char _ p " ,   " c _ wchar _ p "   和   " c _ void _ p "   等 赋值 时 ， 将 改变 它们 所 指向 的 内存地址   ， 而 不是 它们 所 指向 的 内存 区域 的 内容   (   这是 理所当然 的 ， 因为   Python   的   bytes   对象 是 不可 变 的 ) :
为什么 这里 打印 了   " False "   ？   ctypes   实例 是 一些 内存 块 加上 一些 用于 访问 这些 内存 块 的   descriptor   组成
默认   " _ generate _ next _ value _ ( ) "   方法 的 目标 是 提供 所 给出 的 最后 一个   " int "   所在 序列 的 下 一个   " int " ， 但 这种 行为 方式 属于 实现 细节 并且 可能 发生 改变
" asynchat "   异步   socket   指令 / 响应 处理器
（ 请 注意 ， 所有 已知 的 安装程序 都 只 使用 HKLM ， 因此 HKCU 通常 为空 。 ）
" email . parser " :   解析 电子邮件 信息
其子 类有   " BrokenPipeError " ,   " ConnectionAbortedError " ,   " ConnectionRefusedError "   和   " ConnectionResetError "
线程 执行 函数   function   并 附带 参数 列表   args   ( 必须 是 元组 )
ncurses   手册 主页   < https : / / linux . die . net / man / 3 / ncurses > ` _
不光 如此 ， 在 字典 当中 调用   " keys ( ) "   方法 返回 的 结果 ， 其 顺序 没有 保证   ； 但是 在 一个   " EmailMessage "   对象 当中 ， 返回 的 头 字 段 永远 以其 在 原 信息 当中 出现 的 顺序 ， 或 以 其 加入 信息 的 顺序 为序
PEP   285   添加 布尔 类型 由   GvR   撰写 并 实现
函数   " LOG _ MASK ( pri ) "   可 计算 单个 优先级   pri   的 掩码
在   3.2   版 更改 :   增加 了 针对 非 整数 使用   " __ index __ ( ) "   方法 的 特性
删除 指定 的 键
请 注意 对负 数值 进行 标准化 的 结果 可能 会 令人 感到 惊讶
否则 ： 该 对象 必须 为 具有 与 目标 列表 相同 项数 的 可 迭代 对象 ， 这些 项 将 按 从 左 至 右 的 顺序 被 赋值 给 对应 的 目标
这是 一个 与 整个 模块 具有 相同 方法 的 对象 ， 但 对于 需要 此 特定 版本 的   Unicode   数据库 （ 如   IDNA   ） 的 应用程序 ， 则 使用   Unicode   数据库 版本   3.2
例如 将   " str "   对象 给 二进制 流 的   " write ( ) "   方法 会 引发   " TypeError "
如果 同样 的 属性 名称 同时 出现 在 实例 和 类 中 ， 则 属性 查找 会 优先选择 实例 :
使用 ： " bytes . fromhex ( ) "   类 方法 也 实现 相似 的 功能 （ 仅 接受 文本 字符串 参数 ， 不 限制 其中 的 空白 字符 ）
这个   " PyObject "   的 子 类型 代表 一个 隐藏 的 值 ， 适用 于 需要 将 隐藏 值 （ 作为   " void   "   指针 ） 通过   Python   代码 传递 到 其他   C   代码 的   C   扩展 模块
如果 需要 解析 不可 信 或 未经 身份验证 的 数据 ， 请 参见   XML   漏洞
如果   iterable   实际上 不是 可 迭代 对象 则 引发   " TypeError "
与   " clock _ gettime ( ) "   相似 ， 但 返回 时间 为 纳秒
[ 2 ]   和 其他 语言 不 一样 的 是 ,   特殊字符 比如说   " \ n "   在 单引号   ( " ' ... ' " )   和 双引号   ( " " ... " " )   里 有 一样 的 意义
如果 找到 返回   " 1 " ， 如果 未找到 返回   " 0 " ， 如果 遇到 错误 则 返回   "   1 "
当   sort _ keys   为 真值 （ 默认 ） 时 字典 的 键 将 经过 排序 再 写入   plist ， 否则 将 按 字典 的 迭代 顺序 写入
语句   " t   12345 ,   54321 ,   ' hello ! ' "   是 元组 打包 的 一个 例子 ： 值   " 12345 " ,   " 54321 "   和   " ' hello ! ' "   被 打包 进 元组
如果 未 安装 这些 模块 中 的 任何 一种 ， 则 将 使用   " dbm . dumb "   模块 中 慢速 但 简单 的 实现
海龟 移至 初始 坐标   ( 0 , 0 ) ， 并 设置 朝向 为 初始 方向   ( 由 海龟 模式 确定 ， 参见   " mode ( ) " )
注意   lock   只能 是 命名 参数
这个   " PyTypeObject "   的 实例 表示   Python   的 整数 类型
最高 可以 撤回   1000   条 操作 记录
3.3   新版 功能 .
3.2   新版 功能 .
mapping   为 任意 字典 类 对象 ， 其中 的 键 将 匹配 模板 中 的 占位 符
在 这个 示例 中   ，   file   将 在   " with "   语句 块 执行 完成 之后 被 关闭 即使 是 发生 了 异常 :
如果 成功 ， 返回 上述 的 命名 元组 ， 否则 返回   " None "
在 多线程 进程 中 ， 请 谨慎 使用 ， 以便 在 将 此 功能 与 对 继承 所有 句柄 的 其他 进程 创建 函数 （ 例如   " os . system ( ) " ） 的 并发 调用 相结合 时   ， 避免 泄漏 标记 为 可 继承 的 句柄
字符   字节 顺序   大小   对齐 方式   " @ "   按原 字节   按原 字节   按原 字节   "   "   按原 字节   标准   无   " < "   小端   标准   无   " > "   大 端   标准   无   " ! "   网络 （   大 端 ）   标准   无
3.7   新版 功能 .
从子 进程 捕获 到 的 标准 输出
并且 前 两个 属性 的 属性 名称 也 不 一致 ； " os . uname ( ) "   是 将 它们 称为   " sysname "   和   " nodename "
默认 的   " random ( ) "   返回 在   0.0   ≤   x   <   1.0   范围 内   2 ⁻ ⁵ ³   的 倍数
因此 ，   " list . sort ( ) "   对 列表 进行 了 适当 的 排序
将   Unicode   字符串 翻译成 字节 序列 的 规则 被 称为 字符 编码   ， 或者 编码
详情 参见   Path   对象
模块 的 全局 命名 空间 在 模块 定义 被 读入 时 创建 ； 通常 ， 模块 命名 空间 也 会 持续 到 解释器 退出
Python 使用 动态 类型
将 一个   ctypes   对象 包装 为 进程 安全 的 对象 并 返回 ， 使用   lock   同步 对于 它 的 操作
为什么 Python 使用 缩 进来 分组 语句 ？
返回 与   pathname   相关联 的 数据
当 指定 的 选项 未 在 指定 的 节中 被 找到 时 引发 的 异常
在 较 早 的 版本 中 ， 终止符 被 硬 编码 为   " ' \ n ' "
通过   " secrets "   模块 可以 访问 你 的 操作系统 所 能 提供 的 最 安全 的 随机性 来源
导入 此 模块 将会 附加 域 特定 的 路径 到 模块 搜索 路径 并且 添加 一些 内 建 对象 ， 除非 使用 了   "   S "   选项
查看   Class   and   Module   Fixtures   获取 更 详细 的 说明
" pkgutil "   包 扩展 工具
3.9   新版 功能 .
在   3.3   版 更改 :   感知 型 和 简单 型   " time "   实例 之间 的 相等 比较 不会 引发   " TypeError "
与   " ngettext ( ) "   类似 ， 但 在 指定 的   domain   中 查找   message
这个 实例 对象 的 内容 保存 为 一个 正常 字符串 ， 通过   " UserString "   的   " data "   属性 存取
Tk 图形用户界面 ( GUI )
请 注意 如果   mapname   是 另 一 名称 的 别名 则 会 先 检查 别名
因此 ， 如果 你 更改 了 你 的 模块 ， 则 必须 重新启动 解释器 ，   或者 ， 如果 它 只是 一个 要 交互式 地 测试 的 模块 ， 请 使用   " importlib . reload ( ) " ， 例如   " import   importlib ;   importlib . reload ( modulename ) "
当 接收 到 这个 异常 时 ， 生成器 的 代码 会 抛出   " GeneratorExit "   或者   " StopIteration " ； 捕捉 这个 异常 作 其他 处理 是 非法 的 ， 并会 出发   " RuntimeError "
" IntEnum "   值 在 其他 方面 的 行为 都 如 你 预期 的 一样 类似 于 整数 :
当   Unicode   模式   " [ a   z ] "   或   " [ A   Z ] "   与   " IGNORECASE "   标志 结合 使用 时 ， 它们 将 匹配   52   个   ASCII   字母 和   4   个 额外 的 非   ASCII   字母 ： ' İ '   ( U + 0130 ， 拉丁 大写字母   I ， 带 上面 的 点   ) ， ' ı '   ( U + 0131 ， 拉丁文 小写字母 无点   i ) ， ' s '   ( U + 017F ， 拉丁文 小写字母 长   s )   和 ' K '   ( U + 212A ， 开尔文 符号 )
此 方法 应该 仅 在 低 层级 的 基于 回调 的 代码 中 使用
默认 情况 下   " shutil "   提供 以下 格式 :
按照 通常 的   Python   名称 绑定 规则 ， 这 看起来 可能 会 令人 惊讶 ， 但 它 实际上 是 导入 系统 的 一个 基本 特性
在   3.6 . 2   版 更改 :   filename   形参 接受 一个   path   like   object
3.3   新版 功能 .
注意 ， 一个   " ChainMap ( ) "   的 迭代 顺序 是 通过 扫描 最后 的 映射 来 确定 的 :
该 属性 的 名称 由   " add _ argument ( ) "   的   " dest "   关键字 参数 确定
在 此 情况 下   closefd   必须 为   " True "   ( 默认值 )   否则 将会 引发 异常
更 准确 地说   ， 这些 函数 在   " m _ size "   大于   0   并且 模块 状态 （ 即   " PyModule _ GetState ( ) "   的 返回值 ） 为   " NULL "   时 将 不会 被 调用
这个 实用 方法 会 重复 地 调用   " wait ( ) "   直到 满足 判断 式 或者 发生 超时
" html . parser . HTMLParser "   类 的   " unescape ( ) "   方法 已 被 移除 （ 它 自   Python   3.4   起 已 被 弃用 ）
在 十进制 浮点数 中 ， " 0.1   +   0.1   +   0.1   0.3 "   恰好 等于零
搜索 函数 预期 接收 一个 参数 ， 即 全部 以 小写字母 表示 的 编码 名称 ， 并 返回 一个   " CodecInfo "   对象
pwd   为 用于 解密 已 加密   ZIP   文件 的 密码
注意   lock   只能 是 命名 参数
还要 注意 可选 的 后续 子句 总是 以 一个 不能 作为 语句 开头 的 关键字 作为 开头 ， 因此 不会 产生 歧义 （ ‘ 悬空 的   " else " ’ 问题 在   Python   中是 通过 要求 嵌套 的   " if "   语句 必须 缩 进来 解决 的 )
确定   code   是否 属于   tableC.7   ( 不适 用于 规范 表示 )
如果 匹配 的 主机 或 默认 条目 均 不可 用 ， 则 返回   " None "
timeout   可以 为   " None " ， 也 可以 为   float   或   int   型 数值 表示 的 等待 秒数
如果 调用 时   blocking   设 为   " True "   会 阻塞 ， 并 立即 返回   " False "   ； 否则 ， 将 锁 锁定 并 返回   " True "
（ 由   Giampaolo   Rodol à   在   bpo   17561   中 贡献 。 ）
在 一行 中 可以 输入 多个 命令 ， 以   " ; ; "   分隔
" getch ( ) "   会 刷新 屏幕 然后 等待 用户 按键 ， 如果 之前 调用 过   " echo ( ) "   还会 显示 所 按 的 键
如果 未找到 任何 编解码器 ， 则 将 设置   " KeyError "   并 返回   " NULL "
请 注意 在 这些 情况 下 ，   atTime   值 实际上 会 被 用于 计算 初始 轮换 ， 而 后续 轮换 将会 通过 正常 的 间隔时间 计算 来 得出
这 包括 标准 流 ， 因而 也 会 影响 内置 的   " print ( ) "   函数
有关   __ main __   的 特殊 事项
方法   /   属性   目的   " match ( ) "   确定 正则 是否 从 字符串 的 开头 匹配
object _ hook   是 一个 可选 的 函数 ， 它会 被 调 用于 每 一个 解码 出 的 对象 字面 量 （ 即 一个   " dict " ）
使用 上下文 管理器 进行 选择性 记录
如果   datetime2 . year   将要 小于   " MINYEAR "   或 大于   " MAXYEAR "   则 会 引发   " OverflowError "
" select "   等待   I / O   完成
但是 ， 只有 在 不 传递 任何 参数 给 程序 的 情况 下 才能 这么 做
DndHandler   类 处理 拖放 事件 ， 在 事件 控件 的 根 对象 上 跟踪   Motion   和   ButtonRelease   事件
一个 标记 的 指令 ， 用   " > > "   表示 ，
它会 申明 的 类型 的 第一个 单词 ， 比如 “ integer   primary   key ” ， 它会 解析 出   “ integer ” ， 再 比如 “ number ( 10 ) ” ， 它会 解析 出 “ number ”
" ZoneInfo ( key ) " :   当 使用 主 构造 器 构造 时 ， 会 基于 键 序列化 一个   " ZoneInfo "   对象 ， 而 当反 序列化 时 ， 反 序列化 过程 会 使用 主 构造 器 ， 因此 预期 它们 与 其他 对 同一时 区 的 引用 会 是 同一 对象
请 注意 在 调用   " __ getitem __ ( ) "   方法 期间 发生 的 异常 将会 被 屏蔽
这时 ， 你 就 可以 从 注册表 中 移除 作为 事件 日志 条目 来源 的 应用 名称
多个 脚本 文件 ， 演示   " turtle "   模块 的 不同 特性
查看   " extractall ( ) "   的 警告 信息
下列 函数 与 初始化 文件 和 用户 配置 有关 ：
读取 压缩文件 示例 ：
上传 包到 包 索引
常规 包是 传统 的 包 类型 ， 它们 在   Python   3.2   及 之前 就 已 存在
现在 你 将要 写 更长 ， 更 复杂 的   Python   代码 ， 是 时候 讨论一下 代码 风格 了
在   3.3   版 更改 :   tz   现在 可以 被 省略
在   3.4   版 更改 :   现当   indent   不是   " None "   时 ， 采用   " ( ' , ' ,   ' :   ' ) "   作为 默认值
每种 类型 的   hash   都 有 一个 构造 器 方法
Microsoft   Store 包是 一个 简单 的 Python   安装 ， 适用 于 运行 脚本 和 包 ， 以及 使用 IDLE 或 其他 开发 环境
模块 维护者 应该 制作 源码 包 ； 要 实现 可以 运行
还有 一个 适用 于   Oracle   Berkeley   DB   的 第三方 接口
返回 序列 对象   o   重复   count   次 的 结果 ， 失败 时 返回   " NULL "
传给   " only _ keys "   但 在 缓存 中 找 不到 的 键会 被 忽略
在 最后 一个 文件 的 最后 一行 被 读取 之后 ， 返回 该行 的 行号
给定 的 终止 数值 并 不 在 要 生成 的 序列 里 ； " range ( 10 ) "   会 生成 10 个值 ， 并且 是 以 合法 的 索引 生成 一个 长度 为 10 的 序列
type   通常 为 以下 常量 之一 :   " REGTYPE " ,   " AREGTYPE " ,   " LNKTYPE " ,   " SYMTYPE " ,   " DIRTYPE " ,   " FIFOTYPE " ,   " CONTTYPE " ,   " CHRTYPE " ,   " BLKTYPE " ,   " GNUTYPE _ SPARSE "
在   3.1   版 更改 :   parse _ constant   不再 调用   ' null '   ，   ' true '   ，   ' false '
此 模块 提供 了 针对 tty   I / O   控制 的   POSIX   调用 的 接口
一个 返回 模块 源 的 抽象 方法
不同于 普通 赋值 ， 增强 赋值 会 在 对 右手边 求值 之前 对 左手边 求值
返回值 是 一个   " timedelta "   实例 ， 其值 等于 本地 时间 与   UTC   之间 的 时差
此外 ， 以下 方法 可用 来 解包 字符串 、 字节 串 以及 不 透明 数据 :
类似 的   " setcontext ( ) "   会为 当前 上下文 的 目标 自动 赋值
升级   optparse   代码   Part   of   the   Python   documentation ,   describing   how   to   convert   code   that   uses   " optparse " .
在 标识 因特网 上 的 事物 （ 例如 主机名 ） ， 经常 需要 比较 这些 标识 是否 （ 相等 ）
该 模块 作为 输入 的   CPython   字节 码 在 文件   " Include / opcode . h "   中 定义 ， 并 由 编译器 和 解释器 使用
单目 加和减 （ 一元 操作符 ） 意思 是从 空 计数器 加 或者 减去
对于 已 过时 并 预计 在 未来 弃用 ， 但 目前 尚未 弃用 的 特性 相关 警告 的 基类
然而 这种 做法 并 不 保险 ， 因为 当   on _ true   具有 布尔 假值 时 将 会 给出 错误 的 结果
在   3.4   版 更改 :   The   return   type   is   now   " unsigned   long "   rather   than   " long " .
返回 在   shell   中 执行   cmd   产生 的   " ( exitcode ,   output ) "
此 函数 总是 会 成功 执行
下面 是 一个 因为 此 限制 而 失败 的 例子 :
这个 API 与 教材 的 堆 算法 实现 有所不同 ， 具体 区别 有 两 方面 ： （ a ） 我们 使用 了 从零开始 的 索引
默认 的   base   为   10   ， 允许 的 进制 有   0 、 2   36
用于 Unicode 编码 错误 处理程序 的 注册表 API
node _ offset   :   节点 偏移量   ( 对于   BLAKE2b   为   0   至   2   64   1 ， 对于   BLAKE2s   为   0   至   2   48   1 ， 对于 最 左边 第一个 叶子 或 在 连续 模式 下则 为   0 )
如果   line   对于 给定 的 窗口 不可 用 则 会 引发   " curses . error "   异常
比较 一下 我们 将   x   ( a + b )   这样 的 公式 改写 为   x   a + x   b   的 容易 程度 ， 以及 使用 原始 OO 符号 做 相同 事情 的 笨拙 程度
举个 例子 ， 这 可能 包含 创建 临时 或 代理 的 数据库 、 目录 ， 再 或者 启动 一个 服务器 进程
落 在   m   个 排序 数据 点 的 第   i   th   个 以下 的 总体 部分 被 计算 为   " i   /   ( m   +   1 ) "
如果   suffix   不是   " None "   则 文件名 将 以 该 后缀 结尾 ， 是   " None "   则 没有 后缀
例如 ， 如果 他们 选择   " & "   作为 一个 新 的 元字符 ， 旧 的 表达式 将 假设   " & "   是 一个 普通 字符 ， 并且 不会 编写   " \ & "   或   " [ & ] "
返回   " not "   obj   的 结果
相当于   " put ( obj ,   False ) "
如果 第二个 参数 为 一个 对象 ， 则   " isinstance ( obj ,   type ) "   必须 为 真值
它们 是 使用   " yield   from "   语句 创建 的   Python   生成器 ， 可以 等待   Future   和 其他 协程
多余 的 参数 会 被 跳 过 ， 比如 :
为 方便使用 不同 类型 的 文件 ， argparse   模块 提供 了   FileType   工厂 类 ， 该类 接受   " mode   " ,   " bufsize   " ,   " encoding   "   和   " errors   "   等   " open ( ) "   函数参数
如果   using   为   " None "   ， 则 返回 适用 于 调用者 环境 的 默认 浏览器 的 控制器
参数 必须 不 为   " NULL " ， 并且 类型 不会 被 检查 :
调用   " Enum "   的 第一个 参数 是 枚举 的 名称
在   " check ( ) "   中 捕获 并 处理
Python   测试工具 分类 一个   Python   测试工具 的 详细 列表 ， 包含 测试 框架 和 模拟 对象 库
请 注意 ， 输出 需要 使用   “ 打印 ”   或   “ 写入 ”
对于 编码 操作 ， 将会 调用   error _ handler   并 传入 一个   " UnicodeEncodeError "   实例 ， 其中 包含 有关 错误 位置 的 信息
表达式   " x   if   C   else   y "   首先 是 对 条件   C   而 非   x   求值
等价 于   Python   语句   " o1   o2 "
虽然 某些 模块 被 设计 为 在 使用   " import   "   时 只 导出 遵循 某些 模式 的 名称 ， 但 在 生产 代码 中 它 仍然 被 认为 是 不好 的 做法
加载 包含 在 单元 的 第   i   个 空位 中 的 单元 并 释放 可用 的 存储空间
传递 给 内置 函数   " eval ( ) "   和   " exec ( ) "   的 字符串 参数 也 是 代码 块
mview   必须 是 一个   memoryview   实例 ； 这个 宏 不 检查 它 的 类型 ， 你 必须 自己 检查 ， 否则 你 将 面临 崩溃 风险
如果   newline   为   " ' ' " ， 也 会 启用 通用 换行 模式 ， 但行 结束符 会不加 转写 即 返回 给 调用者
想要 建立 一个 可 连接 的 端点 ， 应该 使用   ' 127.0 . 0.1 '
返回 弱 引用 对象   ref   的 被 引用 对象
具体做法 可以 是 在 命令行 提示符 中 运行   " compileall . py "   并 提供 包含 要 编译   Python   文件 的 目录 路径 :
如果 返回 码非 零则 会 引发   " CalledProcessError "
" ' minutes ' " :   以   " HH : MM "   格式 包含   " hour "   和   " minute "
虽然   " Enum " ,   " IntEnum " ,   " IntFlag "   和   " Flag "   预期 可 覆盖 大多数 应用 场景 ，   但 它们 无法 覆盖 全部
对象 中 的 重复 名称
按照 需要 使用   " addcomponent ( ) "   方法 向 此 对象 添加 多个 部件
该 构造 器 接受 一个 可选 的 整数 初始化 器 ； 不会 执行 溢出检查
基于 DLL 名称 的 文件 覆盖 基于 可执行文件 的 文件 ， 如果 需要 ， 可以 为 加载 运行 时 的 任何 程序 限制 路径
返回   o1   除以   o2   得到 的 余数 ， 如果 失败 ， 返回   " NULL "
设置 这些 变量 只会 在 Python 的 调试 版本 中 产生 影响
API   与 特性 的 移除
三个 值 也 可 通过 名称 来 访问 ， 因此   " curses . ncurses _ version [ 0 ] "   等价 于   " curses . ncurses _ version . major " ， 依此类推
引发 一个 审计 事件   " ctypes . addressof " ， 附带 参数   " obj "
csvfile   可以 是 任何 对象 ， 只要 这个 对象 支持   iterator   协议 并 在 每次 调用   " __ next __ ( ) "   方法 时 都 返回 字符串 ，   文件 对象 和 列表 对象 均 适用
被 队列 的 消费者 线程 使用
在 导入 搜索 期间 首先 会 被 检查 的 地方 是   " sys . modules "
默认 情况 下 ， " ZipInfo "   构造 器 将 将 此 成员 设 为   " ZIP _ STORED "
此 模块 可以 执行   Python   值 和 以   Python   " bytes "   对象 表示 的   C   结构 之间 的 转换
" CalledProcessError "   对象 将 在   " returncode "   属性 中 保存 返回 码 并 在   " output "   属性 中 保存 所有 输出
使用   " module   name "   参数 会 引发 审计 事件   " cpython . run _ module "
如果   " '   ' "   是   args   中 唯一 的 值 ， 则 会 从 标准 输入 获取 文件 列表
传递 指针 （ 或 以 引用 方式 传递 形参 ）
Python   3.5   有 什么 新 变化
引发 一个 审计 事件   " shutil . chown "   附带 参数   " path " ,   " user " ,   " group "
另 请参阅   " classmethod ( ) "   ， 用于 创建 备用 类 构造函数 的 变体
删除 和 弃 用 的 模块
" http . cookiejar "   — —   HTTP   客户端 的   Cookie   处理
除了   HTTPS ， 此 函数 还 应当 适用 于 各种 基于   SSL   协议 的 服务器 身份 检查 操作 ， 例如   FTPS ,   IMAPS ,   POPS   等等
这样 做 是 有用 的 ， 如果 使用 外部 编辑器 编 已经 辑 过 了 那个 模块 的 源代码 文件 并且 想 在 退出   Python   解释器 之前 试验 这个 新 版本 的 模块
bpo   33128 :   修复 导致 PathFinder 在 sys . meta _ path 上 出现 两次 的 错误
" __ future __ "   中 不会 删除 特性 的 描述
当 执行器 被 某些 原因 中断 而且 不能 用来 提交 或 执行 新 任务 时 就 会 被 引发 派 生于   " RuntimeError "   的 异常 类
数据 类 根本 不 使用 它 ， 它 是 作为 第三方 扩展 机制 提供 的
将 与   terminfo   功能 名称   capname   相对 应 的 布尔 功能 值以 整数 形式 返回
在 大多数 典型 应用 中 ， " parse _ args ( ) "   将 负责 任何 用法 和 错误 消息 的 格式化 和 打印
PEP   380 :   委托 给子 生成器 的 语法
它 在 被 调用 时会 将源 路径 和 目标 路径 作为 参数 传入
函数 的 执行 会 引入 一个 用于 函数 局部变量 的 新 符号表
这 应当 在   4   KiB   和   1.5   GiB   之间 （ 包含 边界 ）
这个 特性 可以 设置   " allow _ abbrev "   为   " False "   来 关闭 :
ISO   8601 标准 还 规定 了   0   和 负数 年份
需要 注意 的 是 部分 平台 对于 堆栈 大小 会 有 特定 的 限制 ， 例如 要求 大于 32KiB 的 堆栈 大小 或者 需要 根据 系统 内存 页面 的 整数倍 进行 分配 应当 查阅 平台 文档 有关 详细信息 （ 4KiB 页面 比较 普遍 ， 在 没有 更 具体 信息 的 情况 下 ， 建议 的 方法 是 使用 4096 的 倍数 作为 堆栈 大小 ）
优化 后 的   pickle   将 更为 简短 ， 耗费 更为 的 传输 时间 ， 要求 更少 的 存储空间 并 能 更 高效 地 解封
例如 ， 采用 以下 不 完整 的 代码段 :
可以 多次 使用 这个 选项 ， 以便 包含 匹配 子串 的 所有 测试用例
注释 在 语法分析 中会 被 忽略
请 使用   "   W "   " default "   命令行 选项 测试 你 的 应用程序 来 查看   " DeprecationWarning "   和   " PendingDeprecationWarning " ， 甚至 可以 使用   "   W "   " error "   将 它们 视为 错误
下面 是 一个 使用 迭代 器 形式 的 例子 ：
返回   Python   o   数据结构 的   JSON   字符串 表达方式
asyncio   同步 原语 被 设计 为 与   " threading "   模块 的 类似 ， 但 有 两个 关键 注意事项 :
推导 式 的 结构 是 一个 单独 表达式 后面 加 至少 一个   " for "   子句 以及 零个 或 更 多个   " for "   或   " if "   子句
data   必须 为   " str "   类型
key   一个 字符串 :   键   ( 例如   " a " )   或键标   ( 例如   " space " )
返回 具有 指定   year ,   month ,   day ,   hour ,   minute ,   second   和   microsecond   属性 的   " datetime . datetime "   对象
只 需 在 应用程序 的 所有 模块 中 导入 配置 模块 ； 然后 该 模块 可 用作 全局 名称
严格 地说 ， 将 数据 从 内部 形式 转换 为 外部 形式   ( 例如 用于   RPC   缓冲区 )   称为   " marshal "   而 其 逆 过程 则 称为   " unmarshal "
（ 由   Petter   Strandmark   在   bpo   35047   中 贡献 。 ）
它 返回 一个   type   的 新 实例 ， 该 实例 指向 与   obj   相同 的 内存 块
另 一个 与   C   不同之处 在于   " a   <   b   <   c "   这样 的 表达式 会 按 传统 算术 法则 来 解读 :
3.6   新版 功能 .
在 这些 例子 中 ， 请 注意 当 调用 一个 原地 方法 时 ， 运算 和 赋值 是 分成 两个 步骤 来 执行 的
这 意味着 ， 尽管   Python   2   会 继续 修复 bug 并 更新 ， 以便 在 新 的 硬件 和 支持 操作系统 版本 上 正确 构建 ， 但 不会 有 新 的 功能 发布
什么 是 确定性 性能 分析 ？
如果 在 获取 条目 时 发生 了 错误 ， 则 返回   " NULL "   并且 传递 异常
PEP   526 :   变量 注释 的 语法
如果 你 需要 调整 宽度 限制 则 应 显式 地 构造   " PrettyPrinter "   对象
https : / / en . wikipedia . org / wiki / Functional _ programming :   一般性 的 函数 式 编程 的   Wikipedia   条目
size   表示 可 使用   " undo ( ) "   方法 / 函数 撤消 的 海龟 命令 的 次数 上限
调用   " flush ( ) " ， 设置 目标 为   " None "   并 清空 缓冲区
bpo   33363 :   在 异步 函数 外 使用 ` ` async   with ` `   和   " async   for "   时 抛出   SyntaxError 异常
如果 线程 在 调用 此 方法 时 没有 获得 锁 ， 将会 引发   " RuntimeError "   异常
如果 你 的   SMTP   服务器 要求 验证 ， 你 可以 指定 一个   ( username ,   password )   元组 作为   credentials   参数
PEP   328 :   绝对 导入 和 相对 导入
" repr "   ： 如果 为 true （ 默认值 ） ， 则 该 字 段 包含 在 生成 的   " __ repr __ ( ) "   方法 返回 的 字符串 中
幸运 的 是 ， Python 解释器 是 比较 方便 回调 的 ， 并 给 标准 Python 函数 提供 了 标准接口
结合 位置 参数 和 可选 参数
返回 的 字节 数量 可能 少于 或 多于 请求 的 数量
如果   " B   < :   A "   ，   Python   在   " A .__ add __ "   之前 尝试   " B .__ radd __ "
" EmailMessage "   的 类 字典 接口 的 字典 索引 是 头 字段名 ， 头 字段名 必须 是 ASCII 值
用于 Unicode 编码 错误 处理程序 的 注册表 API
" Font "   类 表示 命名 字体
这 将 由 配置 系统 针对 它 所 了解 的 内容 隐式 地 完成
如果 两个 实参 都 省略 ， 则 返回   " 0j "
这个 类 只 适用 于 直接 与 硬件   “ 对话 ” ， 或者 执行 短暂 任务 具有 受限 中断 的 应用
请 注意 某些 此类 运算符 也 作用 于 特定 的 非 数字 类型
除了 上面 列举 的 操作 以外 ， " timedelta "   对象 还 支持 与   " date "   和   " datetime "   对象 进行 特定 的 相加 和 相减 运算 （ 见下文 ）
在   3.4   版 更改 .
2to3   自动 将   Python   2   代码 转为   Python   3   代码
如果 异常 没有 被 某个   " except "   子句 所 处理 ， 则 该 异常 会 在   " finally "   子句 执行 之后 被 重新 引发
数学 和 按位 运算 的 种类 是 最 多 的 ：
使用   Lock   的 推荐 方式 是 通过   " async   with "   语句 :
请 保存   p   的 原始 值 ， 以 避免 在 处理错误 时 丢失 内存
结果 的 符号 ， 如果 不为 零 ， 则 与 原始 除数 的 符号 相同
然而 ， 必须 这样 做 的 情况 相当 少见 ， 所以 这种 用法 还 没有 记录下来
在   3.2   版 更改 :   现在 如果 底层 线程 实现 支持 ， 则 可以 通过 POSIX 上 的 信号 中断 锁 的 获取
此 格式 的 时间 示 例如   " 2003   01   23   00 : 29 : 50 , 411 "
Windows   CE   仍然 受 支持
该 模块 定义 以下内容 ：
另外 ， 集合 对象 需要   " test _ c _ api ( ) "   方法
仅 当空 匹配 与 前 一个 空 匹配 不 相邻 时 ， 才 会 替换 空 匹配
在   " signal "   模块 中 定义 的 变量 是 ：
" doctest "   测试 交互性 的 Python 示例
这 其实 是   Distutils   默认 的 排布 ， 也 是 你 的 配置 脚本 中 需要 的 工作量 最小 的
这 遵循 一月 的 月 号 为   1   的 通常 惯例   ， 所以 它 的 长度 为   13   且   " month _ abbr [ 0 ] "   是 空 字符串
设置 默认 的 内容 类型
在   3.9   版 更改 :   增加 了   counts   形参
默认 情况 下 ， 每个 警告 都 对于 其 发生 所在 的 每个 源行 都 会 打印 一次
参见   coroutine   的 定义
一元 运算符   " + "   ( 正 )   会 产生 与其 数值 参数 相同 的 值
其次 ， 这 意味着 如果 要 显式 引用 或 从 特定 类 调用 该 方法 ， 不 需要 特殊 语法
摊销 表可 通过 累加 利息 和 支付 款项 得到
对   text   ( 字符串 )   中 的 单独 段落 自动 换行 以 使 每行 长度 最多为   " width "   个字符
" multiprocessing . sharedctypes "   模块   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
" struct "   将 字节 串 解读 为 打包 的 二进制 数据
例如 ， " sample ( [ ' red ' ,   ' blue ' ] ,   counts   [ 4 ,   2 ] ,   k   5 ) "   等价 于   " sample ( [ ' red ' ,   ' red ' ,   ' red ' ,   ' red ' ,   ' blue ' ,   ' blue ' ] ,   k   5 ) "
3.9   新版 功能 .
此外 ， " Formatter "   还 定义 了 一些 旨在 被子 类 替换 的 方法 ：
允许 非 资源 名字 被 返回 是 为了 允许 存储 的 一个包 和 它 的 资源 的 方式 是 已知 先验 的 并且 非 资源 名字 会 有用 的 情况
（ 由   Raymond   Hettinger   在   bpo   9025   中 贡献 。 ）
" import "   语句 是 发起 调用 导入 机制 的 最 常用 方式 ， 但 不是 唯一 的 方式
最 可能 的 原因 是 连接 丢失
这个 简单 的 例子 演示 了 一个 应用 如何 使用 对象   ID   来 提取 之前 出现 过 的 对象
一个 进程 可以 被   join   多次
如果   extent   不是 完整 圆周 ， 则 以 当前 画笔 位置 为 一个 端点 绘制 圆弧
" quoteattr ( ) "   将 基于   data   的 内容 选择 一个 引号 字符 ， 以 尽量避免 在 字符串 中 编码 任何 引号 字符
关联 的 值 是 一条 错误信息 ， 其中 包含 未找到 的 名称
不同 的   Python   实现 具有 不同 的 性能 特点
" mmap "   内存 映射 文件 支持
3.3   新版 功能 .
一些 整型 数字 面值 的 示例 如下 :
" _ value _ "   成员 的 值 ； 可以 在   " __ new __ "   中 设置   /   修改
最大 的 日期   ， " date ( MAXYEAR ,   12 ,   31 ) "
开启 一个 新 线程 并 返回 其 标识
使用   " c _ char _ p "   实例 化 的 对象 只能 将 其值 设置 为   bytes   或者 整数
（ 由   Batuhan   Taskaya   在   bpo   40192   中 贡献 。 ）
特别 地 ， 子 解析器 ， " argparse . REMAINDER "   以及 同时 包括 可选 与 位置 参数 的 互斥 分组 是 不受 支持 的
请 注意 ， 此 方法 会 自动 添加 到 类 中 ： 它 不会 在 上面 显示 的   " InventoryItem "   定义 中 直接 指定
其中 最 常用 的 列表   ， 可以 通过 方括号 括起 、 逗号 分隔 的 一组 值得 到
任何 其他 修改 可以 用   " __ new __ ( ) "   也 可以 用   " __ init __ ( ) " ， 应 优先 使用   " __ init __ ( ) "
如果 为 字符 设备 、 块 设备 或   FIFO   之一 则 返回   " True "
解码   input   对象 并 返回 一个 元组   ( 输出 对象 ,   消耗 长度 )
请 注意 使用 此 函数 时 ， 如果 存在 状态 未知 的 其他 线程 ， 则 可能 需要 执行 外部 同步
部分 仅 针对   Mozilla   项目 ， 不过 其 描述 了 通用 的 恰当 做法
" fromstring ( ) "   将 XML 从 字符串 直接 解析 为   " Element "   ， 该 元素 是 已 解析 树 的 根 元素
首先 ， 它们 向 应用 程序代码 公开 了 几种 方法 ， 以便 应用程序 可以 在 运行 时 记录 消息
" json "   JSON   编码 和 解码器
本 例程 所 需 的 时间 与   " len ( fragment ) "   成正比
Python   3.6   有 什么 新 变化
PEP   273 :   从 ZIP 压缩包 导入 模块
添加   " \ N { name } "   转义 符在   " 正则表达式 "   中 的 支持 :
何时 使用   " __ new __ ( ) "   与   " __ init __ ( ) "
看起来 无害 是 吧 ， 但 却 不是
调用   < new _ target > . dnd _ enter ( source ,   event )
通过 对此 属性 赋值 就 可以 在   " StreamReader "   对象 的 生命 期内 在 不同 的 错误处理 策略 之间 进行 切换
创建 一个   " instance "   相同 类型 的 新 对象 ， 用   " changes "   中 的 值 替换 字 段
如果 没有 一个   Task   名称 被 显式 地 赋值 ， 默认 的   asyncio   Task   实现 会 在 实例 化 期间 生成 一个 默认 名称
返回 的 数据 应当 与 之前 任何   " decompress ( ) "   调用 的 输出 进行 拼接
" Counter "   类 有点像 其他 语言 中 的   bags 或 multisets
这些 将 传到   time . tzname
" getch ( ) "   的 宽 字符 版本 ， 返回 一个   Unicode   值
给出 一个 由   " Differ . compare ( ) "   或   " ndiff ( ) "   产生 的 序列   ， 提取 出来 自 文件   1   或   2   (   which   形参 )   的 行 ， 去除 行 前缀
返回 邮件 上 的 标签 列表
3.9   新版 功能 .
如果 存在 被 保存 的 异常   ， 它会 在   " finally "   子句 的 末尾 被 重新 引发
对于   " ' r ' "   ,   提供 的 精度 必须 是 0
这 将 防止   " '   abcd ' "   直接 与 第二个 序列 末尾 的   " '   abcd ' "   相匹配
与   " as _ string ( policy   self . policy . clone ( utf8   True ) ) "   等价
前往 行   Move   the   cursor   to   the   beginning   of   the   line   requested   and   make   that   line   visible
唤醒 所有 正在 等待 此 条件 的 任务
该 模块 不 复制 模块 、 方法 、 栈 追踪 （ stack   trace ） 、 栈帧 （ stack   frame ） 、 文件 、 套 接字 、 窗口 、 数组 以及 任何 类似 的 类型
此 上下文 被   " Context "   构造 器 用作 新 上下文 的 原型
" contextlib "   模块 的 文档
对 Python   语言 核心 进行 的 小 改动 ：
该 方法 返回 一个 布尔值 :   如果 填充 过程 正在 进行 为   " True " ， 否则 为   " False "
MandatoryRelease   也 可能 是   " None " ,   表示 这个 特性 已经 被 撤销
用于 创建 和 运行 服务器 的 代码 看起来 像 这样 ：
PEP   338   定义 了 将 模块 作为 脚本 执行
如果 日志 当前 未 打开 则   " syslog ( ) "   将 不带 参数 地 调用   " openlog ( ) "
如果 你 的 两个 列表 长度 为 3 ， 那么 输出 的 列表 长度 就是 9 :
嵌套 的 元组 在 使用 关键字 参数 时 无法 生效 ， 不 在   kwlist   中 的 关键字 参数 会 导致   " TypeError "   异常
这个 参数 发生 了 什么 事 ？   当不带 参数 地 调用 一个 需要 参数 的 函数 时   Python   肯定 会 引发 异常 即使 参数 实际 未 被 使用 ...
如果 给定 了   compress _ type   ， 它 将 会 覆盖 作为 新 条目 构造 器 的   compression   形参 或 在   zinfo _ or _ arcname   ( 如果 是 一个   " ZipInfo "   实例 )   中 所 给出 的 值
您 还 可以 在   " global "   赋值 之前 看到 之前 没有   spam   的 绑定
采样 大小 是 以 字节 表示 的 每次 采样 的 大小
当 存在 重复 的 键 时 ， 如果   override   真值 则 最后 出现 的 键 胜出
其他 模块 级 更改
如果   flag   为   " True " ， 则   " syncup ( ) "   会 在 窗口 发生 改变 的 任何 时候 自动 被 调用
否则 ， 它 将 是 一个   " ValueError "   来 编码 这些 浮点数
它会 使用   onerror   回调 函数 来 清除 只读 属性 位 并 再次 尝试 删除
大多数   Python   用户 不会 想要 直接 使用 这个 包 ， 而是 使用   Python   包 官方 维护 的 跨 版本 工具
" inspect "   检查 对象
前面 的 字母 可能 会 不同 ， 而且 后面 有 可能 会 有 其他 东西 ， 所以 你 也许 会 看到 类似 这样 的 东西 ：
创建 一个   " FileInput "   类 的 实例
3.2   新版 功能 .
3.9   版后 已 移除 :   " collections . abc . Sequence "   now   supports   " [ ] "
" netrc "   的 实例 或 其子 类 的 实例 会 被 用来 封装 来自   netrc   文件 的 数据
例如 ， 对于 有 如下 代码 的 名为   " myprogram . py "   的 文件 ：
object   or   type   的   " __ mro __ "   属性 列出 了   " getattr ( ) "   和   " super ( ) "   所 共同 使用 的 方法 解析 搜索 顺序
根据 指定 的 矩阵 修改 拉伸 因子 ， 剪切 因子 和 倾角
返回 具有 行 缓冲 的 正常   " cooked "   模式
" xml . dom . minidom "   的   " writexml ( ) " ,   " toxml ( ) "   和   " toprettyxml ( ) "   方法 以及   " xml . etree "   的   " write ( ) "   方法 现在 会 保留 用户 指定 的 属性 顺序
删除 在 光标 之下 的 行
使用   detect _ types   参数 和 模块 级别 的   " register _ converter ( ) "   函数 注册 转换器 可以 简单 的 实现
在   3.3   版 更改 :   Updated   to   be   based   directly   on   " importlib "   rather   than   relying   on   the   package   internal   PEP   302   import   emulation .
你 可能 想 知道 为什么 追加 一个 元素 也 改变 了 x
反 斜杠 不能 用来 拼接 形符 ， 字符串 除外   ( 即 原文 字符串 以外 的 形符 不能 用 反 斜杠 分隔 到 两个 物理 行   )
显示 调用 贴士 在 函数 的 右 括号 后 ， 打开 一个 带有 函数参数 提示 的 小 窗口
缓冲区 接口 使得 对象 可以 选择性 地 允许 或 拒绝 读写 或 只读 缓冲区 的 导出
在   3.5   版 更改 :   现在 支持 匹配 存在 于 证书 的   subjectAltName   字段 中 的   IP   地址
标志 位是 由 零至 四个 值为   " 1 "   的 二进制位 加 一个 值为   " 0 "   的 二进制位 构成 的 序列
可以 直接 给 它 赋值 ， 这样 可以 覆盖 自动 选择 的 路径 ， 但是 不 建议 这样 做
从 代码 对象 中 提取 函数 的 文档 字符串 和 名称
可选 的   info   参数 应为 一个 包含 异常 类型 ， 异常 值 和 回溯 对象 的   3   元组 ，   与   " sys . exc _ info ( ) "   所 返回 的 元组 完全一致
在   3.6   版 更改 :   接受 一个   path   like   object
如何 从 覆盖 基类 的 派生类 调用 基类 中 定义 的 方法 ?
数据 属性 对应 于   Smalltalk   中 的 “ 实例 变量 ” ， 以及   C++   中 的 “ 数据 成员 ”
与   Unicode   相关 的 警告 的 基类
返回 一个 包含 字典 中 所有 值 ( values ) 的   " PyListObject "
" IncrementalDecoder "   实例 的 构造 器
在此之后 对   " _ fields _ "   类 变量 赋值 将会 引发   AttributeError
但   ' A . BB ' ,   ' B . A . B '   等 则 不 允许
在   3.5   版 更改 :   A   list   of   named   tuples   " FrameInfo ( frame ,   filename ,   lineno ,   function ,   code _ context ,   index ) "   is   returned .
参见   " get _ ident ( ) "   函数
这 足以 使 脚本 在 命令提示符 下 作为 “ foo . py ” 命令 被 执行
为什么 原始 字符串 （ r   strings ） 不能 以反 斜杠 结尾 ？
构造 器 接受 的 可选 参数 与 传递 给   " sys . exit ( ) "   的 相同
当 轮换 时 修改 日志 文件 的 文件名
并且 空 字符串 意味着 遍历 脚   本 决定 是否 关注 窗口
在 一个   except   子句 体 被 执行 之前 ， 有关 异常 的 详细信息 存放 在   " sys "   模块 中   ， 可 通过   " sys . exc _ info ( ) "   来 访问
[ 1 ]   虽然   " abs ( x% y )   <   abs ( y ) "   在 数学 中必 为 真 ， 但 对于 浮点数 而言 ， 由于 舍入 的 存在 ， 其 在 数值 上 未必 为 真
删除 对 Python   2.6 及 更 早 版本 的 支持
" dataclass ( ) "   装饰 器 将 向 类 中 添加 各种 “ dunder ” 方法 ， 如下 所述
如果 在 该 语句 体中 发生 了 未 处理 的 异常 ， 则 该 异常 会 在 生成器 发生   yield   时 重新 被 引发
本 指南 讨论 了   Python   对于 表达 文本 数据 的   Unicode   规范 的 支持 ， 并且 解释 了 人们 试图 使用   Unicode   时 经常 遇到 的 问题
" ttk . Widget "   定义 了 由   Tk   带 主题 部件 所 支持 的 标准 选项 和 方法 ， 它们 不 应该 被 直接 实例 化
PEP   3112 :   字节 字 面值
然而 ， 对于 一个 中等 复杂程度 的 生成器 ， 写出 一个 相应 的 类 可能 会 相当 繁杂
而 最后 一个 则 在 同一 函数 定义 中 使用 了 全部 三种 调用 方式 :
在   3.6   版 更改 :   关键字 参数 会 被 打包 为 一个 元组 而 非 字典 ，   argc   指明 参数 的 总 数量
现在 假设 原来 的 成员 1 是 用户 定义 类 的 实例 ， 且 假设 这个 类 定义 了   " __ del __ ( ) "   方法
如果 你 想 找到   adler32   或   crc32   哈希 函数 ， 它们 在   " zlib "   模块 中
可选 的   lock   参数 必须 为   " Lock "   对象 或   " None "
如果 参数 不 在 这些 范围 内 ， 则 抛出   " ValueError "   异常
3.2   新版 功能 .
如果 未 在 其中 找到 指定 名称 ， 再 搜索 内置 命名 空间
类 方法 从 存在 的 序列 或 迭代 实例 创建 一个 新 实例
在   3.8   版 更改 :   Setting   workers   to   0   now   chooses   the   optimal   number   of   cores .
3.4   新版 功能 .
因此 ， 如果 所 输入   iterable   是 已 排序 的 ， 组合 元组 也 将 按 已 排序 的 顺序 生成
3.6   新版 功能 .
返回 的 文件 描述符 可以 被 用作   " os . fdopen ( ) "   的 形 参以 创建 一个 文件 对象
本文 解释 了 与 3.5 相比 ， Python   3.6 中 的 新 功能
Python   只有 一种 模块 对象 类型 ， 所有 模块 都 属于 该 类型 ， 无论 模块 是 用   Python   、 C   还是 别的 语言 实现
反 斜杠   ( " \ " )   字符 被 用来 对 特殊 含义 的 字符 进行 转义 ， 例如 换行 ， 反 斜杠 本身 或是 引号 等 字符
[ 1 ]   在 执行命令 时 键入 中断 引发 的   " KeyboardInterrupt "   异常 ， 可以 由   " try "   语句 处理
使用 C 的 数据结构 类型   TYPE   和 Python 的 类型 对象   type   分配 一个 新 的   Python 对象
返回 分组 的 连续 数据 的 中位数 ， 根据 第   50   个 百分点 的 位置 使用 插值 来 计算
PEP   378 :   千位 分隔符 的 格式 说明符
此 处理程序 不会 调用   " format ( ) " ， 而是 调用   " mapLogRecord ( ) "   然后 再 调用   " urllib . parse . urlencode ( ) "   来 以 适合 发送至   Web   服务器 的 形式 对 字典 进行 编码
如果 模块 是 被 导入 的 ， 那些 代码 是 不 运行 的 :
PEP   3151 :   重写   OS   和   IO   异常 的 层次结构
这 对于 访问 已 在 类 中 被 重载 的 继承 方法 很 有用
Python   的   curses   模块
3.7   新版 功能 .
" __ future __. py "   中 的 每 一条 语句 都 是 以下 格式 的 ：
复制 枚举 成员 和 值
assert   语句 是 在 程序 中 插入 调试 性 断言 的 简便 方式 :
已 支持 并且 已 在   " http . HTTPStatus "   IANA   注册 的 状态 码有 ：
所以 统一 差异 是 一种 只 显示 有 更改 的 行 再加 几个 上下文 行 的 紧凑 形式
返回 一个 新 的 “ bytes ” 对象 ，   是 一个 不可 变 序列 ， 包含 范围 为   " 0   <   x   <   256 "   的 整数
请参阅 附录 ： 设置 环境变量 了解 启动   Python   的 其他 方式
触碰 已 在 窗口 中 被 改变 的 此 窗口 的 各个 上级 窗口 中 的 所有 位置
在   3.3   版 更改 :   移 除了 在 2.4 版本 中 被 弃 用 的   strict   参数
用此 方式 创建 的 函数 对象 默认 接受 任意 数量 的 参数 ， 接受 任意   ctypes   数据 实例 作为 参数   ， 并且 返回 库 加载 器所 指定 的 默认 结果 类型
在   " yield "   和   " return "   语句 中 的 一般 可 迭代 对象 解包 不再 要求 加 圆括号
返回 两个   Task / Future   集合 :   " ( done ,   pending ) "
该 构造 器 接受 一个 可选 的 整数 初始化 器   ； 不会 执行 溢出检查
如果 被 引用 对象 不再 存在 ， 则 返回   " Py _ None "
调用 一个 可 调用 对象 并 传入 位置 参数
通过 输出 变量   buffer   和   length   返回 以   null   为 终止符 的 对象   obj   的 内容
（ 但是 ， 发布 预期 在 其 安装 目录 中 被 构建 的 扩展 几乎 总是 一个 坏主意 。 ）
等待   obj   的   " Task "   对象 ， 如果   obj   是 一个 可 等待 对象 (   " inspect . isawaitable ( ) "   用于 测试 )
有关 执行 此 操作 的 许多 方法 的 详细 讨论 ， 请参阅   Python   Cookbook :
在   Windows   上 ，   " find _ library ( ) "   在 系统 路径 中 搜索 ， 然后 返回 全 路径 ， 但是 如果 没有 预定 义 的 命名 方案 ，   " find _ library ( " c " ) "   调用 会 返回   " None "
" cmd "   支持 面向 行 的 命令 解释器
参见 :   Microsoft   DUMPBIN   工具 一个 用于 查找   DLL   依赖 的 工具
除了 仅仅 报告 您 所 发现 的 错误 之外 ， 同样 欢迎您 提交 修复 它们 的 补丁
调用   " PyObject _ SetAttrString ( ) "   为 模块 中 的 变量 赋值 也 是 可以 的
变种 与 格式 参数
当   o1   支持 时 ， 这个 运算 直接 使用 它 储存 结果
在 模块 创建 完成 但 还 未 执行 之前 ， 导入 机制 会 设置 导入 相关 模块 属性 （ 在 上面 的 示例 伪 代码 中为   “ _ init _ module _ attrs ” ） ， 详情 参见 后续 部分
需要 注意 只有   doctests   会 被 重构
反之   (   block   是   false )   ,   如果 一个 项目 立即 可 得到 ， 则 返回 一个 项目 ， 否则 引发   " Empty "   异常   ( 这种 情况 下 ，   timeout   将 被 忽略 )
( 单位 默认 为 角度 ， 但 可 通过   " degrees ( ) "   和   " radians ( ) "   函数 改变 设置 。 )   角度 的 正负 由 海龟 模式 确定 ， 参见   " mode ( ) "
在   3.2   版 更改 :   添加 了   source _ address   ,   context   和   check _ hostname
" 0   <   seconds   <   3600   24 "   ( 一天 的 秒数 )
传给   " tp _ traverse "   处理 的 访问 函数 的 类型
最小值 先 被 取出 (   最小值 条目 是 由   " sorted ( list ( entries ) ) [ 0 ] "   返回 的 条目 )
Python   Shell   打开 或 唤醒 Python   Shell 窗口
使用 连接 作为 上下文 管理器
可选 的   facility   关键字 参数   ( 默认 为   " LOG _ USER " )   为 没有 显式 编码   facility   的 消息 设置 默认 的   facility
" pencolor " :   颜色 字符串 或 颜色 元组
为了 满足 这种 对 附加 信息 的 需求 ， 你 可以 通过 调用 提供 的   " field ( ) "   函数 来 替换 默认 字 段值
这样 的 类型 或类 还 可能 拥有 其他 特性
这 相当于   Python   表达式   " len ( o ) "
它 有 两个 基本 方法 ，   " acquire ( ) "   和   " release ( ) "
这个 异常 的 属性 将 设置 为 参数 ,   退出 码 ,   以及 标准 输出 和 标准 错误 ,   如果 被 捕获 到 .
Ahlstrom   编写 ， 他 也 提供 了 实现
" FirstHeaderLineIsContinuationDefect "   消息 以 一个 继续 行 作为 其 第一个 标头行
由   Pablo   Galindo   Salgado 提供 补丁
强制   stdout   和   stderr   流 不 使用 缓冲
当 使用   " noqiflush ( ) "   例程 时 ， 与   " INTR " ,   " QUIT "   和   " SUSP "   字符 相关联 的 输入 和 输出 队列 的 正常 刷新 将 不会 被 执行
后续 导入   " parent . two "   或   " parent . three "   则 将 分别 执行   " parent / two / __ init __. py "   和   " parent / three / __ init __. py "
访问   dll   的 导出 变量
" a   ifloordiv ( a ,   b ) "   等价 于   " a   / /   b "
在   3.5   版 更改 :   On   Windows ,   the   function   now   also   supports   socket   handles .
每个 Python 开发人员 都 应该 在 某个 时候 阅读 它 ； 以下 是 为 你 提取 的 最 重要 的 几个 要点 ：
由于 这种 表示法 是 精确 的 ， 它 适用 于 跨越 不同 版本 （ 平台 无关 ） 的   Python   移植 数值 ， 以及 与 支持 相同 格式 的 其他 语言 （ 例如   Java   和   C99 ） 交换 数据 .
如其 为 负值 ， 则 再 加上 序列 长度
编码 二进制   input   文件 的 内容 并 将 经   base64   编码 的 数据 写入   output   文件
3.4   新版 功能 .
在   3.6   版 更改 :   接受 一个 类 路径 对象
（ 由   Victor   Stinner   在   bpo   26516   和   bpo   26564   中 贡献 。 ）
函数   " spam _ system ( ) "   按照 如下 方式 修改 :
当 调用   " exec _ module ( ) "   的 时候 ， 那个 模块 应该 已经 被 初始化 了
Python 中 的 引用 计数
另 请参阅   " sys . version " ,   " sys . hexversion "   以及   " sys . version _ info "   的 文档
检测   ASCII   字母 类 字符 ； 它 等价 于   " isupper ( c )   or   islower ( c ) "
是 的 ， 您 可以 继承 内置 类 ， 例如   " int "   ，   " list "   ，   " dict "   等
抽象 基类   继承 自   抽象 方法   Mixin   方法   " Container "   " __ contains __ "   " Hashable "   " __ hash __ "   " Iterable "   " __ iter __ "   " Iterator "   " Iterable "   " __ next __ "   " __ iter __ "   " Reversible "   " Iterable "   " __ reversed __ "   " Generator "   " Iterator "   " send " ,   " throw "   " close " ,   " __ iter __ " ,   " __ next __ "   " Sized "   " __ len __ "   " Callable "   " __ call __ "   " Collection "   " Sized " ,   " Iterable " ,   " __ contains __ " ,   " Container "   " __ iter __ " ,   " __ len __ "   " Sequence "   " Reversible " ,   " __ getitem __ " ,   " __ contains __ " ,   " __ iter __ " ,   " __ reversed __ " ,   " index " ,   " Collection "   " __ len __ "   and   " count "   " MutableSequence "   " Sequence "   " __ getitem __ " ,   继承 自   " Sequence "   的 方法 ， 以及   " append " ,   " reverse " ,   " __ setitem __ " ,   " extend " ,   " pop " ,   " remove " ， 和   " __ iadd __ "   " __ delitem __ " ,   " __ len __ " ,   " insert "   " ByteString "   " Sequence "   " __ getitem __ " ,   继承 自   " Sequence "   的 方法   " __ len __ "   " Set "   " Collection "   " __ contains __ " ,   " __ le __ " ,   " __ lt __ " ,   " __ eq __ " ,   " __ ne __ " ,   " __ gt __ " ,   " __ iter __ " ,   " __ len __ "   " __ ge __ " ,   " __ and __ " ,   " __ or __ " ,   " __ sub __ " ,   " __ xor __ " ,   and   " isdisjoint "   " MutableSet "   " Set "   " __ contains __ " ,   继承 自   " Set "   的 方法 以及   " clear " ,   " pop " ,   " remove " ,   " __ iter __ " ,   " __ len __ " ,   " __ ior __ " ,   " __ iand __ " ,   " __ ixor __ " ， 和   " __ isub __ "   " add " ,   " discard "   " Mapping "   " Collection "   " __ getitem __ " ,   " __ contains __ " ,   " keys " ,   " items " ,   " values " ,   " get " ,   " __ iter __ " ,   " __ len __ "   " __ eq __ " ,   and   " __ ne __ "   " MutableMapping "   " Mapping "   " __ getitem __ " ,   继承 自   " Mapping "   的 方法 以及   " pop " ,   " popitem " ,   " __ setitem __ " ,   " clear " ,   " update " ， 和   " setdefault "   " __ delitem __ " ,   " __ iter __ " ,   " __ len __ "   " MappingView "   " Sized "   " __ len __ "   " ItemsView "   " MappingView " ,   " Set "   " __ contains __ " ,   " __ iter __ "   " KeysView "   " MappingView " ,   " Set "   " __ contains __ " ,   " __ iter __ "   " ValuesView "   " MappingView " ,   " __ contains __ " ,   " __ iter __ "   " Collection "   " Awaitable "   " __ await __ "   " Coroutine "   " Awaitable "   " send " ,   " throw "   " close "   " AsyncIterable "   " __ aiter __ "   " AsyncIterator "   " AsyncIterable "   " __ anext __ "   " __ aiter __ "   " AsyncGenerator "   " AsyncIterator "   " asend " ,   " athrow "   " aclose " ,   " __ aiter __ " ,   " __ anext __ "
memo   可以 是 一个 将 被 用作   pickle   的 备忘 记录 的   Python   字典 ； 它 可 被 用来 对 由 同一 封存 器 创建 的 多个 封存 对象 执行 反汇编
创建 一个 压缩文件 :
许多 使用   " functools . reduce ( ) "   的 情形 可以 更 清晰 地 写成   " for "   循环 的 形式
3.2   新版 功能 .
这 可以 是 一个 可变 字典 或   " NULL "
接口 选项   for   equivalent   functionality   on   the   command   line   ( " python   path / to / script " ) .
默认值   " ' strict ' "   表示 在 出现 编码 错误 时 引发   " ValueError "
一个   ISO   年 的 第一个 星期 就是 （ 格列 高利 ） 历法 的 一年 中 第一个 包含 星期四 的 星期
出于 多种 原因 它 被 证明 是 非常 有用 的
另外 ， 在 抽象 语法 定义 的 右侧 ， 对 每 一个 构造 器 也 定义 了 一个 类 ； 这些 类 继承 自树 左侧 的 类
在   3.5   版 更改 :   If   you   are   patching   builtins   in   a   module   then   you   don ' t   need   to   pass   " create   True " ,   it   will   be   added   by   default .
对于 二进制 模式 ， 这个 函数 等价 于   " BZ2File "   构造 器 :   " BZ2File ( filename ,   mode ,   compresslevel   compresslevel ) "
例如 ， 一个 统计 用 的 包 可能 包含 一个 实验 数据 的 容器 类
终端 通常 会以 多 字节 转义序列 的 形式 返回 特殊 按键 ， 比如 光标键 和 导航键 比如   Page   Up   键 和   Home   键
新 的 内置 特性 ：
因为 每个 平台 都 实现 了   " strftime ( ) "   ， 它 有时 会 提供 比 列出 的 指令 更 多 的 指令
" stretchfactor " :   ( 正 数值 ,   正 数值 )
在 配置 字典 中 ， 这是 通过 给 每个 目标 对象 一个   ID   来 无 歧义 地 标识 它 ， 然后 在 源头 对象 中 使用 该   ID   来 实现 的
当 你 开始 使用 本 方法 返回 的 文件 执行 任何 操作 时 ， 可能 有人 已经 捷足先登 了
请 参见 Unix 手册 页   vsnprintf ( 2 )
以下 是 一些 简单 的 例子 :
通常 ， 当前 局部 作用域 将 （ 按 字面 文本 ） 引用 当前 函数 的 局部 名称
如果   timeout   是 正数 ， 将会 在 阻塞 了 最 多   timeout   秒 之后 还是 没有 可用 的 对象 时 抛出   " queue . Empty "   异常
默认值   1   表示 将 使用 默认 的 缓冲区 大小
不 保存 其它 对象 的 引用 的 类型 ， 或者 只 保存 原子 类型 （ 如 数字 或 字符串 ） 的 引用 的 类型 ， 不 需要 显式 提供 垃圾 回收 的 支持
本章 将 讨论 一些 可能性
" dbm . gnu "   GNU   对   dbm   的 重 解析
构造函数 有 三个 可 选 参数   — —   消息 格式 字符串 、 日期 格式 字符串 和 样式 指示 符
比较   fromlines   和   tolines   ( 字符串 列表 )   并 返回 一个 字符串 ， 表示 一个 完整   HTML   文件 ， 其中 包含 各行 差异 的 表格 ， 行间 与 行外 的 更改 将 突出 显示
要 通过   " LZMADecompressor "   来 解压缩 多个 数据流 输入 ， 你 必须 为 每个 数据流 都 创建 一个 新 的 解 压缩器
" nis "   Sun   的   NIS   ( 黄页 )   接口
如果   " errcheck "   不 加 更改 地 返回 它 所 接收 的 参数 元组 ， 则   " ctypes "   会 继续 对 输出 形参 执行 常规 处理
" wave "   模块 定义 了 以下 函数 和 异常 :
其 保持 了 向 后 兼容 （ 如 您 所愿 ） ， 但 通过 显示 指定 样式 参数 ， 你 可以 指定 格式化 字符串 的 方式 是 使用   " str . format ( ) "   或   " string . Template "
参数 单位 的 换算 规则 如下 ：
已弃 用 和 不再 使用 的
" LoggerAdapter "   的   " process ( ) "   方法 是 将 上下文 信息 添加 到 日志 的 输出 中
栅栏 对象 可以 被 多次 使用 ， 但 进程 的 数量 不能 改变
返回 信息 头 当中   Content   Disposition   字 段 当中 名为   " filename "   的 参数值
如果 没有 余下 的 值 ， 则 返回   " NULL "   并且 不 设置 异常
要 处理 平台 独立 的 数据格式 或 省略 隐式 的 填充 字节 ， 请 使用   " standard "   大小 和 对齐 而 不是   " native "   大小 和 对齐 ： 详情 参见 字节 顺序 ， 大小 和 对齐 方式
定义 了 所 描述 类 的 模块 名称
指向 由 缓冲区 字 段 描述 的 逻辑 结构 开始 的 指针
失败 时 引发   " SystemError "   异常 并 返回   "   1 "
检查 此 记录器 是否 配置 了 任何 处理器
" for "   语句 会为 你 自动 处理 那些 操作 ， 创建 一个 临时 的 未命名 变量 用来 在 循环 期间 保存 迭代 器
创建 一个   " Calendar "   对象
使用   C   结构 类型   TYPE   和   Python   类型 对象   type   分配 一个 新 的   Python   对象
" malloc " :   对 所有 域   ( " PYMEM _ DOMAIN _ RAW " ,   " PYMEM _ DOMAIN _ MEM " ,   " PYMEM _ DOMAIN _ OBJ " )   使用   C   库 的   " malloc ( ) "   函数
PEP   278   通用 换行 支持 由   Jack   Jansen   撰写 并 实现
与   immutable   的 字符串 不同 ,   列表 是 一个   mutable   类型 ， 就是说 ， 它 自己 的 内容 可以 改变 :
使用   Python   是否 存在 版权 限制 ？
如果   set   不是   " set "   或 其子 类型 的 实例 则 会 引发   " SystemError "
设置 要 报告 的 鼠标 事件 ， 并 返回 一个 元组   " ( availmask ,   oldmask ) "
唯一 的 例外 是   " __ main __ " ， 其中 的   " __ spec __ "   会 在 某些 情况 下设 为   None .
3.3   版后 已 移除 :   现在 可以 让   " classmethod "   配合   " abstractmethod ( ) "   使用 ， 使得 此 装饰 器 变得 冗余
winmode   参数 用于 在   Windows   平台 上 指定 库 的 加载 方式 (   因为   mode   会 被 忽略 )
PEP   498 :   格式化 的 字符串 文字
" MagicMock "   是   " Mock "   的 子类 ， 它 有 所有 预 创建 且 可 使用 的 魔术 方法
frame   参数 必须 不 为   " NULL "
" webbrowser "   方便 的 Web 浏览器 控制器
推送   ch   以便 让 下 一个   " getch ( ) "   返回 该 字符
它 允许 基于 每个 模块 在 某种 新 特性 成为 标准 之前 的 发行版 中 使用 该 特性
窗口 中 每个 字符 的 属性 会 被 修改 为 新 的   background   属性
PEP   445   Add   new   APIs   to   customize   Python   memory   allocators   PEP   由   Victor   Stinner   撰写 并 实现
PySide   则 可以 自由 使用 于 各类 软件
对于 这些 任务 ， 你 也 可以 写 Unix 脚本 或者 Windows 批处理 完成 ， 但是 shell 脚本 最 擅长 移动 文件 和 替换 文本 ， 并 不 适合 GUI 界面 或者 游戏 开发
处理 捕获 组 的 匹配 对象 方法 都 接受 按 编号 引用 组 的 整数 或 包含 所需 组名 的 字符串
否则 实现   " TOS   iter ( TOS ) "
如果 你 只 对 两个 序列 相匹配 的 位置 感兴趣 ， 则   " get _ matching _ blocks ( ) "   就 很 方便 ：
减少 对象   o   的 引用 计数
解析 由   " DictConfigurator "   类 执行 ， 该类 的 构造 器 可 传入 用于 配置 的 字典 ， 并且 具有   " configure ( ) "   方法
如果 你 不再 需要 之前 使用   " getline ( ) "   从文件 读取 的 行 即可 使用 此 函数
更新 窗口 所有 上级 窗口 的 当前 光标 位置 以 反映 窗口 的 当前 光标 位置
" lzma "   用   LZMA   算法 压缩
另一方面 ， 如果 实参 是 整数 或 浮点数 ， 则 返回 具有 相同 值 （ 在   Python   浮点 精度 范围 内 ） 的 浮点数
在 以下   " tzinfo _ examples . py "   文件 中有 一些   " tzinfo "   类 的 例子 ：
" asyncio . Task . current _ task ( ) "   和   " asyncio . Task . all _ tasks ( ) "   已 被 移除
总计 值   " lc   +   lp "   必须 不 大于   4
PEP   389   新 的 命令行 解析 模块   PEP   由   Steven   Bethard   撰写
" N "   ( object )   [ PyObject   ]   和   " O "   相同 ， 然而 它 并 不 增加 对象 的 引用 计数
3.3   新版 功能 .
为 解决 这个 问题 配置 解析器 还 提供 了   " getboolean ( ) "
可以 使用 描述 器来 创建 具有 不同 实现 细节 的 实例 变量
此 扩展 模块 旨在 匹配   ncurses   的   API ， 这是 一个 部署 在   Linux   和   Unix   的   BSD   变体 上 的 开源   curses   库
这是 一个   " PyTypeObject "   实例 并 表示   Python   函数 类型
表 被 声明 为 object : : 类型 的 三个 字 段 :
这 用于 标记 降序 排序
类 定义 了   __ del __   方法 ， 但是 删除 对象 时 没有 调用 它
参数 :   t11   一个 数值   ( 可 选 )
两个 多项 集若要 相等 ， 它们 必须 为 相同 类型 、 相同 长度 ， 并且 每 对 相应 的 元素 都 必须 相等 （ 例如 ， " [ 1 , 2 ]   ( 1 , 2 ) "   为 假值 ， 因为 类型 不同 ）
为什么   list . sort ( )   没有 返回 排序 列表 ？
kevent   在 内部 存储 整数
请 注意 如果   except   子句 被 颠倒 （ 把   " except   B "   放到 第一个 ） ， 它 将 打印   B ，   B ， B   即 第一个 匹配 的   except   子句 被 触发
使用   " auto "   的 形式 如下 :
" optparse "   解析器 的 命令行 选项
（ 由   Mark   Shannon   在   bpo   39156   中 贡献 。 ）
3.9   版后 已 移除 :   " collections . abc . Coroutine "   now   supports   " [ ] "
可以 指定   hint   来 控制 要 读取 的 行数 ： 如果 （ 以 字节 / 字符 数 表示 的 ） 所有 行 的 总 大小 超出 了   hint   则 将 不会 读取 更 多 的 行
对于 嵌套 函数 则 为 上级 函数
这是 通过 配合 使用   " os . scandir ( ) "   和   " fnmatch . fnmatch ( ) "   函数 来 实现 的 ， 而 不是 通过 实际 发起 调用 子 终端
( 默认 :   " 8 " )   如果   " expand _ tabs "   为 真值 ， 则   text   中 所有 的 制表符 将 扩展 为 零个 或 多个 空格 ， 具体 取决于 当 前列 位置 和 给定 的 制表 宽度
( default :   " True " )   如果 为 真值 ， 在 制表符 扩展 之后 、 自动 换行 之前 ，   " wrap ( ) "   方法 将 把 每个 空白 字符 都 替换 为 单个 空格
当 Python 嵌入 到 其他 应用程序 中 时 ， 传统 的 GC 也 成为 一个 问题
源代码 从 名为   file   的 文件 中 加载
将   data   转换成 浮点数 并且 计算 算术 平均数
如 未指定   shear   参数   :   返回 当前 的 剪切 因子 即 剪切 角度 的 切线 ， 与 海龟 朝向 平行 的 线条 将 被 剪切
n   为 期望 的 字符 数量
许多 标准 库 模块   ( " audioop " ,   " ast " ,   " grp " ,   " _ hashlib " ,   " pwd " ,   " _ posixsubprocess " ,   " random " ,   " select " ,   " struct " ,   " termios " ,   " zlib " )   现在 会 使用   PEP   384   所 定义 的 稳定   ABI
每个 钩子 应该 期待 接收 一个 字符串 或 字节 串 对象 ； 字节 串 对象 的 编码 由 钩子 决定 （ 例如 可以 是 文件系统 使用 的 编码   UTF   8   或 其它 编码 ） ， 如果 钩子 无法 解码 参数 ， 它 应该 引发   " ImportError "
特别 注意 ， 由   shell   中 的 空格 分隔 的 选项 （ 例如   input   ） 和 参数 （ 例如   eggs . txt   ） 位于 分开 的 列表 元素 中 ， 而 在 需要 时 使用 引号 或 反 斜杠 转义 的 参数 在   shell   （ 例如 包含 空格 的 文件名 或 上面 显示 的   echo   命令   ） 是 单独 的 列表 元素
标准 的 字节 到 字节 编解码器 不 支持 此 方法
（ 由   Juliette   Monsel   在   bpo   34829   中 贡献 。 ）
使用   "   identifier "   或   "   identifier "   句法 的 正式 参数 不能 被 用作 位置 参数 空位 或 关键字 参数 名称
未指定 的 形参 将 保留 当前 设定 ， 例外情况 是 当 指定 了   encoding   但 未指定   errors   时 将 会 使用   " errors   ' strict ' "
标准 库中 的 重大 改进 ：
返回   o   中 的 第   i   号 元素 ， 失败 时 返回   " NULL "
当前 实现 的 默认值 是 缓存 100 条 语句
使用   dfunc   比较   a   和   b   ( 字节 串 对象 列表 ) ； 产生 以   dfunc   所 返回 格式 表示 的 差异 行 列表 （ 也 是 字节 串 ）
文档 的   reStructuredText   源文件 是   Python   源代码 发布 版 的 一部分
bpo   33184 :   在 MacOS 安装程序 中将 OpenSSL 更新 为 1.1 . 0h
这 将 让   " str ( msg ) "   产生 的 字符串 包含 人类 可读 的 的 序列化 信息内容
" u "   ( " str " )   [ const   Py _ UNICODE   ]   将 一个   Python   Unicode   对象 转化成 指向 一个 以空 终止 的   Unicode   字符 缓冲区 的 指针
创建 一个 迭代 器 ， 返回 从   iterable   里 选中 的 元素
唯一 的 解决方案 是 让 包 作者 提供 一个包 的 显式 索引
结果 将 是   " ( a . replace ( tzinfo   None )   a . utcoffset ( ) )   ( b . replace ( tzinfo   None )   b . utcoffset ( ) ) " ， 除非 具体 实现 绝对 不 溢出
额外 的 参数 必须 被 传入 函数 ， 每个 参数 必须 是 一个 指向   " PyObject   "   变量 的 指针 ； 它们 将 以 来自   args   的 值 填充 ； 它们 将 包含 暂借 的 引用
目前 只 支持   " NONE "   即 无 压缩 格式
如果 请求 失败 ， " PyObject _ Realloc ( ) "   返回   " NULL "   ，   p   仍然 是 指向 先前 内存 区域 的 有效 指针
调用   " close ( ) "   并 不会 销毁 共享内存 区域
第二个 形参   callback   为 一个 可 调用 对象 ， 它会 在   ob   被 作为 垃圾 回收 时 接收 通知 ； 它 应该 接受 一个 单独 形参 ， 即弱 引用 对象 本身
3.2   新版 功能 .
对于 要求 感知 型 对象 的 应用 ， " datetime "   和   " time "   对象 具有 一个 可选 的 时区 信息 属性   " tzinfo " ， 它 可 被 设为 抽象类   " tzinfo "   的 子类 的 一个 实例
3.6   版后 已 移除 :   请 使用   " asyncio "   替代
当 一个 数组 对象 被 打印 或 转换 为 字符串 时 ， 它会 表示 为   " array ( typecode ,   initializer ) "
在   3.3   版 更改 :   添加 了   blocking   形参
值   描述   init   Stop   after   the   " Distribution "   instance   has   been   created   and   populated   with   the   keyword   arguments   to   " setup ( ) "   config   Stop   after   config   files   have   been   parsed   ( and   their   data   stored   in   the   " Distribution "   instance )   commandline   Stop   after   the   command   line   ( " sys . argv [ 1 : ] "   or   script _ args   )   have   been   parsed   ( and   the   data   stored   in   the   " Distribution "   instance . )   run   Stop   after   all   commands   have   been   run   ( the   same   as   if   " setup ( ) "   had   been   called   in   the   usual   way )
如果   x   是   qNaN   或   sNaN   则 返回   " True " ； 否则 返回   " False "
它 必须 为 以下 常数 之一 :
在   3.9   版 更改 :   Added   the   "   s " ,   "   p " ,   "   e "   and   "   hardlink   dupes "   options
有 界 信号量 通过 检查 以 确保 它 当前 的 值 不会 超过 初始值
例如 ， 在 CPython 版本 3.3 中 ，   spam . py 的 编译 版本 将 被 缓存 为   " __ pycache __ / spam . cpython   33 . pyc "
第   1   周是 第   d   天 发生 的 第一周
如果   x   为 零则 返回   " True " ； 否则 返回   " False "
最初 来自 于   Wally   Feurzeig ,   Seymour   Papert   和   Cynthia   Solomon   于   1967   年 所 创造 的   Logo   编程语言
请参阅   The   Warnings   Filter   和   Describing   Warning   Filters   了解 更 多 细节
每种 值 类型 可以 定义 自己 的 “ 格式化 迷你 语言 ” 或 对   format _ spec   的 解读 方式
这个 功能 使用 了   GNU   Readline   来 实现 ，   一个 支持 多种 编辑 方式 的 库
如果 上下文 变量 没有 找到 ，   value   将 指向 ：
注意 我们 现在 指定 了 一个 新 的 关键词   " action " ， 并 赋值 为   " " store _ true " "
一些 用来 从   date   对象 中 提取 字段 的 宏
maxsize   是 个 整数 ， 用于 设置 可以 放入 队列 中 的 项目数 的 上限
For   example   usage   of   the   former   case ,   see   the   示例   section   of   the   " importlib "   documentation .
目前 （ 2000 年 11 月 ）   几乎 所有 使用   IEEE   754   浮点运算 标准 的 机器 以及 几乎 所有 系统 平台 都 会 将   Python   浮点数 映射 为   IEEE   754   “ 双 精度 类型 ”
PEP   343 :   " with "   语句
闰日 计入 ， 可以 引用 2 月   29 日
忘记 处置 一个 拥有 的 引用 会 导致 内存 泄漏
（ 由   Dong   hee   Na   在   bpo   39366   中 贡献 。 ）
Unix 中 的 默认值
（ 由   Inada   Naoki   在   bpo   33597   中 贡献 。 ）
此 函数 会 创建 一个 可变 的   unicode   字符 缓冲区
该 模块 可以 在 命令行 管理程序 中 运行 ， 而 无需 重新启动
" PyASCIIObject "   和   " PyCompactUnicodeObject "   结构
或者 通过 直接 计算 时间 戳 :
3.2   新版 功能 .
" stop " :   垃圾 回收 已 结束
如果 传入   " pack ( ) "   的 字符串 过长 （ 超过 计 数值 减   1 ） ， 则 只有 字符串 前   " count   1 "   个 字节 会 被 存储
bpo   34631 :   在 MacOS 安装程序 中将 OpenSSL 更新 为 1.1 . 1c
对 声明 项目 依赖 的 支持
然后 你 应当 看见 类似 类似 这样 的 东西 ：
在   3.4   版 更改 :   utf   16   和   utf   32   编码器 将 不再 允许 编码 代理 码位   ( " U + D800 "   " U + DFFF " )
PEP   3147 :   PYC   仓库 目录
使用   C   或   C++   扩展   Python
使用 这种 方法 来 提取 参数 的 函数 应当 在 函数 或 方法 表中 被 声明 为   " METH _ VARARGS "
这 将 导致 任何 现有 和 未来 对   " wait ( ) "   的 调用 失败 并 引发   " BrokenBarrierError "
相反 地 ， " datetime . strptime ( ) "   类会 根据 表示 日期 和 时间 的 字符串 和 相应 的 格式 字符串 来 创建 一个   " datetime "   对象
为了 估算 一个 不易 解析 的 模型 分布 ， " NormalDist "   可以 生成 用于 蒙特卡洛 模拟 的 输入 样本 ：
旧式 的   Shell   发起 函数
抵制 这种 诱惑 并 使用   " re . search ( ) "   代替
如果   allowZip64   为   " True "   ( 默认值 )   则 当   zipfile   大于   4   GiB   时   zipfile   将 创建 使用   ZIP64   扩展 的   ZIP   文件
获取 补 全域 的 开始 和 结束 序号
如果 你 准备 好 了 ， 可以 拿 一些 你 最 喜欢 的 饮料 然后 继续
换行 ， 使 一行 不 超过 79 个字符
由于   " warn "   已 被 弃用 ， 请 不要 使用 它   — —   而 要 改用   " warning "
一个 从   " . pyc "   文件 读出 的 程序 并 不会 比 它 从   " . py "   读出 时 运行 的 更 快 ，   " . pyc "   文件 唯一 快 的 地方 在于 载入 速度
包含 实际 参数 的 元组 应当 作为   args   传入 ； 它 必须 确实 是 一个 元组
See   the   泛型 属性 管理   section   below   for   details .
对象 赋值 给 单个 目标 的 操作 按 以下 方式 递归 地 定义
例如 ， 如果 模块 的 名称 是   leo   ， 则   init   函数 将 被 称为   initleo ( )
因为 这些 函数 的 语义 因 平台 而异 , 所以 使用 时 最好 查阅 平台 相关 文档
使用 除 字典 之外 的 其它 对象 传递 上下文 信息   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
3.5   版后 已 移除 :   Use   " BYTECODE _ SUFFIXES "   instead .
配置文件 还 允许 你 为 任何 命令 选项 提供 默认值 ， 而 安装 器 可以 通过 命令行 或 编辑 配置文件 来 覆盖 这些 默认值
缓冲 日志 消息 并 有 条件 地 输出 它们
这种 方式 也 可以 在 用到   " from "   的 时候 使用 ， 并会 有 类似 的 效果 :
如果   picname   为   " " nopic " " ， 则 删除 当前 背景图片
" pprint "   模块 还 提供 了 一些 快捷 函数 ：
" t . tzinfo "   不 为   " None "
形参   key   ,   msg   和   digest   具有 与   " new ( ) "   中 相同 的 含义
自   Python   3.0   起 ， 它 已 被 忽略 并且 不再 使用
对于 在   try   子句 不 引发 异常 时 必须 执行 的 代码 来说 很 有用
因此 它 不 支持 文本 到 文本 的 编码器 ， 例如   " rot _ 13 " ， 但是   " rot _ 13 "   可以 通过 同样 效果 的   " iterencode ( ) "   来 使用
参见 下文 的 讨论
对于   " ' ? ' "   格式 字符 ， 返回值 为   " True "   或   " False "
如果 你 输入 的 数据 由 混合 类型 组成 ， 你 应该 能够 使用   " map ( ) "   来 确保 一个 一致 的 结果 ， 比如 ：   " map ( float ,   input _ data ) "
" CloseBoundaryNotFoundDefect "   找到 了 开始 边界 ， 但 相应 的 结束 边界 无法 被 找到
它 的 默认值 是   " ' % ' " ， 其他 的 值   " ' { ' "   和   " ' $ ' "   也 支持 ， 对应 了 其他 两种 格式化 样式
这个 “ Python   有 什么 新 变化 ？ ” 系列 内容 会带 您 浏览   Python   大 版本 之间 重要 的 变化
在   3.4   版 更改 :   Gained   " create _ module ( ) "   and   " exec _ module ( ) "   methods .
获得 锁 ， 阻塞 或非 阻塞 的
" float "   对象 的 值 是 以 固定 的 精度 （ 通常 为   53   位 ） 存储 的 二进制 浮点数 ， 由于   Python   使用   C   操作 ， 而 后者 依赖于 处理器 中 的 硬件 实现 来 执行 浮点运算
如果 使用 这些 符号 则 表明 可以 通过 何种 形参 将 参数值 传递 给 函数 ： 仅限 位置 、 位置 或 关键字 ， 以及 仅限 关键字
由 函数   " PyCallIter _ New ( ) "   和   " iter ( ) "   内置 函数 的 双 参数 形式 返回 的 迭代 器 对象 类型 对象
这会 使得   " NULL "   返回 码 有些 歧义 ；   请 使用   " PyCapsule _ IsValid ( ) "   或   " PyErr _ Occurred ( ) "   来 消除 歧义
你 可以 将 其 作为 示例 进行 研究 ， 并 在 运行 演示 时 查看 其 作用 效果   ( 但 最好 不要 在 演示 查看器 中 运行 )
在   3.8   版 更改 :   The   " write ( ) "   method   now   preserves   the   attribute   order   specified   by   the   user .
为了 避免 这种 需要 ， 可以 按 需 下载 所有 可能 的 组件 ， 以 创建 一个 完整 的 布局 ， 该 布局 将 不再 需要 internet 连接 ， 而 不管 所 选择 的 特性 是 什么
因此 ， 您 可能 不 希望 直接 使用 该 模块 ； 如果 你 想 在 程序 中 包含 这样 一个 循环 ， 你 可能 需要 使用   " code "   模块
有时 ， 你 希望 当 日志 文件 不断 记录 增长 至 一定 大 小时 ， 打开 一个 新 的 文件 接着 记录
显示 周围 括号 突出 显示 周围 的 括号
在   3.1   版 更改 :   添加 了   processName
当前 实现 中 ， 如果 至少 有   n   个 线程 正在 等待 ， 准确 唤醒   n   个 线程
除了 下面 描述 的 两个 例外 ， 在   " dataclass ( ) "   中 没有 任何 内容 检查 变量 标注 中 指定 的 类型
在   3.3   版 更改 :   从 工厂 函数 变为 类
在 测试 新 想法 或 检验 模块 和 包 的 时候 用 这种 方式 会 非常 方便 （ 请 记得 使用   " help ( x ) " ）
欲了解 构造函数 的 描述 ， 参阅 段落   ZipFile   对象
在   3.7   版 更改 :   增加 了 基于 哈希 的   " . pyc "   文件
在   3.5   版 更改 :   增加 了   " respect _ handler _ level "   参数
形式 为   1 : MM   的 本地 时间 就是 有 歧义 的
内置   " repr ( ) "   的 等价 形式 ， 它 使用 实例 专属 的 格式化
对于 希望 从   Python2   迁移 到   Python3   的 项目 ， 或者 对于 希望 同时 支持   Python2   和   Python3   用户 的 库 和 框架 开发人员 ， 可以 使用 各种 工具 和 指南 来 帮助 决定 合适 的 方法 并 管理所 涉及 的 一些 技术细节
" shutil "   模块 提供 了 一系列 对 文件 和 文件 集合 的 高阶 操作
常见 的 用法 是 把 某种 操作 应用 于 序列 或 可 迭代 对象 的 每个 元素 上 ， 然后 使用 其 结果 来 创建 列表 ， 或者 通过 满足 某些 特定条件 元素 来 创建 子 序列
返回   path   在 系统 中 的   ctime ， 在 有些 系统 （ 比如   Unix ） 上 ， 它 是 元 数据 的 最后 修改 时间 ， 其他 系统 （ 比如   Windows ） 上 ， 它 是   path   的 创建 时间
和   Python   层面 的 类   " complex "   是 同一个 对象
增加 了   " PyModule _ AddType ( ) "   函数 以 协助 将 类型 加入 到 模块 中
当 使用 任意 机制   ( 例如   " importlib "   API ,   " import "   及   " import   from "   语句 或者 内置 的   " __ import __ ( ) " )   加载 一个 子 模块 时 ， 父 模块 的 命名 空间 中 会 添加 一个 对子 模块 对象 的 绑定
更 多 细节 可以 查阅 策略 部分
该 可 调用 对象 会 在   " try " ... " except "   这样 的 结构 内 被 调用 ， 当 它 捕获 到 异常 时 ， 会先 还原 终端 再 重新 引发 这个 异常
针对 模块 特定 错误 引发
access   为 一个 整数 ， 用于 给键 的 预期 安全 访问 指定 访问 掩码
" aifc "   模块 定义 了 以下 函数 ：
p   可以 是 文件 对象 或 具有   " readline ( ) "   方法 的 任何 对象
在 大部分 用例 中 ， 开发者 都 关心 枚举 的 实际 值 是 什么
返回 的 字符串 永远 按照   " email . utils . unquote ( ) "   方法 去除 引号
在   3.3   版 更改 :   由于   " IOError "   现在 是   " OSError "   的 别名 ， 因此 用于 引发   " IOError "   的 操作 现在 会 引发   " OSError "
The   " str "   type   is   described   in   the   Python   library   reference   at   文本 序列 类型   str .
虽然 它们 在 单个 Python 进程 中 保持 不变 ， 但是 在 重复 调用 的 Python 进程 之间 它们 是 不可 预测 的
单调 递增 的 时钟 ， 记录 从 一个 任意 起点 开始 的 时间 ， 不 受 频率 或 时间 调整 的 影响 ， 并且 当 系统 休眠 时 将 不会 递增
使得 可以 通过   " zip (   [ iter ( s ) ]   n ) "   这样 的 惯用 形式 将 一系列 数据 聚类 为 长度 为   n   的 分组
如果 打开 终端 时 发生 错误 ， 则 下层 的   curses   库 可能 会 导致 解释器 退出
直接 print 会 显示 所有 属性 的 值
另外 还有 不少 书籍 深入 讲解   Python
请参阅 内置 函数   " pow ( ) "
你 还 可以 使用 import 语句 的   " from   module   import   name "   形式 编写 相对 导入
生成器 迭代 器 的 方法   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
3.3   新版 功能 .
打开 的 套 接字 类型 取决于   socktype   参数 ， 该 参数 的 默认值 为   " socket . SOCK _ DGRAM "   即 打开 一个   UDP   套 接字
在 Windows 上 使用   Python
" random "   生成 伪 随机数
将 拼接 后 的 字符串 列表 写入 到流 （ 可能 通过 重用   " write ( ) "   方法 ）
作为   " Element "   ，   " root "   具有 标签 和 属性 字典 :
当 你 创建 一个   " LoggerAdapter "   的 实例 时 ， 你 会 传入 一个   " Logger "   的 实例 和 一个 包含 了 上下文 信息 的 字典 对象
在   3.2   版 更改 :   Support   for   binary   input   was   added .
没有 类型 限制 ， 但值 类型 需要 支持 加 ， 减 和 比较 操作
" getopt "   C   风格 的 命令行 选项 解析器
它 类似 于   " PyDictObject " ， 因为 对于 小 尺寸 集合 来说 它 是 固定 大小 的 （ 很 像 元组 的 存储 方式 ） ， 并且 对于 中等 和 大 尺寸 集合 来说 它 将 指向 单独 的 可变 大小 的 内存 块 （ 很 像 列表 的 存储 方式 ）
你 可能 想要 将 其 替换 为 你 自己 的 导入 机制 ： 如果 是 这样的话 ， 你 可以 替换   " DictConfigurator "   或 其 超类   " BaseConfigurator "   类 的   " importer "   属性
如果 给定 的   section   存在 并且 包含 给定 的   option   则 返回   " True " ；   否则 返回   " False "
三个 参数 必须 都 是 整数
hash 代码 根据 键 和 每个 进程 的 种子 而 变化很大 ； 例如 ， " Python "   的 hash 值为   539294296 ， 而 " python " ( 一个 按位 不同 的 字符串 ) 的 hash 值为 1142331976
在   3.4   版 更改 :   Set   " __ name __ " ,   " __ loader __ "   " __ package __ "   unconditionally   to   support   reloading .
基于 文本 的 应用程序 常常 以 反相 显示 状态 行 ， 一个 文本 查看器 可能 需要 突出 显示 某些 单词
MultiContext   class   在   Enthought   CodeTools   package   有 支持 写 映射 的 选项
在   3.2   版 更改 :   query   supports   bytes   and   string   objects .
" vformat ( ) "   完成 将 格式 字符串 分解 为 字符 数据 和 替换 字段 的 工作
有序 字典 的   " popitem ( ) "   方法 移除 并 返回 一个   ( key ,   value )   键值 对
此类 方法 可 构造 一个   " Fraction "   来 表示   dec   的 精确 值 ， 该 参数 必须 是 一个   " decimal . Decimal "   实例
" stat "   解析   " stat ( ) "   结果
如果   capname   不是 一个   terminfo   " 字符串 功能 "   或者 如果 其 被 取消 或 不 存在 于 终端 描述 中则 返回   " None "
如果 反 斜杠 数量 为 奇数 ， 则 最后 一个 反 斜杠 会 如 规则   3   所 描述 的 那样 转义 下 一个 双引号
要 修改 上面 的 例子 来 同时 运行 多个 命令 确实 是 非常简单 的 :
See   section   contextlib   模块   for   more   about   this   module .
请 注意 由于 二进制 浮点数 通常 存在 的 问题   ( 参见 浮点 算术 ： 争议 和 限制 ) ， " Fraction ( 1.1 ) "   的 参数 并 不会 精确 等于   11 / 10 ， 因此   " Fraction ( 1.1 ) "   也 不会 返回 用户 所 期望 的   " Fraction ( 11 ,   10 ) "
Reader   的 更 高级 用法 — — 捕获 并 报告 错误 :
" eval ( ) "   还 具有 将 数字 解读 为   Python   表达式 的 效果 ， 这样   " eval ( ' 09 ' ) "   将会 导致 语法错误 ， 因为   Python   不 允许 十进制 数 的 首位 是   ' 0 '   ( ' 0 '   除外 )
我应 如何 获取   Python   的 公开 测试 版本 ？
可能 最为 人 所 熟知 的 编程 语句 就是   " if "   语句 了
3.8   版后 已 移除 :   Methods   " visit _ Num ( ) " ,   " visit _ Str ( ) " ,   " visit _ Bytes ( ) " ,   " visit _ NameConstant ( ) "   and   " visit _ Ellipsis ( ) "   are   deprecated   now   and   will   not   be   called   in   future   Python   versions
" webbrowser "   方便 的 Web 浏览器 控制器
此 函数 会 调用 底层 库中 的   " history _ get ( ) "
C   API   的 变化
本地 （ 非 DST ） 时区 的 偏移量 ， UTC 以西 的 秒数 （ 西欧 大部分 地区 为 负 ， 美国 为 正 ， 英国 为 零 ）
在 这个 示例 中 它 相当于   " result   result   +   [ a ] "   ， 但 更 高效
通过 向 一个 参考点 添加   offset   来 计算 位置 ； 参考点 由   whence   参数 指定
（ 注意 ： 我们 建议 使用 4 个 空格 来 缩进 Python   代码 。 ）
frame   必须 不 为   " NULL "
请参阅   " sys . platlibdir "   属性 了解 详情
以上 代码 会 打印 几行   " 0   0 "   ， 因为 数组 内容 被 初始化 为   0 .
在   3.9   版 更改 :   This   dictionary   is   no   longer   filled   with   the   default   system   mappings ,   but   only   contains   overrides .
类似 的 ， 如果   empty ( )   返回   " False "   ， 也 不 保证 后续 调用 的   get ( )   不 被 阻塞
3.3   新版 功能 .
PEP   487 :   自定义 类 创建
3.2 . 3   新版 功能 .
它 在 命令行 中 的 基本 用法 如下 ：
关联 的 值 是 一个 字符串 ， 给出 有关 类型 不 匹配 的 详情
timeout   可以 是 整数 或 浮点数
" urllib . response "   urllib   使用 的   Response   类
二进制 文件 的 例子 包括 以 二进制 模式 （ " ' rb ' " ,   " ' wb ' "   or   " ' rb + ' " ） 打开 的 文件 、 " sys . stdin . buffer " 、   " sys . stdout . buffer "   以及   " io . BytesIO "   和   " gzip . GzipFile "   的 实例
注意 这一 改变 同时 反应 在 错误信息 和 帮助 信息 里
返回 一个   " SysLogHandler "   类 的 新 实例 用来 与 通过   address   以   " ( host ,   port ) "   元组 形式 给出 地址 的 远程   Unix   机器 进行 通讯
如果   policy   设 为   " None "   将 恢复 默认 策略
移植 到   Python   3.9
在 文本 模式 下 （ 默认 情况 下 ， 或者 在   mode   参数 中 包含   ` " ' t ' `   ） 时 ， 文件 内容 返回 为   " str "   ， 首先 使用 指定 的   encoding   （ 如果 给定 ）   或者 使用 平台 默认 的 的 字节 编码 解码
3.3   新版 功能 .
但 以   Python   作为 第一种 编程语言 进行 学习 对 学生 可能 更 有利
parse _ int   ， 如果 指定 ， 将 与 每个 要 解码   JSON   整数 的 字符串 一同 调用
以下 两种 表达 是 等价 的 :
由于 它 可 用于 代码 内省 ， 因此 是 对象 存放 文档 的 规范 位置
bpo   34377 :   更新 valgrind 的 抑制 列表 ， 使用   " _ PyObject _ Free " / " _ PyObject _ Realloc "   代替   " PyObject _ Free " / " PyObject _ Realloc "
这个 探针 点 表示 一个 Python 函数 的 执行 已经 开始
如果 你 遵守 此 版权 规则 ， 就 可以 将   Python   用于 商业 领域 ， 以 源码 或 二进制码 的 形式 （ 不论 是否 经过 修改 ） 销售   Python   的 副本 ， 或是 以 某种 形式 包含 了   Python   的 产品
为   float   和   Decimal   的 混合 启用 更 严格 的 语义
返回 或 设置 画笔 的 属性   x / y   拉伸 因子 和 / 或 轮廓
处理 由   " Thread . run ( ) "   引发 的 未 捕获 异常
" CHECK _ SHA256 " :   256   位 安全 哈希 算法
这个 类 的 实例 具有   " __ call __ ( ) "   方法 ， 其 签名 与   " compile _ command ( ) "   相似 ； 区别 在于 如果 该 实例 编译 了 包含   " __ future __ "   语句 的 程序 文本 ， 则 实例 会 ‘ 记住 ’ 并 使用 已 生效 的 语句 编译 编译 所有 后续 程序 文本
用于 定义 抽象 基类 （ ABC ） 的 元类
" Py _ BuildValue ( ) "   并 不 一直 创建 一个 元组
如果   tb   不 为   " None " ， 它 将 打印 头部   " Traceback   ( most   recent   call   last ) : "
如果 指定 了   size ， 则 将 其 用作 长度 ， 否则 将 假定 字符串 以零值 结尾
当 指定 一个 以上 的   pickle   文件 时 ， 在 每次 反汇编 之前 打印 给定 的 前言
请 注意 ， 头字段 已有 的 参数值 可以 通过 头字 段 的   " params "   属性 来 访问 （   举例 ：   " msg [ ' Content   Type ' ] . params [ ' charset ' ] "   ）
PEP   393 :   灵活 的 字符串 表示
在   3.7   版 更改 :   当 提供   " % z "   指令 给   " strptime ( ) "   方法 时 ， UTC   差值 可以 在 时 、 分 和 秒 之间 使用 冒号 分隔符
以下 函数 集 封装 了 系统 分配器
实现 条件 变量 对象 的 类
在   3.7   版 更改 :   The   attribute   is   now   always   ASCII   text
如果   body   是 字符串 或者 类似 字节 的 对象 ， 并且 也 不是 文件   ， Content   Length   头会 设为 正文 的 长度
future   对象 被 取消 时会 触发
如果 指定 了   error _ callback   ,   它 必须 是 一个 接受 单个 参数 的 可 调用 对象
接下来 ， 该 抽取 表达式 会 被 求值
下面 的 案例 展示 了   " SharedMemoryManager "   的 基本 机制 :
" curses . panel "   curses   的 面板 栈 扩展
分配   n   个 字节 并 返回 一个 指向 分配 的 内存 的   " void   "   类型 指针 ， 如果 请求 失败 则 返回   " NULL "
当 不 处于 交互 模式 时 ， " _ "   无 特殊 含义 也 没有 预定 义
清空 现有 字典 的 所有 键值 对
要 指定 变种   ( dialect ) ， 可以 给出   " Dialect "   的 子类 ， 或 给出   fmtparams   关键字 参数   ， 或 两者 都 给出 （ 此时 关键字 参数 会 覆盖   dialect   参数 ）
返回 对应 于   " datetime "   实例 的   POSIX   时间 戳
如果 所 封包 的 协程 未 完成 ， 这 将 返回 其挂 起 所在 的 栈
" default "   ： 如果 提供 ， 这 将 是 该 字 段 的 默认值
" option _ class "   ( 默认 :   optparse . Option )   Class   to   use   when   adding   options   to   the   parser   in   " add _ option ( ) " .
在 后 两种 情况 下 将 分别 返回   " False "   或   " True "
使用 模式 方法 最 简单 的 方式 是 使用   " MagicMock "   class
sip   是 一个 用于 为   C++   库 生成   Python   类 绑定 的 库 ， 它 是 针对   Python   特别 设计 的
参见 :   " sys . excepthook ( ) "   处理 未 捕获 的 异常
所有 当前 命令行 参数 被 聚集 到 一个 列表 中
如果   o   的 类型 为   " PyContext _ Type "   则 返回 真值
请 注意 它 将 为 具有   " __ getitem __ ( ) "   方法 的   Python   类 返回   " 1 " ， 除非 它们 是   " dict "   的 子类   ， 因为 在 一般 情况 下 无法 确定 它 所 支持 键 类型
它 的 目的 是 允许 可 复现 的 哈希 运算 ， 例如 用于 解释器 本身 的 自我 检测 ， 或 允许 一组   python   进程 共享 哈希 值
默认 形参值 会 在 执行 函数 定义 时 按 从 左 至 右 的 顺序 被 求值
如果 生成器 已经 由于 异常 或 正常 退出 则   " close ( ) "   不会 做 任何 事
数组 的 抽象 基类
在   3.7   版 更改 :   The   function   now   uses   the   UTF   8   encoding   in   the   UTF   8   mode .
urx   一个 数值 ,   画面 右上角 的   x   坐标
对于 一个 非 零数 ， 返回 其 运算 数 的 调整 后 指数 作为 一个   " Decimal "   实例
在 失败 时 设置 一个 异常 并 返回   " NULL "
第一 部分 ， 针对 那些 对 性能 有 要求 的 关键 线程 的 日志 记录 附加 一个   " QueueHandler "
如果 没有 元素 的话 ，   就 引发   " IndexError "
Window   对象 会 由 上面 的   " initscr ( ) "   和   " newwin ( ) "   返回 ， 它 具有 以下 方法 和 属性 :
PEP   343 :   " with "   语句
如果 指定 了   callback   ,   它 必须 是 一个 接受 单个 参数 的 可 调用 对象
将 结构 序列   p   的 索引   pos   处 的 字 段 设置 为值   o
Decimal   数字 的 表示 是 完全 精确 的
" http . cookies "   HTTP 状态 管理
如果 要 把   " help ( ) "   的 输出 写 到 磁盘 上 的 一个 文件 ， 重定向 该 输出 到 一个 常规 文件 ：
超出范围 的 抽取 会 导致   " IndexError "
这 与   " PyDict _ GetItem ( ) "   一样 ， 但是   key   被 指定 为   " const   char   " ， 而 不是   " PyObject   "
假设 有 这样 一种 情况 ， 你 需要 将 日志 按 不同 的 格式 和 不同 的 情况 存储 在 控制台 和 文件 中
如果   aw   是 一个 协程 ， 它 将 自动 作为 任务 加入 日程
这 与   " Parser ( ) . parsestr ( s ) "   等价
这样 ， 当 您 需要 排序 的 副本 ， 但 也 需要 保留 未 排序 的 版本 时 ， 就 不会 意外 地 覆盖 列表
阅读   quick   guide   中 的 案例 了解 如何 使用   " Mock "   ， " MagicMock "   和   " patch ( ) "
此 基类 用于 派生 针对 各种 算术 类 错误 而 引发 的 内置 异常 :   " OverflowError " ,   " ZeroDivisionError " ,   " FloatingPointError "
标记   意义   解释   R   读取   读取   O   Old   以前 由 MUA 检测   D   已 删除   标记 为 以后 删除   F   已 标记   标记 为 重要   A   已 回复   回复 给
当 一个 模块 首次 被 导入 时 ， Python   会 搜索 该 模块 ， 如果 找到 就 创建 一个   module   对象   [ 1 ]   并 初始化 它
指定 自定义 的 过滤器 链
关于 套 接字 超时 的 说明
通过 配置 使用 UTC   ( GMT )   格式化 时间
在   3.4   版 更改 :   现在 已 支持 从未 识别 类型 的 下层 比较 函数 返回   NotImplemented   异常
password   和   salt   必须 为 字节 类 对象
PEP   “ Python   增强 提议 ” 的 英文 缩写
他们 是 序列 数据类型 （ 参见 序列 类型   list ,   tuple ,   range ） 中 的 两种
自动 推断 会 创建 一个 与 要 替换 对象 相同 的 属相 和 方法 的 模拟 对象 ， 并且 任何 函数 和 方法 （ 包括 构造函数 ） 都 具有 与 真实 对象 相同 的 调用 签名
此 函数 总是 会 创建 一个 新 的 事件 循环 并 在 结束 时 关闭 之
这 被 称为   1   号 星期 ， 这个 星期四 所在 的   ISO   年 与其 所在 的 格列 高利 年 相同
PEP   3101 :   高级 字符串 格式
" ConnectionError "   的 子类 ， 当 试图 写入 另一端 已 被 关闭 的 管道 ， 或是 试图 写入 已 关闭 写入 的 套 接字 时 将 被 引发
回应 是 个 文件 类 对象 ， 所以 你 可以 调用 如   ` ` . read ( ) ` ` 等 命令
Windows   仍然 使用 传统 编码 格式 作为 系统 的 编码 格式 （ ANSI   代码 页 ）
默认 情况 下 每个 键 都 要求 提供
" argparse "   支持 静默 特定 选项 的 帮助 ， 具体做法 是 将   " help "   的 值 设为   " argparse . SUPPRESS " :
如果 这 是 对   " decode ( ) "   的 最终 调用 则   final   必须 为 真值 （ 默认 为 假值 ）
在   3.4   版 更改 :   当 这个 方法 被 调用 的 时候 ， 触发   " ImportError "   异常 而 不是   " NotImplementedError "
如果 提供 了   onerror   ， 它 必须 为 接受 三个 形参 的 可 调用 对象 :   function   ,   path   和   excinfo
当 解释器 发现 内部 错误 ， 但 情况 看起来 尚未 严重 到 要 放弃 所有 希望 时 将 被 引发
填充 只会 在 连续 结构 成员 之间 自动 添加
如果 被 调用 的 次数 多于 放入 队列 中 的 项目 数量 ， 将 引发   " ValueError "   异常
处理器 将 日志 记录 （ 由 记录器 创建 ） 发送到 适当 的 目标
这些 代码 可能 不是 在 所有 平台 上 都 可 与   " strftime ( ) "   方法 配合 使用
请 注意 有 三个 处理程序 类   ( " StreamHandler " ,   " FileHandler "   和   " NullHandler " )   实际上 是 在   " logging "   模块 本身 定义 的 ， 但 其 文档 与 其他 处理程序 一同 记录 在 此
在 嵌套 函数 中 使用 的 自由 变量 可以 访问 包含 该   def   语句 的 函数 的 局部变量
Python   标准 库 包含 现有 的 对象 类型 、 函数 和 模块 （ 内置 和 用   Python   编写 ） 的 文档 ， 使 语言 具有 广泛 的 应用 范围
描述 结构 序列 的 一个 字 段
增加 了   " ' x ' "   模式
" doctest "   文档 测试 模块 另 一个 风格 完全 不同 的 测试 模块
GNU   tar   manual ,   Basic   Tar   Format   针对   tar   归档文件 的 文档 ， 包含   GNU   tar   扩展
3.5 . 4   新版 功能 .
可选 的   _ class   和   policy   参数 与   " BytesParser "   类 的 构造函数 的 参数 含义 一致
如果 要 比较 的 两个 元素 本身 又 是 相同 类型 的 序列 ， 则 会 递归 地 执行 字典 式 顺序 比较
字符串 字 面值 可以 跨行 连续 输入
还 需要 考虑 其 日志 记录 配置
3.1   功能 的 部分 列表 ， 这些 功能 已 反向 移植 到   2.7 ：
附带 给定   name   的 所有 对此 函数 的 调用 都 将 返回 相同 的 日志 记录器 实例
此 函数 返回 编译 后 字节 码 文件 的 路径 ， 即   cfile   所 使用 的 值
功能键 、 小键盘 键 和 其他 特殊 键则 是 返回 一个 包含 键名 的 多 字节 字符串
如果   " mode   ' w ' "   则 返回 一个 可 写入 的 文件 句柄 ， 它 将 支持   " write ( ) "   方法
（ 由   Karl   Ding   在   bpo   40291   上 贡献 。 ）
它 支持 解密   ZIP   归档 中 的 加密 文件 ， 但是 目前 不能 创建 一个 加密 的 文件
( C   programmers   use   " PyErr _ WarnEx ( ) " ;   see   异常 处理   for   details ) .
在   3.2   版 更改 :   The   return   type   is   now   Py _ hash _ t
当 使用   " ZIP _ BZIP2 "   时 接受 整数   " 1 "   至   " 9 "   ( 更 多 信息 参见   " bz2 " )
在   3.7   版 更改 :   仅 关键字 参数   header
" Task "   或   " Future "   的 内部 状态 无效
这种 转换 独立 于 标识符 所 使用 的 相关 句法
与 数据库 操作 相关 而 不 一定 能受 程序员 掌控 的 错误 引发 的 异常 ， 例如 发生 非 预期 的 连接 中断 ， 数据源 名称 未找到 ， 事务 无法 被 执行 等
在 类   Unix   系统 中 编译 和 链接
在   3.7 . 2   版 更改 :   The   invalidation _ mode   parameter ' s   default   value   is   updated   to   None .
在 Linux 上 ， 您 可以 通过 查看 是否 包含 “ . note . stapsdt ” 部分 来 验证 构建 的 二进制 文件 中 是否 存在 SystemTap 静态 标记
在   3.6   版 更改 :   除了 字符串 值 ， 也 接受   " Path "   对象 作为   filename   参数
（ 由   Yury   Selivanov   在   bpo   20537   中 贡献 。 ）
在   3.5   版 更改 :   Added   the   "   j " ,   "   r " ,   and   "   qq "   options
如果 存在 异常 信息 ， 则 它 不会 被 发送到 服务器
首先 ， 下面 列出 了 深入 了解 前 需要 记住 的 事情 ：
在   " MyClass "   示例 中 ， 这 将 返回 字符串   " ' hello   world ' "
如果 该 方法 的 名称 是 以   " get "   打头 的 ， 它 将 在 所有 节 代理 上以 兼容 字典 的 形式 提供 （ 参见 上面 的   " getdecimal ( ) "   示例 ）
此项 更改 是 由于 普通 字典 自   Python   3.7   起 已 保证 具有 确定 的 元素 顺序
要 使用 自定义 的   " JSONDecoder "   子类 ， 用   " cls "   指定 他 ； 否则 使用   " JSONDecoder "
本章 中 描述 的 各 模块 提供 了 在 （ 几乎 ） 所有 的 操作系统 上 可用 的 操作系统 特性 的 接口 ， 例如 文件 和 时钟
当 一个 模块 被 导入 或 重新 加载 时 ， 一个 抽象 方法 在 它 自己 的 命名 空间 中 执行 那个 模块
如果 字节 数据 无法 被 锁定 ， 则 会 引发   " OSError "
（ 由   Steve   Dower   在   bpo   37834   中 贡献 。 ）
方法 总是 会 被 绑定 到 一个 用户 自定义 类 的 实例
" x   >   y "   和   " not   x   <   y "   ( 对于 完全 排序 )
举例来说 ， " 3 "   和   " 5 "   在 以下 调用 中均 属于 位置 参数 :
当锁 被 锁定 ， 将 它 重置 为 未 锁定 ， 并 返回
我们 可以 计算 平方 列表 的 值 而 不会 产生 任何 副作用
删除 信息 头 当中 字段名 匹配   name   的 所有 字 段
附录 ： 设置 环境变量
当 使用   " add _ payload ( ) "   将 有效 负载 添加 到   " Message "   对象 时 ， 有效 负载 已经 是 一个 标量 ， 而 消息 的   Content   Type   主 类型 不是   multipart   或者 缺少 时 触发 该 异常
( 默认 :   " True " )   如果 为 真值 ， 则 长度 超过   " width "   的 单词 将 被 分开 以 保证 行 的 长度 不会 超过   " width "
这个 模块 定义 了 许多 类 ， 详见 以下 部分
" dbm . dumb "   便携式   DBM   实现
这 应当 只 包含 空白 字符 ， 并且 默认 包含   ASCII   中 所有 的 空白 字符
我 在   CWI   的   ABC   部门 时 在 实现 解释 型 语言 方面 积累 了 丰富 经验 ， 通过 与 这个 部门 成员 的 协同工作 ， 我 学到 了 大量 有关 语言 设计 的 知识
使用   Python   的 问题 追踪 系统
之前 ， 它们 被 颠倒 了
一旦 被 唤醒 （ 并且 计数器 的 值 大于   0 ） ， 则 将 计数器 减   1   并 返回   " True "
否则 将 丢弃 足够 数量 的 末尾 单词 以 使得 剩余 单词 加   " placeholder "   能 适合   " width " :
从   " Error "   所 派生 的 类
为了 获得 对 被 复制 区域 的 细粒度 控制 ， 可以 使用   " overwrite ( ) "   的 第二种 形式
" check "   命令 允许 你 校验 你 的 包 的 元 数据 是否 满足 生成 分发 的 最低 要求
" TZ "   环境变量 的 标准 格式 是 （ 为了 清晰 起 见 ， 添加 了 空格 ） :
返回 字节 对象   o   中 字节 的 长度
' python '   命令 行为 的 变化
firstline   旗标 指明 如果 在 后续 行 发生 解码 错误 ， 则 仅 返回 第一行 就 足够 了
对于 浮点数 ， 结果 是   " ( q ,   a   %   b ) "   ，   q   通常 是   " math . floor ( a   /   b ) "   但 可能 会 比   1   小
在 C 中 执行 此 操作 的 最 简单 方法 是 调用   " PyRun _ InteractiveLoop ( ) "   （ 可能 在 单独 的 线程 中 ） 并 让 Python 解释器 为 您 处理 输入
在 语言 参考 文档 里 加入 过多 的 实现 细节 是 很 危险 的 具体 实现 可能 发生 改变   ， 对 同一 语言 的 其他 实现 可能 使用 不同 的 方式
文件 描述符 的 继承
" fnmatch "   Unix   文件名 模式匹配
此外 ， 对于   " ' g ' "   和   " ' G ' "   转换 ， 末尾 的 零 不会 从 结果 中 被 移除
不同 摘要 大小 的 哈希 对象 具有 完全 不同 的 输出 （ 较 短 哈希 值 并非 较长 哈希 值 的 前缀 ） ； 即使 输出 长度 相同 ， BLAKE2b   和   BLAKE2s   也 会 产生 不同 的 输出 :
两个 参数 的 形式 明确 指定 参数 并 进行 相应 的 引用
这种   " PyObject "   的 子 类型 表示 一个   Python   字节 对象
对应 于   " Ctrl + C "   击键 事件 的 信号
RawTurtle   的 子类 ， 具有 相同 的 接口 ， 但 其 绘图 场所 为 默认 的   " Screen "   类 对象 ， 在 首次 使用 时 自动 创建
对于 许多 类型 来说 ， 该 函数 会 尝试 返回 的 字符串 将会 与 该 对象 被 传递 给   " eval ( ) "   时所 生成 的 对象 具有 相同 的 值 ， 在 其他 情况 下 表示 形式 会 是 一个 括 在 尖括号 中 的 字符串 ， 其中 包含 对象 类型 的 名称 与 通常 包括 对象 名称 和 地址 的 附加 信息
和   " map ( ) "   类似 ， 不过   iterable   中 的 每一项 会 被 解包 再 作为 函数参数
参见 上文 的   " LZMADecompressor "   了解 有关   format   ,   memlimit   和   filters   参数 的 说明
我 的 代码 如何 才能 发现 对象 的 名称 ？
欢迎 提供 添加 这些 功能 的 补丁 ； 请参阅   Python   开发者 指南 了解 有关 为   Python   提交 补丁 的 详情
这些 常量 与   " poll ( ) "   对象 所用 的 相同
如果 模式 的 后续 部分 不 匹配 ， 则 匹配 引擎 将 回退 并 以 较 少 的 重复 次数 再次 尝试
请 注意   " putp ( ) "   的 输出 总是 前往 标准 输出
当 数据 点 的 总数 为 奇数 时 ， 将 返回 中间 数据 点 ：
与 完全 抑制 异常 的 任何 其他 机制 一样 ， 该 上下文 管理器 应当 只 用来 抑制 非常 具体 的 错误 ， 并 确保 该 场景 下 静默 地 继续 执行程序 是 通用 的 正确 做法
图片   Specifies   the   item   image ,   in   case   the   item ' s   image   option   is   empty .
3.6   新版 功能 :   添加   thread _ name _ prefix   参数 允许 用户 控制 由 线程 池 创建 的   " threading . Thread "   工作 线程 名称 以 方便 调试
值   意义   " ' r ' "   以 只读 方式 打开 现有 数据库 （ 默认 ）   " ' w ' "   以 读写 方式 打开 现有 数据库   " ' c ' "   以 读写 方式 打开 数据库 ， 如果 不 存在 则 创建 它   " ' n ' "   始终 创建 一个 新 的 空 数据库 ， 以 读写 方式 打开
如果 加载 失败 ， 则 该 模块 只限 加载 失败 的 模块 将 从   " sys . modules "   中 移除
" _ "   作为 名称 常用 于 连接 国际化 文本 ； 请 参看   " gettext "   模块 文档 了解 有关 此 约定 的 详情
运行 有 图形界面 的 脚本
This   document   covers   using   the   Distutils   to   distribute   your   Python   modules ,   concentrating   on   the   role   of   developer / distributor :   if   you ' re   looking   for   information   on   installing   Python   modules ,   you   should   refer   to   the   安装 Python 模块 （ 旧版 ）   chapter .
本 节 展示 了 一些 使用   " secrets "   来 管理 基本 安全级别 的 应用 技巧 和 最佳 实践
在   3.7   版 更改 :   引入 了 可选 的   " get _ resource _ reader ( ) "   方法
在   3.7   版 更改 :   " BytesWarning "   no   longer   appears   in   the   default   filter   list   and   is   instead   configured   via   " sys . warnoptions "   when   "   b "   is   specified   twice .
这个 类 处理 解析器 和 解释器 状态 （ 用户 命名 空间 的 ） ； 它 不 处理 缓冲器 、 终端 提示 区 或 着 输入 文件名 （ 文件名 总是 显示 地 传递 ）
由   PEP   492   引入
当然 ， 我们 仍然 希望 获知 所有 对   Python   的 商业 使用
member   可以 是 一个 文件名 或   " TarInfo "   对象
虽然   " IntEnum "   是   " enum "   模块 的 一部分 ， 但 要 独立 实现 也 应该 相当 容易 :
可 选 参数   w   ,   l   ,   和   c   分别 表示 日期 列数 ，   周 的 行数 ，   和 月 之间 的 间隔
在 类型 相关 的 限制 以内 ， 它们 会 按 数学 （ 算法 ） 规则 正确 进行 比较 且 不会 有 精度 损失
但是 ， 它们 默认 仍 将 使用 严格 错误处理 句柄 ， 因此 试图 在 文本 模式 下 打开 二进制 文件 将 可能 引发 异常 ， 而 不是 生成 无 意义 的 数据
（ 由   Raymond   Hettinger   贡献 。 ）
宏 版本 的 C 函数   " PyList _ Size ( ) "   ， 没有 错误 检测
当   " PyArg _ Parse   ( ) "   函数 因为 某 一个 格式 单元 转化 失败 而 失败 时 ， 对应 的 以及 后续 的 格式 单元 地址 内 的 变量 都 不会 被 使用
模拟 Python 内部 lookup 链 的 例子
在   Unix   上 ， 你 不应 将   " A . a "   传给 链接 器 作为   " B . so "   和   " C . so " ； 那会 导致 它 被 包括 两次 ， 这样   B   和   C   将 分别 拥有 它们 自己 的 副本
( 显式 地 或 通过 上述 的 隐式 区域 强制 转换 )   配置 其中 一个 区域 选项 将 自动 为   " sys . stdin "   和   " sys . stdout "   启用   " surrogateescape "   错误处理 句柄   ( " sys . stderr "   会 继续 使用   " backslashreplace "   如同 在 任何 其他 区域 选项 中 一样 )
mac _ cyrillic   maccyrillic   保加利亚语 ， 白俄罗斯 语 ， 马其顿 语   ， 俄语 ， 塞尔维亚语   mac _ greek   macgreek   希腊语   mac _ iceland   maciceland   冰岛语   mac _ latin2   maclatin2 ,   maccentraleurope ,   中欧 和 东欧   mac _ centeuro   mac _ roman   macroman ,   macintosh   西欧   mac _ turkish   macturkish   土耳其语   ptcp154   csptcp154 ,   pt154 ,   cp154 ,   哈萨克语   cyrillic   asian   shift _ jis   csshiftjis ,   shiftjis ,   sjis ,   日语   s _ jis   shift _ jis _ 2004   shiftjis2004 ,   sjis _ 2004 ,   日语   sjis2004   shift _ jisx0213   shiftjisx0213 ,   sjisx0213 ,   日语   s _ jisx0213   utf _ 32   U32 ,   utf32   所有 语言   utf _ 32 _ be   UTF   32BE   所有 语言   utf _ 32 _ le   UTF   32LE   所有 语言   utf _ 16   U16 ,   utf16   所有 语言   utf _ 16 _ be   UTF   16BE   所有 语言   utf _ 16 _ le   UTF   16LE   所有 语言   utf _ 7   U7 ,   unicode   1   1   utf   7   所有 语言   utf _ 8   U8 ,   UTF ,   utf8 ,   cp65001   所有 语言   utf _ 8 _ sig   所有 语言
RFC   不 允许   infinite   或者   NaN   数值 的 表达方式
在 响应 提示 输入 空行 时 调用 的 方法
这种 机制 速度 很快 ， 因为 对于 每个 输入 记录 只会 调用 一次 键 函数
name   可以 是 一个   path   like   object
如果 没有 使用 该 方法 关闭   hkey   ( 或者 通过   " hkey . Close ( ) " ) ， 在 对象   hkey   被   Python   销毁 时会 将 其 关闭
请 参考 它们 各自 的 专门 文档 ， 以 确定 你 正在 使用 的 这个 实现 有 哪些 你 需要 了解 的 东西
函数 原型 类似 于   C   中 的 函数 原型 ；   它们 在 不 定义 具体 实现 的 情况 下 描述 了 一个 函数 （ 返回 类型 、 参数 类型 、 调用 约定 ）
在   3.5   版 更改 :   添加 了 对   " xztar "   格式 的 支持
获取 有关 指定 时钟 的 信息 作为 命名 空间 对象
" __ iadd __ "   成功 执行 ， 因此 列表 得到 了 扩充 ， 但是 虽然   " result "   指向 了   " a _ tuple [ 0 ] "   已经 指向 的 同一 对象 ， 最后 的 赋值 仍然 导致 了 报错 ， 因为 元组 是 不可 变 的
fd   是 任何 初始化 序列 将 被 发送到 的 文件 描述符 ； 如 未指定 或 为   "   1 " ， 则 将 使用   " sys . stdout "   的 文件 描述符
项目 的 构建 与 打包
正则表达式 模式 被 编译成 一系列 字节 码 ， 然后 由用   C   编写 的 匹配 引擎 执行
" distutils "   构建 和 安装   Python   模块
3.3   新版 功能 .
为了 避免 这个 并且 得到 结果   " 9 " ,   你 可以 用 这个 式子   " (   3 )   2 " .
Python   列表 有 一个 内置 的   " list . sort ( ) "   方法 可以 直接 修改 列表
在 当前 语言 环境 下 表示 月份 简写 的 数组
当 目标 函数 执行 失败 时 ，   会 将 抛出 的 异常 对象 作为 参数传递 给   error _ callback   执行
从   file   object   f   中 读取   n   项 （ 解读 为 机器 值 ） 并 将 它们 添加 到 数组 末尾
返回值 是 一个 派生 自   " Enum "   的 新类
这 往往 不是 因为 它们 难以实现 ， 而是 因为 还 没有 人 需要 它们
类似 地 ， 当 从 一个 子 解析器 请求 帮助 消息 时 ， 只有 该 特定 解析器 的 帮助 消息 会 被 打印 出来
现在 所有 平台 下 的   " mmap . flush ( ) "   方法 都 会 在 成功 时 返回   " None "   并 在 错误 时 引发 异常
本 模块 定义 如下 内容 ：
函数 可能 因此 而 耗尽 迭代 器 的 输出 ， 如果 你 要 对 同样 的 数据流 做 不同 的 操作 ， 你 必须 重新 创建 一个 迭代 器
" concurrent . futures "   — —   启动 并行任务
使用 这种 小 语言 ， 你 可以 为 要 匹配 的 可能 字符串 集 指定 规则 ； 此集 可能 包含 英语 句子 ， 电子邮件 地址 ， TeX 命令 或 你 喜欢 的 任何 内容
这 允许 你 输入   python   来 运行 解释器 ， 并且   pip   用于 包 安装程序
初始 情况 下锁 处于 解锁 状态
3.7   新版 功能 .
基于 弱 引用 的 终结 器 还 具有 另 一项 优势 ， 就是 它们 可 被 用来 为 定义 由 第三方 控制 的 类 注册 终结 器 ， 例如 当 一个 模块 被 卸载 时 运行 特定 代码 :
将   infile   输出 写入 到 给定 的   outfile
返回 对应 于   POSIX   时间 戳 例如   " time . time ( ) "   的 返回值 的 本地 日期 和 时间
当 解析   2   位数 年份 时 ， 会 按照   POSIX   和   ISO   C   标准 进行 转换 ： 数值   69   99   映射 为   1969   1999 ， 而 数值   0   68   被 映射 为   2000   2068
parse _ float   ， 如果 指定 ， 将 与 每个 要 解码   JSON   浮点数 的 字符串 一同 调用
结果 的 指数 为 零 ， 无论   " x " ,   " y "   和   " modulo "   的 指数 是 多少
它 通过 对 表达式 逐个 求值 直至 找到 一个 真值 （ 请参阅 布尔运算 了解 真值 与 假值 的 定义 ） 在 子句 体中 选择 唯一 匹配 的 一个 ； 然后 执行 该 子句 体 （ 而且   " if "   语句 的 其他 部分 不会 被 执行 或 求值 ）
该 设置 对应 于   " fileConfig ( ) "   中 的 同名 形参
下列 附加 字符 可 被 添加 至 旗标 以 控制 数据库 的 打开方式 ：
显示 一条 起 始于   " ( y ,   x ) "   长度 为   n   个字符   ch   的 垂直线
对于   " copytree ( ) " ， 此 异常 参数 将 是 一个 由 三元组   (   srcname   ,   dstname   ,   exception   )   构成 的 列表
从 海龟 位置 到 由   ( x , y ) ， 矢量 或 另 一 海龟 对应 位置 的 连线 的 夹角
Python   内存 管理器 有 不同 的 组件 来 处理 各种 动态 存储管理 方面 的 问题 ， 如 共享 、 分割 、 预 分配 或 缓存
为了 能 处理 最终 化 ， 事件 循环 应该 定义 一个 终结 器 函数 ， 它 接受 一个 异步 生成器 迭代 器且 可能 调用   " aclose ( ) "   并 执行 协程
3.4   新版 功能 .
发布 日期 :   2017   10   16
如果 脚本 名称 直接 指向 一个   Python   文件 ， 则 包含 该 文件 的 目录 将 被 加入   " sys . path "   的 开头 ， 并且 该 文件 会 被 作为   " __ main __ "   模块 来 执行
此 函数 等价 于   " HMAC ( key ,   msg ,   digest ) . digest ( ) " ， 但 使用 了 优化 的   C   或 内联 实现 ， 对 放入 内存 的 消息 能 处理 得 更 快
这 总是 当前 模块 的 字典 （ 在 函数 或 方法 中   ， 不是 调用 它 的 模块 ， 而是 定义 它 的 模块 ）
它 的 执行 速度 比   " floor ( sqrt ( n ) ) "   快 但是 比   " math . sqrt ( ) "   慢 :
在 之前 的 版本 中则 将 引发   " RuntimeError "
并且 由于   J   恰好 有   53   位   ( 即   " >   2   52 "   但   " <   2   53 " ) ，   N   的 最佳值 为   56 :
格式   描述   filename   使用 指定 的 文件名 而 不是   StreamHandler   创建   FileHandler
这 意味着 如果 你 从头开始 阅读 本手册 ， 并 在 感到 厌烦 时 跳 到 下 一章 ， 你 仍 能 对   Python   库 的 可用 模块 和 所 支持 的 应用领域 有个 大致 了解
这 就是 为什么 当 你 的 应用 不 需要 带有 空行 的 值时 ， 你 应该 考虑 禁用 它们
尝试 这些 方法 很快 就 会 清楚 它们 的 含义 :
3.4   版后 已 移除 :   因为 被 使用 的 次数 很少 ， 此 格式化 模块 已经 被弃 用 了
我们 可以 看到 在 此 情况 下   " x "   和   " y "   就 不再 相等 了
方 差值 较大 表明 数据 的 散布 范围 较大 ； 方 差值 较 小 表明 它 紧密 聚集 于 均值 附近
它 将 在   3.10   或   4.0   中 被 移除
它 通过 查看 字段 的 类型 是否 为   " dataclasses . InitVar "   类型 来 实现
" $ $ "   将 被 转义 成 单个 字符   " $ " :
通常 来说 ,   一个 为   0   的 退出 码 表示 进程 运行 正常 .
这里 给出 的 实现 仍 可 在 子类 中 被 调用
这 可以 通过 将 一个 字符串 列表 传给   " parse _ args ( ) "   来 实现
格式 字符串 是 用来 在 打包 和解 包 数据 时 指定 预期 布局 的 机制
当 不再 有 对 某个 元素 的 强 引用 时 元素 将 被 丢弃
timeout 为 负数 的 情况 下 和 为 0 的 情况 相同
关于 第一行 规则 的 一种 例外情况 是 ， 源码 以   UNIX   " shebang "   行 开头
作为 一种 特殊 情况 ， 对于 由   " PyMemoryView _ FromBuffer ( ) "   或   " PyBuffer _ FillInfo ( ) "   包装 的   temporary   缓冲区 ， 此字 段 为   " NULL "
3.6   新版 功能 :   增加 了   timespec   参数
例如 ， 表达式   " 11   / /   4 "   的 计算结果 是   " 2 "   ， 而 与 之 相反 的 是 浮点数 的 真正 除法 返回   " 2.75 "
而 像   PyGame   这样 的 第三方 模块 同样 有助于 扩大 学生 的 接触 领域
" ArgumentParser "   对象 不 允许 在 相同 选项 字符串 下 有 两种 行为
从 函数 返回   " Py _ True "   时 ， 需要 增加 它 的 引用 计数
大多数 异常 都 定义 为 名称 以 “ Error ” 结尾 ， 类似 于 标准 异常 的 命名
3.6   新版 功能 .
在   3.8   版 更改 :   对于   " int "   操作数 ， 三 参数 形式 的   " pow "   现在 允许 第二个 参数 为 负值 ， 即 可以 计算 倒数 的 余数
PEP   3129   类 装饰 器   PEP   由   Collin   Winter   撰写
shell   风格 通配符 所 使用 的 特殊字符 如下 ：
" gzip "   模块 提供 了 简单 的 命令行 界面 用于 压缩 和解 压缩文件
“ 常规 文件名 字符 ” 的 定义 取决于 具体 平台 ： 在   Unix   上 是 指正 斜杠 以外 的 任何 字符 ； 在   Windows   则 是 指反 斜杠 或 冒号 以外 的 任何 字符
请 注意   " Differ "   所 生成 的 增量 并 不 保证 是 最小 差异
" html . parser "   简单 的   HTML   和   XHTML   解析器
" " ) " "   的 权 标值
如果 用   " . "   作为 参数 ， 则 列出 当前 行 周围 的   11   行
返回 所 创建 的 经 正规化 的 路径 （ 对应 于 目录 或 新 文件 ）
开始 为   Python   贡献 您 的 知识
" ctypes "   对 变长 数组 和 结构 体 提供 了 一些 支持
调用   " PyEval _ InitThreads ( ) "   现在 没有 任何 效果
由于 同样 的 原因 ， 没有   " PyNone _ Check ( ) "   函数
在 之前 版本 中 某些 脚本 会 无条件 地 使用   " __ VENV _ PROMPT __ " ， 而 另 一些 脚本 只 在 其 恰好 被 设置 时 （ 这是 默认 情况 ） 才 会 使用 ， 还有 的 脚本 会 改用   " __ VENV _ NAME __ "
在   3.3   版 更改 :   " __ loader __ "   and   " __ package __ "   are   automatically   set   ( when   possible ) .
内置 函数   " abs ( ) "   " delattr ( ) "   " hash ( ) "   " memoryview ( ) "   " set ( ) "   " all ( ) "   " dict ( ) "   " help ( ) "   " min ( ) "   " setattr ( ) "   " any ( ) "   " dir ( ) "   " hex ( ) "   " next ( ) "   " slice ( ) "   " ascii ( ) "   " divmod ( ) "   " id ( ) "   " object ( ) "   " sorted ( ) "   " bin ( ) "   " enumerate ( ) "   " input ( ) "   " oct ( ) "   " staticmethod ( ) "   " bool ( ) "   " eval ( ) "   " int ( ) "   " open ( ) "   " str ( ) "   " breakpoint ( ) "   " exec ( ) "   " isinstance ( ) "   " ord ( ) "   " sum ( ) "   " bytearray ( ) "   " filter ( ) "   " issubclass ( ) "   " pow ( ) "   " super ( ) "   " bytes ( ) "   " float ( ) "   " iter ( ) "   " print ( ) "   " tuple ( ) "   " callable ( ) "   " format ( ) "   " len ( ) "   " property ( ) "   " type ( ) "   " chr ( ) "   " frozenset ( ) "   " list ( ) "   " range ( ) "   " vars ( ) "   " classmethod ( ) "   " getattr ( ) "   " locals ( ) "   " repr ( ) "   " zip ( ) "   " compile ( ) "   " globals ( ) "   " map ( ) "   " reversed ( ) "   " __ import __ ( ) "   " complex ( ) "   " hasattr ( ) "   " max ( ) "   " round ( ) "
从   f   读取 并 解析 配置 数据 ， 它 必须 是 一个 产生   Unicode   字符串 的 可 迭代 对象 （ 例如 以 文本 模式 打开 的 文件 ）
3.4   新版 功能 .
3.9   新版 功能 .
返回   path   的 最后 访问 时间
对于 攻击者 来说 ， 它 可以 将 传输 的 数据量 减少 三个 量级 或 更 多
PEP   338 :   将 模块 作为 脚本 执行
根据 给定 的 可读   raw   流 和   buffer _ size   创建   " BufferedReader "   的 构造 器
As   part   of   this   change ,   the   安装   Python   模块   and   分发   Python   模块   sections   of   the   documentation   have   been   completely   redesigned   as   short   getting   started   and   FAQ   documents
因为 它 不是 一个 真正 的 字 段 ， 所以 它 不会 被 模块 级 的   " fields ( ) "   函数 返回
（   PEP   342   解释 了 具体 的 规则 ， 也 就是   " yield "   表达式 必须 括 起来 ， 除非 是 出现 在 最 顶级 的 赋值 表达式 的 右边
当   fileobj   为   " None "   时 ，   filename   参数 只 用于   gzip   文件 头 中 ， 这个 文件 有 可能 包含 未 压缩文件 的 源 文件名
用于 检测 特定 对象 类型 的 宏   ( " Pytype _ Check ( ) " )   不会 检测   " NULL "   指针 同样 地 ， 有 大量 代码 会 连续 调用 这些 宏来 测试 一个 对象 是否 为 几种 不同 预期 类型 之一 ， 这 将 会 生成 冗余 的 测试
" get _ instructions ( ) "   函数 和   " Bytecode "   类 提供 字节 码 指令 的 详细信息 的   " Instruction "   实例 ：
下面 的 例子 演示 了 进程 池 的 用法 :
整数 值   length   如果 给出 则 为 缓冲区 大小
这 和 传递 参数 引用 类似
使用   pickle   协议 版本   4   可以 方便 地 封存 嵌套 在 其他 类中 的 枚举
如果 你 有   " tkinter " ， 你 可能 还 想 查看   Tools / demo / redemo . py ， 这是   Python   发行 附带 的 演示 程序
如果 无 路径 可用   ， 则 引发   " ImportError "
文件 必须 已 存在
（ 由   Dong   hee   Na   在   bpo   38602   中 贡献 。 ）
请 点击 侧边 栏中 的 “ 新建 （ Create   New ） ” 链接 ， 打开 报告 表单
bpo   38174 :   将 厂商 化 的   expat   库 版本 更新 至   2.2 . 8 ， 这 解决 了   CVE   2019   15903
使用 专门 的 可执行文件 作为 启动 程序 需要 一些 编码 ， 但 为 用户 提供 了 最 透明 的 体验
可以 通过   " / uninstall "   选项 立即 开始 删除 Python   不会 显示 任何 提示
将 指定 位置 上 的 历史 条目 替换 为   line
3.3   新版 功能 .
这 是 你 通常 将 使用 的 入口 点
它们 会 返回 内核 所 分配 给 当前 线程 的 原生 整数 线程   ID
无法访问 所 需 的 共享 库
赋值 给   " __ debug __ "   是 非法 的
举例 而言 ， 十进制 的 小数
3.3   新版 功能 .
在   3.8   版 更改 :   添加 了   errors   参数
调试信息 会 被 写入   " sys . stderr "
名称   描述   默认值   InstallAllUsers   为 所有 用户 安装
结果 在   Python   版中 总是 会 被 正确 地 舍入
" 1   <   日期   <   给定 年 月 对应 的 天数 "
设置 海龟 的 朝向 为   to _ angle
它们 可 被 用于 控制 生成器 函数 的 执行
为此 ， 它们 的 摘要 需 指定 一个 长度
标准 名称 包括 :
在 文档 扩展 和 嵌入   Python   解释器 中有 说明
3.2   新版 功能 .
Deprecated   since   version   3.9 ,   will   be   removed   in   version   3.10 :   The   "   X   oldparser "   选项
当 将   ' socket '   作为   name   形参 传入 时 ， 函数   " asyncio . BaseTransport . get _ extra _ info ( ) "   现在 会 返回 一个 可 安全 使用 的 套 接字 对象
文件格式   描述   注释   " gztar "   gzipped   tar   文件   ( " . tar . gz " )   ( 1 )   " bztar "   bzipped   tar   文件   ( " . tar . bz2 " )   " xztar "   xzipped   tar   文件   ( " . tar . xz " )   " ztar "   压缩   tar   文件   ( " . tar . Z " )   ( 3 )   " tar "   tar   文件   ( " . tar " )   " zip "   zip   文件   ( " . zip " )   ( 2 ) , ( 4 )   " rpm "   RPM   ( 5 )   " pkgtool "   Solaris   pkgtool   " sdux "   HP   UX   swinstall   " wininst "   Windows 的 自 解压 ZIP 文件   ( 4 )   " msi "   Microsoft 安装程序
" MalformedHeaderDefect "   找到 一个 缺失 了 冒号 或 格式 错误 的 标头
将 第二个 ， 第三个 和 第四个 堆栈 项 向上 提升 一个 位置 ， 将 顶项 移动 到 第四个 位置
3.2   新版 功能 .
丢失 所有 未 处理 的 数据
设置 后 ， 所有 回收 器 找到 的 不可 达 对象 会 被 添加 进   garbage   而 不是 直接 被 释放
如果 你 没有 显式 地 关闭 文件 ， Python 的 垃圾 回收 器 最终 将 销毁 该 对象 并 为 你 关闭 打开 的 文件 ， 但 这个 文件 可能 会 保持 打开 状态 一段时间
走向 编程 的 第一步
（ 由   Serhiy   Storchaka   在   bpo   32489   中 贡献 。 ）
此 函数 必须 显示 地 调用   ( 海龟 绘图 类 并 不 使用 此 函数 )
你 可以 通过 如下 方式 实例 化 一个   " Textbox " :
它 使用 面向对象 接口 ， 比   C   库 的 抽象 层级 略 高
下面 的 示例 使用   " os . open ( ) "   函数 的   dir _ fd   的 形参 ， 从 给定 的 目录 中 用 相对路径 打开 文件 :
这个 库 并 不 能够 解析 或 写入 在   Windows   Registry   扩展 版本   INI   语法 中 所 使用 的 值 类型 前缀
bpo   38334 :   修复 了 在 加密 的   " zipfile . ZipExtFile "   上 向 后 搜索 的 问题
当   o1   支持 时   ， 这个 运算 直接 使用 它 储存 结果
如果   " PY _ PYTHON   3 "   且   " PY _ PYTHON3   3.1 " ， 命令   " python "   和   " python3 "   都 将 特别 使用 3.1
设置 或 返回   TurtleScreen   的 背景 颜色
列出 当前 文件 的 源代码
ensure _ ascii   参数 以外 ， 此 模块 是 严格 的 按照 在   Python   对象 和   " Unicode   strings "   间 的 转换 定义 的 ， 并且 因此 不能 直接 解决 字符 编码 的 问题
如果 当前 上下文 引用 了 一个 目录 则 返回   " True "
在   3.8   版 更改 :   添加 了   mtime   形参 用于 可 重复 的 输出
AIFF   C   是 该 格式 的 更新 版本 ， 其中 包括 压缩 音频 数据 的 功能
Python   API   的 更改
如果   capname   不是 一个 布尔 功能 则 返回   "   1 " ， 如果 其 被 取消 或 不 存在 于 终端 描述 中则 返回   " 0 "
（ 仅 支持   Solaris   及其 衍生 版本 ） 返回 一个   " / dev / poll "   轮询 对象 ， 请参阅 下方   / dev / poll   轮询 对象 获取   devpoll   对象 所 支持 的 方法
默认值 是从   " sys . argv "   获取
将 此 记录器 的 过滤器 应用 于 记录 ， 如果 记录 能 被 处理 则 返回   " True "
将   rows   （ 即能 迭代 出 多个 上述   row   对象 的 迭代 器 ） 中 的 所有 元素 写入   writer   的 文件 对象 ， 并 根据 当前 设置 的 变种 进行 格式化
下列 所有 参数 都 是 可选项 并且 也 可 作为 实例 属性 来 访问
调用 此 函数 会 解码   uuencod   编码 的   in _ file   文件 并 将 结果 放入   out _ file   文件
此外 ， 由于 使用 的 重构 算法   " TextIOWrapper . tell ( ) "   和   " TextIOWrapper . seek ( ) "   都 相当 慢
关于 一个 加载 器 的 实际 定义 请 查看   PEP   302
" os . urandom ( ) "   也 可以 用来 生成 合适 的 认证 密钥
如果 给出   callback   并且 不是   " None "   ， 则 在 每次 试验 后 将 使用 两个 参数 调用 它 ：   " callback ( number ,   time _ taken ) "
urllib 很 易于 使用 （ 注意   URL   不仅仅 可以 以 ' http : ' 开头 ， 也 可以 是 ' ftp : ' ，   ' file : ' 等 ）
应用 技巧 与 最佳 实践
这个 示例 只 演示 了 在 控制台 和 文件 中 去 记录 日志 ， 但 你 也 可以 自由组合 任意 数量 的 日志 处理器
返回值 是 一个 浮点数 ， 为 纪元 秒数 （ 参见   " time "   模块 ）
正则表达式 通常 用于 通过 将 正则 分成 几个 子 组来 解析 字符串 ， 这些 子组 匹配 不同 的 感兴趣 组件
如果 文件 已经 存在 ， 则 抛   出   " FileExistsError "   异常
data   应当 是 一个 包含 一行 或 多行 内容 的   bytes   like   object
0   ( 默认值 )   表示 基于 其他 过滤器 选项 自动 选择
" keyword "   检验 Python 关键字
基于 给定 密钥   key   和   digest   返回   msg   的 摘要
目前 ，   " Decimal "   实例 总是 规范 的 ， 所以 这个 操作 总是 返回   " True "
（ 由   Raymond   Hettinger   和   Steven   D ' Aprano   在   bpo   35904   中 贡献   。 ）
如果 省略   count ， 则 忽略 次数 将 设置 为   0
bpo   35214 :   添加 了   clang   Memory   Sanitizer   构建 工具 以 绕过 来自   posix ,   socket ,   time ,   test _ io   和   test _ faulthandler   的 误报 问题
仅限 关键字 参数   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
( See   2to3   自动 将   Python   2   代码 转为   Python   3   代码   for   more   on   this   tool . )   Run   the   result   of   the   translation   under   Python   3.0
如果 文件 发生变化 ， 它会 被 关闭 并 使用 文件名 重新 打开
align   字符串   " left " ,   " center "   或   " right "
它们 是 一个 私有 类 的 实例 :
此 算法 没有 加密 强度 ， 不 应用 于 身份验证 和 数字签名
进程 间 共享 状态
名称 （ 字符串 ）   符号 值   " auth "   LOG _ AUTH   " authpriv "   LOG _ AUTHPRIV   " cron "   LOG _ CRON   " daemon "   LOG _ DAEMON   " ftp "   LOG _ FTP   " kern "   LOG _ KERN   " lpr "   LOG _ LPR   " mail "   LOG _ MAIL   " news "   LOG _ NEWS   " syslog "   LOG _ SYSLOG   " user "   LOG _ USER   " uucp "   LOG _ UUCP   " local0 "   LOG _ LOCAL0   " local1 "   LOG _ LOCAL1   " local2 "   LOG _ LOCAL2   " local3 "   LOG _ LOCAL3   " local4 "   LOG _ LOCAL4   " local5 "   LOG _ LOCAL5   " local6 "   LOG _ LOCAL6   " local7 "   LOG _ LOCAL7
( 在   py2exe   ,   PyInstaller   和   cx _ Freeze   上 测试通过 )
传递 给   " Struct "   和 模块 层级 函数 的 已 编译 版 最新 格式 字符串 会 被 缓存 ，   因此 只 使用 少量 格式 字符串 的 程序 无需 担心 重用 单独 的   " Struct "   实例
3.9   新版 功能 .
在 此 记录器 上 记录   " WARNING "   级别 的 消息
bpo   41984 :   垃圾 回收 器 现在 会 跟踪 所有 用户 定义 类
在   3.7   版 更改 :   这个 模块 曾经 为 可选项 ， 但 现在 总是 可用
" statistics "   数学 统计 函数
更 糟糕 的 是 ， 如果 问题 发生变化 并且 你 想要 将   " bat "   和   " exe "   排除 为 扩展 ， 那么 该 模式 将 变得 更加 复杂 和 混乱
这些 参数 是   pminrow   ,   pmincol   ,   sminrow   ,   smincol   ,   smaxrow   ,   smaxcol   ；   p   参数 表示 要 显示 的 面板 区域 的 左上角 而   s   参数 定义 了 要 显示 的 面板 区域 在 屏幕 上 的 剪切 框
该 函数 将 总是 返回 一个 新 的 引用 ，   但 不 保证 创建 一个 新 的 对象 ； 它 有 可能 返回 一个 现有 的 代理 对象
你 可以 注册 你 自己 的 转换器 并 或是 定制 已 提供 的 转换器
使用 参数   oparg   计算   opcode   的 堆栈 效果
这是 字符串 的 默认 类型 ， 可以 省略
这个 函数 也 可以 用来 执行 任何 代码 对象 （ 如   " compile ( ) "   创建 的 ）
超时 与   " accept "   方法
由   Jeroen   Demeyer 修复
类似 于   " copy ( ) " ， 区别 在于   " copy2 ( ) "   还会 尝试 保留 文件 的 元 数据
Capsule   的 析 构器 回调 的 类型
使用   " subprocess "   模块
不同 的 终端 使用 相差 很大 的 代码 ， 并且 往往 有 自己 的 小 怪癖
如果   a   是   int   类型 ， 则 直接 使用
增量 式 的 编码 和 解码
如果 输入 的 可 迭代 对象 完全 不 返回 任何 值   ， " TypeError "   异常 就 会 抛出
对于 浮点数 ， 它 将 向 零 舍入
调用   " join ( ) "   前 必须 先 调用   " close ( ) "   或者   " terminate ( ) "
这 相当于   Python   表达式   " key   in   o "
此 模块 提供 了 对   Unicode   Character   Database   ( UCD )   的 访问 ， 其中 定义 了 所有   Unicode   字符 的 字符 属性
如果   encoding   不 为   " None " ， 则 会 将 其 用作 打开 文件 的 编码 格式
非 无限 数 被 零除 的 信号
" partial ( ) "   接受 参数   " ( function ,   arg1 ,   arg2 ,   ... ,   kwarg1   value1 ,   kwarg2   value2 ) "
" | "   表明 在   Python   参数 列表 中 剩下 的 参数 都 是 可选 的
当 在 序列 中 循环 时 ， 用   " enumerate ( ) "   函数 可以 将 索引 位置 和 其 对应 的 值 同时 取出
（ 由   Tim   Hopper   和   Dan   Lidral   Porter   在   bpo   20523   中 贡献 。 ）
（ 由   Victor   Stinner   在   bpo   39947   中 贡献 。 ）
在 确定 数字 大 小时 字 面值 中 的 下划线 会 被 忽略
这 意味着 以下 代码 将 打印 出   42 :
则 执行 如下 代码 将 在   " spam "   模块 中 添加 对   " foo "   和   " bar "   的 名称 绑定 :
获取 和 安装   MacPython
如果 单独 使用   " METH _ VARARGS "   ， 函数 会 等待 Python 传来 tuple 格式 的 参数 ， 并 最终 使用   " PyArg _ ParseTuple ( ) "   进行 解析
" TarInfo "   对象 具有 以下 公有 数据 属性 :
处理 等待 下 一个 项目 时 引发 的 异常
接下来 可以 在 后续 读取 时 直接 返回 缓冲 数据
锁 是 条件 对象 的 一部分 ， 你 不必 单独 地 跟踪 它
例如 ，   " operator . add ( x ,   y ) "   与 表达式   " x + y "   相同
基于 路径 的 查找 器会 迭代 搜索 路径 中 的 每个 条目 ， 并且 每次 都 查找 与 路径 条目 对应 的   path   entry   finder   ( " PathEntryFinder " )
" gc "   垃圾 回收 器 接口
返回 一个   " DatagramHandler "   类 的 新 实例 ， 该 实例 旨在 与 使用   host   与   port   给定 地址 的 远程 主机 进行 通信
对于   " executemany ( ) "   语句 ， 修改 行数会 被 汇总 至   " rowcount "
PEP   372 :   有序 字典
当 使用 此 方法 时 ， 回退 值 可以 通过   " fallback "   仅限 关键字 参数 来 提供 :
u   LAW   是 一种 音频 编码 格式 ， 仅 使用   8   位 采样 即可 获得 大约   14   位 的 动态 范围
如果 省略 此参数 或 设置 为   " None "   ， 则 创建 的 映射 不带 名称
（ 由   Serhiy   Storchaka   在   bpo   32749   中 贡献 。 ）
btn   鼠标 按钮 编号 ， 默认值 为   1   ( 鼠标 左键 )
下表 对   Python   中 运算符 的 优先 顺序 进行 了 总结 ， 从 最 低优先级 （ 最后 绑定 ） 到 最高 优先级 （ 最先 绑定 ）
init _ or _ size   必须 是 一个 指明 数组 大小 的 整数 ， 或者 是 一个 将 被 用来 初始化 数组 条 目的 字符串
请 注意 如果 消息 对象 没有 前导 文本 ， 则   preamble   属性 将 为   " None "
不带 表达式 参数 的   " return "   会 返回   " None "
这能 清楚 地 表明 ，   " cm "   作用 于 整个 函数 ， 而 不仅仅 是 函数 的 一部分 （ 同时 也 能 保持 不错 的 缩进 层级 ）
编写 自己 的 C 扩展 有 很多 选择 ， 具体 取决于 您 要 做 的 事情
这些 名称 是 由 解释器 及其 实现 （ 包括 标准 库 ） 定义 的
在 处理 大量 子 监视器 时 没有 明显 的 开销 (   O ( 1 )   每次 子 监视器 结束 )
这 意味着   " n "   的 值 在 第一个 lambda 中为   " 0 "   ， 在 第二个 lambda 中为   " 1 "   ， 在 第三个 中为   " 2 "   ， 依此类推
正如   Skein   哈希 函数 的 作者 所 言 :
后面 几行 应该 是 一个 或 多个 段落 ， 描述 对象 的 调用 约定 ， 它 的 副作用 等
在 大部分 情况 下 ， 这 应该 都 不会 有 附带 影响
这 可以 用于 从 一个 字符串 解码 JSON 文档 ， 该 字符串 的 末尾 可能 有 无关 的 数据
（ 由   Andrew   Svetlov   在   bpo   36921   中 贡献 。 ）
实例 化   " Cmd "   本身 是 没有 充分 理由 的 ，   它 作为 自定义 解释器 类 的 超类 是 非常 有用 的 为了 继承   " Cmd "   的 方法 并且 封装 动作 方法
为了 方便 起 见 ， 还 包括 了 C89 标准 不 需要 的 其他 一些 指令
他们 通过 检查 对象 的   " PyBufferProcs . bf _ releasebuffer "   字 段 是否 为   " NULL "   来 发挥作用 ， 该字 段 不 允许 为   " bytearray "   这样 的 可变 对象
使用 多个 日志 处理器 和 多种 格式化
发送数据 到   stdin   ( 如果   input   不 为   " None " ) ；
如果   " changes "   中 的 值 没有 指定 字 段 ， 则 引发   " TypeError "
发布 日期 :   2018   03   28
为了 防止 字段名 冲突 ， 方法 和 属性 以 下划线 开始
定义 单个 的 命令行 参数 应当 如何 解析
对应 于   " errno "   " ECONNREFUSED "
此 方法 的 参数 与   " make _ file ( ) "   方法 的 相同
在   3.5   版 更改 :   return   a   Morsel   object   instead   of   a   dict .
数组 以   " lists "   形式 返回
UNICODE   版本 通常 会 在 名字 最后 以   " W "   结尾 ， 而   ANSI   版本 的 则 以   " A "   结尾
可选 的 形参   length   设置 输出 缓冲区 的 初始 大小
代码 还 必须 使用 使用   Windows   的   " GetProcAddress ( ) "   例程 获得 的 指针 访问   " python   NN   . dll "   中 程序 和 数据 （ 即   Python   的   C   API   ）
将 在 指定   section   中 的   option   强制 转换 为 布尔值 的 便捷 方法
" pickletools "   pickle   开发者 工具集
返回 该 对象 的 哈希 值 （ 如果 它 有 的话 ）
返回   p   所 指向 的 结构 序列 中 ， 位于   pos   处 的 对象
在 这些 生成 的 方法 中 使用 的 成员 变量 使用   PEP   526   类型 注释 定义
文件 对象 有 一些 额外 的 方法 ， 例如   " isatty ( ) "   和   " truncate ( ) "   ， 它们 使用 频率 较 低 ； 有关 文件 对象 的 完整 指南 请参阅 库 参考
返回 与 代码 对象   code   关联 的 新 函数 对象
可用 的 值 请参阅 错误处理 方案
3.8   新版 功能 :   dirs _ exist _ ok   形参
3.7   新版 功能 .
3.5   新版 功能 .
当   " return "   将 控制 流传 出 一个 带有   " finally "   子句 的   " try "   语句 时 ， 该   " finally "   子句 会先 被 执行 然后 再 真正 离开 该 函数
创建 虚拟环境 后 ， 您 可以 激活 它
例如 ，   " a [ i ]   +   f ( x ) "   首先 查找   " a [ i ] " ， 然后 对   " f ( x ) "   求值 并 执行 加法 操作 ， 最后 将 结果 写 回到   " a [ i ] "
对于 其他 非   POSIX   平台 ，   目前 只是 返回   " sys . platform "
附加 工具 类 和 函数
（ 必须 定义 为类 方法 。 ）
可以 使用 以下 的 常量 :
因此 ， 如果 所 输入   iterable   是 已 排序 的 ， 组合 元组 也 将 按 已 排序 的 顺序 生成
" functools "   模块 定义 了 以下 函数 :
它 早晚 会 因为 访问 到 野 指针 或者 什么 的 把 自己 搞 崩溃 ， 所以 我们 最好 在 遇到   " NULL "   后 就让 它 退出 循环 :
或者 ，   手动 删除程序 包 目录 并 再次 安装
" transport . abort ( ) "   立即 关闭 传输
Windows 系统 相关 模块
3.9   版后 已 移除 :   " collections . abc . Container "   now   supports   " [ ] "
如果 要 标注 参数 的话 ， 使用 如   " Mapping "   的 抽象 容器 类型 是 更好 的 选择
与 Python 相关 的 路径 和 文件
3.5   新版 功能 .
如果   indent   是 一个 字符串 （ 比如   ` ` " \ t " " ） ， 那个 字符串 会 被 用于 缩进 每 一层
3.3   版后 已 移除 :   现在 可以 让   " property " ,   " property . getter ( ) " ,   " property . setter ( ) "   和   " property . deleter ( ) "   配合   " abstractmethod ( ) "   使用 ， 使得 此 装饰 器 变得 冗余
在 类型 标注 中 现在 你 可以 使用 内置 多项 集 类型 例如   " list "   和   " dict "   作为 通用 类型 而 不必 从   " typing "   导入 对应 的 大写 形式 类型 名   ( 例如   " List "   和   " Dict " )
PEP   465   用于 矩阵 乘法 的 专用 中缀 运算符
使用 上下文 的   " traps "   字段 中 的 字典 设置 单个 陷阱 ：
" tkinter . dnd "   拖放 操作 支持
属性   " loop . slow _ callback _ duration "   可 用于 设置 以 秒 为 单位 的 最小 执行 持续时间   ， 这 被 视为 “ 缓慢 ”
在   3.9   版 更改 :   This   function   is   now   also   available   in   the   limited   API .
不同于   " dbm . gnu "   等 其他 模块 ， 它 不 需要 外部 库
3.6   版后 已 移除 :   keyfile   and   certfile   are   deprecated   in   favor   of   context
对于 不 指定   " key "   形参 而是 基于 文件 构造 时 区 ， 该 属性 将 设为   " None "
如果 带有   lineno   参数 ， 则 在 当前 文件 相应 行处 设置 一个 断点
" threading . Thread "   的   " isAlive ( ) "   方法 已 被 移除
这些 字符 会 被 忽略 ， 但 作为 结果 的 已 解码 字节 串 可能 无效
在 这里 还 可以 发现 更 多 细节 ， 特定 形参 可以 被 标记 为 仅限 位置
对于 多数 应用 来说 ， 在 最 简单 的 情况 下 ， 你 可以 认为 搜索 从 父类 所 继承 属性 的 操作 是 深度 优先 、 从 左 至 右 的 ， 当 层次结构 中 存在 重叠 时 不会 在 同一个 类中 搜索 两次
如果   size   为 一个 整型 数则 将 开辟 一个 指定 大小 的 空 缓冲区
解释器 也 可以 通过 交互 模式 被 发起 调用 ； 在 此 情况 下 ， 它 并 不 读取 和 执行 一个 完整 程序 ， 而是 每次 读取 和 执行 一条 语句 （ 可能 为 复合 语句 ）
是   " parseaddr ( ) "   的 逆 操作 ， 接受 一个   " ( 真实 名字 ,   电子邮件 地址 ) "   的 二元 组 ， 并 返回 适合 于   To   or   Cc   标头 的 字符串
成功 时 返回   " 0 " ， 失败 时 返回   "   1 "
要 想 补充 或 覆盖   dialect   参数 ， 程序员 还 可以 单独 指定 某些 格式 参数 ， 这些 参数 的 名称 与 下面   " Dialect "   类 定义 的 属性 相同
这个 美妙 的 属性 允许 你 在 一系列 排序 步骤 中 构建 复杂 的 排序
将 运算符 映射 到 函数
它 派生 自   " MessageError "
返回 一个 可 等待 对象 ， 它会 在 运行 时向 异步 生成器 函数 暂停 的 位置 抛入 一个   " GeneratorExit "
如果 未指定   mode   ， 则 会 使用   " ' a ' "
对于 非 数字 类型 ， 该字段 表示 最大 字 段 大小   — —   换句话说 就是 要 使用 多少 个 来自 字 段 内容 的 字符
获取 一个 查询 结果 的 所有 （ 剩余 ） 行 ， 返回 一个 列表
" FMT _ XML "   格式 的   XML   数据 会 使用 来自   " xml . parsers . expat "   的   Expat   解析器 请参阅 其 文档 了解 错误 格式   XML   可能 引发 的 异常
仅限   Windows ： 创建   " OleDLL "   实例
缩进 更少 的 行 不 应该 出现 ， 但是 如果 它们 出现 ， 则 应该 剥离 它们 的 所有 前导 空格
使用   " str . split ( ) "   将 参数 拆 分为 单词 ， 使用   " str . capitalize ( ) "   将 单词 转为 大写 形式 ， 使用   " str . join ( ) "   将 大写 的 单词 进行 拼接
否则 ， 如果 任一 参数 为 浮点数 ， 另 一 参数 会 被 转换 为 浮点数 ；
DTrace 和 SystemTap 是 监控 工具 ， 它们 都 提供 了 一种 检查 计算机系统 上 的 进程 的 方法
日志 记录器 的 传播 设置
现在 静态 链接 的   Python   将 可以 加载 使用 共享 库   Python   构建 的   C   扩展
这样 ， 将来 调用   " poll ( ) "   方法 时 将 检查 文件 描述符 是否 有 未 处理 的   I / O   事件
（ 由   Serhiy   Storchaka   在   bpo   35459   中 贡献 。 ）
发生 线程 相关 错误 时 抛出
从 队列 中 取出 并 返回 对象
指针 类型 会 被 缓存 并 在 内部 重用 ， 因此 重复 调用 此 函数 耗费 不 大
如果 传入 了 整型 参数   waitflag   ， 具体 的 行为 取决于 传入 的 值 ： 如果 是   0   的话 ， 只会 在 能够 立刻 获取 到 锁 时 才 获取 ， 不会 等待 ， 如果 是非 零 的话 ， 会 像 之前 提到 的 一样 ， 无条件 获取 锁
在   " sys . path "   中 只能 出现 字符串 和 字节 串 ； 所有 其他 数据类型 都 会 被 忽略
它 同样 包含 在   Python   源码 发布 包中 ， 文件名 为   " Tools / scripts / diff . py "
DLL   的 实际 使用
此 特性 不 被   " 标准 "   Ascii85   编码 格式 所 支持
bpo   36262 :   修复 了 在   " float ( str ) " ,   " complex ( str ) " ,   " pickle . load ( ) " ,   " marshal . load ( ) "   等 所用 的 函数   " _ Py _ dg _ strtod ( ) "   中 进行 从 字符串 到 浮点数 的 转换 时偶 有 发生 的 一个 内存 泄漏 问题
3.3   新版 功能 .
多个 测试运行 的 顺序 由 内置 字符串 排序 方法 对 测试 名 进行 排序 的 结果 决定
" hash ( ) "   的 结果 应该 与 是否 相等 一致
包含   HTTP   请求 行 的 字符串 表示
引发 一个 审计 事件   " winreg . EnumKey " ， 附带 参数   " key " ,   " index "
3.5   新版 功能 .
请 注意 ， 配置文件 中 引用 的 类 名称 需要 相对 于 日志 记录 模块 ， 或者 可以 使用 常规 导入 机制 解析 的 绝对值
如果 整个 结果 字节 串 都 包含 压缩 数据 ， 它 将 为 一个 空 的   bytes   对象   " b " " "
通常 在   Python   中   ( 以及 在 标准 库 的 所有 代码 中 )   会 改变 原 对象 的 方法 将 返回   " None "   以 帮助 避免 混淆 这 两种 不同 类型 的 操作
如果 你 在 自己 的 可执行文件 中 加载   " python3 . dll "   或   " python37 . dll "   ， 在   " Py _ Initialize ( ) "   之前 ， 要 显式 调用   " Py _ SetPath ( ) "   或 （ 至少 ）   " Py _ SetProgramName ( ) "
在   3.7   版 更改 :   database   现在 可以 是 一个   path   like   object   对象 了   ， 不仅仅 是 字符串
如果   n   小于   1   则 将 引发   " StatisticsError "
联合 类型 的 联合 类型 会 被 展开 打平 ， 比如 :
（ 由   Serhiy   Storchaka   在   bpo   9179   中 贡献 。 ）
为了 获得 真正 能 独立 运行 的 应用程序 ， 来自 库里 的   Tcl   脚本 也 需要 被 整合 进 应用程序
它 只能 作为 位置 参数 传入
文件 中 的 这些 命令 以前 是 无效 的
如果 参数 为 字符串 ，   则 不 允许 有 开头 或 末尾 的 空格 或 下划线
这个 模块 为 应用 与 库 实现 了 灵活 的 事件 日志 系统 的 函数 与 类
某些 模块 仅 适用 于 同一 台 机器 上 的 两个 进程 ， 例如   " signal "   和   " mmap "
callback   也 可以 为   " None "   或   " NULL "
推荐 使用   " isinstance ( ) "   内置 函数 来 检测 对象 的 类型 ， 因为 它会 考虑 子类 的 情况
转换 老 的 不 等 语法 ， 将   " < > "   转为   " !   "
从   iterable   所 定义 的 数据 集中 返回 前   n   个 最小 元素 组成 的 列表
命令   描述   include   pat1   pat2   ...   包括 与 列出 的 模式匹配 的 所有 文件   exclude   pat1   pat2   ...   排除 与 列出 的 模式匹配 的 所有 文件   recursive   include   dir   pat1   pat2   ...   包括   dir   下 与 列出 的 模式匹配 的 所有 文件   recursive   exclude   dir   pat1   pat2   ...   排除   dir   下 与 列出 的 模式匹配 的 所有 文件   global   include   pat1   pat2   ...   包括 与 源树 匹配 的 所有 文件 和 任何 列出 的 模式   global   exclude   pat1   pat2   ...   排除 与 源树 匹配 的 所有 文件 和 任何 列出 的 模式   prune   dir   排除   dir   下 的 所有 文件   graft   dir   包括   dir   下 的 所有 文件
在   3.8   版 更改 :   如果 可用 将 使用   " __ index __ ( ) "
为 窗口 设置 阻塞 或非 阻塞 读取 行为
谨防 将   " sys . stdin "   数据 替换 为   “ 类似 文件 的 对象 ”
请 注意 使用   " for   line   in   file :   ... "   就 足够 对 文件 对象 进行 迭代 了 ，   可以 不必 调用   " file . readlines ( ) "
调用   " encode ( ) " / " decode ( ) "   方法 后 的 全部 输出 相当于 将 所有 通过 无 状态 编码器 / 解码器 进行 编码 / 解码 的 单个 输入 连接 在 一起 所 得到 的 输出
一个 简短 的 用法 示例 :
PEP   420   还 引入 了   " find _ loader ( ) "   协议 作为   " find _ module ( ) "   的 替代
如何 在 不 阻塞 的 情况 下 检查 按键 ？
根据 格式 字符串   format   和 额外 参数 ， 输出 不 超过   size   字节 到   str
作者 :   Guido   van   Rossum
不过 在 某些 特殊 情况 下 ， 模块 是 在 其 安装 目录 中 被 构建 的 ， 因此 这 可能 会 是 个 有用 的 功能
由 第三方 扩展 模块 所 导出 的   " PyTypeObject "   应该 具有 当前   Python   版本 所 要求 的 所有 空位   ， 包括   " tp _ finalize "   ( " Py _ TPFLAGS _ HAVE _ FINALIZE "   不会 再 在 读取   " tp _ finalize "   之前 被 检查 )
应用程序 要 负责 确保 正确 地 转义 所有 空白 字符 和 特殊字符 以 防止   shell   注入 漏洞
" PyEval _ CallObject " ,   " PyEval _ CallFunction " ,   " PyEval _ CallMethod "   和   " PyEval _ CallObjectWithKeywords "   函数 已 被 弃用
另 一个 用法 是 传递 一个 小 函数 作为 参数 :
在   Windows   上 非法 字符   ( " : " ,   " < " ,   " > " ,   " | " ,   " " " ,   " ? " ,   and   "   " )   会 被 替换 为 下划线   ( " _ " )
Python   3.1   有 什么 新 变化
开发 过程 的 变化
" NoneType "   类型 的 唯一 值
Python   适合 做 什么 ？
" importlib . import _ module ( ) "   以及 内置 的   " __ import __ ( ) "   等 函数 也 可以 被 用来 发起 调用 导入 机制
一些 典型 的 值 包括 :   " " general " "   或   " " common " "
header   旗标 控制 空格符 是否 要 编码 为 下划线 ， 具体 描述 见   RFC   1522
CPython   支持 两种 不同 的 调用 协议 ：   tp _ call   和 矢量 调用
函数 和 方法 装饰 器 是 在   PEP   318   中 被 引入 的
超出范围 的 索引 号会 以 与 普通 切片 一致 的 方式 进行 剪切
系统 将 通过 为 文件名 添加 扩展名 来 保存 旧 日志 文件
如果 之前 保存 在   capsule   中 的   name   不 为   " NULL " ， 则 不会 尝试 释放 它
类似 于   " PyObject _ New ( ) "   ， 适用 于 设置 了   " Py _ TPFLAGS _ HAVE _ GC "   标签 的 容器 对象
启动 安装程序 后 ， 可以 选择 以下 两个 选项 之一 ：
如果 环境变量   " PYTHONPATH "   存在 ， 如 环境变量 中 所述 ， 则 接下来 添加 其 条目
此 返回值 是 与   " time . time ( ) "   返回值 类似 的   " float "   对象
出现 身份验证 错误 时 引发
include   all   Python   source   files   in   the   " distutils "   and   " distutils / command "   subdirectories   ( because   packages   corresponding   to   those   two   directories   were   mentioned   in   the   " packages "   option   in   the   setup   script   see   section   编写 安装 脚本 )
一些 用法 示例 ：
Python   行为 的 改变
在   3.6   版 更改 :   Out   of   range   port   numbers   now   raise   " ValueError " ,   instead   of   returning   " None " .
在   " is _ multipart ( ) "   返回   " True "   的 场合 下 ， 负载 应当 是 一个 字符串 对象 （ 有 可能 是 一个 使用 了 内容 传输 编码 进行 编码 的 二进制 负载 ）
参数 :   name   一个 有效 的 形状 名 字符串
受 支持 的   INI   文件 结构
Catucci   和   Antoine   Pitrou   在   bpo   4471   中 贡献 。 ）
当以   RFC   2231   格式 来 编码 标头形 参时 ， " Message . get _ param "   可能 返回 一个 包含 字符集 、 语言 和 值 的   3   元组
下表 概述 了 已知 的 攻击 以及 各种 模块 是否 容易 受到 攻击
要 了解   " property ( ) "   如何 根据 描述 器 协议 实现 ， 这里 是 一个 纯   Python   的 等价 实现 如下 :
在 失败 时 设置 一个 异常 并 返回   " NULL "
应用程序 可以 使用   " rmtree . avoids _ symlink _ attacks "   函数 属性 来 确定 此类情况 具体 是 哪 一些
对 记录 的 属性 字典 执行 封存 并 以 二进制 格式 将 其 写入 套 接字
这样 的   " NaN "   是 静默 产生 的 ， 并且 在 产生 之后 参与 其它 计算 时 总是 会 得到   " NaN "   的 结果
返回 一个 字符串 描述 运算 数 的   class
在   3.5   版 更改 :   添加 了   numeric _ owner   形参
如果 有 位置 参数 ， 它们 必须 和   " T ._ fields "   中 的 元素 一样 多 ； 他们 会 像 这些 名字 的 属性 一样 被 赋值
结果 状态   " MMDFMessage "   状态   R   标记   R   标记   O   标记   O   标记   D   标记   D   标记   F   标记   F   标记   A   标记   A   标记
在   3.2   版 更改 :   添加 了 上下文 管理器 支持
“ 修改 ”   允许 您 通过 修改 复选框 来 添加 或 删除 功能 未 更改 的 复选框 将 不会 安装 或 删除 任何 内容
请 注意 前导 空格 在   Python   语句 中是 有 重要 作用 的 ！
" arg0 "   是 事件 名称 的   C   字符串 ， " arg1 "   是 一个 指向 元组 对象 的   " PyObject "   指针
" defaultdict "   是 内置   " dict "   类 的 子类
在   3.9   版 更改 :   类 可 使用 任何 有效 的   " assignment _ expression "   来 装饰
对于 所有 满足 这些 条件 的   " ( i ' ,   j ' ,   k ' ) " ， 如果   " i   i ' " ,   " j   <   j ' "   也 被 满足 ， 则 附加条件   " k   >   k ' " ,   " i   <   i ' "
" html "   超文本 标记 语言 支持
在   3.4   版 更改 :   添加 了   atTime   形参
在 交互 模式 下 ， 如果 结果 值不为   " None " ， 它会 通过 内置 的   " repr ( ) "   函数 转换 为 一个 字符串 ， 该 结果 字符串 将 以 单独 一行 的 形式 写入 标准 输出 （ 例外情况 是 如果 结果 为   " None " ， 则 该 过程 调用 不 产生 任何 输出 。 ）
如果 输入 字节 串 对象 的 引用 计数 不 为 一则 调用 此 函数 将 报错
hide   是 需要 隐藏 的 文件名 列表 ， 且 默认 为   " [ os . curdir ,   os . pardir ] "
而 相应 的 更 简洁 更   Pythonic   的 方法 是 这样 的 :
当 给定   seed   时 ， 创建 一个 新 的 底层 随机数 生成器 实例
" ArgumentParser "   对象 允许 通过 指定 备用 格式化 类 来自 定义 帮助 格式
一个 字符串 形式 的 助记符 ， 用来 指明 发生 错误 的 原因 ， 例如   " CERTIFICATE _ VERIFY _ FAILED "
当 同时 给出   mapping   和   kwds   并且 存在 重复 时 ， 则 以   kwds   中 的 占位 符为 优先
3.8   新版 功能 :   "   bind "   argument   enhanced   to   support   IPv6
3.8   新版 功能 .
替代   " os . popen ( ) " ,   " os . popen2 ( ) " ,   " os . popen3 ( ) "
" ctypes "   将 创建   descriptor   ， 它 允许 通过 直接 属性 访问 来 读取 和 写入 字 段
如果 您 想 分析   Python   代码 的   AST   表示 ， 请参阅   " ast . parse ( ) "
" PyCompilerFlags "   结构 体 添加 了 一个 新 的   cf _ feature _ version   字 段
完成 此 操作 后 ，   您 可以 分发 应用程序 ， 而 无需 用户 安装 Python
因此 如果 稍后 还 需要 返回 结果 ， 可 保存 为 列表 ：
在   " async   def "   函数 中 构建 推导 式 可以 通过 在 打头 的 表达式 后 加上   " for "   或   " async   for "   子句 ， 也 可能 包含 额外 的   " for "   或   " async   for "   子句 ， 还 可能 使用   " await "   表达式
在   3.3   版 更改 :   在 版本 3.2 中 ， " strftime ( ) "   方法 只 限于   years   >   1000
子类 的 文档 位于 段落   FileCookieJar   subclasses   and   co   operation   with   web   browsers
允许 通过 支持 的 模式 打开 用于 读取 或 写入 文本 或 二进制 数据 :   ' r ' ,   ' w ' ,   ' rb ' ,   ' wb '
例如 ， 以下 代码   " if   key   in   mapping :   return   mapping [ key ] "   可能 由于 在 检查 操作 之后 其他 线程 从   mapping   中移 除了   key   而 出错
" abc "   抽象 基类
生成器 表达式 是 用 圆括号 括 起来 的 紧凑 形式 生成器 标注
3.5   新版 功能 .
（ 由   Terry   J
模拟 一个 字符串 对象
此 异常 的 实例 提供 了 三个 有用 属性 :   " msg "   为 错误 的 文本 说明 ， " filename "   为 源文件 的 名称 ， 而   " lineno "   给出 了 错误 所在 的 行号
隐式 的 行 拼接 可以 带有 注释
dict _ type   为 字典 用来 从   plist   文件 读取 的 类型
一次性 地 创建   Struct   对象 并 调用 其 方法 相比 使用 同样 的 格式 调用   " struct "   函数 更为 高效 ， 因为 这样 格式 字符串 只 需 被 编译 一次
C   API   中 的 改变
例如 :   " ( x   y   for   x   in   range ( 10 )   for   y   in   range ( x ,   x + 10 ) ) " .
一个 完整 的   Python   程序 会 在 最小 初始化 环境 中 被 执行 ： 所有 内置 和 标准 模块 均 为 可用 ， 但 均 处于 未 初始化 状态 ， 只有   " sys "   ( 各种 系统 服务 ) ,   " builtins "   ( 内置 函数 、 异常 以及   " None " )   和   " __ main __ "   除外
接收 一条 信息 ， 使用   authkey   作为 键 计算 信息 摘要 ， 然后 将 摘要 发送 回去
3.7   新版 功能 .
key   为 某个 已经 打开 的 键 ， 或者 预定 义 的   HKEY _   常量 之一
这 意味着 长 序列 的 大多数 排列 永远 不会 产生
此 函数 不会 检查数据 点 之间 是否 至少 相隔   interval   的 距离
要 为 所有 格式化 程序 更改 此项 ， 例如 当 你 希望 所有 日志 时间 都 显示 为   GMT ， 请 在   " Formatter "   类中 设置   " converter "   属性
在 Unix 平台 中 使用 Python
对于 失效 的 符号 链接 ， 返回   " False "
确定   code   是否 属于   tableC.2 . 2   ( 非   ASCII   控制字符 )
errors   是 一个 可选 的 字符串 参数 ， 用于 指定 如何 处理 编码 和 解码 错误 这 不能 在 二进制 模式 下 使用
字符串 中 的 回车 换行 会 自动 包含 到 字符串 中 ， 如果 不想 包含 ， 在 行尾 添加 一个   " \ "   即可
开头 的 四行 对应   " Screen . setup ( ) "   方法 的 参数
对象 必须 不 为   " NULL " ； 如果 你 不 确定 它 不 为   " NULL " ， 可 使用   " Py _ XDECREF ( ) "
flags   形参 应当   " os . O _ APPEND " ,   " os . O _ RDONLY "   和   " os . O _ TEXT "   按位   OR   的 结果
当   maxsplit   非 零时   ， 将 最 多 进行   maxsplit   次 拆分 ， 并且 字符串 的 其余部分 将 作为 列表 的 最后 一个 元素 返回
为了 能 正确 地 与 抽象 基类 机制 实现 互操作 ， 描述符 必须 使用   " __ isabstractmethod __ "   将 自身 标识 为 抽象 的
如果 在   10   次 尝试 后 字节 数据 仍 无法 被 锁定 ， 则 会 引发   " OSError "
列表 作为 队列 使用
" fractions "   和   " decimal "   模块 可令 进行 此类 计算 更加 容易 :
要 允许 用户 在 没有 测试 套件 的 情况 下 轻松 安装 Python 的 个人 副本 ， 可以 使用 以下 命令 提供 快捷方式
在   3.7   版 更改 :   repeat   的 默认值 由   3   更 改为   5
大多数 函数 返回 一个 对象 的 引用 ， 并 传递 引用 拥有 关系
" \ W "   匹配 任何 非 字母 与 数字 字符 ； 这 相当于 类   " [ ^ a   zA   Z0   9 _ ] "
保留 的 标识符 类
frame   参数 必须 不 为   " NULL "
此 模块 所 提供 的 实现 了 序列 行为 的 类 同样 也 可 用于 子 类化 ：
" shutil "   高阶 文件 操作
行号 ， 用于 每行 的 第一条 指令
在   3.8   版 更改 :   以前 ， 不 支持 带有 档案 注释 的   ZIP   档案
成功 时 返回   o   转换 为 整数 对象 后 的 结果 ， 失败 时 返回   " NULL "
（ 由   Berker   Peksag   在   bpo   9372   中 贡献 。 ）
下列 函数 适用 于   " set "   或 其子 类型 的 实例 ， 但 不可 用于   " frozenset "   或 其子 类型 的 实例
3.4   新版 功能 .
Unicode   4.1   中 所有 可用 的 标识符 字符 列表 可 参见 以下 非正式   HTML   文件   https : / / www . unicode . org / Public / 13.0 . 0 / ucd / DerivedCoreProperties . txt
此外 ， 严格 的   1982   年 原始   RFC   822   标准 要求 两位数 的 年份 （ % y 而 不是 % Y ） ， 但是 实际 在 2000 年 之前 很久 就 转移 到 了   4 位数 年
内存 可以 是   C   扩展 中 的 一个 大 的 常量 数组 ， 也 可以 是 在 传递 到 操作系统 库 之前 用于 操作 的 原始 内存 块 ， 或者 可以 用来 传递 本 机 内存 格式 的 结构化 数据
如果 实例 的 字典 具有 与非 数据 描述 器 同名 的 条目 ， 则 该 字典 条目 优先
在 这种 情况 下 ， 数据 类 将 向 类 添加   " __ setattr __ ( ) "   和   " __ delattr __ ( ) "   方法
如果 在 已 记录 的 消息 中 使用 这些 属性 ， 则 需要 格外 小心
在   3.2   版 更改 :   通过 提供 用于 创建 记录 的 工厂 方法 已 使得   " LogRecord "   的 创建 更 易于 配置
特定 于   FreeBSD   的 更改 ：
" calendar "   日历 相关 函数
" http . client "   HTTP   协议 客户端
正规 形式 KD （ NFKD ） 将 应用 兼容性 分解 ， 即用 其 等价 项 替换 所有 兼容性 字符
它 应当 产生 一个 可变 序列 对象 （ 例如 列表 ）
返回 一个 字节 串 对象 作为 字符   ch   的 可 打印 表示 形式
这种 字符串 可 包含 替换 字 段 ， 即以   " { } "   标示 的 表达式
失败 时会 引发 异常 并 返回   "   1 "   ； 成功 时 返回   " 0 "
创建 一个 共享 的   " threading . Semaphore "   对象 并 返回 它 的 代理
Python   2.0   有 什么 新 变化
Tk   Widget   Styling   Support   一份 文档 介绍 Tk 支持 的 主题
需要 注意 的 点 在于 ，   " sys . stdout "   的 全局 副作用 意味着 此 上下文 管理器 不 适合 在 库 代码 和 大多数 多线程 应用程序 中 使用
写 一个 返回 斐波 那契 数列 的 列表 （ 而 不是 把 它 打印 出来 ） 的 函数 ， 非常简单 :
参数 可以 是 浮点数 ， 以 指示 更 精确 的 睡眠 时间
使   " \ w " 、 " \ W " 、 " \ b " 、 " \ B "   和 大小写 敏感 匹配 依赖于 当前 区域 而 不是   Unicode   数据库
" tm _ isdst "   会 强制 设 为   0
" printf "   风格 的 字节 串 格式化
一个 虚 数字 面值 将 生成 一个 实部 为   0.0   的 复数
该 datetime   对象 的 非 日期 部分 将 使用 其 标准 默认值 来 填充
将流 的 大小 调整 为 给定 的   size   个 字节 （ 如果 未指定   size   则 调整 至 当前 位置 ）
当 通过 调用 参数 列表 中 的 对象 构造 器 创建对象 时 很 实用
为了 支持 扩展 ， Python   API （ 应用程序 编程 接口 ） 定义 了 一系列 函数 、 宏 和 变量   ， 可以 访问   Python   运行 时 系统 的 大部分 内容
（ 由   Dong   hee   Na   在   bpo   37804   中 贡献 。 ）
等价 于   Python   语句   " o1   / /   o2 "
如果 可 识别 则 默认 为   fileobj   的 模式 ； 否则 默认 为   " ' rb ' "
文件 不能 重命名 或 删除
为   " object .__ enter __ ( ) "   提供 的 一个 默认 实现 是 返回   " self "   而   " object .__ exit __ ( ) "   是 一个 默认 返回   " None "   的 抽象 方法
参数 :   size   一个 整型 数值 或   " None "
要 获取 Lisp 样式 的 列表 ， 可以 使用 元组 模拟 cons 单元 ：
3.8   新版 功能 .
（ 由   Kyle   Stanley   在   bpo   39349   中 贡献 。 ）
创建 一个 迭代 器 ， 只 返回   iterable   中   predicate   为   " False "   的 元素
使用   " datetime "   对象 的 例子 ：
用户 也 可以 禁用 通常 的   Shell   主 模块 重启
列表 推导 式 中 的 初始 表达式 可以 是 任何 表达式 ， 包括 另 一个 列表 推导 式
Python   定义 了 两种 类型 的 包 ，   常规 包 和 命名 空间 包
install   命令 会 确保   build   命令 已经 运行 ， 然后 运行 子 命令   install _ lib   ,   install _ data   和   install _ scripts
分配   n   个 字节 并 返回 一个 指向 分配 的 内存 的   " void   "   类型 指针 ， 如果 请求 失败 则 返回   " NULL "
返回 spinbox 当前 值
将 字节 码 计数器 的 值 增加   delta
当 一个 事件 将 其他 事件 排入 执行 计划 时 ， 它们 的 调试 时间 向 未来 方向 延长 ， 这样 它们 可 方便 地入 堆
当 解析器 读 到 无法 识别 的 声明 时 ， 此 方法 被 调用
为 提升 与   import   语句 的 一致性 ， 现在   " importlib . util . resolve _ name ( ) "   对于 无效 的 相对 导入 尝试 会 引发   " ImportError "   而 不是   " ValueError "
这些 函数 自   Python   3.2   或 更 早就 已 被 弃用
在   3.7   版 更改 :   start   and   end   are   now   adjusted   to   behave   like   " str [ start : end ] " .
下面 的   8   个 比特 位是 字符 本身 ， 上面 的 比特 位则 为 属性
返回 当前 对应 调用者 的 控制线 程 的   " Thread "   对象
如果 为空 ， 此包 将 替换 任何 接近 于 日期 格式 字符串   " ' % Y   % m   % d   % H : % M : % S ' "   的 内容
消除 副作用 意味着 不能 使用 随 程序运行 而 更新 的 数据结构 ； 每个 函数 的 输出 必须 只 依赖于 输入
" string "   模块 包含 一个 通用 的   " Template "   类 ， 具有 适用 于 最终用户 的 简化 语法
用于 在 重复 的 时间段 中 消除 边界 时间 歧义
这样 做 的 一个 后果 是 虽然   "   expression "   句法 可能 出现 于 显式 的 关键字 参数 之后   ， 但 它 会 在 关键字 参数 （ 以及 任何   "   expression "   参数 见下文 ）   之前 被 处理
字典 显示 是 一个 用花 括号 括 起来 的 可能 为空 的 键 / 数据 对 系列 :
连续 返回 由   iterable   元素 生成 长度 为   r   的 排列
根据   v   创建 一个   " PyFloatObject "   对象 ， 失败 时 返回   " NULL "
查找 给定 编码 的 编解码器 并 返回 其   " StreamReader "   类 或 工厂 函数
默认 实现 会 转至   " readall ( ) "   和   " readinto ( ) "
这些 文档 生成 自   reStructuredText   原 文档 ， 由   Sphinx   （ 一个 专门 为   Python   文档 写 的 文档 生成器 ） 创建
如果 为 带有 句点 的 名称 执行 调用 ， 它 将 尝试 尽量 求值 直到 最后 一部分 为止 而 不 产生 附带 影响 （ 函数 不会 被 求值 ， 但 它 可以 生成 对   " __ getattr __ ( ) "   的 调用 ） ， 并 通过   " dir ( ) "   函数 来 匹配 剩余 部分
请 注意 默认 的   " tzinfo . fromutc ( ) "   方法 在   " tzinfo "   的 子类 中 可以 被 重载   ， 从而 影响   " astimezone ( ) "   的 返回 结果
pass _ fds   是 一个 可选 的 在 父子 进程 间 保持 打开 的 文件 描述符 序列
测量 音频 信号 的 能量
协程 在 之后 有 机会 进行 清理 甚至 使用   " try "   ...   ...   " except   CancelledError "   ...   " finally "   代码 块 抑制 异常 来 拒绝请求
替代   / bin / sh   shell   命令 替换
在 所有   exit   处理程序 获得 运行 机会 之后 ， 所 引发 的 最后 一个 异常 会 被 重新 引发
保持 对 其 元素 弱 引用 的 集合 类
调用   " format ( value ,   format _ spec ) "   会 转换成   " type ( value ) .__ format __ ( value ,   format _ spec ) "   ， 所以 实例 字典 中 的   " __ format __ ( ) "   方法 将 不会 调用
如果   Future   为 取消 或 调用   " set _ result ( ) "   设置 了 结果 或 调用   " set _ exception ( ) "   设置 了 异常 ， 那么 它 就是 完成
其中   T   是 两个 序列 中 元素 的 总 数量 ， M   是 匹配 的 数量 ， 即   2.0   M   /   T
禁用   " site "   的 导入 及其 所 附带 的 基于 站点 对   " sys . path "   的 操作
font   字体 指示 符 元组   ( family ,   size ,   options )   name   唯一 的 字体 名   exists   指向 现有 命名 字体 （ 如果 有 ）
文件 关闭 后 ， 对 文件 的 任何 操作 （ 例如 读取 或 写入 ） 都 会 引发   " ValueError "
返回 库 文件 的 文件名
计算 反向 累积 分布 函数 ， 也 称为 分 位数 函数 或 百分点 函数
带 参数 调用 该 方法 来 改变 选择 在   Python   3.6   中 已弃 用
如果 目标 是 已 存在 的 目录 ， 则   src   会 被 移至 该 目录 下
成功 时 返回   " 0 " ， 失败 时 返回   "   1 "
本节 中 的 大部分 示例 都 使用   TurtleScreen   类 的 一个 实例 ， 命名 为   " screen "
如果 已经 有 数据 从流 中 被 读取 则 将 无法 再 改变 编码 格式 或行 结束符
PyQt   PyQt   是 一个 针对   Qt   工具集 通过   sip   包装 的 绑定
在   3.5   版 更改 :   Added   support   for   passing   file   descriptor   to   this   function .
它 不是 嵌套 实体 ， 而是 一遍 又 一遍 地 重复 一个 具有 几千个 字符 的 大型 实体
如果 对象 实现 了 垃圾 回收 器 协议 则 返回 非零值 ， 否则 返回   0
当 使用 管道 时用   " Popen . communicate ( ) "   来 规避 它
其他 更为 通用 的 则 定义 在 这里
3.8   新版 功能 .
在 进程 之间 交换 对象
表明 在 发生 舍入 之后 的 指数 大于   " Emax "
如果   denominator   为   " 0 "   将会 引发   " ZeroDivisionError "
以本机 或 标准   bool   类型 表示 的   0   或   1   将 被 打包 ， 任何 非零值 在 解包 时 将 为   " True "
这 在 调试 期间 与   JSON   输入 进行 比较 时会 很 有用
" pprint "   数据 美化 输出
" str "   是 内置 字符串   class
过期 的   NFS   文件 句柄
所有 算术 和 位 运算 具有 相同 的 优先级 :
在   CPython   里 ， 基于 生成器 的 协程 （ 使用   " types . coroutine ( ) "   或   " asyncio . coroutine ( ) "   包装 的 生成器 ） 都 是 可 等待 对象   ， 即使 他们 不 含有   " __ await __ ( ) "   方法
在 每个 线程 的   " run ( ) "   方法 被 调用 前 ，   func   会 被 传递 给   " sys . settrace ( ) "
查看   " BaseHandler . < protocol > _ response ( ) "   以 获取 更 多 信息
" try "   ...   " except "   语句 有 一个 可选 的   else   子句   ， 在 使用 时 必须 放在 所有 的   except   子句 后面
当 另 一 集合 远大于 基础 集合 的 情况 下 优化 了   " difference _ update ( ) "   的 性能
将   coro   协程 打包 为 一个   " Task "   排入 日程 准备 执行
向 实例 添加 一个 名为   section   的 节
这 适用 于 当 你 想要 匹配 可能 带有 特殊字符 的 任意 字符串 字 面值 的 情况
如果 你 需要 更多地 控制 日期 / 时间 的 格式 ， 请 为   " basicConfig "   提供   datefmt   参数 ， 如下 例 所示 :
如果   follow _ symlinks   为 假值 ， 并且   src   和   dst   均 为 符号 链接 ，   " copymode ( ) "   将 尝试 修改   dst   本身 的 模式 （ 而 非 它 所 指向 的 文件 ）
例如 ， 对于 以下 函数 定义   :
这 完全 由   value   中 的 位数 决定
将 记录 输出 到 文件
3.1   新版 功能 :   " NullHandler "   类
对象 可以 包含 任意 数量 和 类型 的 数据
执行 在   string   参数 中 提供 的 初始化 行
" fractions . gcd ( ) "   函数 已 被 移除 ， 它 自   Python   3.5   起 被 弃用   ( bpo   22486 )   ： 请 改用   " math . gcd ( ) "
此 复制 是 破坏性 的 ， 这 意味着 当前 背景 字符 会 覆盖 掉   destwin   的 旧 内容
注意 非零 的 十进制 数 开头 不 允许 有 额外 的 零
从流 中 读取 并 返回 一行
当前 命名 空间 不 受 影响 ： 对于 一条 标准   import   语句 ， 会 执行 后续 的   " STORE _ FAST "   指令 来 修改 命名 空间
Python 也 包含 有 集合 类型
一个 由 可用 方法 组成 的 枚举 ， 解释器 可以 用来 确定 字节 码 文件 是否 与 源文件 保持一致
如果 类 已经 定义 了   " __ lt __ ( ) "   、   " __ le __ ( ) "   、   " __ gt __ ( ) "   或者   " __ ge __ ( ) "   中 的 任意 一个 ， 将 引发   " TypeError "
舍入 到 零 的 反 方向
如果 字节 数据 无法 被 锁定 ， 程序 会 在   1   秒 之后 立即 重试
虽然 官方   Python   实现 差不多 得到 最 广泛 的 欢迎 ， 但 也 有 一些 其他 实现 对 特定 领域 的 用户 来说 更具 吸引力
" % A "   本地化 的 星期 中 每日 的 完整 名称
简而言之 ， 在 转向   " re "   模块 之前 ， 请 考虑 是否 可以 使用 更快 更 简单 的 字符串 方法 解决问题
在   3.3   版 更改 :   If   " sys . implementation . cache _ tag "   is   " None " ,   then   " NotImplementedError "   is   raised .
在   3.7   版 更改 :   size   参数 现在 是 可选 的
此 原型 必须 求值 为 一个 可 调用 对象 （ 用户 定义 的 函数 ， 内置 函数 ， 内置 对象 的 方法 ， 类 对象 ， 类 实例 的 方法 以及 任何 具有   " __ call __ ( ) "   方法 的 对象 都 是 可 调用 对象 ）
建议 对 方法 名 使用 前缀 ， 例如 本例 中 的   " visit _ "
使用 4 个 空格 缩进 ， 不要 使用 制表符
对于 嵌入 Python 的 应用程序 ：
当 When   most   everything   in   " optparse "   中 几乎 所有 内容 都 已 被 复制粘贴 或 打 上 补丁 时 ， 维持 向下兼容 看来 已 是 不切实际 的
" strftime ( ) "   和   " strptime ( ) "   Format   Codes
type   hint   类型 提示   annotation   为 变量 、 类 属性 、 函数 的 形参 或 返回值 指定 预期 的 类型
preamble   属性 包含   MIME   文档 开头 部分 的 这些 处于 保护 范围 之外 的 文本
返回 可 迭代 对象 中 最小 的 元素 ， 或者 返回 两个 及 以上 实参 中 最小 的
就 地 实现   " TOS   TOS1   / /   TOS "
采样率   描述   8000   " / dev / audio "   的 默认 采样率   11025   语音 录音   22050   44100   CD 品质 的 音频 （ 16 位 采样 和 2 通道 ）   96000   DVD 品质 的 音频 （ 24 位 采样 ）
在 增强 赋值 的 版本 中 ， " x "   仅会 被 求值 一次
将 指定 的 堆栈 信息 （ 由   " traceback . print _ stack ( ) "   返回 的 字符串 ， 但 移除 末尾 的 换行符 ） 格式化 为 字符串
如果 该 参数 省略 或 为   " None "   (   默认值 ) ， 则 会 自动 进行 算术 均值 的 计算
在   3.3   版 更改 :   Argument   can   be   omitted   or   " None " .
在   3.2   版 更改 :   usenetrc   is   now   " False "   by   default .
用于   PYTHON   2.0   的   BEOPEN . COM   许可 协议
" dbm "   是 一种 泛用 接口 ， 针对 各种   DBM   数据库 包括   " dbm . gnu "   或   " dbm . ndbm "
geturl   返回 所 获取 页面 的 真实   URL
生成器 表达式 相比 完整 的 生成器 更 紧凑 但 较 不 灵活 ， 相比 等效 的 列表 推导 式 则 更为 节省 内存
相反 ， 如果 数据 类 检测 到 类型 为   " list "   、   " dict "   或   " set "   的 默认 参数 ， 则 会 引发   " TypeError "
" distutils . ccompiler "   CCompiler 基类
这个 例子 说明 了 这 一点 ：
CPython   implementation   detail :   其他 实现 的 命令行 方案 可能 有所不同
这些   stat   元组 可能 是 由   " os . fstat ( ) " 、 " os . lstat ( ) "   或   " os . stat ( ) "   返回 的
不同 类型 的 方法 可以 有 相同 的 名称 而 不会 引起 歧义
如果 对象   obj   是   memoryview   对象 ， 则 返回   true
有些 磁带 甚至 能够 反向 读取   ， 这 也 被 用来 避免 倒 带 的 耗时
替换 字段 以 一个 右花 括号   " ' } ' "   作为 结束
在   3.5   版 更改 :   现在 支持 可写 的 字节 类 对象
返回 当前 进程 的 系统 和 用户 CPU 时间 总和 的 值 （ 以小 数秒 为 单位 ）
这 意味着 任何 子目录 的 路径 都 不该 出现 在   resouce   参数值 内
推荐 另外 一种 方法 ： 使用   DB   API   的 参数 替换
构建 和   C   API   的 改变
它 必须 设置 为 一个 正整数   ， 表示 字段 的 最大 对齐 字节
如果 尝试 加入 当前 线程 会 导致 死锁 ，   " join ( ) "   会 引起   " RuntimeError "   异常
3.4   新版 功能 .
此 操作 在 细节 上 相当于 :
在 上面 的 示例 中 ， 你 可以 通过 将 其 声明 为 全局 来 访问 外部 作用域 变量 ：
当 传入 多模 数据 时   " statistics . mode ( ) "   函数 不会 再 引发 异常
返回 一个 上下文 管理器 ， 如果 任何 一个 指定 的 异常 发生 在 使用 该 上下文 管理器 的   with   语句 中 ， 该 异常 将 被 它 抑制 ， 然后 程序 将 从   with   语句 结束 后 的 第一个 语句 开始 恢复 执行
上下文 精度 和 舍入 仅 在 算术 运算 期间 发挥作用
在   3.9   版 更改 :   No   longer   called   before   the   module   state   is   allocated .
PEP   328 :   绝对 导入 和 相对 导入
请 注意 在 时间 戳 概念 包含 闰秒 的 非   POSIX   系统 上 ， 闰秒 会 被   " fromtimestamp ( ) "   所 忽略 ， 结果 可能 导致 两个 相差 一秒 的 时间 戳 产生 相同 的   " datetime "   对象
hash   based   pyc   基于 哈希 的   pyc   使用 对应 源文件 的 哈希 值 而 非 最后 修改 时间 来 确定 其 有效性 的 字节 码 缓存 文件
这 意味着 不会 测试 后续 输入 的 有效性
获取 一个 宽 字符
它 需要 两个 函数 来 实际 处理 “ 外部 世界 ”   — —   timefunc   应当 不带 参数 地 调用 ， 并 返回 一个 数字 （ “ 时间 ” ， 可以 为 任意 单位 ）
委派 给 父级 的 意思 是 如果 一个 记录器 的 级别 设置 为   NOTSET ， 将 遍历 其 祖先 记录器 ， 直到 找到 级别 不是   NOTSET   的 记录器 ， 或者 到 根 记录器 为止
禁用 断点 表示 它 不会 导致 程序 停止 执行 ， 但是 与 清除 断点 不同 ， 禁用 的 断点 将 保留 在 断点 列表 中 并且 可以 （ 重新 ） 启用
（ 由   C é dric   Krier   在   bpo   35153   中 贡献 。 ）
对   text   中 的 单独 段落 自动 换行 并 返回 包含 被 自动 换行 段落 的 单独 字符串
大部分 程序 会 显示 一堆 内容 然后 等待 按键 或者 其他 某些 用户 侧 动作
举个 例子 ， 在 一个 字典 当中 ， 键 之间 不可 重复 ， 但是 信息 头字 段 是 可以 重复 的
载入 上下文 管理器 的   " __ exit __ ( ) "   以便 后续 使用
当 解压缩 一个 数据流 时 ， 窗口 大小 必须 不 小于 用于 压缩 数据流 的 原始 窗口 大小 ； 使用 太小 的 值 可能 导致   " error "   异常
要 以 序列 的 索引 来 迭代 ， 您 可以 将   " range ( ) "   和   " len ( ) "   组合 如下 :
future   语句 编译器 怎样 处理   future   import
如果 要 将 整数 转换 为 八进制 字符串 ， 并 可 选择 有无 “ 0o ” 前缀 ， 则 可以 使用 如下 方法 ：
这些 参数 的 默认值 是 模块 级 常量   " WRAPPER _ ASSIGNMENTS "   ( 它 将 被 赋值 给   wrapper   函数 的   " __ module __ " ,   " __ name __ " ,   " __ qualname __ " ,   " __ annotations __ "   和   " __ doc __ "   即 文档 字符串 )   以及   " WRAPPER _ UPDATES "   ( 它 将 更新   wrapper   函数 的   " __ dict __ "   即 实例 字典 )
然后 对 每行 代码 ， 你 说明 这 行 代码执行 前 的 不 变量   X   和   Y   以及 执行 后 稍 有 不同 的 不 变量   X '   和   Y '   为 真
当 共享 对象 没有 被 任何 代理 器 引用 时 ， 会 被 管理器 进程 删除
PEP   573   ， 从   C   扩展 类型 的 方法 快速访问 模块 状态 ；
在 非 交互 模式 下 ，   表达式 语句 以   " POP _ TOP "   终止
该 实现 在 “ Python   增强 提议 ”   PEP   305   ( CSV   文件   API )   中 被 提出   《 Python   增强 提议 》 提出 了 对   Python   的 这 一 补充
在 没有   " readline "   的 平台 ,   此 模块 定义 的   " Completer "   类 仍然 可以 用于 自定义 行为 .
它们 的 缺点 可以 举例说明 ： 如果 你 在 一台 小端序 的 机器 上 使用   " UTF   32   BE "   则 你 将 必须 在 编码 和 解码 时 翻转 字节
此 方法 要求 线程 终止 ， 然后 等待 它 完成 终止 操作
从 对象   o   中 移除 对象   key   的 映射
另 请参阅   " __ aiter __ ( ) "   和   " __ anext __ ( ) "   了解 详情
bpo   36430 :   修复 了 函数   " itertools . count ( ) "   中 的 潜在 引用 对象 泄漏
这个 方法 提交 当前 事务
将 对象   item   添加 到 列表   list   的 末尾
现在   " os . putenv ( ) "   和   " os . unsetenv ( ) "   函数 将 总是 可用
这是 一个 非负 整数
返回 输入 的 数值
如果 调用 还 没 完成 那么 这个 方法 将 等待   timeout   秒
此类 用于 声明 一个 新 的 上下文 变量 ， 如 :
Python   结合 了 超强 的 功能 和 极 清晰 的 语法
如果 目的 是 将 文件 内容 做 为 可 执行 代码 ，   则 应 使用 此 函数
将   capsule   内部 的 名称 设 为   name
引发 一个 审计 事件   " shutil . make _ archive "   并 附带 参数   " base _ name " ,   " format " ,   " root _ dir " ,   " base _ dir "
将 对象   v   赋值 给   o   的 第   i   号 元素
并且 ， 在 许多 应用程序 中 ，   数据 在 循环 内 单个 强制 转换 为   " Decimal "
JSON   是   YAML   1.2   的 一个 子集
3.7   新版 功能 .
" await "   " start _ unix _ server ( ) "   启动 一个 Unix   socket 服务
如果   "   h "   or   "   help "   在 命令行 中 被 提供 ,   参数 解析器 帮助 信息 会 打印 :
所有   gzip   东方 压缩 流中 必须 包含 时间 戳 这个 字 段
例如 ， 以下 文件系统 布局 定义 了 一个 最高 层级 的   " parent "   包 和 三个 子包 :
当   " 0   <   r   <   n "   时 ， 返回 项 的 个数 是   " n !   /   r !   /   ( n   r ) ! " ； 当   " r   >   n "   时 ， 返回 项 个数 为 0
返回 一个   pyfloat   内容 的   C   " double "   表示 ， 但 没有 错误 检查
完成 之前 输入 的 所有 数据 的 解析 并 返回 根 消息 对象
可以 通过 标准 的   Python   distutils   模式 （   " python   setup . py   install "   ）   安装 软件包
（ 还有 另 一个 子 模块   " logging . config "   ， 用于 配置 功能 ）
一条 注释 以 不 包含 在 字符串 字 面值 内 的 井 号   ( " # " )   开头 ， 并 在 物理 行 的 末尾 结束
" pickle "   Python   对象 序列化
此 模块 提供 了 以下 两种 打开 文件 钩子 ：
更新   OS   X   安装包 ， 使用 SQLite   3.14 . 1   和   XZ   5.2 . 2 版本
" email . parser " :   解析 电子邮件 信息
为   " C "   生成 的   " __ init __ ( ) "   方法 看起来 像 :
你 可以 使用 以下 模式 :
在   3.4   版 更改 :   " ' surrogatepass ' "   错误处理 方案 现在 适用 于   utf   16   和   utf   32   编解码器
由   " open ( ) "   返回 的   Wave _ read   对象 ， 有 以下 几种 方法 :
该 参数 是 由 多个 形参 组成 的 元组
成功 时 返回   " 0 "
由于   " object "   没有   " __ dict __ " ， 因此 无法 将 任意 属性 赋给   " object "   的 实例
但是 ， 如果 你 这样 做 ， 你 将 无法 如 你 所 预期 的 那样 在 事件 日志 查看器 中 看到 这些 事件   — —   它 必须 能 访问 注册表 来 获取   . dll   名称
" dbm . gnu "   GNU   对   dbm   的 重 解析
两个 参数 或者 必须 都 为 数字 ， 或者 都 为 相同 类型 的 序列
发布 日期 :   2017   06   17
本 例程 所 需 的 时间 与   " len ( fragment ) "   成正比
请参阅 下面 的 “ 编辑 和 导航 ” 部分 中 的   Calltips
对象 上 的 方法 调用 的   mock
不可 比较 任务 问题 的 另 一种 解决方案 是 创建 一个 忽略 任务 条目 并且 只 比较 优先级 字段 的 包装 器类 :
在 许多 应用 场景 中 人们 都 不 关心 枚举 的 实际 值 是 什么
如果   ob   的 类型 为   " PyGen _ Type "   则 返回 真值 ；   ob   必须 不 为   " NULL "
此 代码 实际上 会 在   Python   运行 于 交互 模式 时 自动 运行   ( 参见   Readline   configuration )
如果   typed   设置 为 true ， 不同 类型 的 函数参数 将 被 分别 缓存
方差 或称 相对 于 均值 的 二阶 距 ， 是 对 数据 变化 幅度 （ 延展 度 或 分散度 ） 的 度量
以下 是 解决方案 ：
无效 的 日志 记录器 名称
其他 图形用户界面 （ GUI ） 包
3.5   新版 功能 .
" bisect "   数组 二分 查找 算法
mtime   参数 是 一个 可选 的 数字 时间 戳 用于 写入 流 的 最后 修改 字 段 ，
修改 实例 分配 或 中止 分配 的 类型 可能 需要 进行 调整
在 这个 例子 中   " match ( ) "   将 返回 一个 匹配 对象 ， 因此 你 应该 将 结果 储存 到 一个 变量 中以 供 稍后 使用
返回 一个   " IPv4Address "   或   " IPv6Address "   对象 ， 取决于 作为 参数传递 的   IP   地址
在   3.9   版 更改 :   No   longer   called   before   the   module   state   is   allocated .
不是 所有   Python   对象 类型 都 受 支持 ； 一般来说 ， 此 模块 只能 写入 和 读取 不 依赖于 特定   Python   调用 的 对象
" Callable [ ... ,   ReturnType ] "   （ 使用 字面 省略号 ） 能 被 用于 提示 一个 可 调用 对象 ， 接受 任意 数量 的 参数 并且 返回   " ReturnType "
显然 它 已 被   RFC   1832   所 淘汰
此 函数 中 调用 的 两个 函数 都 使用 了 空 指针 （ 用   " None "   作为 空 指针 ） :
如果   x   是   s   的 成员 则   " x   in   s "   求值 为   " True " ， 否则 为   " False "
" ' > ' "   强制 字段 在 可用 空间 内右 对齐 （ 这是 数字 的 默认值 ）
这种   " 中间 语言 "   运行 在 根据 字节 码 执行 相应 机器码 的   virtual   machine   之上
默认 情况 下 ， 或者 当   pages   为   " 0 "   或负 整数 时 ， 整个 数据库 将 在 一个 步骤 中 复制 ； 否则 该 方法 一次 循环 复制   pages   规定 数量 的 页面
当   raw   形参为 假值 时   " get ( ) "   所 采用 的 递归 插值 的 最大 深度
此 行为 是 禁用 任何 现有 的 非根 日志 记录器 除非 它们 或 它们 的 上级 在 日志 记录 配置 中 被 显式 地 命名
3.4   新版 功能 .
默认值 为   " 9 "
3.2   新版 功能 :   annotate   参数
使用 函数参数 列表 中 的   "   "   和   "   "   说明符 收集 参数 ; 这会 将 位置 参数 作为 元组   ， 将 关键字 参数 作为 字典
请参阅 语句 解释 及 变量 编译 了解 详情
" ipaddress "   模块 提供 来 工厂 函数 来 方便 地 创建   IP   地址 ， 网络 和 接口 ：
这一 特性 可 用于 作为 那个 模块 的 优点 ， 如果 它 维护 一个 全局 表 或者 对象 的 缓存   — —   使用   " try "   语句 ， 就 可以 测试 表 的 存在 并且 跳过 它 的 初始化 ， 如果 有 需要的话 :
PEP   520   保留 类 属性 定义 顺序   PEP   由   Eric   Snow   撰写 并 实现
当 两者 都 存在 时 ， 子 解析器 的 命令 将 出现 在 输出 帮助 消息 中 它们 自己 的 分组 内
尽管   asyncio 队列 不是 线程 安全 的 ， 但是 他们 是 被 设计 专用 于   async / await   代码
一些 Python 用户 对 了解 同一 问题 的 不同 方法 的 相对 性能 产生 了 浓厚 的 兴趣
4   默认 为 整数 零值 的 输入 形参
在 之前 的 版本 中 ， 如果   " AssertionError "   异常 被 屏蔽 则   assert   语句 将 不能 正常 运作
（ 由   Giampaolo   Rodol à   在   bpo   14807   中 贡献 。 ）
" ContextDecorator "   被 用 在   " contextmanager ( ) "   中 ， 因此 你 自然 获得 了 这项 功能
使用 内置 的   " super ( ) "   函数 ：
final   限定符 会 指示 静态 类型 检查 器 限制 进行 子 类化 、   重载 或 重新 赋值 :
" HH : MM : SS . ffffff " ， 如果   " microsecond "   不 为   0
更 糟糕 的 是 ， 对象   " __ del __ ( ) "   的 方法 执行 顺序 是 任意 的
也 可以 使用   "   e "   将   " exec ( ) "   解读 为 函数
如果 对象   o   提供 数字 的 协议 ， 返回 真   " 1 " ， 否则 返回 假
代理 的 线程 安全性
代码 库 和 插件   FAQ
以下 示例 演示 了 协程 是 如何 侦听 取消 请求 的 :
" marshal "   内部   Python   对象 序列化
反转 数组 中 各项 的 顺序
这是   " chr ( ) "   的 逆函数
在 Tkinter 中键 绑定 不 工作 ： 为什么 ？
背景 的 属性 部分 会 与 写入 窗口 的 所有 非 空白 字符 合并 （ 即   OR   运算 ）
像   " dict . update ( ) "   但是 是 加上 ， 而 不是 替换
一个 与   " Future   类似 "   的 对象 ， 可 运行   Python   协程
与 unix   shell 不同 ， Python 不 执行 任何 自动 路径 扩展
pwd   是 用于 解密 文件 的 密码
返回 由 调用 引发 的 异常
" Py _ MARSHAL _ VERSION "   指明 了 当前 文件 的 格式 （ 当前 取值 为   2 ）
如果 不 使用 这个 装饰 器 工厂 函数 ， 则   example   函数 的 名称 将 变为   " ' wrapper ' " ， 并且   " example ( ) "   原本 的 文档 字符串 将会 丢失
这 通常 由 对象 的 type 字段 定义 的   " tp _ dealloc "   处理函数 来 调用
还 接受 以下 可 选 参数 ： "   n "   如果 可能 ， 在 新 的 浏览器 窗口 中 打开   URL   ；   "   t "   在 新 的 浏览器 页面 （ “ 标签 ” ） 中 打开   URL
函数 定义 并 不会 执行 函数 体 ； 只有 当 函数 被 调用 时才 会 执行 此 操作
shebang   lines   的 参数
最 多 只有 一个 单独 的 读取 流 来 服务 这个 方法 调用
写入 数据库 将 不会 同步
而 位置 参数 可以 这么 创建 :
对应 于   " errno "   " EAGAIN " ,   " EALREADY " ,   " EWOULDBLOCK "   和   " EINPROGRESS "
它 将 总是   " ' aix ' "   而 不再 是   " ' aix3 ' "   ..   " ' aix7 ' "
从 队列 中 删除 事件
3.4   新版 功能 .
pendict   一个 或 多个 以 下列 键为 关键字 的 关键字 参数
这个 数字 的 值 对应 于 存放 在   " http . server . BaseHTTPRequestHandler . responses "   代码 字典 中 的 某个 值
这 和   MSVC   中 的   " # pragma   pack ( n ) "   功能 一样
如果 你 编写 的 代码 就 像 下面 一样 ：
用于 实现 调度 器 的 各种 结构 都 得到 了 充分 的 研究 ， 堆 是 非常 适宜 的 一种 ， 因为 它们 的 速度 相当 快 ， 并且 几乎 是 恒定 的 ， 最坏 的 情况 与 平均 情况 没有 太 大 差别
( 补丁 由 Giampaolo   Rodola   提供 )
padx   和   pady   A   distance   designating   external   padding   on   each   side   of   the   slave   widget .
默认 支持 以下 对象 和 类型 ：
在   3.4   版 更改 :   添加   file   形参
（ 由   Amaury   Forgeot   d ' Arc   和   Antoine   Pitrou   贡献 。 ）
当 语法 上 需要 一个 语句 ， 但 程序 需要 什么 动作 也 不 做 时 ， 可以 使用 它
如果   op   的 类型 为   " PySeqIter _ Type "   则 返回   true
例如 ， 将   " 5.0 E + 3 "   表示 为   " 5000 "   可以 让 值 保持 恒定 ， 但是 无法 显示 原本 的 两位 有效数字
如果 对象 实现 了 自己 的   " __ hash __ ( ) "   方法 ， 请 注意 ， " hash ( ) "   根据 机器 的 字长 来 截断 返回值
此 模块 提供 了 两个 接口
" tabnanny "   模糊 缩进 检测
在   3.2   版 更改 :   Result   is   a   structured   object   rather   than   a   simple   2   tuple .
后续   " syslog ( ) "   调用 的 日志 选项 可以 通过 调用   " openlog ( ) "   来 设置
因此 ， 规则 同样 适用 于   " wait ( ) "   ： 锁 必须 在 被 调用 时 保持 获取 ， 并 在 返回 时 重新 获取
但 并 不是 所有 的   POST   都 来自 表单 ： 你 能 使用 一个   POST   来 传输 任何 数据 到 你 自己 的 应用 上
调用   " PyArg _ ParseTuple ( ) "   ( 或 其 同级 对象 之一 )   并 传入   " y   " ,   " w   "   or   " s   "   格式 代码 中 的 一个
如果 展开 路径 失败 ， 或者 路径 不是 以 波浪 号 开头 ， 则 路径 将 保持 不变
是否 有 专门 针对   Python   的 新闻组 或 邮件 列表 ？
模块 可以 通过 检查 自己 的   " __ name __ "   来 得知 是否 运行 在   main   作用域 中 ， 这 使得 模块 可以 在 作为 脚本 或是 通过   " python   m "   运行 时 条件性 地 执行 一些 代码 ，   而 在 被   import   时 不会 执行
当然 ， 你 也 可以 创建   " Connection "   类 的 子类 ， 然后 创建 提供 了   factory   参数 的   " connect ( ) "   方法
可以 定义 异常 类 ， 它 可以 执行 任何 其他 类 可以 执行 的 任何 操作 ， 但 通常 保持 简单   ， 只 提供 一些 属性 ， 这些 属性 允许 处理程序 为 异常 提取 有关 错误 的 信息
运算   方法 名称   " < "   " __ lt __ ( ) "   " <   "   " __ le __ ( ) "   " > "   " __ gt __ ( ) "   " >   "   " __ ge __ ( ) "   "   "   " __ eq __ ( ) "   " !   "   " __ ne __ ( ) "
例如 ， 给定 以下 的 包 布局 结构 :
一个 元组 由 几个 被 逗号 隔开 的 值 组成 ， 例如
如果 调用 线程 在 没有 获得 锁 的 情况 下 调用 这个 方法 ， 会 引发   " RuntimeError "   异常
asyncio   也 支持 旧式 的 基于 生成器 的 协程
会 被 替换 的 空白 字符 如下 ： 制表 ， 换行 ， 垂直 制表 ， 进纸 和 回车   ( " ' \ t \ n \ v \ f \ r ' " )
现在 将 为 所有 特殊 形式 和 特殊 通用 别名   ( 例如   " Union "   和   " List " )   显示 文档 字符串
如果   timeout   是 一个 浮点 型 ， 该 方法 会 最 多 阻塞 这么 多 秒
CPython 的 列表 实际上 是 可变 长度 的 数组 ， 而 不是 lisp 风格 的 链表
如果 未指定 显示 ， 则 假定 为主 应用程序 窗口
SciPy 项目   < https : / / scipy . org >   有 许多 其他 模块 用于 数值 计算
在 操作数 的 每个 数位 间 应用 逻辑运算   or
这个 例子 演示 了 如何 将   " ref "   的 一个 子类 用于 存储 有关 对象 的 附加 信息 并 在 引用 被 访问 时 影响 其所 返回 的 值 :
关闭 用于 控制   kqueue   对象 的 文件 描述符
" Timer "   类 是   " Thread "   类 的 子类 ， 因此 可以 像 一个 自定义 线程 一样 工作
相比之下 ， " 1.1 "   和   " 2.2 "   这样 的 数字 在 二进制 浮点 中 没有 精确 的 表示
形参   v   不可 为   " NULL " ； 它 不会 被 检查
与   " gettempdir ( ) "   相同 ， 但 返回值 为 字节 类型
（ 由   twisteroid   ambassador   在   bpo   33530   中 贡献 。 ）
第二个 函数   " pos _ only _ arg "   在 函数 定义 中 带有   " / " ， 限制 仅 使用 位置 形参
epoch   的 具体 日期 和   leap   seconds   的 处理 取决于 平台
它 支持 使用 列 名称 的 映射 访问 以及 索引 、 迭代 、 文本 表示 、 相等 检测 和   " len ( ) "   等 操作
当前 时刻 正在 栅栏 中 阻塞 的 线程 数量
关闭 连接 远程 主机 的 套 接字
一个 表示 解释器 启动 时间 点 的 字符串 环境 的 字典
这个 问题 的 解决方案 是 创建 一个   virtual   environment   ， 一个 目录 树 ， 其中 安装 有 特定 Python 版本 ， 以及 许多 其他 包
（ 由   Serhiy   Storchaka   在   bpo   38371   中 贡献 。 ）
AIFF   是 音频 交换 文件格式   ( Audio   Interchange   File   Format ) ， 一种 用于 在 文件 中 存储 数字音频 采样 的 格式
在 出错 时 ， 调试 钩子 使用   " tracemalloc "   模块 来 回溯 内存 块 被 分配 的 位置
" random . shuffle ( ) "   的   random   形参 已 被 弃用
PEP   237 :   统一 长 整数 和 整数
如果 找到 并 移除 返回   " 1 " ， 如果 未找到 （ 无 操作 ） 返回   " 0 " ， 如果 遇到 错误 则 返回   "   1 "
3.5   新版 功能 .
帮助 信息 有点 不同
这 使得 节点 和 其 孩子 节点 索引 之间 的 关系 不太 直观 但 更加 适合 ，   因为   Python   使用 从零开始 的 索引
引发 一个 审计 事件   " ctypes . call _ function " ， 附带 参数   " func _ pointer " ,   " arguments "
在   3.6   版 更改 :   接受 一个 类 路径 对象
在   3.5   版 更改 :   Added   the   context   argument .
l   指定 了 每星期 占用 的 行数
（ 由   Kyle   Stanley   在   bpo   39207   中 贡献 。 ）
接下来 将   Shape   对象 添加 到   Screen   对象 的 形状 列表 并 使用 它 :
" Dialect "   类 是 主要 依赖于 其 属性 的 容器 类 ， 用于 将 定义 好 的 参数传递 给 特定 的   " reader "   或   " writer "   实例
" Counter "   对象 的 常用 案例
调用 前者 以 实现 浅层 拷贝 操作 ， 该 方法 不用 传入 额外 参数
它 返回 一个 排序 过 的 字符串 列表   :
位置 或 关键字 参数
" inspect "   模块 提供 了 一些 有用 的 函数 帮助 获取 对象 的 信息 ， 例如 模块 、 类 、 方法 、 函数 、 回溯 、 帧 对象 以及 代码 对象
这比 在 原始 弱 引用 上 设置 回调 函数 更 简单 ， 因为 模块 会 自动 确保 对象 被 回收 前 终结 器 一直 保持 存活
Include _ lib   安装 标准 库 和 扩展 模块   1   Include _ pip   安装 捆绑 的 pip 和 setuptools   1   Include _ symbols   安装 调试 符号 (   . pdb )   0   Include _ tcltk   安装 Tcl / Tk   支持 和 IDLE   1   Include _ test   安装 标准 库 测试 套件   1   Include _ tools   安装 实用程序 脚本   1   LauncherOnly   仅 安装 启动器
对于 特定 类型 的 无效 或 已损坏   gzip   文件 现在 将 引发   " BadGzipFile "   而 不是   " OSError "
file   object   文件 对象 对外 提供 面向 文件   API   以 使用 下层 资源 的 对象 （ 带有   " read ( ) "   或   " write ( ) "   这样 的 方法 ）
请参阅   " copystat ( ) "   了解 有关 修改 符号 链接 元 数据 的 平台 支持 的 更 多 信息
Python   有 多 稳定 ？
有关 最后 两个 选项 的 参考 文档 ， 请参阅 配置 函数
" setFormatter ( ) "   选择 一个 该 处理程序 使用 的   Formatter   对象
3.3   新版 功能 .
" hashlib "   安全 哈希 与 消息 摘要
shebang   line 的   " / usr / bin / env "   形式 还有 一个 特殊 属性
相比 内置 的   " float "   二进制 浮点 实现 ， 该类 特别 适用 于
此 模块 为 涉及   " with "   语句 的 常见 任务 提供 了 实用 的 工具
不 应当 使用 的 选项
其中 包括 空格 、 制表 、 换行 、 回车 、 进纸 和 纵向 制表符
这种 简单 的 序列化 技术 可以 处理 列表 和 字典 ， 但是 在 JSON 中 序列化 任意 类 的 实例 需要 额外 的 努力
在   3.5   版 更改 :   添加 了   members   形参
关于 基本 的 验证 的 入门 指南 ， 带有 一些   Python   的 示例
对于 浮点数 和 虚数 （ 复数 ） 的 情况 ， 该值 可能 为 近似值
在 文件   " setup . py "   里 ， 所有 动作 的 入口 通过   " setup "   函数
请 使用   " load ( ) " ,   " loads ( ) " ,   " dump ( ) "   和   " dumps ( ) "   等 函数
在   3.3   版 更改 :   The   locking   scheme   has   changed   to   per   module   locks   for   the   most   part
PEP   3149   ABI   Version   Tagged   . so   Files   PEP   由   Barry   Warsaw   撰写
用于 Python 数据结构 的 可 扩展 JSON 编码器
defects   属性 包含 在 解析 消息 时 发现 的 所有 问题 的 列表
每个 记录器 可以 有 零个 、 一个 或 多个 与 之 关联 的 处理程序 （ 通过   " Logger "   的   " addHandler ( ) "   方法 ）
其他 模块 级 更改
如果 指定 了 转换 符 ， 表达式 的 求值 结果 会先 转换 再 格式化
从 离散 或 标称 的   data   返回 单个 出现 最多 的 数据 点
3.10   版后 已 移除 :   Python   3.9   将 切换 到   PEG   解析器   ( 参见   PEP   617   ) ，   Python   3.10   可能 会 包含   lib2to3   的   LL ( 1 )   解析器 所 不能 解析 的 新 语法
一些 虚 数字 面值 的 示例 如下 :
将 归档 中 的 一个 成员 提取 为 文件 对象
不论 哪 种 形式 的 输入 字符串 也 都 可以 带有 前缀 和 / 或 后缀 的 空格符
文本 变量   Specifies   a   name   whose   value   will   be   used   in   place   of   the   text   option   resource
在 Windows 上 使用   Python
通常 ， Python 解释器 里 多个 线程 无法 进入 对方 的 路径 ， 因为 有个 全局 锁 保护 着 Python 整个 对象 空间
当然 你 也 可以 直接 使用   " ABCMeta "   作为 元类 来 定义 抽象 基类 ， 例如 ：
参数 :   canvas   一个   " tkinter . Canvas "   ,   " ScrolledCanvas "   或   " TurtleScreen "   类 对象
解 引用 指针 的 时候 ，   " ctypes "   会 帮 你 检测 是否 指针 为   " NULL "   ( 但是 解 引用 无效 的 非   " NULL "   指针 仍会 导致   Python   崩溃 ) :
在   3.6   版 更改 :   添加 了 对   " ' e ' "   格式 的 支持
我们 来 用 单个 脚本 举例 ：
为 繁忙 的   Python   开发者 所 准备 的 现代   Tkinter   由   Mark   Rozerman   所著 的 关于 如何 使用   Python   和   Tkinter   来 搭建 有 吸引力 的 和 现代化 的 图形用户界面 的 书籍
" fillcolor ( ) "   返回 以 颜色 描述 字符串 或 元组   ( 见 示例 )   表示 的 当前 填充 颜色
另 一个 次要 原因 是 冒号 使 带有 语法 突出 显示 的 编辑器 更 容易 工作 ； 他们 可以 寻找 冒号 来 决定 何时 需要 增加 缩进 ， 而 不必 对 程序 文本 进行 更 精细 的 解析
弹出 并 返回   heap   的 最小 的 元素 ， 保持 堆 的 不变性
" ' r ' "   只读 模式
如果 此形 参 不 存在 或者 此形 参 的   " robots . txt "   条目 存在 语法错误 ， 则 返回   " None "
IDN   A   标签 例如   " www   . xn   pthon   kva . org "   仍然 受 支持 ， 但   " x   . python . org "   不再 能 匹配   " xn   tda . python . org "
（ 由   David   Townshend   在   bpo   12760   中 贡献 。 ）
关于 为什么   " if   __ name __   ' __ main __ ' "   部分 是 必需 的 解释 ， 请 参见 编程 指导
对于 复合 字段名 称 ， 仅会 为 字段名 称 的 第一个 组件 调用 这些 函数 ； 后续 组件 会 通过 普通 属性 和 索引 操作 来 进行 处理
" ' x : gz ' "   使用 gzip 压缩 创建 tarfile
forkserver   程序 启动 并 选择   forkserver   启动 方法 时 ， 将 启动 服务器 进程
幸运 的 是 ， Python   接口 隐藏 了 所有 这些 细节
" typing . NamedTuple "   类 已弃 用 了   " _ field _ types "   属性 而 改用 具有 同样 信息 的   " __ annotations __ "   属性
被 用作 启动 进程 的 参数
" pencolor ( r ,   g ,   b ) "   设置 画笔 颜色 为 以   r   ,   g   ,   b   表示 的   RGB   颜色
另 一些 数则 不 应 具有 多余 位 ， 需要 验证 有效性
encode   和   decode   参数 必须 遵循   " Codec "   接口
（ 由   Victor   Stinner   在   bpo   40010   上 贡献 。 ）
当 主线 程 退出 时 ， 由 系统 决定 其他 线程 是否 存活
我 对   ABC   语言 有过 许多 抱怨 ， 但 同时 也 很 喜欢 它 的 许多 特性
模块 方法 表 和 初始化 函数
" partial "   对象 是 由   " partial ( ) "   创建 的 可 调用 对象
在   3.8   版 更改 :   新 的   generation   形参
在 使用 任何 这些 函数 之前 ， 必须 在 你 的 源码 中 包含 头文件   " datetime . h "   ( 请 注意 此 文件 并未 包含 在   " Python . h "   中 ) ， 并且 宏   " PyDateTime _ IMPORT "   必须 被 发起 调用 ， 通常 是 作为 模块 初始化 函数 的 一部分
在   3.6   版 更改 :   此 操作码 仅 用于 附带 位置 参数 的 调用
此 哈希 对象 的 规范 名称 ， 总是 为 小写 形式 并且 总是 可以 作为   " new ( ) "   的 形参 用来 创建 另 一个 此 类型 的 哈希 对象
在 本 文档 中 ， 我们 将 探索 使用 Python 对 数据 进行 排序 的 各种 技术
" TextWrapper "   的 实例 属性 （ 以及 构造 器 的 关键字 参数 ） 如下 所示 ：
3.6   新版 功能 .
列表 作为 栈 使用
创建 一个 迭代 器 ， 它 返回   data   中 经   selectors   真值 测试 为   " True "   的 元素
为此 ，   将   " TZ "   环境变量 设置 为 所 需时区 数据文件 的 路径 ， 相对 于 系统   ' zoneinfo '   时 区 数据库 的 根目录 ， 通常 位于   " / usr / share / zoneinfo "
" ' ? ' "   转换 码 对应 于   C99   定义 的   " _ Bool "   类型
3.3   版后 已 移除 .
" getpass "   便携式 密码 输入 工具
可见 的 细节 依赖于 操作系统 ， 一些 系统 的 Python 解释器 使用 全局 命名 空间 ( 例如 Windows ) ， 有些 则 在 链接 时 需要 一个 严格 的 已 导入 符号 列表 ( 一个 例子 是 AIX ) ， 或者 提供 可选 的 不同 策略 ( 如 Unix 系列 )
使用   Semaphore   的 推荐 方式 是 通过   " async   with "   语句
dictionary   view   字典 视图 从   " dict . keys ( ) " ,   " dict . values ( ) "   和   " dict . items ( ) "   返回 的 对象 被 称为 字典 视图
如果 存在   " "   identifier " "   这样 的 形式 ， 它会 被 初始化 为 一个 新 的 有序 映射 来 接收 任何 额外 的 关键字 参数 ， 默认 为 一个 相同 类型 的 空 映射
为什么 Python 中 没有 switch 或 case 语句 ？
创建 源码 发行 包 :   sdist   命令
由 处理程序 所 对应 过滤器 的   ID   组成 的 列表
Shape   形状 数组 中 的 值 被 限定 在   " shape [ n ]   >   0 "
按 名称 查找 字符
如果   c   是 可 打印 字符 ， 则 字符串 为 字符 本身
记录 会 被 格式化 ， 然后 发送到   syslog   服务器
" sleep ( ) "   总是 会 挂 起 当前任务 ， 以 允许 其他 任务 运行
还有 一个 可以 提取 整个 字符串 的 方法   " getstr ( ) "
你 还 可以 使用   pydoc   在 本 机上 启动 一个   HTTP   服务 ， 这 将 向 来访 的   Web   浏览器 提供 文档 服务
以   Linux   为例 ，   Python   3.7   的 后缀   " . cpython   37m   x86 _ 64   linux   gnu . so "   在   Python   3.8   中 改为   " . cpython   38   x86 _ 64   linux   gnu . so "
否则 不能 保证 这个 写过 队列 的 进程 可以 正常 终止
（ 由   Victor   Stinner   在   bpo   21536   中 贡献 。 ）
" heapq "   模块 提供 了 基于 常规 列表 来 实现 堆 的 函数
答案 1 ：   不幸 的 是 ， 解释器 为 每个 Python 堆栈 帧 推送 至少 一个 C 堆栈 帧
请 注意 ，   eval ( )   并 没有 对 外围 环境 下 的   ( 非 局部 )   嵌套 作用域 的 访问 权限
编码   别名   语言   ascii   646 ,   us   ascii   英语   big5   big5   tw ,   csbig5   繁体中文   big5hkscs   big5   hkscs ,   hkscs   繁体中文   cp037   IBM037 ,   IBM039   英语   cp273   273 ,   IBM273 ,   csIBM273   德语   3.4   新版 功能
" asyncio . Future . cancel ( ) "   接受 一个 可选 的   " msg "   参数 ， 但   " concurrent . futures . cancel ( ) "   无 此参数
" Control   L "   刷新 屏幕
模块   " base64 "   编码 与 解码   MIME   base64   数据
添加 了 一个 新 函数   " math . isqrt ( ) "   用于 计算 精确 整数 平方根 而 无需 转换 为 浮点数
3.5 . 3   新版 功能 .
如果 没有 找到 匹配   " key "   的 文件 ， 构造 器 将 引发   " ZoneInfoNotFoundError "
关于 使用   distutils   的 额外 信息 可以 参考   Distutils   Cookbook
在   3.8   版 更改 :   Functions   wrapped   in   " functools . partial ( ) "   now   return   " True "   if   the   wrapped   function   is   a   coroutine   function   .
" ipaddress "   现在 支持   IPv6   作用域 地址 （ 即 带有   " % < scope _ id > "   前缀 的   IPv6   地址 ）
在   3.1   版 更改 :   位置 参数 说明符 对于   " str . format ( ) "   可以 省略 ， 因此   " ' { }   { } ' . format ( a ,   b ) "   等价 于   " ' { 0 }   { 1 } ' . format ( a ,   b ) "
" TarFile "   对象 可 在   " with "   语句 中 作为 上下文 管理器 使用
3.4   新版 功能 .
如果   replace   为   " False "   （ 默认值 ） ， 该头 字 段 会 被 移动 到 所有 头字段 列表 的 末尾
尽管 官方 文档 不太 完整 ， 但 有 其他 资源 可以 参考 ， 比如 Tk 手册 ， 教程 等
连接 被 对方 重置
一个 编写 小 函数 的 方式 是 使用   " lambda "   表达式
一个 对应 星期一 到 星期天 的   CSS   class   列表
本 指南 仅 介绍 构建 和 分发 扩展 的 基本 工具 ， 这些 扩展 是 作为 此 Python 版本 的 一部分 提供 的
" qsort ( ) "   将 用来 给 整数 数组 排序 :
如果 一个 关键字 已 存在 （ 作为 显式 关键字 参数 ， 或 来自 另 一个 拆包 ） ， 则 将 引发   " TypeError "   异常
对于 Unix ，   epoch   是 1970 年 1 月   1 日 00 : 00 : 00 （ UTC ）
" except "   子句 指定 一个 或 多个 异常 处理器
3.4   新版 功能 .
在   3.4   版 更改 :   默认 启用   ZIP64   扩展
将 信息 的 信封 头 设置 为   unixform   ， 这 应当 是 一个 字符串
已弃 用 的   Python   模块 、 函数 和 方法
返回 具有 同样   hour ,   minute ,   second ,   microsecond   和   fold   值 的   " time "   对象
可 调用 对象   factory   具有 如下 签名 :
" loop . default _ exception _ handler ( ) "   默认 异常 处理器 实现
" sys . exc _ info ( ) "   返回 一个   3   元组 ，   由 异常 类 、 异常 实例 和 回溯 对象 组成 （ 参见 标准 类型 层级 结构 一节 ） ， 用于 在 程序 中 标识 异常 发生 点
op   必须 尚未 被 垃圾 回收 器 追踪
这里 ，   " floatnumber "   是   Python   浮点数 的 字符串 形式 ， 详见 浮点 数字 面值
增量 式 的 编码 和 解码
弱 引用 对象 没有   " ref .__ callback __ "   以外 的 方法 和 属性
返回 最小 可 表示 归一化 正 浮点数   DBL _ MIN   为   C   " double "
生成 有关 数据 的 报告
group   应该 为   " None " ； 为了 日后 扩展   " ThreadGroup "   类 实现 而 保留
现在 当 自定义 元类 未 在 传给   " type .__ new __ "   的 命名 空间 中 提供   " __ classcell __ "   入口 时 将 引发   " RuntimeError "
作者 要 感谢 以下 人员 对 本文 各种 草稿 给予 的 建议 ， 更正 和 协助 ： Ian   Bicking , Nick   Coghlan ,   Nick   Efford ,   Raymond   Hettinger ,   Jim   Jewett ,   Mike   Krell , Leandro   Lameiro ,   Jussi   Salmela ,   Collin   Winter ,   Blake   Winton
上面 显示 的 参数 只是 常见 的 一些
第   3   版 添加 了 对于 对象 实例 化 和 递归 的 支持
" Tuple [ int ,   float ,   str ] "   是 一个 由 整数 、 浮点数 和 字符串 组成 的 三元组
如果 输出 流 不可 查找 且   nframes   与 实际 写入 的 帧 数 不 匹配 时 引发 异常
序列 中 的 格式 单元 可能 有 嵌套
默认 文件名 为 最近 所 使用 的 文件名
按值 查找   A   和   B   的 值 将 返回   A
返回 从 总体 序列 或 集合 中 选择 的 唯一 元素 的   k   长度 列表
它 做到 这 一点 是 通过 实现 自己 的   " __ getattribute __ ( ) "   方法 ， 这样 就 能 以 可 预测 的 顺序搜索 类 ， 并且 支持 协作 多重 继承
这个 字节 串 数据 的 长度 将 与 传给 构造 器 的 摘要 的 长度   digest _ size   相同
在   " close ( ) "   方法 已 被 调用 后 其余 方法 将会 引发   " OSError "
" 0 "   ( 默认值 )   意味着 仅 执行 绝对 导入
在   3.6   版 更改 :   dir   参数 现在 可 接受 一个 路径 类 对象   (   path   like   object   )
3.8   新版 功能 .
返回 可以 用来 模式化 的 指定 年 月 的 数据 ( 与   " yeardatescalendar ( ) "   类似   )
从   stdout   和   stderr   读取数据 ， 直至 到达   EOF ；
基于   " record "   提供 一个 字典 ， 它 将 被 执行   URL   编码 并 发送至   Web   服务器
这是 一个 大小 为   " digest _ size "   的 字节 串 对象 ， 字节 串中 可 包含   0   至   255   的 完整 取值 范围
在   3.8   版 更改 :   在   Windows   上 ， " ProactorEventLoop "   现在 是 默认 的 事件 循环
但是 ， 此 接口 已 被 弃用 ； 在   Windows   中 调用者 最好 是 自行 打开 文件 ， 并 在 需要 时 确保 模式 为   " ' rb ' "   or   " ' wb ' "
" audioop "   处理 原始 音频 数据
选项   描述   状况   Either   " normal " ,   " disabled "   or   " hidden "
请 注意 在 发生 异常 事件 时 被 打开 用于 写入 的 归档 将 不会 被 终结 ； 只有 内部 使用 的 文件 对象 将 被 关闭
( " \ 20 "   将 被 解释 为 对 组   20   的 引用 ， 而 不是 对组   2   的 引用 ， 后 跟 字面 字符   " ' 0 ' " 。 )   以下 替换 都 是 等效 的 ， 但 使用 所有 三种 变体 替换 字符串
此 方法 的 行为 类似 于   " notify ( ) " ， 但会 唤醒 所有 正在 等待 的 任务
" __ path __ "   指定 在 一个包 中 搜索 路径 的 一个 字符串 列表
例如 ， 对于 一个   " Context "   的 实例   " C "   和   " Decimal "   的 实例   " x " ， " C . exp ( x ) "   就 等价 于   " x . exp ( context   C ) "
pointer   参考 可以 不 为   " NULL "
另 请参阅   Examples   小节
省略 时 ， 默认设置 使用 最 安全 的 DLL 加载 的 标志 ， 以 避免 DLL 劫持 等 问题
有时 对 枚举 中 的 成员 进行 程序化 访问 是 很 有用 的 （ 例如 在 某些 场合 不能 使用   " Color . RED "   因为 在 编程 时 并不知道 要 指定 的 确切 颜色 ）
正负 无穷 ， 正负 零 和   nan   会 分别   被 格式化 为   " inf " ,   "   inf " ,   " 0 " ,   "   0 "   和   " nan " ， 无论 精度 如何   设定
如果 在 达到 数据流 末尾 之前 访问 此 属性 ， 其值 将 为   " b ' ' "
在   3.3   版 更改 :   添加 了   policy   关键字
与   " parse ( ) "   方法 类似 ， 只不过 它 要求 输入 为 一个   bytes   like   object   而 不是 类 文件 对象
verbose   参数 已 不再 使用 并 进入 弃用 状态
在 之前 的 版本 中则 将 引发   " RuntimeError "
使用 科学 计数法 将 一个 数字 转换 为 字符串
为了 执行 必要 的 资源 清理 ，   在 所有 使用 这个 共享内存 块 的 进程 中 ，   " unlink ( ) "   应该 调用 一次 ( 且 只能 调用 一次 )
过滤器 提供 了 更 精细 的 设施 ， 用于 确定 要 输出 的 日志 记录
如果 它 未 被 处理 ， 则   Python   解释器 就 将 退出 ； 不会 打印 任何 栈 回溯 信息
" urllib . robotparser "   用于 解析   " robots . txt "   文件
请参阅   Python   发行版 中 的 文件   " Grammar / Grammar "   ， 以 获取 语言 语法 上下文 中 名称 的 定义
配合   " QueueHandler "   类 使用 ， " QueueListener "   可用 来 使 处理程序 在 与 执行 日志 记录 的 线程 不同 的 线程 上 完成 工作
For   more   information   see   配置 函数 .
组合   " Flag "   的 成员
B   称为 小 版本号 ， 它会 在 语言 特性 发生 较 小 改变 时 递增
对于   " f ( x1 ,   x2 ,   y ,   x3 ,   x4 ) "   调用 ， 如果   y   求值 为 一个 序列   y1   ,   ... ,   yM   ， 则 它 就 等价 于 一个 带有   M + 4   个 位置 参数   x1   ,   x2   ,   y1   ,   ... ,   yM   ,   x3   ,   x4   的 调用
如果 要 调试 它们 ， 可以 设置   flag   参数 为   " True "   并 调用 此 函数
注意 任何 由 调用者 提供 的   Python   对象 引用 是 借来 的 引用 ； 不要 递减 它们 的 引用 计数 ！
在 可能 的 情况 下 ， 支持 以下 同义词 ：
如果 给定   compresslevel   ， 它 必须 为   " 1 "   至   " 9 "   之间 的 整数
在   UNIX   上 会 使用   child   watchers   来 让 子 进程 结束 等待 ， 详情 请参阅 进程 监视器
不幸 的 是 ，   对 随机性 是否 足够 的 标准 会 随着 计算机 越来越 强大 并 能够 在 更 短时间 内 进行 更 多 猜测 而 不断 提高
PEP   324 :   新 的 子 进程 模块
如果 输入 日期 的 时区值 为   "   0000 " ， 则   " datetime "   将 为 一个 简单 型   " datetime " ， 而 如果 日期 符合   RFC   标准 则 它 将 代表 一个   UTC   时间 ， 但是 并 不 指明 日期 所在 消息 的 实际 源时区
例如   " meth . im _ func "   会 被 转换 为   " meth .__ func __ "
用于 实现 格式化 字 面值 字符串 （ f   字符串 ）
返回 一个 指向 可 用作 基于 字符 的 输入 的 只读 内存地址 的 指针
如果 错误码 被 设置 ， 会 抛出 一个   Python   异常
args   应当 是 一个 程序 参数 的 序列 或者 是 一个 单独 的 字符串 或   path   like   object
" PySet _ ClearFreeList ( ) " :   集合 自由 列表 已 在   Python   3.4   中 被 移除
更新 的 模块 ： ElementTree   1.3
此 特征 的 作用 之一 是 使得 从 默认 的 基础 认证 升级 到 更 快速 的 会 话 认证 成为 可能
在   3.6   版 更改 :   加入   exitmsg   参数
日志 功能 应以 所 追踪 事件 级别 或 严重性 而定
一般 的 ， 当 一个 表达式 设置 一个 指针 指向 一个 缓冲区 ， 这个 缓冲区 可以 被 相应 的   Python   对象 管理 ， 并且 这个 缓冲区 共享 这个 对象 的 生存 周期
除非 设置 了   " MULTILINE "   标志 ， 否则 只会 在 字符串 的 开头 匹配
排除 掉 的 时间 部分 将 被 截断 ， 而 不是 被 舍入
此外 ， 一旦 完成 了 配置 ， 在 运行 时 任意 改变 日志 记录器 、 处理程序 、 过滤器 、 格式化 器 的 对象 图 就 不是 很 有 必要 ； 日志 记录器 和 处理程序 的 详细 程度 只 需 通过 设置 级别 即可 实现 控制 （ 对于 日志 记录器 则 可 设置 传播 旗标 ）
universal _ newlines   参数 等同于   text   并且 提供 向 后 兼容性
" ' x : bz2 ' "   使用 bzip2   压缩 创建 tarfile
此 变量 如果 被 设为 一个 非空 字符串 ， 它 就 相当于 指定   "   i "   选项
当子 类化   " Enum "   时 ， 在 基类 序列 中 的 混合 类型 必须 出现 于   " Enum "   本身 之前 ， 如 以上   " IntEnum "   的 例子 所示
这 一节 提供 了 多个 使用 链 映射 的 案例
元 钩子 的 注册 是 通过 向   " sys . meta _ path "   添加 新 的 查找 器 对象 ， 具体 如下 所述
锁定 的 文件 区域 从 当前 文件 位置 开始 扩展   nbytes   个 字节 ，   并 可能 持续 到 超出 文件 末尾
" print ( ) "   也 可以 使用 ， 但 它 不是 一个 调试器 命令 它 执行   Python   " print ( ) "   函数
更改 的 Python   API
在   3.4   版 更改 :   文件 现在 禁止 继承
" __ enter __ ( ) "   启动 服务 进程 （ 如果 它 还 没有 启动 ） 并且 返回 管理器 对象   ，   " __ exit __ ( ) "   会 调用   " shutdown ( ) "
使用 十进制 浮点数 可以 消除 十进制 表示 错误 （ 即 能够 完全 精确 地 表示   " 0.1 "   这样 的 数 ） ； 然而 ， 某些 运算 在 非 零 数位 超出 给定 的 精度 时 仍然 可能 导致 舍入 错误
" csv "   模块 实现 了   CSV   格式 表单 数据 的 读写
如果   utc   参数 为 真值 ， 将 使用   UTC   时间 ； 否则 会 使用 本地 时间
" asyncio . new _ event _ loop ( ) "   创建 一个 新 的 事件 循环
一个 元组 ， 其中 包含 每个 受 支持 的 模块 可 引发 的 异常 ， 另外 还有 一个 名为   " dbm . error "   的 特殊 异常 作为 第一项 后者 最 在 引发   " dbm . error "   时 被 使用
当 传入   " None "   时 ， 应当 由类 的 设计者 来 决定 最佳 回应 方式
在   3.3   版 更改 :   Added   " service _ actions "   call   to   the   " serve _ forever "   method .
使用 这个 转换 表将   fp   ( 一个 支持   " . read ( ) "   并 包含 一个   JSON   文档 的   text   file   或者   binary   file   )   反 序列化 为 一个   Python   对象
某些 类型 也 能 接受 其他 对象
" hashlib "   安全 哈希 与 消息 摘要
Python   对 循环 引用 的 垃圾 检测 与 回收 需要 “ 容器 ” 对象 类型 的 支持 ， 此 类型 的 容器 对象 中 可能 包含 其它 容器 对象
分配   nelem   个 元素 ， 每个 元素 的 大小 为   elsize   字节 ， 并 返回 指向 分配 的 内存 的   " void   "   类型 指针 ， 如果 请求 失败 则 返回   " NULL "
这 将 覆盖 大多数 其他 选项
此 模块 中 所 定义 的 类型 都 不可 被 实例 化
最后   ， 也许 你 会 很 好奇 如何 从 一个 指定 范围 内 获取 一个 列表
如果 需要 连接 到 某些 当前 不 存在 Python 扩展 的 C 或 C   ++ 库 ， 可以 尝试 使用   SWIG   等 工具 包装 库 的 数据类型 和 函数
Python 代码 通常 比 同样 功能 的 C ， C++ ， Java   代码 要 短 很多 ， 原因 列举如下 ：
Panel   对象 ， 如 上面   " new _ panel ( ) "   所 返回 的 对象 ， 是 带有 栈 顺序 的 多个 窗口
对于 简单 的 字节 缓冲区 ， " PyMemoryView _ FromMemory ( ) "   是 首选 函数
3.2   版后 已 移除 :   The   assert   aliases   listed   in   the   third   column   have   been   deprecated .
如果 文件 以 文本 模式 打开 则 为 字符串 ； 否则 字节
未 被 压缩 的 归档 成员 的 数字 常数
3.2   新版 功能 .
3.3   新版 功能 .
请参阅   PEP   567   查看 更 多 细节
不要 将   " 用户   site   packages   目录 "   添加 到   " sys . path "
默认 交互式 解释器 的 替代品
类似 的 ， 要 从 结果 元组 获取 任何 非   " None "   值 ， 你 同样 需要 设置   " stdout   PIPE "   或者   " stderr   PIPE "
在   a   和   b   之间 进行 全 比较
什么 是 方法 ？
spawn   和   forkserver   启动 方式
Unittest 支持 简单 的 测试 搜索
将   cell   对象   cell   的 内容 设 为   value
它 还 展示 了 此 模块 所 提供 的 许多 其他 函数
（ 注意 ， 大多数 用户 未 根据 密码 数据库 显式 列为 所属 组 的 成员
这 意味着 字符串 的 格式 必须 和 在 命令提示符 中 所 输入 的 完全相同
3.2   新版 功能 .
如果   doraise   为 假值 （ 默认 ） ， 则 将 写入 错误信息 到   " sys . stderr " ， 但 不会 引发 异常
额外 的 关键词 参数 会 通过 类 的 构造函数 传递
返回 当前 线程 的 系统 和 用户 CPU 时间 之 和 的 值 （ 以小 数秒 为 单位 ）
( " os . chflags "   不是 在 所有 平台 上均 可用 。 )
如果   x   是 规范 的 则 返回   " True " ； 否则 返回   " False "
将 通过 调用   " runcode ( ) "   执行 代码 （ 该 方法 也 会 处理 运行 时 异常 ， " SystemExit "   除外   ）
要 请求 将 附加 位 强制 为 零 ， 可以 将 标志 ` ` strict   False ` `   传递 给 构造函数   :
PEP   282 :   logging   包
" numbers "   模块   (   PEP   3141   )   定义 了 数字 抽象 基类 的 层次结构 ， 其中 逐级 定义 了 更 多 操作
在   3.3   版 更改 :   " URLError "   已 被 设为   " OSError "   而 不是   " IOError "   的 子类
对于 所有   " SET _ ADD "   、   " LIST _ APPEND "   和   " MAP _ ADD "   指令 ， 当弹 出 添加 的 值 或 键值 对时 ， 容器 对象 保留 在 堆栈 上 ， 以便 它 可 用于 循环 的 进一步 迭代
" PrettyPrinter "   的 实例 具有 下列 方法 ：
从 一个 字典 获取 日志 记录 配置
对于 类   Unix   操作系统 ， Python   通常 会 分成 一系列 的 软件包 ， 因此 可能 需要 使用 操作系统 所 提供 的 包 管理工具 来 获取 部分 或 全部 可 选 组件
" configparser "   配置文件 解析器
为了 确定 何时 要 运行 ， 垃圾 回收 器会 跟踪 自上 一次 回收 后 对象 分配 和 释放 的 数量
失败 时 返回 非零值 并 设置 一个 异常
可以 手工 配置   " SelectorEventLoop "   来 使用   " SelectSelector "   或   " PollSelector "   以 在 这些 较 老 版本 的   macOS   上 支持 字符 设备
新 的 实例 基于   fileobj   ， 它 可以 是 一个 普通 文件 ， 一个   " io . BytesIO "   对象 ， 或者 任何 一个 与 文件 相似 的 对象
提示 ： 内置 函数   " range ( ) "   会 返回 一个 可 迭代 的 整数 序列 ， 适用 于 模拟   Pascal   中 的   " for   i   :   a   to   b   do "   这种 效果 ； 例如   " list ( range ( 3 ) ) "   会 返回 列表   " [ 0 ,   1 ,   2 ] "
调试器 （ 切换 ）   激活 后 ， 在 Shell 中 输入 的 代码 或 从 编辑器 中 运行 的 代码 将 在 调试器 下 运行
之前 仅限 操作码   " >   HAVE _ ARGUMENT "   带有 参数
Python   3.9   发布 于   2020   年   10   月   5   日
3.9   版后 已 移除 :   在 将来 ，   seed   必须 是 下列 类型 之一 :   NoneType   ,   " int " ,   " float " ,   " str " ,   " bytes "   或   " bytearray "
如果   first _ line   不是   " None "   ， 则 表示 应该 为 反汇编 代码 中 的 第一个 源代码 行 报告 的 行号
返回 的 数据 应当 与 之前 任何   " compress ( ) "   调用 的 输出 进行 拼接
dst   和   src   必须 为 整数 或 可 被 转换 为 指针 的   ctypes   实例
在   3.5   版 更改 :   quiet   parameter   was   changed   to   a   multilevel   value .
压缩 设置 可 被 指定 为 一个 预设 的 压缩 等级 （ 通过   preset   参数 ） 或 以 自定义 过滤器 链来 详细 设置 （ 通过   filters   参数 ）
使用 定制 钩子 存放   thread   可能 会 在 它 设为 被 终结 对象 时 将 其 重生
在   3.6 . 2   版 更改 :   path   形参 接受 一个   path   like   object
将   " basestring "   转换 为   " str "
关于 使用   " str . format ( ) "   进行 字符串 格式化 的 完整 概述 ， 请参阅 格式 字符串 语法
对于   " time "   对象 ， 年 、 月 、 日 的 格式 代码 不应 被 使用 ， 因为   " time "   对象 没有 这些 值
" StartBoundaryNotFoundDefect "   在   Content   Type   标头 中 宣称 的 开始 边界 无法 被 找到
所 发送 字节 串 的 格式 与   " makePickle ( ) "   文档 中 的 描述 一致
" BooleanOptionalAction "   在   " argparse "   中 可用 并会 添加 对 布尔 型 操作 例如   "   foo "   和   "   no   foo "   的 支持 :
形参 必须 不 为   " NULL "
如果 数据结构 包含 循环 链接 （ 例如 ， 每个 子级 都 有 一个 父级 引用 ， 每个 父级 都 有 一个 子级 列表 的 树 ） ， 则 引用 计数 将 永远 不会 返回 零
相反 地 ， " importlib . reload ( ) "   将 重用 同一个 模块 对象 ， 并 简单 地 通过 重新 运行 模块 的 代码 来 重新 初始化 模块 内容
然而   ， 命令行 字符串 经常 需要 被 当作 其它 的 类型 ， 比如   " float "   或者   " int "
附加 工具 类 和 函数
成功 时 返回   o1   和   o2   " 按位 与 "   的 结果 ， 失败 时 返回   " NULL "
保证 所 代理 的 方法 的 参数 是 可以 序列化 的
如果   when   被 省略 ， 则 默认 为   " termios . TCSAFLUSH "   ， 并 传递 给   " termios . tcsetattr ( ) "
位置 参数   :   不 属于 关键字 参数 的 参数
在   BLAKE2   中 ， 盐值 会 在 初始化 期间 作为 对 哈希 函数 的 一次性 输入 而 不是 对 每个 压缩 函数 的 输入 来 处理
Deque 的 最大 尺寸 ， 如果 没有 限定 的话 就是   " None "
Python 使用 传统 的 引用 计数 实现 ， 也 提供 了 循环 监测器 ， 用以 检测 引用 循环
你 还 可以 使用   " compileall "   模块 自动 编译 一个 目录 或 多个 目录 下 的 所有 文件
错误 输出 重定向 和 程序 终止
" k "   ( " int " )   [ unsigned   long ]   将 一个   C   " unsigned   long "   无 符号长 整型 转化成   Python   整型 对象
要 在 接收端 将 记录 解封 并 输出 到   " LogRecord " ， 请 使用   " makeLogRecord ( ) "   函数
等价 于   Python   表达式   " o1   +   o2 "
其他   CPython   实现 的 改变
设计 和 历史 常见问题
" fix _ sentence _ endings "   默认 为 假值
不可 变 对象 不 需要 声明 此 方法 ， 因为 他们 不 可能 直接 产生 循环 引用
详细 文档 请 参见 命令行 界面
解包 并 返回 同质 条 目的 列表
将   " dict . has _ key ( key ) "   转换 为   " key   in   dict "
在 单个 程序 中 跨 模块 共享 信息 的 规范 方法 是 创建 一个 特殊 模块 （ 通常 称为 config   或 cfg ）
如果 没有 找到 ， 然后 解释器 从   " sys . path "   变量 给出 的 目录 列表 里 寻找 名为   " spam . py "   的 文件
假设 我们 要 删除 排名 高于 50 的 所有 国家 / 地区 :
这有 几个 可能 的 原因
提示 用户 输入 一个 密码 且 不会 回显
要 转换 为键 函数 ， 只 需 包装 旧 的 比较 函数 ：
没有 参数 会 引发 审计 事件   " cpython . run _ stdin "
3.9   新版 功能 .
注意 任何 由 调用者 提供 的 Python 对象 引用 是 借来 的 引用 ； 不要 递减 它们 的 引用 计数 ！
这 将 同时 应用   E   和   s
此 模块 提供 了 下列 函数 ， 对应 于 标准   C   库中 的 函数 :
模块   " compileall "   编译 一个 目录 树中 所有   Python   源文件 的 工具
有 一种 方式 可以 简单 地 直接 调用 基类 方法 ： 即 调用   " BaseClassName . methodname ( self ,   arguments ) "
在   3.5   版 更改 :   现在 ，   suffix   、   prefix   和   dir   可以 以   bytes   类型 按 顺序 提供 ， 以 获得   bytes   类型 的 返回值
bpo   24432 :   更新 Windows   构建 和 OS   X   10.5   安装程序 以 使用 OpenSSL   1.0 . 2c .
所有 流式 读取器 必须 提供 此 构造 器 接口
更 多 信息 ， 请 参见 使用   DTrace   和   SystemTap   检测 CPython
将 带有 属性   attr   的 字符   ch   绘制 到   " ( y ,   x ) " ， 覆盖 之前 在 该 位置 上 绘制 的 任何 字符
是否 有 办法 得到 一个 非 指数 表示 形式 ？
在   3.6   版 更改 :   Now   only   called   for   exceptions   derived   from   the   " Exception "   class .
Python   核心 使用 多个 访问者 函数 实现 循环 引用 的 垃圾 检测 ， 不 需要 用户 自行 实现 访问者 函数
此 字符 的 字节 翻转 版本   ( " 0xFFFE " )   是 一个 不可 出现 于   Unicode   文本 中 的 非法 字符
btn   鼠标 按钮 编号 ， 默认值 为   1   ( 鼠标 左键 )
要 运行 全局 解释器 ， 请 停用 虚拟环境 ， 或 显式 指定 全局 Python 版本
timeout   形参为 适当 的   " select ( ) "   或   " poll ( ) "   调用 设置 超时 参数 ， 以 秒 为 单位 ;   默认值 为 30 秒
打印 全部 命令行 选项 的 简短 描述
过时 的 文档 被 移动 至   email . message . Message :   Representing   an   email   message   using   the   compat32   API
这个 方法 可以 最小 代价 实现 命令式 的 栈 操作 ， 诸如   " dup " ,   " drop " ,   " swap " ,   " over " ,   " pick " ,   " rot " ,   和   " roll "
在   3.5   版 更改 :   添加 了 对   xztar   格式 的 支持
因为 每个 模块 只有 一个 实例 ， 所以 对 模块 对象 所 做 的 任何 更改 都 会 在 任何 地方 反映 出来
可以 被 封存 / 解封 的 对象
返回   list   中 列表 对象 的 长度 ； 这 等于 在 列表 对象 调用   " len ( list ) "
日语 :   cp932 ,   euc   jis   2004 ,   euc   jp ,   euc   jisx0213 ,   iso   2022   jp ,   iso   2022   jp   1 ,   iso   2022   jp   2 ,   iso   2022   jp   3 ,   iso   2022   jp   ext ,   iso   2022   jp   2004 ,   shift   jis ,   shift   jisx0213 ,   shift   jis   2004
现在 我们 能 用 实例 对象 做 什么 ？   实例 对象 理解 的 唯一 操作 是 属性 引用
返回值 由 两个 元素 组成 ： 第一个 是   " ( option ,   value ) "   对 的 列表 ； 第二个 是 在 去除 该 选项 列表 后 余下 的 程序 参数 列表 （ 这 也 就是   args   的 尾部 切片 ）
" heapq "   堆 队列 算法
从   5.4   版本 开始 ， ncurses   库 使用   " nl _ langinfo "   函数 来 决定 如何 解释 非   ASCII   数据
" refresh ( ) "   实际上 做 了 两件事 ：
语句 解释 及 变量 编译
如果   x   是 显式   NaN   则 返回   " True " ； 否则 返回   " False "
在 写入 其他 类型 的 对象 之前 ， 需要 先 把 它们 转化 为 字符串 （ 在 文本 模式 下 ） 或者 字节 对象 （ 在 二进制 模式 下 ） :
如果   x   不是   Python   " int "   对象 ， 则 必须 定义 返回 整数 的   " __ index __ ( ) "   方法
Python   是 一门 以 稳定 著称 的 编程语言
Sphinx   Sphinx 工具 链 的 文档 和 代码
在   3.5   版 更改 :   The   " sendfile ( ) "   method   was   added .
从 迭代 对象 或 映射 对象 减去 元素
在   3.3   版 更改 :   添加 了   policy   关键字
要 获取 有效 路径 ， 参见   " commonpath ( ) "
模块   " calendar "   一般 日历 相关 功能
标准 类型 层级 结构
（ 由   Victor   Stinner   在   bpo   36465   中 贡献 。 ）
billion   laughs   /   exponential   entity   expansion   （ 狂笑 / 递归 实体 扩展 ）   Billion   Laughs   攻击 也 称为 递归 实体 扩展 使用 多级 嵌套 实体
设置   " default _ factory "   为   " int " ， 使   " defaultdict "   用于 计数 （ 类似 其他 语言 中 的   bag   或   multiset ） ：
" ZoneInfo "   文件 的 行为 取决于 它 的 构造 方式 :
当 文件 用于 写入 时 ， 文件 对象 应该 支持   seek   操作 ， 除非 提前 获知 写入 的 采样 总数 ， 并 使用   " writeframesraw ( ) "   和   " setnframes ( ) "
发布 日期 :   2019   02   03
" d "   ( " float " )   [ double ]   将 一个 Python 浮点数 转化成 一个 C   " double "   双 精度 浮点数
默认值 为   " True "
key   function 则 是 一个 接受 一个 参数 ， 并 返回 另 一个 用以 排序 的 值 的 可 调用 对象
返回 一个 将   function   应用 于   iterable   中 每一项 并 输出 其 结果 的 迭代 器
当 省略   timeout   参数 时该 函数 将 阻塞 直到 至少 有 一个 文件 描述符 准备就绪
如果   var   在 上下文 对象 中 具有 值则 返回   var   的 值
我 怎样 使用   Python   脚本 制作 可执行文件 ？
这 两个 模块 背后 的 基本 思想 是 创建 一个 或 多个 网络 通道   ， 类 的 实例   " asyncore . dispatcher "   和   " asynchat . async _ chat "
Python   中 使用 的   Timsort   算法 可以 有效 地 进行 多种 排序 ， 因为 它 可以 利用 数据 集中 已 存在 的 任何 排序
在   3.4   版 更改 :   现当   indent   不是   " None "   时 ， 采用   " ( ' , ' ,   ' :   ' ) "   作为 默认值
典型 的 引用 计数 实现 无法 回收 处于 引用 循环 中 的 对象 ， 或者 被 循环 所 引用 的 对象 ， 哪怕 没有 循环 以外 的 引用 了
表达式   " x   or   y "   首先 对   x   求值 ； 如果   x   为 真则 返回 该值 ； 否则 对   y   求值 并 返回 其 结果 值
此 方法 会以 字符串 形式 返回 窗口 内容 ； 是否 包括 窗口 中 的 空白 将 受到   " stripspaces "   属性 的 影响
将   TOS   替换 为   " getattr ( TOS ,   co _ names [ namei ] ) "
使用 自定义 的   " __ new __ ( ) "
有 很多 支持 Python 编程语言 的 集成 开发 环境
如果 省略 ， 则 此 形参 默认 为   " True "
举个 例子 ，   " is _ multipart "   在   " EmailMessage "   是   " message / rfc822 "   类型 的 信息 的 情况 下 ， 其 返回值 也 是   " True "
对于 字 面值 匹配 ， 请 将 原 字符 用 方括号 括 起来
移除   text   中 每 一行 的 任何 相同 前缀 空白符
这些 嵌套 字段 也 可以 包含 有 它们 自己 的 转换 字段 和 格式 说明符 ， 但 不可 再 包含 更 深层 嵌套 的 替换 字 段
受 支持 的   INI   文件 结构
如果 给出 额外 的 参数 和 / 或 关键字 参数 ， 它们 也 将 被 传给 该 方法
when   参数 确定 何时 改变 属性 :   " TCSANOW "   表示 立即 改变 ， " TCSADRAIN "   表示 在 传输 所有 队列 输出 后 再 改变 ， 或   " TCSAFLUSH "   表示 在 传输 所有 队列 输出 并 丢失 所有 队列 输入 后 再 改变
重置 库 例程 使用 的 时间 转换规则
PEP   3155   类 和 函数 的 限定 名称   PEP   由   Antoine   Pitrou   撰写 并 实现
返回 一个 从   " __ enter __ "   返回   enter _ result   的 上下文 管理器 ， 除此之外 不 执行 任何 操作
如果 调用者 的 控制线 程 不是 利用   " threading "   创建 ， 会 返回 一个 功能 受限 的 虚拟 线程 对象
PEP   366   Main   module   explicit   relative   imports   PEP   由   Nick   Coghlan   撰写 并 实现
循环体 是 缩进 的   ： 缩进 是   Python   组织 语句 的 方式
当   default   被 指定 时 ， 其 应该 是 一个 函数 ， 每当 某个 对象 无法 被 序列化 时 它 会 被 调用
" aifc "   读写   AIFF   和   AIFC   文件
如果 反 序列化 的 数据 不是 有效   JSON   文档 ， 引发   " JSONDecodeError "   错误
但是 ， 如果 你 确信 需要 自定义 级别 ， 那么 在 执行 此 操作 时应 特别 小心 ，   如果 你 正在 开发 库 ， 则 定义 自定义 级别 可能 是 一个 非常 糟糕 的 主意
PEP   378   千位 分隔符 的 格式 说明符   PEP   由   Raymond   Hettinger   撰写 ， 并 由   Eric   Smith   和   Mark   Dickinson   实现
使用   NCURSES   编写程序 :   一篇 面向   C   程序员 的 详细 教程
Python   的   curses   模块
立即 关闭   cursor （ 而 不是 在 当   " __ del __ "   被 调用 的 时候 ）
如果 你 需要 解析 不 受 信任 或 未经 身份验证 的 数据 ， 请参阅   XML   漏洞 和   defusedxml   包 部分
和 模块 一样 ， 类 也 拥有   Python   天然 的 动态 特性 ： 它们 在 运行 时 创建 ， 可以 在 创建 后 修改
在   3.3   版 更改 :   ( 参见 :   bpo   12419 。 )   在 较 早 的 版本 中 ， 没有   " ident "   或   " tag "   前缀 工具 可以 用来 标识 消息 的 来源
" ( flags   &   0x03 )   0x03 " :   在 格式化   value   之前 调用 其   " ascii ( ) "
当 对于 无效 结果 需要 中断 计算 进行 特别 处理 时 ， 这是 一个 很 有用 的 返回值
在   3.8   版 更改 :   现在 可以 接受   " bytes "   类型
3.6   新版 功能 :   " Flag " ,   " IntFlag " ,   " auto "
这 被 认为 是 最好 的 默认 行为
" sorted ( iterable ,   key   None ,   reverse   False ) "   会 将   iterable   中 的 元素 收集 到 一个 列表 中 ， 然后 排序 并 返回 结果
常数   颜色   " COLOR _ BLACK "   黑色   " COLOR _ BLUE "   蓝色   " COLOR _ CYAN "   青色 （ 浅绿 蓝色 ）   " COLOR _ GREEN "   绿色   " COLOR _ MAGENTA "   洋红色 （ 紫红色 ）   " COLOR _ RED "   红色   " COLOR _ WHITE "   白色   " COLOR _ YELLOW "   黄色
3.3   新版 功能 .
只 运行 匹配 模式 或 子串 的 测试方法 和 类
这 一行 应 以 大写字母 开头 ， 以 句点 结尾
这 提供 了 类似 于 目前 已有 的   " property ( ) " ,   " classmethod ( ) "   和   " staticmethod ( ) "   等 函数 的 文档 选项 :
在 消息 中 显示 日期 / 时间
确定 适当 的 元类
上述 代码 与 第一个 例子 完全 等价
如果   ob   不是 一个 弱 引用 对象 ， 或者 如果   callback   不是 可 调用 对象 ， " None "   或   " NULL " ， 该 函数 将 返回   " NULL "   并且 引发   " TypeError "
另外 一些 时候 你 要 构造 一个 新 的 tuple 来 传递 参数
其它 方法 必须 在 持有 关联 的 锁 的 情况 下 调用
会 引发 一个   " KeyError "   异常 ， 因为 第二行 中 使用 的   " [ 1 ,   2 ] "   的   id   与 第一行 中 的   id   不同
PEP   342 :   生成器 的 新 特性
（ 由   Ethan   Smith   在   bpo   32380   中 贡献 ）
3.9   新版 功能 .
" HRESULT "   的 值 包含 的 信息 说明 函数调用 成功 还是 失败 ， 以及 额外 错误码
返回 一个   " namedtuple ( ) "   " ( nchannels ,   sampwidth ,   framerate ,   nframes ,   comptype ,   compname ) " ， 与   " get   ( ) "   方法 的 输出 相同
通过 返回 一个 结果 元组 :
然而 请 注意 ， 尽管 显示 的 帮助 看起来 清楚 完整 ， 但 它 可以 比 现在 更 有 帮助
正如 前面 所 提到 过 的 ， 除了 整数 、 字符串 以及 字节 串 之外 ， 所有 的   Python   类型 都 必须 使用 它们 对应 的   " ctypes "   类型 包装 ， 才 能够 被 正确 地 转换 为 所 需 的 C语言 类型
返回   Content   Type   头字 段 中 的   " charset "   参数 ， 强制 小写
也 有 一些 例外
" time "   的 格式 与   " offset "   的 格式 相同 ， 但 不 允许 使用 前导 符号 （   '   '   或   ' + '   ）
否则 为   " False "   ， 且   " read ( ) "   将 引发   " OSError "   错误
calendar 还 提供 了   " MONDAY " ,   " TUESDAY " ,   " WEDNESDAY " ,   " THURSDAY " ,   " FRIDAY " ,   " SATURDAY "   和   " SUNDAY "   几个 常量 方便使用
它 也 用于 转义 所有 元字符 ， 因此 您 仍然 可以 在 模式 中 匹配 它们 ； 例如 ， 如果 你 需要 匹配   " [ "   或   " \ " ， 你 可以 在 它们 前面 加 一个 反 斜杠 来 移除 它们 的 特殊 含义 ： " \ [ "   或   " \ \ "
形参 可以 为   " NULL "
字符串 转换 与 格式化
从 正在 运行 的 程序 进入 调试器 的 典型 用法 是 插入
例如 ， 如果 可以 在 当前 位置 找到 组   1   的 确切 内容 ， 则   " \ 1 "   将 成功 ， 否则 将 失败
程序员 注意事项 :   函数 属于 一类 对象
" " " . replace ( " " ,   s ,   n ) "   对于 所有 非零 的   " n "   都 将 返回   " s "   而 不是 空 字符串
这 将 让   " bytes ( msg ) "   产生 一个 包含 序列化 信息内容 的 字节 序列 对象
size   参数 指明 要 读取 并 解码 的 已 编码 字节 或 码位 的 最大 数量 近似值
如果 未指定   facility   ， 则 使用   " LOG _ USER "
还有 一个   " patch . dict ( ) "   用于 在 一定 范围 内 设置 字典 中 的 值 ， 并 在 测试 结束 时 将 字典 恢复 为 其 原始 状态 ：
为 顶级 记录器 配置 处理程序 并 根据 需要 创建 子 记录器 就 足够 了
异常 类 从   " urllib . error "   模块 中 导出
在   3.3   版 更改 :   The   locking   scheme   has   changed   to   per   module   locks   for   the   most   part
空白行 会 被 忽略 ， 以 一个   " ' # ' "   开始 的 注释 行 也 是 如此
如果 指定 了   size   ， 则 将 其 用作 字符串 中 的 字符 数量 ， 否则 将 假定 字符串 以零值 结尾
将 编码器 重置 为 初始状态
它 允许 使用 mock 对象 替换 受 测试 系统 的 部分 ， 并 对 它们 如何 已经 被 使用 进行 断言
bpo   32505 :   如果 数据 类 的 成员 变量 的 类型 为 Field ， 但 没有 类型 注解 ， 则 引发   TypeError
3.2   新版 功能 .
在   Python   3.2 . 4   和   3.3 . 1   之前 的 版本 中 ， 它 错误 地 将 默认值 设 为了 为   " 0 " ， 这 是 无 缓冲 的 并且 允许 短 读取
将   " exec "   语句 转换 为   " exec ( ) "   函数调用
本章 中 描述 的 各 模块 可帮 你 编写   Python   程序
在   3.8   版 更改 :   可能 会 在 内部 使用 平台 专属 的 快速 拷贝 系统 调用 以 更 高效 地 拷贝 文件
这一 程序 被 设计 为 当 指定   "   verbosity "   选项 时 显示 某些 东西 ， 否则 不 显示
在 多个 模块 中 使用 日志
Nested   Contexts   recipe   提供 了 是否 对 第一个 映射 或 其他 映射 进行 写 和 其他 修改 的 选项
引发 一个 审计 事件   " syslog . closelog "   不 附带 任何 参数
stdin   ,   stdout   和   stderr   分别 指定 被 运行 的 程序 的 标准 输入 、 输出 和 标准 错误 的 文件 句柄
引发   exc   作为 异常
这个 映射 起到 缓存 之前 导入 的 所有 模块 的 作用 （ 包括 其中 间 路径 ）
这 不起作用 ， 因为 如果 你 构造 一个 具有 相同 值 的 新 列表 ， 它 将 无法 找到 ； 例如 :
各种 枚举 有何 区别 ？
在子 进程 中 抛出 的 异常 ， 在 新 的 进程 开始 执行 前 ， 将会 被 再次 在 父 进程 中 抛出
" NoBoundaryInMultipartDefect "   一条 消息 宣称 有 多个 部分 ， 但 却 没有   boundary   形参
" pkgutil "   包 扩展 工具
它们 可以 指向   URL 、 数据库 查询 或 可以 用 字符串 指定 的 任何 其他 位置
详情 见   PEP   411
" ' insert ' "   " b [ j1 : j2 ] "   应 插入 到   " a [ i1 : i1 ] "
Lambda 函数 可以 在 需要 函数 对象 的 任何 地方 使用
bpo   33604 :   更新 HMAC   md5 默认 报告 DeprecationWarning ， 并 将 在 3.8 移除
该 内置 变量 的 值会 在 解释器 启动 时 确定
3.5 . 4   新版 功能 .
在   Unix   上 ，   configure   脚本 将 尝试 定位 适当 的 头文件 来 简化 此 模块 的 构建
如果 字典 中 没有   key   ， 则 会 引发   " KeyError "
例如 ， 它 可 被 用于 比较 文件 ， 并 可 产生 多种 格式 的 不同 文件 差异 信息 ， 包括   HTML   和 上下文 以及 统一 的   diff   数据
参见   " StatisticDiff "   类
这些 模块 自   Python   3.7   起 已 被 弃用 ， 它们 需要 线程 支持
此 方法 返回 一个 由 共享 库 导出 的   ctypes   类型
" nonlocal "   语句 会 使得 所 列出 的 名称 指向 之前 在 最近 的 包含 作用域 中 绑定 的 除 全局变量 以外 的 变量
" IncrementalEncoder "   可以 通过 提供   errors   关键字 参数 来 实现 不同 的 错误处理 方案
在 未 锁定 的 锁 调用 时 ， 会 引发   " RuntimeError "   异常
在 语义上 等价 于 :
这篇 文档 由   John   Lee   审订
作为 对 使用 上述   " request ( ) "   方法 的 替代 同 ， 你 也 可以 通过 使用 下面 的 四个 函数 ， 分 步骤 发送 请 的 请求
它 将 回退 ， 直到 它 为   " [ bcd ]   "   尝试 零 匹配 ， 如果 随后 失败 ， 引擎 将 断定 该 字符串 与 正则 完全 不 匹配
如果 操作系统 可用 ， 则   " hashlib " ,   " posix " ,   " ssl " ,   " crypt "   模块 使用   OpenSSL 库来 提高 性能
prog   将 与 子 命令 帮助 一同 显示 的 用法 信息 ， 默认 为 程序 名称 和子 解析器 参数 之前 的 任何 位置 参数
在   3.4   版 更改 :   同样 支持 命名 空间 包
如果 您 在 非 Macintosh 平台 上 编码 或 解码 文本文件 ， 它们 仍 将 使用 旧 的 Macintosh   换行符 约定 （ 回车符 作为 行尾 ）
如果 给定 了   sizehint   ， 则 将 其 作为   size   参数传递 给 流 的   " read ( ) "   方法
这些 文件 位于   " PCbuild "   目录 中
如果   x   不是   Python   的   " int "   对象 ， 那 它 需要 定义   " __ index __ ( ) "   方法 返回 一个 整数
现在   ， CPython 可以 正确 地 实现 malloc ( ) 和 free ( )
建议 你 根据 所 测试 的 功能 ， 将 测试 用   TestCase   实现 集合起来
负 的 位置 值 将 被 视为 相对 于 输入 字符串 的 末尾
这 对于 帮助 捕捉 逻辑 错误 非常 有用 :
另 一个 功能 是 你 可以 指定 正则 的 某些 部分 必须 重复 一定 次数
将   fun   指定 的 函数 绑定 到 在 此 海龟 上 移动 鼠标 事件
下表 显示 了 传统 转换器 映射 到 实参 转换器 的 情况
再次 使用   " False "   来 禁用 该 功能
你 可以 使用   " basicConfig ( ) "   指定 目标 （ 例如 控制台 或 文件 ） ， 如 教程 示例 中 所示
导入 机制 是 可 扩展 的 ， 因此 可以 加入 新 的 查找 器以 扩展 模块 搜索 的 范围 和 作用域
因此 ， 当 先前 的   " print ( x ) "   尝试 打印 未 初始化 的 局部变量 时会 导致 错误
在   3.8   版 更改 :   如果 可用 将 使用   " __ index __ ( ) "
如何 让 编辑器 不要 在 我 的   Python   源代码 中 插入   tab   ？
跳过 被 装饰 的 测试 ， 除非   condition   为 真
这 应当 小于 或 等于   273
模拟 基于   ' action   >   assertion '   模式 ， 而 不是 许多 模拟 框架 所 使用 的   ' record   >   replay ' 模式
fileobj   和   filename   至少 有 一个 不为 空
" tokenize "   对   Python   代码 使用 的 标记 解析器
（   " codeop "   模块 是 低 层级 的 ， 用于 支持 编译 可能 不 完整 的   Python   代码 块 。 ）
unittest   添加 了   " addModuleCleanup ( ) "   和   " addClassCleanup ( ) "   以 支持 对   " setUpModule ( ) "   和   " setUpClass ( ) "   进行 清理
如果 失败 ， 返回   " NULL "
如果   " __ complex __ ( ) "   未定义 则 将 回退 至   " __ float __ ( ) "
ident   的 默认值 依赖于 系统 库 ， 它 往往 为   " python "   而 不是   Python   程序 文件 的 实际 名称
如果 一个 分离 的 类 不 希望 依照 这个 需求 ， 所有 的 特殊 方法 就 必须 重写 ； 请 参照 源代码 进行 修改
optionxform   函数 会 将 选项 名称 转换 为 规范 形式
" \ S "   匹配 任何 非 空白 字符 ； 这 相当于 类   " [ ^   \ t \ n \ r \ f \ v ] "
（ 请参阅   " PyCapsule _ GetPointer ( ) "   了解 如何 对   capsule   名称 进行 比较 的 有关 信息   。 ）
有时 能够 重现 伪 随机数 生成器 给出 的 序列 是 很 有 用处 的
如果 某种 压缩 方法 不 受 支持 ， 则 会 引发   " CompressionError "
包含 所有 可用 类型 码 的 字符串
web   installer   （ 网络 安装包 ） 是 一个 小 的 初始化 工具 ， 它 将 在 安装 过程 中 ， 根据 需要 自动 下载 所 需 的 组件
named   tuple   具名 元组 术语 “ 具名 元组 ” 可 用于 任何 继承 自 元组 ， 并且 其中 的 可 索引 元素 还 能 使用 名称 属性 来 访问 的 类型 或类
3.4   新版 功能 .
SQLite   原生 只 支持 5 种 类型 ： TEXT ， INTEGER ， REAL ， BLOB   和   NULL
缓冲区 接口 的 消费者 的 一个 例子 是 文件 对象 的   " write ( ) "   方法 ： 任何 可以 输出 为 一系列 字节 流 的 对象 可以 被 写入 文件
此 转换 通常 需要 53 位 或 更 多位数 的 精度
输出 参数 可以 是 文件名 或类 文件 对象 （   " write ( ) "   和   " close ( ) "   方法 的 任何 对象 ）
之后 ， 你 可以 看 一下 日志 操作手册
closure   必须 为   " Py _ None "   或   cell   对象 的 元组
不 严谨 地 讲 ， 该类 有 一个 名称 ： 虽然 它 是 绑定 了 两个 名称 并 通过 名称   B   发起 调用 ， 所 创建 的 实例 仍然 被 视为 类   A   的 一个 实例
在   3.7   版 更改 :   Universally   administered   MAC   addresses   are   preferred   over   locally   administered   MAC   addresses ,   since   the   former   are   guaranteed   to   be   globally   unique ,   while   the   latter   are   not .
在   3.8 . 2   版 更改 :   Require   " Py _ ssize _ t "   for   " # "   format   characters
从文件 关联   ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
返回 密码 数据库 中 所有 项目 的 列表 ， 顺序 不是 固定 的
对 导出 对象 的 新 引用
ctypes   数据类型 的 通用 方法 ， 它们 都 是 类 方法 （ 严谨 地说 ， 它们 是   metaclass   的 方法 ） :
为什么   if / while / def / class 语句 需要 冒号 ？
这 等价 于 :
如果   IO   对象 不 使用 文件 描述符 ， 则 会 引发   " OSError "
另 一个 窗口 将 被 激活
strip _ text   :   set   to   true   to   strip   whitespace   before   and   after   text   content   （ 默认值 ： 否 ）
否则 ，   " ArgumentParse "   将会 看到 两个   "   h /   help "   选项 （ 一个 在 父 参数 中 一个 在子 参数 中 ） 并且 产生 一个 错误
应当 使用   " html . unescape ( ) "   来 将 字符 引用 转换 为 对应 的   unicode   字符
如果 没有 对应 的 文件 ，   则 使用 “ 另存为 ” 代替
3.2   新版 功能 .
目前 ，   " CLOCK _ REALTIME "   是   clk _ id   唯一 可 接受 的 值
如果 指定 了   longopts   ， 则 必须 为 一个 由 应当 被 支持 的 长 选项 名称 组成 的 列表
传入 使用   " fmean ( ) "   和   " stdev ( ) "   基于   data   估算 出 的   mu   和   sigma   形参 创建 一个 正态分布 实例
如果 测试 成功 ， 这个 测试函数 应当 返回 一个 描述 图像 类型 的 字符串 ， 否则 返回   " None "
3.1   新版 功能 .
有关 更 多 详细信息 ， 请参阅 Python 源代码 中 的   " Misc / SpecialBuilds . txt "
" json "   JSON   编码 和 解码器
" distutils . core "   分发 包 功能 的 核心
附带   " ' r ' "   和   " ' w ' "   旗 标的 打开 操作 不会 再 创建 数据库
它 拥有 一系列 方法 ， 可以 为 大部分 常用 数据类型 创建 并 返回 代理 对象 代理   ， 用于 进程 间 同步
所有 常用 的 数学 运算 和 特殊 方法 都 适用
phase   可 为 以下 两值 之一 ：
Future   对象 用来 链接 底层 回 调式 代码 和 高层 异步 / 等待 式 代码
当 发起 调用 时 如果   timeout   不 为   " None " ， 则 它 将 阻塞 最 多   timeout   秒
请参阅   difflib   的 命令行 接口 获取 更 详细 的 示例
flags   已经 弃用 且 完全 被 忽略
此 函数 复杂度 为   O ( 1 )   ， 也就是说 对于 只 包含 几个 上下文 变量 和 很多 上下文 变量 的 情况 ， 他们 是 一样 快 的
ABC   " MyIterable "   定义 了 标准 的 迭代 方法   " __ iter __ ( ) "   作为 一个 抽象 方法
在 资源 数量 固定 的 任何 情况 下 ， 都 应该 使用 有 界 信号量
例如 ，   " datetime . timetuple ( ) "   会 调用 其   " tzinfo "   属性 的   " dst ( ) "   方法 来 确定 应该 如何 设置   " tm _ isdst "   旗标 ， 而   " tzinfo . fromutc ( ) "   会 调用   " dst ( ) "   来 在 跨越 时区 时 处理   DST   的 改变
在   3.4   版 更改 :   Support   width   and   precision   formatter   for   " " % s " " ,   " " % A " " ,   " " % U " " ,   " " % V " " ,   " " % S " " ,   " " % R " "   added .
将 老 的 元类 语法 （ 类体 中 的   " __ metaclass __   Meta " ） 替换 为 新 的 （ " class   X ( metaclass   Meta ) " ）
有 少数 的 常量 存在 于 内置 命名 空间 中
到 目前为止 ， 我们 只是 针对 静态 字符串 执行 搜索
3.5   新版 功能 .
Sun ,   Mon ,   ... ,   Sat   ( 1 )   ( en _ US ) ;   So ,   Mo ,   ... ,   Sa   ( de _ DE )   " % A "   本地化 的 星期 中 每日 的 完整 名称
在   3.2   版 更改 :   Previously ,   Windows   registry   settings   were   ignored .
如果   filenames   中 名称 对应 的 某个 文件 无法 被 打开 ， 该 文件 将 被 忽略
当 使用 适当 的 参数 运行 时 ， 它会 输出 命令行 传入 整数 的 总和 或者 最大值 ：
" % z "   " utcoffset ( ) "   会 被 转换 为   " ± HHMM [ SS [ . ffffff ] ] "   形式 的 字符串 ， 其中   " HH "   为 给出   UTC   时差 的 小时 部分 的   2   位 数码 字符串 ， " MM "   为 给出   UTC   时差 的 分钟 部分 的   2   位 数码 字符串 ， " SS "   为 给出   UTC   时差 的 秒 部分 的   2   位 数码 字符串 ， 而   " ffffff "   为 给出   UTC   时差 的 微秒 部分 的   6   位 数码 字符串
在 某些 平台 上 ， 如果 使用   " os . stat ( ) "   查询 到 目标 文件 没有 执行 权限 ， 即使   path   确实 存在 ， 本 函数 也 可能 返回   " False "
" arg0 "   是 模块 名称 ，   " arg1 "   表示 模块 是否 成功 加载
如果 您 使用 Python 字典 将 名称 映射 到 图像 ， 或 将 图像 映射 到 名称 ， 则 图像 对象 将 保持 活动状态 ， 因为 它们 在 字典 中 显示 为值 或键
如果   path   中 没有 斜杠 ，   head   将 为 空
要 获取 一个   tar   归档 中 文件 的 列表 ， 请 使用   "   l "   选项 :
如果 可以 读取 流 ， 则 返回   " True "
表示 复数 的 Python 对象
这些 通常 对 测试工具 ，   管理工具 和 原型 有用 ， 这些 工具 随后 将 被 包含 在 更 复杂 的 接口 中
data   可以 是 序列 或 可 迭代 对象
" try "   子句 会 被 执行 ，   包括 任何   " except "   和   " else "   子句
chunksize   对   " ThreadPoolExecutor "   没有 效果
例如 ， 在 日志 记录器 或 处理程序 中 表示   " level "   的 字符串 值   " ' DEBUG ' "   将 被 自动 转换 为值   " logging . DEBUG " ， 而   " handlers " ,   " filters "   和   " formatter "   条目 将 接受 一个 对象   ID   并 解析 为 适当 的 目标 对象
返回   number   舍入 到 小数点 后   ndigits   位 精度 的 值
它会 返回 与 同名 内置 函数 所 返回 字符串 相似 的 字符串 ， 区别 在于 附带 了 对 多数 类型 的 大小 限制
特别 地 ，   setuptools   是 一个 对于   " distutils "   的 增强 选项   ， 它 能 提供 ：
参数 :   n   非负 整型 数
可 选 关键 字形 参   linejunk   和   charjunk   均 为 过滤 函数   ( 或 为   " None " )   ：
例如 ， " 10   2 "   返回   " 100 " ， 而   " 10   2 "   返回   " 0.01 "
此 函数 不会 增加 对   v   的 引用
调用 这个 方法 时   Future   已经 完成   ,   回调 函数 已 被   " loop . call _ soon ( ) "   调度
名称 长度 不能 超过   100   个字符 ， 并且 没有 用户 / 分组 名 信息
当 使用 对象 类型 并 不 适用 时 ， 他们 会 产生 一个   Python   异常
定义 一个   " __ iter __ ( ) "   方法 来 返回 一个 带有   " __ next __ ( ) "   方法 的 对象
在   a   中 找到   x   合适 的 插入 点以 维持 有序
枚举 值 之间 的 排序 比较 不 被 支持
（ 如果 你 已经 对 测试 的 概念 比较 熟悉 了 ， 你 可能 想 直接 跳转 到 这 一部分 断言 方法 。 ）
这次 当前 位置 的 字   符是   " ' b ' "   ， 所以 它 成功 了
PEP   353 :   使用 ssize _ t 作为 索引 类型
中断 执行 停止 正在 运行 的 程序
确定   code   是否 属于   tableC.6   ( 不适 用于 纯 文本 )
3.2   新版 功能 .
返回   " True "   ， 除非 提供 的   timeout   过期 ， 这种 情况 下 返回   " False "
" copyreg "   注册 配合   " pickle "   模块 使用 的 函数
默认值 为   " 40 "
强烈建议 在 可能 引入 隐藏 在 复杂 优化 中 的 回归 之前 ， 要 有 良好 的 代码 覆盖率 （   通过 单元测试 或 任何 其他 技术 ）
此 函数 会 在 调用 时 将 你 陷入 调试器 中
结果 字符串 可 被 直接 用作 属性 值 :
( 请 注意 忽略 编码 格式 错误 会 导致 数据 丢失 。 )   " ' replace ' "   会 在 出现 错误 数据 时 插入 一个 替换 标记   ( 例如   " ' ? ' " )
添加 来自 字符串 的 项 ， 将 字符串 解读 为 机器 值 的 数组 （ 相当于 使用   " fromfile ( ) "   方法 从文件 中 读取数据 ）
返回   " Makefile "   的 目录
在 所有 平台 上 ， 配置 值会 在   " sysconfig . get _ config _ var ( ) "   中以   " TZPATH "   键 的 形式 提供
想 了解 更 多 有关 静态方法 的 信息 ， 请参阅 标准 类型 层级 结构
如果   TOS   为 真值 ， 则 将 字节 码 计数器 的 值 设为   target   并 将   TOS   留在 栈顶
这 两个 小数 具有 相同 的 值 ， 唯一 真正 的 区别 是 第一个 是 以   10   为 基数 的 小数 表示法 ， 第二个 则 是   2   为 基数
Python   Packaging   Index   是 一个 开源 许可 的 软件包 公共 存储 库 ， 可 供 所有   Python   用户 使用
在   3.5   版 更改 :   The   " PyMemAllocator "   structure   was   renamed   to   " PyMemAllocatorEx "   and   a   new   " calloc "   field   was   added .
这些 类 的 形参 可能 还 需要 包括   " sys . stderr "   这样 的 外部 对象
确定   code   是否 属于   tableD.1   ( 带有 双向 属性   " R "   或   " AL "   的 字符 )
返回 第二个 类型 的 一个 实例 ， 该 返回 实例 和 第一个 参数 指向 同 一片 内存空间 :
最终 返回 一个 Python 对象 适合 于 返回 C 函数调用 给 Python 代码
CookieJar   和   FileCookieJar   对象
PEP   370 :   分 用户 的   site   packages   目录
如果 可以 被 确定 ， 则   mode   会 被   fileobj   的 模式 所 覆盖
为 给定 的   encoding   获取 一个 编码器 函数
现在 默认 采用   " select . EPOLL _ CLOEXEC "   标志
在   3.4   版 更改 :   添加 了 对 不可 搜索 文件 的 支持
当 在 编码数据 时 使用   " ' surrogateescape ' "   错误处理 方案 时 ， 此 代理 将 被   转换 回 相同 的 字节
" binascii "   模块 包含 很多 在 二进制 和 二进制 表示 的 各种 ASCII 码 之间 转换 的 方法
默认 的 字符 编码 格式 ： 在   Windows   上 为   " ' utf   8 ' " ， 其他 系统 上 则 为   " sys . getfilesystemencoding ( ) "   所 返回 的 值
当   " exec _ module ( ) "   可用 的 时候 ， 那么 则 提供 了 向 后 兼容 的 功能
发布 日期 :   2016   12   06
使用   C   或   C++   扩展   Python
更 多 信息 ， 请 参考 其他 图形用户界面 （ GUI ） 包 小节
我会 从   Python   的 一个 语言 特性 ，   编写 函数 式 风格 程序 的 重要 基石 开始 说起 ：   迭代 器
在   nargs   描述 中 查看 案例
没有 到 主机 的 路由
安装程序 将 此 位置 添加 到   shell   路径
path   指定 一个 要 提取 到 的 不同 目录
PEP   3120   使用   UTF   8   作为 默认 的 源 编码
返回 的 值 是 一个 整数 ， 通常 为   " logging . DEBUG " 、   " logging . INFO "   等等
它 适用 于 确定 是 哪个 屏幕 窗口 子集 包围 着 某个 鼠标 事件 的 位置
将 结果 输出 至 新 的 输出 窗口
如果 通过 调用   " field ( ) "   指定 字段 的 默认值 ， 则 该 字 段 的 类 属性 将 替换 为 指定 的   " default "   值
在 此 记录器 上 记录   " DEBUG "   级别 的 消息
如果 自动 换行 输出 结果 没有 任何 内容 ， 则 返回 空 列表
设置 垃圾 回收 阈值 （ 收集 频率 ）
以下 错误处理 方案 仅 适用 于 文本 编码   :
实现   " TOS . name   TOS1 " ， 其中   namei   是   name   在   " co _ names "   中 的 索引 号
3.5   新版 功能 .
3.9   版后 已 移除 :   Deprecated   in   favor   of   " status " .
与   " self . date ( ) . toordinal ( ) "   相同
bpo   31292 :   为 包含   " include "   指令 的 文件 修复   " setup . py   check   restructuredtext "
" functools . reduce ( func ,   iter ,   [ initial _ value ] ) "   持续 地 在 可 迭代 对象 的 所有 元素 上 执行 操作 ， 因此 它 不 能够 用 在 无限 的 可 迭代 对象 上
将   The   Vectorcall   Protocol   添加 到   Python / C   API
如果   backtick   为 真值 ， 零会用   " ' ` ' "   而 不是 空格 来 表示
向 外部 函数 传入 序列 形式参数 的 一个 例子 如下 :
" email "   电子邮件 与   MIME   处理 包
这些 名称 的 选择 完全 取决于 使用   logging   的 开发者
对于 所有 代码 点 都 低于 128 、 256 或 65536 的 字符串 ， 有 一些 特殊 情况 ； 否则 ， 代码 点 必须 低于   1114112 （ 这是 完整 的 Unicode 范围 ）
在   3.5   版 更改 :   添加   allow _ abbrev   参数
对   " basicConfig ( ) "   的 调用 应该 在   " debug ( ) "   ，   " info ( ) "   等 的 前面
当 此 模块 作为 脚本 运行 时 ， 会 使用   " main ( ) "   来 编译 命令行 中 指定 的 所有 文件
" decimal "   十进制 定点 和 浮点运算
增量 式 编解码器 可以 保持 状态
一个 传递 上下文 信息 和 日志 事件 信息 的 简单 办法 是 使用 类   " LoggerAdapter "
获取 或 以 其他 方式 使用   Python   的 条款 和 条件
如果   write _ through   为   " True " ， 对   " write ( ) "   的 调用 会 确保 不 被 缓冲 ：   在   " TextIOWrapper "   对象 上 写入 的 任何 数据 会 立即 交给 其 下层 的   buffer   来 处理
当 这些 字节 被 具有 不同 字节 顺序 的   CPU   读取 时 ， 则 必须 进行 字节 翻转
" cgitb "   用于   CGI   脚本 的 回溯 管理器
所有 其他   " configparser "   异常 的 基类
在   3.3   版 更改 :   现在 连接 对象 自身 可以 通过   " Connection . send ( ) "   和   " Connection . recv ( ) "   在 进程 之间 传递
使用 add _ reader ( ) 监听 FD ( 文件 描述符 ) 的 读取 事件 .
a . out   中 的   . lib   部分 已损坏
数组 属于 序列 类型 ， 其 行为 与 列表 非常 相似 ， 不同之处 在于 其中 存储 的 对象 类型 是 受限 的
如果 你 匹配 固定 字符串 或 单个 字符 类 ， 并且 你 没有 使用 任何   " re "   功能 ， 例如   " IGNORECASE "   标志 ， 那么 正则表达式 的 全部 功能 可能 不是 必需 的
指明 模块 所 使用 的 格式
其余 的 参数 必须 是 在 下面 范围 内 的 整数 ：
3.8   新版 功能 .
如果 重新分配 失败 ， 则   bytes   上 的 原 字节 串 对象 将 被 撤销 分配 ，   bytes   会 被 设为   " NULL " ， 同时 设置   " MemoryError "   并 返回   "   1 "
然而 ， Python 中 并 没有 告诉 解释器 这 一点
3.5   新版 功能 .
The   binary   and   text   transforms   provided   in   the   standard   library   are   detailed   in   二进制 转换   and   文字 转换 .
在 这里   " / "   和   "   "   是 可选 的
感知 型 对象 是 用来 表示 一个 没有 解释 空间 的 固定 时间 点
执行   command   中 的   Python   代码
协议 族 不受 支持
用 二进制 模式 写入 和 读取   bzip2   压缩文件 ：
LBYL   “ 先 查看 后 跳跃 ” 的 英文 缩写
如果   p   是 字典 对象 或者 字典 类型 的 子 类型 的 实例 ， 则 返回 真
以下 所有 变量 是 一些 简单 的 符号 索引 ， 用于 访问   " os . stat ( ) " ,   " os . fstat ( ) "   或   " os . lstat ( ) "   所 返回 的   10   条目 元组
继承 优于 序列化 、 反 序列化
dateutil   包 具有 扩展 时区 和 解析 支持 的 第三方 库
" pass "   语句 什么 也 不 做
声明 该   function   应当 被 用作   type   类型 对象 的 “ 归约 函数 ”
如果 没有   maps   被 指定 ， 就 提供 一个 默认 的 空 字典 ， 这样 一个 新链 至少 有 一个 映射
PEP   420   隐式 命名 空间 包
另 一个 优点 是 ， Python   中 的 字符串 被 视为 与 数字 一样 “ 基本 ”
程序运行 情况 如下 ：
3.2   新版 功能 .
" ClassVar "   并 不 改变   Python   运行 时 行为 ， 但 它 可以 被 用于 第三方 类型 检查 器
" __ loader __ "   属性 必须 被 设为 导入 系统 在 加载 模块 时 使用 的 加载 器 对象
硬 编码 的 值   " UTC "   和   " GMT "
将   n   设 为   10   以 使用 十分 位
对应 于   Python   中 的 单 目前 缀 取正 运算符 执行 取正 操作
在   Windows   下 ， 此参数 将 给出 原生 的   Windows   错误码
你 可以 尝试 以 多种 不 属性 位 组合 来 显示 文本 ， 但   curses   不 保证 所有 的 组合 都 是 有效 的 ， 或者 看上去 有 明显 不同
所有 示例 都 假定 使用 一台 大 端 机器 的 本机 字节 顺序 、 大小 和 对齐 方式
这个 结构 体有 三个 字 段 ：
返回 一个   " datetime . timezone "   对象 ， 该 对象 具有 以   offset   参数 表示 的 未命名 固定 时差
" C   Home " / " C   End "   跳转 到 文档 首 / 尾
Nuitka   是 一个 将   Python 编译成   C++   代码 的 新兴 编译器 ， 旨在 支持 完整 的 Python 语言
" spam . error "   异常 可以 在 扩展 模块 中 抛出 ， 通过   " PyErr _ SetString ( ) "   函数调用 ， 如下 ：
引发 一个 审计 事件   " ctypes . cdata " ， 附带 参数   " address "
这个 类 的 作用 是 比较 由 文本 行 组成 的 序列 ， 并 产生 可供 人 阅读 的 差异 或 增量 信息
为了 帮助 组织 模块 并 提供 名称 层次结构 ， Python   还 引入 了 包 的 概念
因此 ， 附带 关键字 参数 调用   " divmod ( ) "   将会 导致 报错 :
但是 ， 在 某些 情况 下 最好 强制 将 类型 格式化 为 一个 字符串 ， 覆盖 其 本身 的 格式化 定义
在 一行 中 首次 出现 的 分隔 子 字符串 会 被 视为 一个 分隔符
在   3.5   版 更改 :   Added   the   two   tuple   form   for   the   address   constructor   parameter .
在   3.9   版 更改 :   增加 了   errors   形参
传   " RawDescriptionHelpFormatter "   给   " formatter _ class   "   表示   description   和   epilog   已经 被 正确 的 格式化 了 ， 不能 在 命令行 中 被 自动 换行 :
还要 注意 更新   " os . environ "   将 导致 此 字典 失效
默认 的   " TZPATH "   未 通过 其他 方式 指定 时 可 在 编译 时 进行 配置
如果   " expand _ tabs "   为 假值 且   " replace _ whitespace "   为 真值 ， 每个 制表符 将 被 替换 为 单个 空格 ， 这 与 制表符 扩展 是 不 一样 的
此外 也 有 对   GNOME   的 绑定
由 服务器返回 的 状态 码
distutils   的 大多数 扩展 都 在 想要 修改 现有 命令 的   " setup . py "   脚本 中 编写 ； 其中 许多 只是 简单 地 在   " . py "   文件 以外 添加 了 一些 应当 被 拷贝到 包中 的 文件 后缀 以便 使用
输入 源 的 给出 形式 可以 为 字符串 、 文件 类 对象 或   " InputSource "   对象 ； 解析器 将 使用 此 函数 来 针对 它们 的   " parse ( ) "   方法 实现 多态   source   参数
名称   含义   " NUL "   " SOH "   标题 开始 ， 控制台 中断   " STX "   文本 开始   " ETX "   文本 结束   " EOT "   传输 结束   " ENQ "   查询 ， 附带   " ACK "   流量 控制   " ACK "   确认   " BEL "   蜂鸣器   " BS "   退格   " TAB "   制表符   " HT "   " TAB "   的 别名 ：   " 水平 制表符 ”   " LF "   换行   " NL "   " LF "   的 别名 ：   " 新 行 "   " VT "   垂直 制表符   " FF "   换页   " CR "   回车   " SO "   Shift   out ， 开始 替换 字符集   " SI "   Shift   in ， 恢复 默认 字符集   " DLE "   Data   link   escape ， 数据 链接 转义   " DC1 "   XON ， 用于 流程 控制   " DC2 "   Device   control   2 ， 块 模式 流程 控制   " DC3 "   XOFF ， 用于 流程 控制   " DC4 "   设备 控制 4   " NAK "   否定 确认   " SYN "   同步 空闲   " ETB "   末端 传输 块   " CAN "   取消   " EM "   媒体 结束   " SUB "   替换   " ESC "   退出   " FS "   文件 分隔符   " GS "   组 分隔符   " RS "   Record   separator ， 块 模式 终止符   " US "   单位 分隔符   " SP "   空格   " DEL "   删除
迭代 器 的 输出 有 两个 很 常见 的 使用 方式 ， 1 )   对 每 一个 元素 执行 操作 ， 2 )   选择 一个 符合条件 的 元素 子集
Branch   Call   Jump   ( BCJ )   过滤器 ：   " FILTER _ X86 "
这个 模块 定义 了 以下 函数 ：
一些 可靠 地 检测   KDE   的 方法 会 很 好 ； 仅 检查   " KDEDIR "   变量 是 不够 的
" IOBase "   也 是 一个 上下文 管理器 ， 因此 支持   " with "   语句
回到 参数 的 否定
" random "   生成 伪 随机数
返回 一个 新 的 实例 方法 对象 ，   func   应为 任意 可 调用 对象 ，   func   将 在 实例 方法 被 调用 时 作为 函数 被 调用
3.7   新版 功能 .
adjustable   ：   如果 时钟 可以 自动 更改 （ 例如 通过 NTP 守护 程序 ） 或 由 系统管理员 手动 更改 ， 则 为   " True "   ， 否则 为   " False "
如果 是 字符串 ， 那么 该 字符串 将 被 解析 为 一系列   Python   语句 并 执行 （ 除非 发生 语法错误 ）
该 实例 将 被 用作 此 模块 中 函数 的 全局 状态 ， 并且 还 将 在 迭代 期间 被 返回 使用
此 方法 适用 于 找出 给定 浮点数 的 有理数 近似值 ：
打包 固定 长度 字符串   s
使用 这些 函数 ， 上述 示例 变得 更 简单 ， 更 快捷 ：
除非 明确 注释 ， 这些 函数 支持   " int "   ，   " float "   ，   " Decimal "   和   " Fraction "
" execfile ( ) "   的 实 参会 使用   " open ( ) " ，   " compile ( ) "   和   " exec ( ) "   包装
一些 用来 从   timedelta   对象 中 提取 字段 的 宏
对于 根 日志 记录器 以外 的 日志 记录器 ， 还 需要 某些 附加 信息
可以 通过   " usage   "   关键字 参数 覆盖 这一 默认 消息 ：
自从 编写 这个 文档 开始 ， 一些 语义 已经 发生 改变 了 （ 比如 基于   " sys . modules "   中   " None "   的 重定向 ）
" StreamWriter "   实例 的 构造 器
操作 名称 的 序列 ， 可 使用 字节 码来 索引
如果 您 正在 尝试 为 DOS 命令 构建 路径名 ， 请 尝试 以下 示例
另 参见   RawTurtle / Turtle   方法   " speed ( ) "
添加 了   " pgettext ( ) "   及其 变化 形式
如果 你 使用   " addLevelName ( ) "   将 级别 关联 到 名称 则 会 返回 你 为   level   所 关联 的 名称
" copy "   浅层   ( shallow )   和 深层   ( deep )   复制 操作
在   " f   attrgetter ( ' name ' ) "   之后 ， 调用   " f ( b ) "   将 返回   " b . name "
如果   " Tarinfo "   对象 为 普通 文件 则 返回   " True "
如果   compact   为 假值 （ 默认 ） 则 长 序列 的 每一项 将 被 格式化 为 单独 的 行
Python   3.9   已 切换 到   PEG   解析器   ( 参见   PEP   617   ) ， Python   3.10   可以 会 包含   lib2to3   的   LL ( 1 )   解析器 所 不能 解析 的 新 语法
如果 提供 了 可选 参数   header   且 为 真值 ， 下划线 将 被 解码 为 空格
3.2   新版 功能 .
所有者 具有 读取 权限
函数   " spam . system ( ) "   不会 直接 调用 C 库函数   " system ( ) "   ， 但 一个 函数   " PySpam _ System ( ) "   会 负责 调用 ， 当然 现实 中会 更 复杂 些 ( 例如 添加   " spam "   到 每个 命令 )
返回 当前 执行 帧 中 内置 函数 的 字典 ， 如果 当前 没有 帧 正在 执行 ， 则 返回 线程 状态 的 解释器
大多数 编辑器 和 集成 开发 环境 支持 语法 高亮 ， 调试 工具 和   PEP   8   检查
Cython   和   CFFI   库 提供 了 对于   Python   的   C   API   的 抽象
对于 整数 和 指针 类型 ， 它 是 一个 整数 ， 对于 字符 类型 ， 它 是 一个 单 字符 字符串 对象 或 字符串 ， 对于 字符 指针 类型 ，   它 是 一个   Python   字节 串 对象 或 字符串