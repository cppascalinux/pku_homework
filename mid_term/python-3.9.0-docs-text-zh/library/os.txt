"os" --- 多种操作系统接口
*************************

**源代码：** Lib/os.py

======================================================================

本模块提供了一种使用与操作系统相关的功能的便捷式途径。 如果你只是想读
写一个文件，请参阅 "open()"，如果你想操作文件路径，请参阅 "os.path" 模
块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 "fileinput"
模块。 为了创建临时文件和目录，请参阅 "tempfile" 模块，对于高级文件和
目录处理，请参阅 "shutil" 模块。

关于这些函数的可用性的说明：

* Python中所有依赖于操作系统的内置模块的设计都是这样，只要不同的操作系
  统某一相同的功能可用，它就使用相同的接口。例如，函数 "os.stat(path)"
  以相同的格式返回关于 *path* 的状态信息（该格式源于 POSIX 接口）。

* 特定于某一操作系统的扩展通过操作 "os" 模块也是可用的，但是使用它们当
  然是对可移植性的一种威胁。

* 所有接受路径或文件名的函数都同时支持字节串和字符串对象，并在返回路径
  或文件名时使用相应类型的对象作为结果。

* 在 VxWorks 系统上，os.fork, os.execv 和 os.spawn*p* 不被支持。

注解:

  如果使用无效或无法访问的文件名与路径，或者其他类型正确但操作系统不接
  受的参数，此模块的所有函数都抛出 "OSError" （或者它的子类）。

exception os.error

   内建的 "OSError" 异常的一个别名。

os.name

   导入的依赖特定操作系统的模块的名称。以下名称目前已注册: "'posix'",
   "'nt'", "'java'".

   参见:

     "sys.platform" 有更详细的描述. "os.uname()" 只给出系统提供的版本
     信息。

     "platform" 模块对系统的标识有更详细的检查。


文件名，命令行参数，以及环境变量。
==================================

在 Python 中，使用字符串类型表示文件名、命令行参数和环境变量。 在某些
系统上，在将这些字符串传递给操作系统之前，必须将这些字符串解码为字节。
Python 使用文件系统编码来执行此转换（请参阅
"sys.getfilesystemencoding()" ）。

在 3.1 版更改: 在某些系统上，使用文件系统编码进行转换可能会失败。 在这
种情况下，Python 会使用 代理转义编码错误处理器，这意味着在解码时，不可
解码的字节被 Unicode 字符 U+DCxx 替换，并且这些字节在编码时再次转换为
原始字节。

文件系统编码必须保证成功解码小于 128 的所有字节。如果文件系统编码无法
提供此保证， API 函数可能会引发 UnicodeErrors 。


进程参数
========

这些函数和数据项提供了操作当前进程和用户的信息。

os.ctermid()

   返回与进程控制终端对应的文件名。

   可用性: Unix。

os.environ

   一个表示字符串环境的 *mapping* 对象。 例如，"environ['HOME']" 是你
   的主目录（在某些平台上）的路径名，相当于 C 中的 "getenv("HOME")"。

   这个映射是在第一次导入 "os" 模块时捕获的，通常作为 Python 启动时处
   理 "site.py" 的一部分。除了通过直接修改 "os.environ" 之外，在此之后
   对环境所做的更改不会反映在 "os.environ" 中。

   该映射除了可以用于查询环境外，还能用于修改环境。当该映射被修改时，
   将自动调用 "putenv()"。

   在Unix系统上，键和值会使用 "sys.getfilesystemencoding()" 和
   "'surrogateescape'" 的错误处理。如果你想使用其他的编码，使用
   "environb"。

   注解:

     直接调用 "putenv()" 并不会影响  "os.environ"，所以推荐直接修改
     "os.environ"。

   注解:

     在某些平台上，包括 FreeBSD 和 Mac OS X，设置 "environ" 可能导致内
     存泄露。参阅 "putenv()" 的系统文档。

   可以删除映射中的元素来删除对应的环境变量。当从 "os.environ" 删除元
   素时，以及调用 "pop()" 或 "clear()" 之一时，将自动调用 "unsetenv()"
   。

   在 3.9 版更改: 已更新并支持了 **PEP 584** 的合并 ("|") 和更新
   ("|=") 运算符。

os.environb

   字节版本的 "environ": 一个以字节串表示环境的 *mapping* 对象。
   "environ" 和 "environb" 是同步的（修改 "environb" 会更新 "environ"
   ，反之亦然）。

   只有在 "supports_bytes_environ" 为 "True" 的时候 "environb" 才是可
   用的。

   3.2 新版功能.

   在 3.9 版更改: 已更新并支持了 **PEP 584** 的合并 ("|") 和更新
   ("|=") 运算符。

os.chdir(path)
os.fchdir(fd)
os.getcwd()

   以上函数请参阅 文件和目录 。

os.fsencode(filename)

   将 *路径类* *filename* 编码为文件系统编码，使用 "'surrogateescape'"
   错误回调方法，在 Windows 上会使用 "'strict'"，"bytes" 类型则原样返
   回。

   "fsdecode()" 是此函数的逆向函数。

   3.2 新版功能.

   在 3.6 版更改: 增加对实现了 "os.PathLike" 接口的对象的支持。

os.fsdecode(filename)

   将 *路径类* *filename* 从文件系统编码方式解码，编码方式应使用的是
   "'surrogateescape'" 错误回调方法，在 Windows 上应使用的是
   "'strict'" 方法。"str" 字符串则原样返回。

   "fsencode()" 是此函数的逆向函数。

   3.2 新版功能.

   在 3.6 版更改: 增加对实现了 "os.PathLike" 接口的对象的支持。

os.fspath(path)

   返回路径的文件系统表示。

   如果传入的是 "str" 或 "bytes" 类型的字符串，将原样返回。否则
   "__fspath__()" 将被调用，如果得到的是一个 "str" 或 "bytes" 类型的对
   象，那就返回这个值。其他所有情况则会抛出 "TypeError"  异常。

   3.6 新版功能.

class os.PathLike

   某些对象用于表示文件系统中的路径（如 "pathlib.PurePath" 对象），本
   类是这些对象的 *抽象基类*。

   3.6 新版功能.

   abstractmethod __fspath__()

      返回当前对象的文件系统表示。

      这个方法只应该返回一个 "str" 字符串或 "bytes" 字节串，请优先选择
      "str" 字符串。

os.getenv(key, default=None)

   如果存在，返回环境变量 *key* 的值，否则返回 *default*。 *key* ，
   *default* 和返回值均为 str 字符串类型。

   在Unix系统上，键和值会使用 "sys.getfilesystemencoding()" 和
   ``'surrogateescape'`` 错误处理进行解码。如果你想使用其他的编码，使
   用 "os.getenvb()"。

   可用性: 大部分的Unix系统，Windows。

os.getenvb(key, default=None)

   如果存在环境变量 *key* 那么返回其值，否则返回 *default*。 *key* ，
   *default* 和返回值均为bytes字节串类型。

   "getenvb()" 仅在 "supports_bytes_environ" 为 "True" 时可用。

   可用性: 大部分的Unix系统。

   3.2 新版功能.

os.get_exec_path(env=None)

   返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相
   似。指定的 *env* 应为用于搜索 PATH 的环境变量字典。默认情况下，当
   *env* 为 "None" 时，将会使用 "environ" 。

   3.2 新版功能.

os.getegid()

   返回当前进程的有效组ID。对应当前进程执行文件的 "set id" 位。

   可用性: Unix。

os.geteuid()

   返回当前进程的有效用户ID。

   可用性: Unix。

os.getgid()

   返回当前进程的实际组ID。

   可用性: Unix。

os.getgrouplist(user, group)

   返回该用户所在的组 ID 列表。可能 *group* 参数没有在返回的列表中，实
   际上用户应该也是属于该 *group*。*group* 参数一般可以从储存账户信息
   的密码记录文件中找到。

   可用性: Unix。

   3.3 新版功能.

os.getgroups()

   返回当前进程对应的组ID列表

   可用性: Unix。

   注解:

     在Mac OS X系统中，"getgroups()" 会和其他 Unix 平台有些不同。如果
     Python 解释器是在 "10.5" 或更早版本中部署，"getgroups()" 返回当前
     用户进程相关的有效组ID列表。 该列表长度由于系统预设的接口限制，最
     长为 16。 而且在适当的权限下，返回结果还会因 "getgroups()" 而发生
     变化；如果 Python 解释器是在 "10.5" 以上版本中部署，"getgroups()"
     返回进程所属有效用户 ID 所对应的用户的组 ID 列表，组用户列表可能
     因为进程的生存周期而发生变动，而且也不会因为 "setgroups()" 的调用
     而发生，返回的组用户列表长度也没有长度 16 的限制。在部署中，
     Python 解释器用到的变量 "MACOSX_DEPLOYMENT_TARGET" 可以用
     "sysconfig.get_config_var()"。

os.getlogin()

   返回通过控制终端进程进行登录的用户名。在多数情况下，使用
   "getpass.getuser()" 会更有效，因为后者会通过检查环境变量 "LOGNAME"
   或 "USERNAME" 来查找用户，再由 "pwd.getpwuid(os.getuid())[0]" 来获
   取当前用户 ID 的登录名。

   可用性: Unix, Windows。

os.getpgid(pid)

   根据进程id *pid* 返回进程的组 ID 列表。如果 *pid* 为 0，则返回当前
   进程的进程组 ID 列表

   可用性: Unix。

os.getpgrp()

   返回当时进程组的ID

   可用性: Unix。

os.getpid()

   返回当前进程ID

os.getppid()

   返回父进程ID。当父进程已经结束，在Unix中返回的ID是初始进程(1)中的一
   个，在Windows中仍然是同一个进程ID，该进程ID有可能已经被进行进程所占
   用。

   可用性: Unix, Windows。

   在 3.2 版更改: 添加WIndows的支持。

os.getpriority(which, who)

   获取程序调度优先级。*which* 参数值可以是 "PRIO_PROCESS"，
   "PRIO_PGRP"，或 "PRIO_USER" 中的一个，*who* 是相对于 *which*
   ("PRIO_PROCESS" 的进程标识符，"PRIO_PGRP" 的进程组标识符和
   "PRIO_USER" 的用户ID)。当 *who* 为 0 时（分别）表示调用的进程，调用
   进程的进程组或调用进程所属的真实用户 ID。

   可用性: Unix。

   3.3 新版功能.

os.PRIO_PROCESS
os.PRIO_PGRP
os.PRIO_USER

   函数 "getpriority()" 和 "setpriority()" 的参数。

   可用性: Unix。

   3.3 新版功能.

os.getresuid()

   返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实
   用户ID，有效用户ID和甲暂存用户ID。

   可用性: Unix。

   3.2 新版功能.

os.getresgid()

   返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实
   组ID，有效组ID和暂存组ID。

   可用性: Unix。

   3.2 新版功能.

os.getuid()

   返回当前进程的真实用户ID。

   可用性: Unix。

os.initgroups(username, gid)

   调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，
   包括指定的组ID。

   可用性: Unix。

   3.2 新版功能.

os.putenv(key, value)

   将名为 *key* 的环境变量值设置为 *value*。该变量名修改会影响由
   "os.system()"， "popen()" ，"fork()" 和 "execv()" 发起的子进程。

   "os.environ" 中的参数赋值会自动转换为对 "putenv()" 的调用。不过
   "putenv()" 的调用不会更新 "os.environ"，因此最好使用 "os.environ"
   对变量赋值。

   注解:

     在某些平台上，包括 FreeBSD 和 Mac OS X，设置 "environ" 可能导致内
     存泄露。参阅 "putenv()" 的系统文档。

   引发一个 审计事件 "os.putenv"，附带参数 "key", "value"。

   在 3.9 版更改: 该函数现在总是可用。

os.setegid(egid)

   设置当前进程的有效组ID。

   可用性: Unix。

os.seteuid(euid)

   设置当前进程的有效用户ID。

   可用性: Unix。

os.setgid(gid)

   设置当前进程的组ID。

   可用性: Unix。

os.setgroups(groups)

   将 *group* 参数值设置为与当进程相关联的附加组ID列表。*group* 参数必
   须为一个序列，每个元素应为每个组的数字ID。该操作通常只适用于超级用
   户。

   可用性: Unix。

   注解:

     在 Mac OS X 中，*groups* 的长度不能超过系统定义的最大有效组 ID 个
     数，一般为 16。 如果它没有返回与调用 setgroups() 所设置的相同的组
     列表，请参阅 "getgroups()" 的文档。

os.setpgrp()

   根据已实现的版本（如果有）来调用系统 "setpgrp()" 或 "setpgrp(0, 0)"
   。相关说明，请参考 Unix 手册。

   可用性: Unix。

os.setpgid(pid, pgrp)

   使用系统调用 "setpgid()"，将 *pid* 对应进程的组ID设置为 *pgrp*。相
   关说明，请参考 Unix 手册。

   可用性: Unix。

os.setpriority(which, who, priority)

   设置程序调度优先级。 *which* 的值为 "PRIO_PROCESS", "PRIO_PGRP" 或
   "PRIO_USER" 之一，而 *who* 会相对于 *which* ("PRIO_PROCESS" 的进程
   标识符, "PRIO_PGRP" 的进程组标识符和 "PRIO_USER" 的用户 ID) 被解析
   。 *who* 值为零 (分别) 表示调用进程，调用进程的进程组或调用进程的真
   实用户 ID。 *priority* 是范围在 -20 至 19 的值。 默认优先级为 0；较
   小的优先级数值会更优先被调度。

   可用性: Unix。

   3.3 新版功能.

os.setregid(rgid, egid)

   设置当前进程的真实和有效组ID。

   可用性: Unix。

os.setresgid(rgid, egid, sgid)

   设置当前进程的真实，有效和暂存组ID。

   可用性: Unix。

   3.2 新版功能.

os.setresuid(ruid, euid, suid)

   设置当前进程的真实，有效和暂存用户ID。

   可用性: Unix。

   3.2 新版功能.

os.setreuid(ruid, euid)

   设置当前进程的真实和有效用户ID。

   可用性: Unix。

os.getsid(pid)

   调用系统调用 "getsid()"。相关说明，请参考 Unix 手册。

   可用性: Unix。

os.setsid()

   使用系统调用 "getsid()"。相关说明，请参考 Unix 手册。

   可用性: Unix。

os.setuid(uid)

   设置当前进程的用户ID。

   可用性: Unix。

os.strerror(code)

   根据 *code* 中的错误码返回错误消息。 在某些平台上当给出未知错误码时
   "strerror()" 将返回 "NULL" 并会引发 "ValueError"。

os.supports_bytes_environ

   如果操作系统上原生环境类型是字节型则为 "True" (例如在 Windows 上为
   "False")。

   3.2 新版功能.

os.umask(mask)

   设定当前数值掩码并返回之前的掩码。

os.uname()

   返回当前操作系统的识别信息。返回值是一个有5个属性的对象：

   * "sysname" - 操作系统名

   * "nodename" - 机器在网络上的名称（需要先设定）

   * "release" - 操作系统发行信息

   * "version" - 操作系统版本信息

   * "machine" - 硬件标识符

   为了向后兼容，该对象也是可迭代的，像是一个按照 "sysname"，
   "nodename"，"release"，"version"，和 "machine" 顺序组成的元组。

   有些系统会将 "nodename" 截短为 8 个字符或截短至前缀部分；获取主机名
   的一个更好方式是 "socket.gethostname()"  或甚至可以用
   "socket.gethostbyaddr(socket.gethostname())"。

   可用性: 较新的 Unix 版本。

   在 3.3 版更改: 返回结果的类型由元组变成一个类似元组的对象，同时具有
   命名的属性。

os.unsetenv(key)

   取消设置（删除）名为 *key* 的环境变量。变量名的改变会影响由
   "os.system()"，"popen()"，"fork()" 和 "execv()" 触发的子进程。

   删除在 "os.environ" 中的变量会自动转换为对 "unsetenv()" 的调用。但
   是 "unsetenv()" 不能更新 "os.environ"，因此最好直接删除
   "os.environ" 中的变量。

   引发一个 审计事件 "os.unsetenv"，附带参数 "key"。

   在 3.9 版更改: 该函数现在总是可用，并且在 Windows 上也可用。


创建文件对象
============

这些函数创建新的 *file objects* 。（参见 "open()" 以获取打开文件描述符
的相关信息。）

os.fdopen(fd, *args, **kwargs)

   返回打开文件描述符 *fd* 对应文件的对象。类似内建 "open()" 函数，二
   者接受同样的参数。不同之处在于 "fdopen()" 第一个参数应该为整数。


文件描述符操作
==============

这些函数对文件描述符所引用的 I/O 流进行操作。

文件描述符是一些小的整数，对应于当前进程所打开的文件。例如，标准输入的
文件描述符通常是0，标准输出是1，标准错误是2。之后被进程打开的文件的文
件描述符会被依次指定为3，4，5等。“文件描述符”这个词有点误导性，在 Unix
平台中套接字和管道也被文件描述符所引用。

当需要时，可以用 "fileno()" 可以获得 *file object* 所对应的文件描述符
。需要注意的是，直接使用文件描述符会绕过文件对象的方法，会忽略如数据内
部缓冲等情况。

os.close(fd)

   关闭文件描述符 *fd*。

   注解:

     该功能适用于低级 I/O 操作，必须用于 "os.open()" 或 "pipe()" 返回
     的文件描述符。若要关闭由内建函数 "open()"、"popen()" 或
     "fdopen()" 返回的 "文件对象"，则应使用其相应的 "close()" 方法。

os.closerange(fd_low, fd_high)

   关闭从 *fd_low* （包括）到 *fd_high* （排除）间的文件描述符，并忽略
   错误。类似（但快于）:

      for fd in range(fd_low, fd_high):
          try:
              os.close(fd)
          except OSError:
              pass

os.copy_file_range(src, dst, count, offset_src=None, offset_dst=None)

   从文件描述符 *src* 复制 *count* 字节，从偏移量 *offset_src* 开始读
   取，到文件描述符 *dst*，从偏移量 *offset_dst* 开始写入。如果
   *offset_src* 为 None，则 *src* 将从当前位置开始读取；*offset_dst*
   同理。*src* 和 *dst* 指向的文件必须处于相同的文件系统，否则将会抛出
   一个 "errno" 被设为 "errno.EXDEV" 的 "OSError" 。

   此复制的完成没有额外的从内核到用户空间再回到内核的数据转移花费。另
   外，一些文件系统可能实现额外的优化。完成复制就如同打开两个二进制文
   件一样。

   返回值是复制的字节的数目。这可能低于需求的数目。

   Availability: Linux kernel >= 4.5 或 glibc >= 2.27。

   3.8 新版功能.

os.device_encoding(fd)

   如果连接到终端，则返回一个与 *fd* 关联的设备描述字符，否则返回
   "None"。

os.dup(fd)

   返回一个文件描述符 *fd* 的副本。该文件描述符的副本是 不可继承的。

   在 Windows 中，当复制一个标准流（0: stdin, 1: stdout, 2: stderr）时
   ，新的文件描述符是 可继承的。

   在 3.4 版更改: 新的文件描述符现在是不可继承的。

os.dup2(fd, fd2, inheritable=True)

   把文件描述符 *fd* 复制为 *fd2*，必要时先关闭后者。返回 *fd2*。新的
   文件描述符默认是 可继承的，除非在 *inheritable* 为 "False" 时，是不
   可继承的。

   在 3.4 版更改: 添加可选参数 *inheritable*。

   在 3.7 版更改: 成功时返回 *fd2*，以过去的版本中，总是返回 "None"。

os.fchmod(fd, mode)

   将 *fd* 指定文件的权限状态修改为 *mode*。可以参考 "chmod()" 中列出
   *mode* 的可用值。从Python 3.3开始，这相当于 "os.chmod(fd, mode)"。

   引发一个 审计事件 "os.chmod"，附带参数 "path"、"mode"、"dir_fd"。

   可用性: Unix。

os.fchown(fd, uid, gid)

   分别将 *fd* 指定文件的所有者和组 ID 修改为 *uid* 和 *gid* 的值。若
   不想变更其中的某个 ID，可将相应值设为 -1。参考  "chown()"。从
   Python 3.3 开始，这相当于 "os.chown(fd, uid, gid)"。

   引发一个 审计事件 "os.chown"，附带参数 "path"、"uid"、"gid"、
   "dir_fd"。

   可用性: Unix。

os.fdatasync(fd)

   强制将文件描述符 *fd* 指定文件写入磁盘。不强制更新元数据。

   可用性: Unix。

   注解:

     该功能在 MacOS 中不可用。

os.fpathconf(fd, name)

   返回与打开的文件有关的系统配置信息。*name* 指定要查找的配置名称，它
   可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（
   POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。
   当前操作系统已定义的名称在 "pathconf_names" 字典中给出。对于未包含
   在该映射中的配置名称，也可以传递一个整数作为 *name*。

   如果 *name* 是一个字符串且不是已定义的名称，将抛出 "ValueError" 异
   常。如果当前系统不支持 *name* 指定的配置名称，即使该名称存在于
   "pathconf_names"，也会抛出 "OSError" 异常，错误码为 "errno.EINVAL"
   。

   从 Python 3.3 起，此功能等价于 "os.pathconf(fd, name)"。

   可用性: Unix。

os.fstat(fd)

   获取文件描述符 *fd* 的状态. 返回一个 "stat_result" 对象。

   从 Python 3.3 起，此功能等价于 "os.stat(fd)"。

   参见: "stat()" 函数。

os.fstatvfs(fd)

   返回文件系统的信息，该文件系统是文件描述符 *fd* 指向的文件所在的文
   件系统，与 "statvfs()" 一样。从 Python 3.3 开始，它等效于
   "os.statvfs(fd)"。

   可用性: Unix。

os.fsync(fd)

   强制将文件描述符 *fd* 指向的文件写入磁盘。在 Unix，这将调用原生
   "fsync()" 函数；在 Windows，则是 MS "_commit()" 函数。

   如果要写入的是缓冲区内的 Python *文件对象* *f*，请先执行
   "f.flush()"，然后执行 "os.fsync(f.fileno())"，以确保与 *f* 关联的所
   有内部缓冲区都写入磁盘。

   可用性: Unix, Windows。

os.ftruncate(fd, length)

   截断文件描述符 *fd* 指向的文件，以使其最大为 *length* 字节。从
   Python 3.3 开始，它等效于 "os.truncate(fd, length)"。

   引发一个 审计事件 "os.truncate"，附带参数 "fd", "length"。

   可用性: Unix, Windows。

   在 3.5 版更改: 添加了 Windows 支持

os.get_blocking(fd)

   获取文件描述符的阻塞模式：如果设置了 "O_NONBLOCK" 标志位，返回
   "False"，如果该标志位被清除，返回 "True"。

   参见 "set_blocking()" 和 "socket.socket.setblocking()"。

   可用性: Unix。

   3.5 新版功能.

os.isatty(fd)

   如果文件描述符 *fd* 打开且已连接至 tty 设备（或类 tty 设备），返回
   "True"，否则返回 "False"。

os.lockf(fd, cmd, len)

   在打开的文件描述符上，使用、测试或删除 POSIX 锁。*fd* 是一个打开的
   文件描述符。*cmd* 指定要进行的操作，它们是 "F_LOCK"、"F_TLOCK"、
   "F_ULOCK" 或 "F_TEST" 中的一个。*len* 指定哪部分文件需要锁定。

   引发一个 审计事件 "os.lockf"，附带参数 "fd"、"cmd"、"len"。

   可用性: Unix。

   3.3 新版功能.

os.F_LOCK
os.F_TLOCK
os.F_ULOCK
os.F_TEST

   标志位，用于指定 "lockf()" 进行哪一种操作。

   可用性: Unix。

   3.3 新版功能.

os.lseek(fd, pos, how)

   将文件描述符 *fd* 的当前位置设置为 *pos*，位置的计算方式 *how* 如下
   ：设置为 "SEEK_SET" 或 "0" 表示从文件开头计算，设置为 "SEEK_CUR" 或
   "1" 表示从文件当前位置计算，设置为 "SEEK_END" 或 "2" 表示文件末尾计
   算。返回新指针位置，这个位置是从文件开头计算的，单位是字节。

os.SEEK_SET
os.SEEK_CUR
os.SEEK_END

   "lseek()" 函数的参数，它们的值分别为 0、1 和 2。

   3.3 新版功能: 某些操作系统可能支持其他值，例如 "os.SEEK_HOLE" 或
   "os.SEEK_DATA"。

os.open(path, flags, mode=0o777, *, dir_fd=None)

   打开文件 *path*，根据 *flags* 设置各种标志位，并根据 *mode* 设置其
   权限状态。当计算 *mode* 时，会首先根据当前 umask 值将部分权限去除。
   本方法返回新文件的描述符。新的文件描述符是 不可继承 的。

   有关 flag 和 mode 取值的说明，请参见 C 运行时文档。标志位常量（如
   "O_RDONLY" 和 "O_WRONLY"）在 "os" 模块中定义。特别地，在 Windows 上
   需要添加 "O_BINARY" 才能以二进制模式打开文件。

   本函数带有 *dir_fd* 参数，支持 基于目录描述符的相对路径。

   引发一个 审计事件 "open"，附带参数 "path"、"mode"、"flags"。

   在 3.4 版更改: 新的文件描述符现在是不可继承的。

   注解:

     本函数适用于底层的 I/O。常规用途请使用内置函数 "open()"，该函数的
     "read()" 和 "write()" 方法（及其他方法）会返回 *文件对象*。要将文
     件描述符包装在文件对象中，请使用 "fdopen()"。

   3.3 新版功能: *dir_fd* 参数。

   在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函
   数现在会重试系统调用，而不是触发 "InterruptedError" 异常 (原因详见
   **PEP 475**)。

   在 3.6 版更改: 接受一个 *类路径对象*。

以下常量是 "open()" 函数 *flags* 参数的选项。可以用按位或运算符 "|" 将
它们组合使用。部分常量并非在所有平台上都可用。有关其可用性和用法的说明
，请参阅 *open(2)* 手册（Unix 上）或 MSDN （Windows 上）。

os.O_RDONLY
os.O_WRONLY
os.O_RDWR
os.O_APPEND
os.O_CREAT
os.O_EXCL
os.O_TRUNC

   上述常量在 Unix 和 Windows 上均可用。

os.O_DSYNC
os.O_RSYNC
os.O_SYNC
os.O_NDELAY
os.O_NONBLOCK
os.O_NOCTTY
os.O_CLOEXEC

   这个常数仅在 Unix 系统中可用。

   在 3.3 版更改: 增加 "O_CLOEXEC" 常量。

os.O_BINARY
os.O_NOINHERIT
os.O_SHORT_LIVED
os.O_TEMPORARY
os.O_RANDOM
os.O_SEQUENTIAL
os.O_TEXT

   这个常数仅在 Windows 系统中可用。

os.O_ASYNC
os.O_DIRECT
os.O_DIRECTORY
os.O_NOFOLLOW
os.O_NOATIME
os.O_PATH
os.O_TMPFILE
os.O_SHLOCK
os.O_EXLOCK

   上述常量是扩展常量，如果 C 库未定义它们，则不存在。

   在 3.4 版更改: 在支持的系统上增加 "O_PATH"。增加 "O_TMPFILE"，仅在
   Linux Kernel 3.11 或更高版本可用。

os.openpty()

   打开一对新的伪终端，返回一对文件描述符 "（主，从）"，分别为 pty 和
   tty。新的文件描述符是 不可继承 的。对于（稍微）轻量一些的方法，请使
   用 "pty" 模块。

   可用性: 某些 Unix。

   在 3.4 版更改: 新的文件描述符不再可继承。

os.pipe()

   创建一个管道，返回一对分别用于读取和写入的文件描述符 "(r, w)"。新的
   文件描述符是 不可继承 的。

   可用性: Unix, Windows。

   在 3.4 版更改: 新的文件描述符不再可继承。

os.pipe2(flags)

   创建带有 *flags* 标志位的管道。可通过对以下一个或多个值进行“或”运算
   来构造这些 *flags*："O_NONBLOCK"、"O_CLOEXEC"。返回一对分别用于读取
   和写入的文件描述符 "(r, w)"。

   可用性: 某些 Unix。

   3.3 新版功能.

os.posix_fallocate(fd, offset, len)

   确保为 *fd* 指向的文件分配了足够的磁盘空间，该空间从偏移量 *offset*
   开始，到 *len* 字节为止。

   可用性: Unix。

   3.3 新版功能.

os.posix_fadvise(fd, offset, len, advice)

   声明即将以特定模式访问数据，使内核可以提前进行优化。数据范围是从
   *fd* 所指向文件的 *offset* 开始，持续 *len* 个字节。*advice* 的取值
   是如下之一："POSIX_FADV_NORMAL", "POSIX_FADV_SEQUENTIAL",
   "POSIX_FADV_RANDOM", "POSIX_FADV_NOREUSE", "POSIX_FADV_WILLNEED" 或
   "POSIX_FADV_DONTNEED"。

   可用性: Unix。

   3.3 新版功能.

os.POSIX_FADV_NORMAL
os.POSIX_FADV_SEQUENTIAL
os.POSIX_FADV_RANDOM
os.POSIX_FADV_NOREUSE
os.POSIX_FADV_WILLNEED
os.POSIX_FADV_DONTNEED

   用于 "posix_fadvise()" 的 *advice* 参数的标志位，指定可能使用的访问
   模式。

   可用性: Unix。

   3.3 新版功能.

os.pread(fd, n, offset)

   从文件描述符 *fd* 所指向文件的偏移位置 *offset* 开始，读取至多 *n*
   个字节，而保持文件偏移量不变。

   返回所读取字节的字节串 (bytestring)。如果到达了 *fd* 指向的文件末尾
   ，则返回空字节对象。

   可用性: Unix。

   3.3 新版功能.

os.preadv(fd, buffers, offset, flags=0)

   从文件描述符 *fd* 所指向文件的偏移位置 *offset* 开始，将数据读取至
   可变 *字节类对象* 缓冲区 *buffers* 中，保持文件偏移量不变。将数据依
   次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来
   保存其余数据。

   flags 参数可以由零个或多个标志位进行按位或运算来得到：

   * "RWF_HIPRI"

   * "RWF_NOWAIT"

   返回实际读取的字节总数，该总数可以小于所有对象的总容量。

   操作系统可能对允许使用的缓冲区数量有限制（使用 "sysconf()" 获取
   "'SC_IOV_MAX'" 值）。

   本方法结合了 "os.readv()" 和 "os.pread()" 的功能。

   可用性：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD
   2.7 或更高版本，AIX 7.1 或更高版本。使用标志位需要 Linux 4.6 或更高
   版本。

   3.7 新版功能.

os.RWF_NOWAIT

   不要等待无法立即获得的数据。如果指定了此标志，那么当需要从后备存储
   器中读取数据，或等待文件锁时，系统调用将立即返回。

   如果成功读取数据，则返回读取的字节数。如果未读取到数据，则返回 "-1"
   ，并将错误码 errno 置为 "errno.EAGAIN"。

   可用性：Linux 4.14 或更高版本。

   3.7 新版功能.

os.RWF_HIPRI

   高优先级读/写。允许基于块的文件系统对设备进行轮询，这样可以降低延迟
   ，但可能会占用更多资源。

   目前在 Linux 上，此功能仅在使用 "O_DIRECT" 标志打开的文件描述符上可
   用。

   可用性：Linux 4.6 或更高版本。

   3.7 新版功能.

os.pwrite(fd, str, offset)

   将 *str* 中的字节串 (bytestring) 写入文件描述符 *fd* 的偏移位置
   *offset* 处，保持文件偏移量不变。

   返回实际写入的字节数。

   可用性: Unix。

   3.3 新版功能.

os.pwritev(fd, buffers, offset, flags=0)

   将缓冲区 *buffers* 的内容写入文件描述符 *fd* 的偏移位置 *offset* 处
   ，保持文件偏移量不变。缓冲区 *buffers* 必须是由 *字节类对象* 组成的
   序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第
   二个缓冲区，照此继续。

   flags 参数可以由零个或多个标志位进行按位或运算来得到：

   * "RWF_DSYNC"

   * "RWF_SYNC"

   返回实际写入的字节总数。

   操作系统可能对允许使用的缓冲区数量有限制（使用 "sysconf()" 获取
   "'SC_IOV_MAX'" 值）。

   本方法结合了 "os.writev()" 和 "os.pwrite()" 的功能。

   可用性：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD
   2.7 或更高版本，AIX 7.1 或更高版本。使用标志位需要 Linux 4.7 或更高
   版本。

   3.7 新版功能.

os.RWF_DSYNC

   提供立即写入功能，等效于 "O_DSYNC" "open(2)" 标志。该标志仅作用于系
   统调用写入的数据。

   可用性：Linux 4.7 或更高版本。

   3.7 新版功能.

os.RWF_SYNC

   提供立即写入功能，等效于 "O_SYNC" "open(2)" 标志。该标志仅作用于系
   统调用写入的数据。

   可用性：Linux 4.7 或更高版本。

   3.7 新版功能.

os.read(fd, n)

   从文件描述符 *fd* 中读取至多 *n* 个字节。

   返回所读取字节的字节串 (bytestring)。如果到达了 *fd* 指向的文件末尾
   ，则返回空字节对象。

   注解:

     该功能适用于低级 I/O 操作，必须用于 "os.open()" 或 "pipe()" 返回
     的文件描述符。若要读取由内建函数 "open()"、"popen()"、"fdopen()"
     或 "sys.stdin" 返回的 "文件对象"，则应使用其相应的 "read()" 或
     "readline()" 方法。

   在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函
   数现在会重试系统调用，而不是触发 "InterruptedError" 异常 (原因详见
   **PEP 475**)。

os.sendfile(out_fd, in_fd, offset, count)
os.sendfile(out_fd, in_fd, offset, count, headers=(), trailers=(), flags=0)

   将文件描述符 *in_fd* 中的 *count* 字节复制到文件描述符 *out_fd* 的
   偏移位置 *offset* 处。返回复制的字节数，如果到达 EOF，返回 "0"。

   定义了 "sendfile()" 的所有平台均支持第一种函数用法。

   在 Linux 上，将 *offset* 设置为 "None"，则从 *in_fd* 的当前位置开始
   读取，并更新 *in_fd* 的位置。

   第二种函数用法可以在 Mac OS X 和 FreeBSD 上使用，其中，*headers* 和
   *trailers* 是任意的缓冲区序列，它们分别在写入 *in_fd* 的数据前、后
   被写入。返回值与第一种用法相同。

   在 Mac OS X 和 FreeBSD 上，将 *count* 设为 "0" 表示持续复制直到
   *in_fd* 的结尾。

   所有平台都支持将套接字作为 *out_fd* 文件描述符，有些平台也支持其他
   类型（如常规文件或管道）。

   跨平台应用程序不应使用 *headers*、*trailers* 和 *flags* 参数。

   可用性: Unix。

   注解:

     有关 "sendfile()" 的高级封装，参见 "socket.socket.sendfile()"。

   3.3 新版功能.

   在 3.9 版更改: *out* 和 *in* 参数被重命名为 *out_fd* 和 *in_fd*。

os.set_blocking(fd, blocking)

   设置指定文件描述符的阻塞模式：如果 blocking 为 "False"，则为该描述
   符设置 "O_NONBLOCK" 标志位，反之则清除该标志位。

   参见 "get_blocking()" 和 "socket.socket.setblocking()"。

   可用性: Unix。

   3.5 新版功能.

os.SF_NODISKIO
os.SF_MNOWAIT
os.SF_SYNC

   "sendfile()" 函数的参数（假设当前实现支持这些参数）。

   可用性: Unix。

   3.3 新版功能.

os.readv(fd, buffers)

   从文件描述符 *fd* 将数据读取至多个可变的 *字节类对象* 缓冲区
   *buffers* 中。将数据依次存放到每个缓冲区中，填满一个后继续存放到序
   列中的下一个缓冲区，来保存其余数据。

   返回实际读取的字节总数，该总数可以小于所有对象的总容量。

   操作系统可能对允许使用的缓冲区数量有限制（使用 "sysconf()" 获取
   "'SC_IOV_MAX'" 值）。

   可用性: Unix。

   3.3 新版功能.

os.tcgetpgrp(fd)

   返回与 *fd* 指定的终端相关联的进程组（*fd* 是由 "os.open()" 返回的
   已打开的文件描述符）。

   可用性: Unix。

os.tcsetpgrp(fd, pg)

   设置与 *fd* 指定的终端相关联的进程组为 *pg*（*fd* 是由 "os.open()"
   返回的已打开的文件描述符）。

   可用性: Unix。

os.ttyname(fd)

   返回一个字符串，该字符串表示与文件描述符 *fd* 关联的终端。如果 *fd*
   没有与终端关联，则抛出异常。

   可用性: Unix。

os.write(fd, str)

   将 *str* 中的字节串 (bytestring) 写入文件描述符 *fd*。

   返回实际写入的字节数。

   注解:

     该功能适用于低级 I/O 操作，必须用于 "os.open()" 或 "pipe()" 返回
     的文件描述符。若要写入由内建函数 "open()"、"popen()"、"fdopen()"
     、"sys.stdout" 或 "sys.stderr" 返回的 "文件对象"，则应使用其相应
     的 "write()" 方法。

   在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函
   数现在会重试系统调用，而不是触发 "InterruptedError" 异常 (原因详见
   **PEP 475**)。

os.writev(fd, buffers)

   将缓冲区 *buffers* 的内容写入文件描述符 *fd*。缓冲区 *buffers* 必须
   是由 *字节类对象* 组成的序列。缓冲区以数组顺序处理。先写入第一个缓
   冲区的全部内容，再写入第二个缓冲区，照此继续。

   返回实际写入的字节总数。

   操作系统可能对允许使用的缓冲区数量有限制（使用 "sysconf()" 获取
   "'SC_IOV_MAX'" 值）。

   可用性: Unix。

   3.3 新版功能.


查询终端的尺寸
--------------

3.3 新版功能.

os.get_terminal_size(fd=STDOUT_FILENO)

   返回终端窗口的尺寸，格式为 "(columns, lines)"，它是类型为
   "terminal_size" 的元组。

   可选参数 "fd" （默认为 "STDOUT_FILENO" 或标准输出）指定应查询的文件
   描述符。

   如果文件描述符未连接到终端，则抛出 "OSError" 异常。

   "shutil.get_terminal_size()" 是供常规使用的高阶函数，
   "os.get_terminal_size" 是其底层的实现。

   可用性: Unix, Windows。

class os.terminal_size

   元组的子类，存储终端窗口尺寸 "(columns, lines)"。

   columns

      终端窗口的宽度，单位为字符。

   lines

      终端窗口的高度，单位为字符。


文件描述符的继承
----------------

3.4 新版功能.

每个文件描述符都有一个 "inheritable"（可继承）标志位，该标志位控制了文
件描述符是否可以由子进程继承。从 Python 3.4 开始，由 Python 创建的文件
描述符默认是不可继承的。

在 UNIX 上，执行新程序时，不可继承的文件描述符在子进程中是关闭的，其他
文件描述符将被继承。

在 Windows 上，不可继承的句柄和文件描述符在子进程中是关闭的，但标准流
（文件描述符 0、1 和 2 即标准输入、标准输出和标准错误）是始终继承的。
如果使用 "spawn*" 函数，所有可继承的句柄和文件描述符都将被继承。如果使
用 "subprocess" 模块，将关闭除标准流以外的所有文件描述符，并且仅当
*close_fds* 参数为 "False" 时才继承可继承的句柄。

os.get_inheritable(fd)

   获取指定文件描述符的“可继承”标志位（为布尔值）。

os.set_inheritable(fd, inheritable)

   设置指定文件描述符的“可继承”标志位。

os.get_handle_inheritable(handle)

   获取指定句柄的“可继承”标志位（为布尔值）。

   可用性: Windows。

os.set_handle_inheritable(handle, inheritable)

   设置指定句柄的“可继承”标志位。

   可用性: Windows。


文件和目录
==========

在某些 Unix 平台上，许多函数支持以下一项或多项功能：

* **指定文件描述符为参数：** 通常在 "os" 模块中提供给函数的 *path* 参
  数必须是表示文件路径的字符串，但是，某些函数现在可以接受其 *path* 参
  数为打开文件描述符，该函数将对描述符指向的文件进行操作。（对于 POSIX
  系统，Python 将调用以 "f" 开头的函数变体（如调用 "fchdir" 而不是
  "chdir"）。）

  可以用 "os.supports_fd" 检查某个函数在你的平台上是否支持将 *path* 参
  数指定为文件描述符。如果不支持，使用该功能将抛出
  "NotImplementedError" 异常。

  如果该函数还支持 *dir_fd* 或 *follow_symlinks* 参数，那么用文件描述
  符作为 *path* 后就不能再指定上述参数了。

* **基于目录描述符的相对路径：** 如果 *dir_fd* 不是 "None"，它就应该是
  一个指向目录的文件描述符，这时待操作的 path 应该是相对路径，相对路径
  是相对于前述目录的。如果 path 是绝对路径，则 *dir_fd* 将被忽略。（对
  于 POSIX 系统，Python 将调用该函数的变体，变体以 "at" 结尾，可能以
  "f" 开头（如调用 "faccessat" 而不是 "access"）。

  可以用 "os.supports_dir_fd" 检查某个函数在你的平台上是否支持
  *dir_fd*。如果不支持，使用该功能将抛出 "NotImplementedError" 异常。

* **不跟踪符号链接：** 如果 *follow_symlinks* 为 "False"，并且待操作路
  径的最后一个元素是符号链接，则该函数将在符号链接本身而不是链接所指向
  的文件上操作。（对于 POSIX 系统，Python 将调用该函数的 "l..." 变体。
  ）

  可以用 "os.supports_follow_symlinks" 检查某个函数在你的平台上是否支
  持 *follow_symlinks*。如果不支持，使用该功能将抛出
  "NotImplementedError" 异常。

os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)

   使用 实际用户ID/用户组ID 测试对 *path* 的访问。请注意，大多数测试操
   作将使用 有效用户ID/用户组ID，因此可以在 suid/sgid 环境中运用此例程
   ，来测试调用用户是否具有对 *path* 的指定访问权限。*mode* 为 "F_OK"
   时用于测试 *path* 是否存在，也可以对 "R_OK"、"W_OK" 和 "X_OK" 中的
   一个或多个进行“或”运算来测试指定权限。允许访问则返回 "True"，否则返
   回 "False"。更多信息请参见 Unix 手册页 *access(2)*。

   本函数支持指定 基于目录描述符的相对路径 和 不跟踪符号链接。

   如果 *effective_ids* 为 "True"，"access()" 将使用 有效用户ID/用户组
   ID 而非 实际用户ID/用户组ID 进行访问检查。您的平台可能不支持
   *effective_ids*，您可以使用 "os.supports_effective_ids" 检查它是否
   可用。如果不可用，使用它时会抛出 "NotImplementedError" 异常。

   注解:

     使用 "access()" 来检查用户是否具有某项权限（如打开文件的权限），
     然后再使用 "open()" 打开文件，这样做存在一个安全漏洞，因为用户可
     能会在检查和打开文件之间的时间里做其他操作。推荐使用 *EAFP* 技术
     。如:

        if os.access("myfile", os.R_OK):
            with open("myfile") as fp:
                return fp.read()
        return "some default data"

     最好写成:

        try:
            fp = open("myfile")
        except PermissionError:
            return "some default data"
        else:
            with fp:
                return fp.read()

   注解:

     即使 "access()" 指示 I/O 操作会成功，但实际操作仍可能失败，尤其是
     对网络文件系统的操作，其权限语义可能超出常规的 POSIX 权限位模型。

   在 3.3 版更改: 添加 *dir_fd*、*effective_ids* 和 *follow_symlinks*
   参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.F_OK
os.R_OK
os.W_OK
os.X_OK

   作为 "access()" 的 *mode* 参数的可选值，分别测试 *path* 的存在性、
   可读性、可写性和可执行性。

os.chdir(path)

   将当前工作目录更改为 *path*。

   本函数支持 指定文件描述符为参数。其中，描述符必须指向打开的目录，不
   能是打开的文件。

   本函数可以抛出 "OSError" 及其子类的异常，如 "FileNotFoundError"、
   "PermissionError" 和 "NotADirectoryError" 异常。

   引发一个 审计事件 "os.chdir"，附带参数 "path"。

   3.3 新版功能: 在某些平台上新增支持将 *path* 参数指定为文件描述符。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.chflags(path, flags, *, follow_symlinks=True)

   将 *path* 的 flags 设置为其他由数字表示的 *flags*。*flags* 可以用以
   下值按位或组合起来（以下值在 "stat" 模块中定义）：

   * "stat.UF_NODUMP"

   * "stat.UF_IMMUTABLE"

   * "stat.UF_APPEND"

   * "stat.UF_OPAQUE"

   * "stat.UF_NOUNLINK"

   * "stat.UF_COMPRESSED"

   * "stat.UF_HIDDEN"

   * "stat.SF_ARCHIVED"

   * "stat.SF_IMMUTABLE"

   * "stat.SF_APPEND"

   * "stat.SF_NOUNLINK"

   * "stat.SF_SNAPSHOT"

   本函数支持 不跟踪符号链接。

   引发一个 审计事件 "os.chflags"，附带参数 "path"、"flags"。

   可用性: Unix。

   3.3 新版功能: *follow_symlinks* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True)

   将 *path* 的 mode 更改为其他由数字表示的 *mode*。*mode* 可以用以下
   值之一，也可以将它们按位或组合起来（以下值在 "stat" 模块中定义）：

   * "stat.S_ISUID"

   * "stat.S_ISGID"

   * "stat.S_ENFMT"

   * "stat.S_ISVTX"

   * "stat.S_IREAD"

   * "stat.S_IWRITE"

   * "stat.S_IEXEC"

   * "stat.S_IRWXU"

   * "stat.S_IRUSR"

   * "stat.S_IWUSR"

   * "stat.S_IXUSR"

   * "stat.S_IRWXG"

   * "stat.S_IRGRP"

   * "stat.S_IWGRP"

   * "stat.S_IXGRP"

   * "stat.S_IRWXO"

   * "stat.S_IROTH"

   * "stat.S_IWOTH"

   * "stat.S_IXOTH"

   本函数支持 指定文件描述符、指定基于目录描述符的相对路径 和 不跟踪符
   号链接。

   注解:

     尽管 Windows 支持 "chmod()"，但只能用它设置文件的只读标志（
     "stat.S_IWRITE" 和 "stat.S_IREAD" 常量或对应的整数值）。所有其他
     标志位都会被忽略。

   引发一个 审计事件 "os.chmod"，附带参数 "path"、"mode"、"dir_fd"。

   3.3 新版功能: 添加了指定 *path* 为文件描述符的支持，以及 *dir_fd*
   和 *follow_symlinks* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)

   将 *path* 的用户和组 ID 分别修改为数字形式的 *uid* 和 *gid*。若要使
   其中某个 ID 保持不变，请将其置为 -1。

   本函数支持 指定文件描述符、指定基于目录描述符的相对路径 和 不跟踪符
   号链接。

   参见更高阶的函数 "shutil.chown()"，除了数字 ID 之外，它也接受名称。

   引发一个 审计事件 "os.chown"，附带参数 "path"、"uid"、"gid"、
   "dir_fd"。

   可用性: Unix。

   3.3 新版功能: 添加了指定 *path* 为文件描述符的支持，以及 *dir_fd*
   和 *follow_symlinks* 参数。

   在 3.6 版更改: 支持 *类路径对象*。

os.chroot(path)

   将当前进程的根目录更改为 *path*。

   可用性: Unix。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.fchdir(fd)

   将当前工作目录更改为文件描述符 *fd* 指向的目录。fd 必须指向打开的目
   录而非文件。从 Python 3.3 开始，它等效于 "os.chdir(fd)"。

   引发一个 审计事件 "os.chdir"，附带参数 "path"。

   可用性: Unix。

os.getcwd()

   返回表示当前工作目录的字符串。

os.getcwdb()

   返回表示当前工作目录的字节串 (bytestring)。

   在 3.8 版更改: 在 Windows 上，本函数现在会使用 UTF-8 编码格式而不是
   ANSI 代码页：请参看 **PEP 529** 了解具体原因。 该函数在 Windows 上
   不再被弃用。

os.lchflags(path, flags)

   将 *path* 的 flags 设置为其他由数字表示的 *flags*，与 "chflags()"
   类似，但不跟踪符号链接。从 Python 3.3 开始，它等效于
   "os.chflags(path, flags, follow_symlinks=False)"。

   引发一个 审计事件 "os.chflags"，附带参数 "path"、"flags"。

   可用性: Unix。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.lchmod(path, mode)

   将 *path* 的权限状态修改为 *mode*。如果 path 是符号链接，则影响符号
   链接本身而非链接目标。可以参考 "chmod()" 中列出 *mode* 的可用值。从
   Python 3.3 开始，它等效于 "os.chmod(path, mode,
   follow_symlinks=False)"。

   引发一个 审计事件 "os.chmod"，附带参数 "path"、"mode"、"dir_fd"。

   可用性: Unix。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.lchown(path, uid, gid)

   将 *path* 的用户和组 ID 分别修改为数字形式的 *uid* 和 *gid*，本函数
   不跟踪符号链接。从 Python 3.3 开始，它等效于 "os.chown(path, uid,
   gid, follow_symlinks=False)"。

   引发一个 审计事件 "os.chown"，附带参数 "path"、"uid"、"gid"、
   "dir_fd"。

   可用性: Unix。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)

   创建一个指向 *src* 的硬链接，名为 *dst*。

   本函数支持将 *src_dir_fd* 和 *dst_dir_fd* 中的一个或两个指定为 基于
   目录描述符的相对路径，支持 不跟踪符号链接。

   引发一个 审计事件 "os.link" 附带参数 "src"、"dst"、"src_dir_fd"、
   "dst_dir_fd"。

   可用性: Unix, Windows。

   在 3.2 版更改: 添加了对 Windows 的支持。

   3.3 新版功能: 添加 *src_dir_fd*、*dst_dir_fd* 和 *follow_symlinks*
   参数。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *src* 和 *dst*。

os.listdir(path='.')

   返回一个包含由 *path* 指定目录中条目名称组成的列表。 该列表按任意顺
   序排列，并且不包括特殊条目 "'.'" 和 "'..'"，即使它们存在于目录中。
   如果有文件在调用此函数期间在被移除或添加到目录中，是否要包括该文件
   的名称并没有规定。

   *path* 可以是 *类路径对象*。如果 *path* 是（直接传入或通过
   "PathLike" 接口间接传入） "bytes" 类型，则返回的文件名也将是
   "bytes" 类型，其他情况下是 "str" 类型。

   本函数也支持 指定文件描述符为参数，其中描述符必须指向目录。

   引发一个 审计事件 "os.listdir"，附带参数 "path"。

   注解:

     要将 "str" 类型的文件名编码为 "bytes"，请使用 "fsencode()"。

   参见: "scandir()" 函数返回目录内文件名的同时，也返回文件属性信息，它在
       某些具体情况下能提供更好的性能。

   在 3.2 版更改: *path* 变为可选参数。

   3.3 新版功能: 新增支持将 *path* 参数指定为打开的文件描述符。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.lstat(path, *, dir_fd=None)

   在给定路径上执行本函数，其操作相当于 "lstat()" 系统调用，类似于
   "stat()" 但不跟踪符号链接。返回值是 "stat_result" 对象。

   在不支持符号链接的平台上，本函数是 "stat()" 的别名。

   从 Python 3.3 起，此功能等价于 "os.stat(path, dir_fd=dir_fd,
   follow_symlinks=False)"。

   本函数支持 基于目录描述符的相对路径。

   参见: "stat()" 函数。

   在 3.2 版更改: 添加对 Windows 6.0 (Vista) 符号链接的支持。

   在 3.3 版更改: 添加了 *dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *src* 和 *dst*。

   在 3.8 版更改: 目前在 Windows 上，遇到表示另一个路径的重解析点（即
   名称代理，包括符号链接和目录结点），本函数将打开它。其他种类的重解
   析点由 "stat()" 交由操作系统解析。

os.mkdir(path, mode=0o777, *, dir_fd=None)

   创建一个名为 *path* 的目录，应用以数字表示的权限模式 *mode*。

   如果目录已存在，则抛出 "FileExistsError" 异常。

   某些系统会忽略 *mode*。如果没有忽略它，那么将首先从它中减去当前的
   umask 值。如果除最后 9 位（即 *mode* 八进制的最后 3 位）之外，还设
   置了其他位，则其他位的含义取决于各个平台。在某些平台上，它们会被忽
   略，应显式调用 "chmod()" 进行设置。

   本函数支持 基于目录描述符的相对路径。

   如果需要创建临时目录，请参阅 "tempfile" 模块中的
   "tempfile.mkdtemp()" 函数。

   引发一个 审计事件 "os.mkdir"，附带参数 "path"、"mode"、"dir_fd"。

   3.3 新版功能: *dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.makedirs(name, mode=0o777, exist_ok=False)

   递归目录创建函数。与 "mkdir()" 类似，但会自动创建到达最后一级目录所
   需要的中间目录。

   *mode* 参数会传递给 "mkdir()"，用来创建最后一级目录，对于该参数的解
   释，请参阅 mkdir() 中的描述。要设置某些新建的父目录的权限，可以在调
   用 "makedirs()" 之前设置 umask。现有父目录的权限不会更改。

   如果 *exist_ok* 为 "False" (默认值)，则如果目标目录已存在将引发
   "FileExistsError"。

   注解:

     如果要创建的路径元素包含 "pardir" (如 UNIX 系统中的 "..")
     "makedirs()" 将无法明确目标。

   本函数能正确处理 UNC 路径。

   引发一个 审计事件 "os.mkdir"，附带参数 "path"、"mode"、"dir_fd"。

   3.2 新版功能: *exist_ok* 参数。

   在 3.4.1 版更改: 在 Python 3.4.1 以前，如果 *exist_ok* 为 "True"，
   且目录已存在，且 *mode* 与现有目录的权限不匹配，"makedirs()" 仍会抛
   出错误。由于无法安全地实现此行为，因此在 Python 3.4.1 中将该行为删
   除。请参阅 bpo-21082。

   在 3.6 版更改: 接受一个 *类路径对象*。

   在 3.7 版更改: *mode* 参数不再影响新创建的中间目录的权限。

os.mkfifo(path, mode=0o666, *, dir_fd=None)

   创建一个名为 *path* 的 FIFO（命名管道，一种先进先出队列），具有以数
   字表示的权限状态 *mode*。将从 mode 中首先减去当前的 umask 值。

   本函数支持 基于目录描述符的相对路径。

   FIFO 是可以像常规文件一样访问的管道。FIFO 如果没有被删除（如使用
   "os.unlink()"），会一直存在。通常，FIFO 用作“客户端”和“服务器”进程
   之间的汇合点：服务器打开 FIFO 进行读取，而客户端打开 FIFO 进行写入
   。请注意，"mkfifo()" 不会打开 FIFO --- 它只是创建汇合点。

   可用性: Unix。

   3.3 新版功能: *dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.mknod(path, mode=0o600, device=0, *, dir_fd=None)

   创建一个名为 *path* 的文件系统节点（文件，设备专用文件或命名管道）
   。*mode* 指定权限和节点类型，方法是将权限与下列节点类型
   "stat.S_IFREG"、"stat.S_IFCHR"、"stat.S_IFBLK" 和 "stat.S_IFIFO" 之
   一（按位或）组合（这些常量可以在 "stat" 模块中找到）。对于
   "stat.S_IFCHR" 和 "stat.S_IFBLK"，*device* 参数指定了新创建的设备专
   用文件（可能会用到 "os.makedev()"），否则该参数将被忽略。

   本函数支持 基于目录描述符的相对路径。

   可用性: Unix。

   3.3 新版功能: *dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.major(device)

   提取主设备号，提取自原始设备号（通常是 "stat" 中的 "st_dev" 或
   "st_rdev" 字段）。

os.minor(device)

   提取次设备号，提取自原始设备号（通常是 "stat" 中的 "st_dev" 或
   "st_rdev" 字段）。

os.makedev(major, minor)

   将主设备号和次设备号组合成原始设备号。

os.pathconf(path, name)

   返回所给名称的文件有关的系统配置信息。*name* 指定要查找的配置名称，
   它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（
   POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。
   当前操作系统已定义的名称在 "pathconf_names" 字典中给出。对于未包含
   在该映射中的配置名称，也可以传递一个整数作为 *name*。

   如果 *name* 是一个字符串且不是已定义的名称，将抛出 "ValueError" 异
   常。如果当前系统不支持 *name* 指定的配置名称，即使该名称存在于
   "pathconf_names"，也会抛出 "OSError" 异常，错误码为 "errno.EINVAL"
   。

   本函数支持 指定文件描述符为参数。

   可用性: Unix。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.pathconf_names

   字典，表示映射关系，为 "pathconf()" 和 "fpathconf()" 可接受名称与操
   作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪
   些名称。

   可用性: Unix。

os.readlink(path, *, dir_fd=None)

   返回一个字符串，为符号链接指向的实际路径。其结果可以是绝对或相对路
   径。如果是相对路径，则可用 "os.path.join(os.path.dirname(path),
   result)" 转换为绝对路径。

   如果 *path* 是字符串对象（直接传入或通过 "PathLike" 接口间接传入）
   ，则结果也将是字符串对象，且此类调用可能会引发 UnicodeDecodeError。
   如果 *path* 是字节对象（直接传入或间接传入），则结果将会是字节对象
   。

   本函数支持 基于目录描述符的相对路径。

   当尝试解析的路径可能含有链接时，请改用 "realpath()" 以正确处理递归
   和平台差异。

   可用性: Unix, Windows。

   在 3.2 版更改: 添加对 Windows 6.0 (Vista) 符号链接的支持。

   3.3 新版功能: *dir_fd* 参数。

   在 3.6 版更改: 在 Unix 上可以接受一个 *类路径对象*。

   在 3.8 版更改: 在 Windows 上接受 *类路径对象* 和字节对象。

   在 3.8 版更改: 增加了对目录链接的支持，且返回值改为了“替换路径”的形
   式（通常带有 "\\?\" 前缀），而不是先前那样返回可选的 "print name"
   字段。

os.remove(path, *, dir_fd=None)

   移除（删除）文件 *path*。如果 *path* 是目录，则抛出
   "IsADirectoryError" 异常。请使用 "rmdir()" 删除目录。

   本函数支持 基于目录描述符的相对路径。

   在 Windows 上，尝试删除正在使用的文件会抛出异常。而在 Unix 上，虽然
   该文件的条目会被删除，但分配给文件的存储空间仍然不可用，直到原始文
   件不再使用为止。

   本函数在语义上与 "unlink()" 相同。

   引发一个 审计事件 "os.remove"，附带参数 "path"、"dir_fd"。

   3.3 新版功能: *dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.removedirs(name)

   递归删除目录。工作方式类似于 "rmdir()"，不同之处在于，如果成功删除
   了末尾一级目录，"removedirs()" 会尝试依次删除 *path* 中提到的每个父
   目录，直到抛出错误为止（但该错误会被忽略，因为这通常表示父目录不是
   空目录）。例如，"os.removedirs('foo/bar/baz')" 将首先删除目录
   "'foo/bar/baz'"，然后如果 "'foo/bar'" 和 "'foo'" 为空，则继续删除它
   们。如果无法成功删除末尾一级目录，则抛出 "OSError" 异常。

   引发一个 审计事件 "os.remove"，附带参数 "path"、"dir_fd"。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)

   将文件或目录 *src* 重命名为 *dst*。如果 *dst* 已存在，则下列情况下
   将会操作失败，并抛出 "OSError" 的子类：

   在 Windows 上，如果 *dst* 已存在，则抛出 "FileExistsError" 异常。

   在 Unix 上，如果 *src* 是文件而 *dst* 是目录，将抛出
   "IsADirectoryError" 异常，反之则抛出 "NotADirectoryError" 异常。如
   果两者都是目录且 *dst* 为空，则 *dst* 将被静默替换。如果 *dst* 是非
   空目录，则抛出 "OSError" 异常。如果两者都是文件，则在用户具有权限的
   情况下，将对 *dst* 进行静默替换。如果 *src* 和 *dst* 在不同的文件系
   统上，则本操作在某些 Unix 分支上可能会失败。如果成功，重命名操作将
   是一个原子操作（这是 POSIX 的要求）。

   本函数支持将 *src_dir_fd* 和 *dst_dir_fd* 中的一个或两个指定为 基于
   目录描述符的相对路径。

   如果需要在不同平台上都能替换目标，请使用 "replace()"。

   引发一个 审计事件 "os.rename" 附带参数 "src"、"dst"、"src_dir_fd"、
   "dst_dir_fd"。

   3.3 新版功能: *src_dir_fd* 和 *dst_dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *src* 和 *dst*。

os.renames(old, new)

   递归重命名目录或文件。工作方式类似 "rename()"，除了会首先创建新路径
   所需的中间目录。重命名后，将调用 "removedirs()" 删除旧路径中不需要
   的目录。

   注解:

     如果用户没有权限删除末级的目录或文件，则本函数可能会无法建立新的
     目录结构。

   引发一个 审计事件 "os.rename" 附带参数 "src"、"dst"、"src_dir_fd"、
   "dst_dir_fd"。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *old* 和 *new*。

os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)

   将文件或目录 *src* 重命名为 *dst*。如果 *dst* 是目录，将抛出
   "OSError" 异常。如果 *dst* 已存在且为文件，则在用户具有权限的情况下
   ，将对其进行静默替换。如果 *src* 和 *dst* 在不同的文件系统上，本操
   作可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要
   求）。

   本函数支持将 *src_dir_fd* 和 *dst_dir_fd* 中的一个或两个指定为 基于
   目录描述符的相对路径。

   引发一个 审计事件 "os.rename" 附带参数 "src"、"dst"、"src_dir_fd"、
   "dst_dir_fd"。

   3.3 新版功能.

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *src* 和 *dst*。

os.rmdir(path, *, dir_fd=None)

   移除（删除）目录 *path*。如果目录不存在或不为空，则会分别抛出
   "FileNotFoundError" 或 "OSError" 异常。要删除整个目录树，可以使用
   "shutil.rmtree()"。

   本函数支持 基于目录描述符的相对路径。

   引发一个 审计事件 "os.rmdir"，附带参数 "path"、"dir_fd"。

   3.3 新版功能: *dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.scandir(path='.')

   返回一个 "os.DirEntry" 对象的迭代器，它们对应于由 *path* 指定目录中
   的条目。 这些条目会以任意顺序生成，并且不包括特殊条目 "'.'" 和
   "'..'"。 如果有文件在迭代器创建之后在目录中被移除或添加，是否要包括
   该文件对应的条目并没有规定。

   如果需要文件类型或文件属性信息，使用 "scandir()" 代替 "listdir()"
   可以大大提高这部分代码的性能，因为如果操作系统在扫描目录时返回的是
   "os.DirEntry" 对象，则该对象包含了这些信息。所有 "os.DirEntry" 的方
   法都可能执行一次系统调用，但是 "is_dir()" 和 "is_file()" 通常只在有
   符号链接时才执行一次系统调用。"os.DirEntry.stat()" 在 Unix 上始终需
   要一次系统调用，而在 Windows 上只在有符号链接时才需要。

   *path* 可以是 *类路径对象*。如果 *path* 是（直接传入或通过
   "PathLike" 接口间接传入的） "bytes" 类型，那么每个 "os.DirEntry" 的
   "name" 和 "path" 属性将是 "bytes" 类型，其他情况下是 "str" 类型。

   本函数也支持 指定文件描述符为参数，其中描述符必须指向目录。

   引发一个 审计事件 "os.scandir"，附带参数 "path"。

   "scandir()" 迭代器支持 *上下文管理* 协议，并具有以下方法：

   scandir.close()

      关闭迭代器并释放占用的资源。

      当迭代器迭代完毕，或垃圾回收，或迭代过程出错时，将自动调用本方法
      。但仍建议显式调用它或使用 "with" 语句。

      3.6 新版功能.

   下面的例子演示了 "scandir()" 的简单用法，用来显示给定 *path* 中所有
   不以 "'.'" 开头的文件（不包括目录）。"entry.is_file()" 通常不会增加
   一次额外的系统调用:

      with os.scandir(path) as it:
          for entry in it:
              if not entry.name.startswith('.') and entry.is_file():
                  print(entry.name)

   注解:

     在基于 Unix 的系统上，"scandir()" 使用系统的 opendir() 和
     readdir() 函数。在 Windows 上，它使用 Win32 FindFirstFileW 和
     FindNextFileW 函数。

   3.5 新版功能.

   3.6 新版功能: 添加了对 *上下文管理* 协议和 "close()" 方法的支持。如
   果 "scandir()" 迭代器没有迭代完毕且没有显式关闭，其析构函数将发出
   "ResourceWarning" 警告。本函数接受一个 *类路径对象*。

   在 3.7 版更改: 在 Unix 上新增支持 指定文件描述符为参数。

class os.DirEntry

   由 "scandir()" 生成的对象，用于显示目录内某个条目的文件路径和其他文
   件属性。

   "scandir()" 将在不进行额外系统调用的情况下，提供尽可能多的此类信息
   。每次进行 "stat()" 或 "lstat()" 系统调用时，"os.DirEntry" 对象会将
   结果缓存下来。

   "os.DirEntry" 实例不适合存储在长期存在的数据结构中，如果你知道文件
   元数据已更改，或者自调用 "scandir()" 以来已经经过了很长时间，请调用
   "os.stat(entry.path)" 来获取最新信息。

   因为 "os.DirEntry" 方法可以进行系统调用，所以它也可能抛出 "OSError"
   异常。如需精确定位错误，可以逐个调用 "os.DirEntry" 中的方法来捕获
   "OSError"，并适当处理。

   为了能直接用作 *类路径对象*，"os.DirEntry" 实现了 "PathLike" 接口。

   "os.DirEntry" 实例所包含的属性和方法如下：

   name

      本条目的基本文件名，是根据 "scandir()" 的 *path* 参数得出的相对
      路径。

      如果 "scandir()" 的 *path* 参数是 "bytes" 类型，则 "name" 属性也
      是 "bytes" 类型，否则为 "str"。使用 "fsdecode()" 解码 byte 类型
      的文件名。

   path

      本条目的完整路径：等效于 "os.path.join(scandir_path,
      entry.name)"，其中 *scandir_path* 就是 "scandir()" 的 *path* 参
      数。仅当 "scandir()" 的 *path* 参数为绝对路径时，本路径才是绝对
      路径。如果 "scandir()" 的 *path* 参数是 文件描述符，则 "path" 属
      性与上述 "name" 属性相同。

      如果 "scandir()" 的 *path* 参数是 "bytes" 类型，则 "path" 属性也
      是 "bytes" 类型，否则为 "str"。使用 "fsdecode()" 解码 byte 类型
      的文件名。

   inode()

      返回本条目的索引节点号 (inode number)。

      这一结果是缓存在 "os.DirEntry" 对象中的，请调用
      "os.stat(entry.path, follow_symlinks=False).st_ino" 来获取最新信
      息。

      一开始没有缓存时，在 Windows 上需要一次系统调用，但在 Unix 上不
      需要。

   is_dir(*, follow_symlinks=True)

      如果本条目是目录，或是指向目录的符号链接，则返回 "True"。如果本
      条目是文件，或指向任何其他类型的文件，或该目录不再存在，则返回
      "False"。

      如果 *follow_symlinks* 是 "False"，那么仅当本条目为目录时返回
      "True" （不跟踪符号链接），如果本条目是任何类型的文件，或该文件
      不再存在，则返回 "False"。

      这一结果是缓存在 "os.DirEntry" 对象中的，且 *follow_symlinks* 为
      "True" 和 "False" 时的缓存是分开的。请调用 "os.stat()" 和
      "stat.S_ISDIR()" 来获取最新信息。

      一开始没有缓存时，大多数情况下不需要系统调用。特别是对于非符号链
      接，Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如
      网络文件系统）返回了 "dirent.d_type == DT_UNKNOWN"。如果本条目是
      符号链接，则需要一次系统调用来跟踪它（除非 *follow_symlinks* 为
      "False"）。

      本方法可能抛出 "OSError" 异常，如 "PermissionError" 异常，但
      "FileNotFoundError" 异常会被内部捕获且不会抛出。

   is_file(*, follow_symlinks=True)

      如果本条目是文件，或是指向文件的符号链接，则返回 "True"。如果本
      条目是目录，或指向目录，或指向其他非文件条目，或该文件不再存在，
      则返回 "False"。

      如果 *follow_symlinks* 是 "False"，那么仅当本条目为文件时返回
      "True" （不跟踪符号链接），如果本条目是目录或其他非文件条目，或
      该文件不再存在，则返回 "False"。

      这一结果是缓存在 "os.DirEntry" 对象中的。缓存、系统调用、异常抛
      出都与 "is_dir()" 一致。

   is_symlink()

      如果本条目是符号链接（即使是断开的链接），返回 "True"。如果是目
      录或任何类型的文件，或本条目不再存在，返回 "False"。

      这一结果是缓存在 "os.DirEntry" 对象中的，请调用
      "os.path.islink()" 来获取最新信息。

      一开始没有缓存时，大多数情况下不需要系统调用。其实 Windows 和
      Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）
      返回了 "dirent.d_type == DT_UNKNOWN"。

      本方法可能抛出 "OSError" 异常，如 "PermissionError" 异常，但
      "FileNotFoundError" 异常会被内部捕获且不会抛出。

   stat(*, follow_symlinks=True)

      返回本条目对应的 "stat_result" 对象。本方法默认会跟踪符号链接，
      要获取符号链接本身的 stat，请添加 "follow_symlinks=False" 参数。

      在 Unix 上，本方法需要一次系统调用。在 Windows 上，仅在
      *follow_symlinks* 为 "True" 且该条目是一个重解析点（如符号链接或
      目录结点）时，才需要一次系统调用。

      在 Windows 上，"stat_result" 的 "st_ino"、"st_dev" 和 "st_nlink"
      属性总是为零。请调用 "os.stat()" 以获得这些属性。

      这一结果是缓存在 "os.DirEntry" 对象中的，且 *follow_symlinks* 为
      "True" 和 "False" 时的缓存是分开的。请调用 "os.stat()" 来获取最
      新信息。

   注意，"os.DirEntry" 和 "pathlib.Path" 的几个属性和方法之间存在很好
   的对应关系。具体来说是 "name" 属性，以及 "is_dir()"、"is_file()"、
   "is_symlink()" 和 "stat()" 方法，在两个类中具有相同的含义。

   3.5 新版功能.

   在 3.6 版更改: 添加了对 "PathLike" 接口的支持。在 Windows 上添加了
   对 "bytes" 类型路径的支持。

os.stat(path, *, dir_fd=None, follow_symlinks=True)

   获取文件或文件描述符的状态。在所给路径上执行等效于 "stat()" 系统调
   用的操作。*path* 可以是字符串类型，或（直接传入或通过 "PathLike" 接
   口间接传入的） bytes 类型，或打开的文件描述符。返回一个
   "stat_result" 对象。

   本函数默认会跟踪符号链接，要获取符号链接本身的 stat，请添加
   "follow_symlinks=False" 参数，或使用 "lstat()"。

   本函数支持 指定文件描述符为参数 和 不跟踪符号链接。

   在 Windows 上，传入 "follow_symlinks=False" 将禁用所有名称代理重解
   析点，其中包括符号链接和目录结点。其他类型的重解析点将直接打开，比
   如不像链接的或系统无法跟踪的重解析点。当多个链接形成一个链时，本方
   法可能会返回原始链接的 stat，无法完整遍历到非链接的对象。在这种情况
   下，要获取最终路径的 stat，请使用 "os.path.realpath()" 函数尽可能地
   解析路径，并在解析结果上调用 "lstat()"。这不适用于空链接或交接点，
   否则会抛出异常。

   示例:

      >>> import os
      >>> statinfo = os.stat('somefile.txt')
      >>> statinfo
      os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,
      st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,
      st_mtime=1297230027, st_ctime=1297230027)
      >>> statinfo.st_size
      264

   参见: "fstat()" 和 "lstat()" 函数。

   3.3 新版功能: 增加 *dir_fd* 和 *follow_symlinks* 参数，可指定文件描
   述符代替路径。

   在 3.6 版更改: 接受一个 *类路径对象*。

   在 3.8 版更改: 在 Windows 上，本方法将跟踪系统能解析的所有重解析点
   ，并且传入 "follow_symlinks=False" 会停止跟踪所有名称代理重解析点。
   现在，如果操作系统遇到无法跟踪的重解析点，*stat* 将返回原始路径的信
   息，就像已指定 "follow_symlinks=False" 一样，而不会抛出异常。

class os.stat_result

   本对象的属性大致对应于 "stat" 结构体成员，主要作为 "os.stat()"、
   "os.fstat()" 和 "os.lstat()" 的返回值。

   属性：

   st_mode

      文件模式：包括文件类型和文件模式位（即权限位）。

   st_ino

      与平台有关，但如果不为零，则根据 "st_dev" 值唯一地标识文件。通常
      ：

      * 在 Unix 上该值表示索引节点号 (inode number)。

      * 在 Windows 上该值表示 文件索引号 。

   st_dev

      该文件所在设备的标识符。

   st_nlink

      硬链接的数量。

   st_uid

      文件所有者的用户 ID。

   st_gid

      文件所有者的用户组 ID。

   st_size

      文件大小（以字节为单位），文件可以是常规文件或符号链接。符号链接
      的大小是它包含的路径的长度，不包括末尾的空字节。

   时间戳：

   st_atime

      最近的访问时间，以秒为单位。

   st_mtime

      最近的修改时间，以秒为单位。

   st_ctime

      取决于平台：

      * 在 Unix 上表示最近的元数据更改时间，

      * 在 Windows 上表示创建时间，以秒为单位。

   st_atime_ns

      最近的访问时间，以纳秒表示，为整数。

   st_mtime_ns

      最近的修改时间，以纳秒表示，为整数。

   st_ctime_ns

      取决于平台：

      * 在 Unix 上表示最近的元数据更改时间，

      * 在 Windows 上表示创建时间，以纳秒表示，为整数。

   注解:

     "st_atime"、"st_mtime" 和 "st_ctime" 属性的确切含义和分辨率取决于
     操作系统和文件系统。例如，在使用 FAT 或 FAT32 文件系统的 Windows
     上，"st_mtime" 有 2 秒的分辨率，而 "st_atime" 仅有 1 天的分辨率。
     详细信息请参阅操作系统文档。类似地，尽管 "st_atime_ns"、
     "st_mtime_ns" 和 "st_ctime_ns" 始终以纳秒表示，但许多系统并不提供
     纳秒精度。在确实提供纳秒精度的系统上，用于存储 "st_atime"、
     "st_mtime" 和 "st_ctime" 的浮点对象无法保留所有精度，因此不够精确
     。如果需要确切的时间戳，则应始终使用 "st_atime_ns"、"st_mtime_ns"
     和 "st_ctime_ns"。

   在某些 Unix 系统上（如 Linux 上），以下属性可能也可用：

   st_blocks

      为文件分配的字节块数，每块 512 字节。文件是稀疏文件时，它可能小
      于 "st_size"/512。

   st_blksize

      “首选的” 块大小，用于提高文件系统 I/O 效率。写入文件时块大小太小
      可能会导致读取-修改-重写效率低下。

   st_rdev

      设备类型（如果是 inode 设备）。

   st_flags

      用户定义的文件标志位。

   在其他 Unix 系统上（如 FreeBSD 上），以下属性可能可用（但仅当 root
   使用它们时才被填充）：

   st_gen

      文件生成号。

   st_birthtime

      文件创建时间。

   在 Solaris 及其衍生版本上，以下属性可能也可用：

   st_fstype

      文件所在文件系统的类型的唯一标识，为字符串。

   在 Mac OS 系统上，以下属性可能也可用：

   st_rsize

      文件的实际大小。

   st_creator

      文件的创建者。

   st_type

      文件类型。

   在 Windows 系统上，以下属性也可用：

   st_file_attributes

      Windows 文件属性："dwFileAttributes"，由
      "GetFileInformationByHandle()" 返回的
      "BY_HANDLE_FILE_INFORMATION" 结构体的成员之一。请参阅 "stat" 模
      块中的 "FILE_ATTRIBUTE_*" 常量。

   st_reparse_tag

      当 "st_file_attributes" 存在 "FILE_ATTRIBUTE_REPARSE_POINT" 集合
      时，本字段包含重解析点类型标记。请参阅 "stat" 模块中的
      "IO_REPARSE_TAG_*" 常量。

   标准模块 "stat" 中定义了函数和常量，这些函数和常量可用于从 "stat"
   结构体中提取信息。（在 Windows 上，某些项填充的是虚值。）

   为了向后兼容，一个 "stat_result" 实例还可以作为至少包含 10 个整数的
   元组访问，以提供 "stat" 结构中最重要（和可移植）的成员，整数顺序为
   "st_mode", "st_ino", "st_dev", "st_nlink", "st_uid", "st_gid",
   "st_size", "st_atime", "st_mtime", "st_ctime"。某些实现可能在末尾还
   有更多项。为了与旧版 Python 兼容，以元组形式访问 "stat_result" 始终
   返回整数。

   3.3 新版功能: 添加了 "st_atime_ns"、"st_mtime_ns" 和 "st_ctime_ns"
   成员。

   3.5 新版功能: 在 Windows 上添加了 "st_file_attributes" 成员。

   在 3.5 版更改: 在 Windows 上，如果可用，会返回文件索引作为 "st_ino"
   的值。

   3.7 新版功能: 在 Solaris 及其衍生版本上添加了 "st_fstype" 成员。

   3.8 新版功能: 在 Windows 上添加了 "st_reparse_tag" 成员。

   在 3.8 版更改: 在 Windows 上，"st_mode" 成员现在可以根据需要将特殊
   文件标识为 "S_IFCHR"、"S_IFIFO" 或 "S_IFBLK"。

os.statvfs(path)

   在所给的路径上执行 "statvfs()" 系统调用。返回值是一个对象，其属性描
   述了所给路径上的文件系统，并且与 "statvfs" 结构体的成员相对应，即：
   "f_bsize", "f_frsize", "f_blocks", "f_bfree", "f_bavail",
   "f_files", "f_ffree", "f_favail", "f_flag", "f_namemax", "f_fsid"。

   为 "f_flag" 属性位定义了两个模块级常量：如果存在 "ST_RDONLY" 位，则
   文件系统以只读挂载；如果存在 "ST_NOSUID" 位，则文件系统禁用或不支持
   setuid/setgid 位。

   为基于 GNU/glibc 的系统还定义了额外的模块级常量。它们是 "ST_NODEV"
   （禁止访问设备专用文件），"ST_NOEXEC" （禁止执行程序），
   "ST_SYNCHRONOUS" （写入后立即同步），"ST_MANDLOCK" （允许文件系统上
   的强制锁定），"ST_WRITE" （写入文件/目录/符号链接），"ST_APPEND" （
   仅追加文件），"ST_IMMUTABLE" （不可变文件），"ST_NOATIME" （不更新
   访问时间），"ST_NODIRATIME" （不更新目录访问时间），"ST_RELATIME"
   （相对于 mtime/ctime 更新访问时间）。

   本函数支持 指定文件描述符为参数。

   可用性: Unix。

   在 3.2 版更改: 添加了 "ST_RDONLY" 和 "ST_NOSUID" 常量。

   3.3 新版功能: 新增支持将 *path* 参数指定为打开的文件描述符。

   在 3.4 版更改: 添加了 "ST_NODEV"、"ST_NOEXEC"、"ST_SYNCHRONOUS"、
   "ST_MANDLOCK"、"ST_WRITE"、"ST_APPEND"、"ST_IMMUTABLE"、
   "ST_NOATIME"、"ST_NODIRATIME" 和 "ST_RELATIME" 常量。

   在 3.6 版更改: 接受一个 *类路径对象*。

   3.7 新版功能: 添加了 "f_fsid"。

os.supports_dir_fd

   一个 "set" 对象，指示 "os" 模块中的哪些函数接受一个打开的文件描述符
   作为 *dir_fd* 参数。不同平台提供的功能不同，且 Python 用于实现
   *dir_fd* 参数的底层函数并非在 Python 支持的所有平台上都可用。考虑到
   一致性，支持 *dir_fd* 的函数始终允许指定描述符，但如果在底层不支持
   时调用了该函数，则会抛出异常。（在所有平台上始终支持将 *dir_fd* 指
   定为 "None"。）

   要检查某个函数是否接受打开的文件描述符作为 *dir_fd* 参数，请在
   "supports_dir_fd" 前使用 "in" 运算符。例如，如果 "os.stat()" 在当前
   平台上接受打开的文件描述符作为 *dir_fd* 参数，则此表达式的计算结果
   为 "True":

      os.stat in os.supports_dir_fd

   目前 *dir_fd* 参数仅在 Unix 平台上有效，在 Windows 上均无效。

   3.3 新版功能.

os.supports_effective_ids

   一个 "set" 对象，指示 "os.access()" 是否允许在当前平台上将其
   *effective_ids* 参数指定为 "True"。（所有平台都支持将
   *effective_ids* 指定为 "False"。）如果当前平台支持，则集合将包含
   "os.access()"，否则集合为空。

   如果当前平台上的 "os.access()" 支持 "effective_ids=True"，则此表达
   式的计算结果为 "True":

      os.access in os.supports_effective_ids

   目前仅 Unix 平台支持 *effective_ids*，Windows 不支持。

   3.3 新版功能.

os.supports_fd

   一个 "set" 对象，指示在当前平台上 "os" 模块中的哪些函数接受一个打开
   的文件描述符作为 *path* 参数。不同平台提供的功能不同，且 Python 所
   使用到的底层函数（用于实现接受描述符作为 *path*）并非在 Python 支持
   的所有平台上都可用。

   要判断某个函数是否接受打开的文件描述符作为 *path* 参数，请在
   "supports_fd" 前使用 "in" 运算符。例如，如果 "os.chdir()" 在当前平
   台上接受打开的文件描述符作为 *path* 参数，则此表达式的计算结果为
   "True":

      os.chdir in os.supports_fd

   3.3 新版功能.

os.supports_follow_symlinks

   一个 "set" 对象，指示在当前平台上 "os" 模块中的哪些函数的
   *follow_symlinks* 参数可指定为 "False"。不同平台提供的功能不同，且
   Python 用于实现 *follow_symlinks* 的底层函数并非在 Python 支持的所
   有平台上都可用。考虑到一致性，支持 *follow_symlinks* 的函数始终允许
   将其指定为 "False"，但如果在底层不支持时调用了该函数，则会抛出异常
   。（在所有平台上始终支持将 *follow_symlinks* 指定为 "True"。）

   要检查某个函数的 *follow_symlinks* 参数是否可以指定为 "False"，请在
   "supports_follow_symlinks" 前使用 "in" 运算符。例如，如果在当前平台
   上调用 "os.stat()" 时可以指定 "follow_symlinks=False"，则此表达式的
   计算结果为 "True":

      os.stat in os.supports_follow_symlinks

   3.3 新版功能.

os.symlink(src, dst, target_is_directory=False, *, dir_fd=None)

   创建一个指向 *src* 的符号链接，名为 *dst*。

   在 Windows 上，符号链接可以表示文件或目录两种类型，并且不会动态改变
   类型。如果目标存在，则新建链接的类型将与目标一致。否则，如果
   *target_is_directory* 为 "True"，则符号链接将创建为目录链接，为
   "False" （默认）将创建为文件链接。在非 Windows 平台上，
   *target_is_directory* 被忽略。

   本函数支持 基于目录描述符的相对路径。

   注解:

     在 Windows 10 或更高版本上，如果启用了开发人员模式，非特权帐户可
     以创建符号链接。如果开发人员模式不可用/未启用，则需要
     *SeCreateSymbolicLinkPrivilege* 权限，或者该进程必须以管理员身份
     运行。当本函数由非特权账户调用时，抛出 "OSError" 异常。

   引发一个 审计事件 "os.symlink"，附带参数 "src"、"dst"、"dir_fd"。

   可用性: Unix, Windows。

   在 3.2 版更改: 添加对 Windows 6.0 (Vista) 符号链接的支持。

   3.3 新版功能: 添加了 *dir_fd* 参数，现在在非 Windows 平台上允许
   *target_is_directory* 参数。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *src* 和 *dst*。

   在 3.8 版更改: 针对启用了开发人员模式的 Windows，添加了非特权账户创
   建符号链接的支持。

os.sync()

   强制将所有内容写入磁盘。

   可用性: Unix。

   3.3 新版功能.

os.truncate(path, length)

   截断 *path* 对应的文件，以使其最大为 *length* 字节。

   本函数支持 指定文件描述符为参数。

   引发一个 审计事件 "os.truncate"，附带参数 "path", "length"。

   可用性: Unix, Windows。

   3.3 新版功能.

   在 3.5 版更改: 添加了 Windows 支持

   在 3.6 版更改: 接受一个 *类路径对象*。

os.unlink(path, *, dir_fd=None)

   移除（删除）文件 *path*。该函数在语义上与 "remove()" 相同，"unlink"
   是其传统的 Unix 名称。请参阅 "remove()" 的文档以获取更多信息。

   引发一个 审计事件 "os.remove"，附带参数 "path"、"dir_fd"。

   3.3 新版功能: *dir_fd* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.utime(path, times=None, *[, ns], dir_fd=None, follow_symlinks=True)

   设置文件 *path* 的访问时间和修改时间。

   "utime()" 有 *times* 和 *ns* 两个可选参数，它们指定了设置给 *path*
   的时间，用法如下：

   * 如果指定 *ns*，它必须是一个 "(atime_ns, mtime_ns)" 形式的二元组，
     其中每个成员都是一个表示纳秒的整数。

   * 如果 *times* 不为 "None"，则它必须是 "(atime, mtime)" 形式的二元
     组，其中每个成员都是一个表示秒的 int 或 float。

   * 如果 *times* 为 "None" 且未指定 *ns*，则相当于指定 "ns=(atime_ns,
     mtime_ns)"，其中两个时间均为当前时间。

   同时为 *times* 和 *ns* 指定元组会出错。

   注意，根据操作系统记录访问时间和修改时间的分辨率，后续的 "stat()"
   调用可能不会返回此处设置的确切时间。请参阅 "stat()"。保留精确时间的
   最佳方法是使用 "os.stat()" 结果对象中的 *st_atime_ns* 和
   *st_mtime_ns* 字段，并将 *ns* 参数设置为 *utime*。

   本函数支持 指定文件描述符、指定基于目录描述符的相对路径 和 不跟踪符
   号链接。

   引发一个 审计事件 "os.utime"，附带参数 "path"、"times"、"ns"、
   "dir_fd"。

   3.3 新版功能: 新增支持将 *path* 参数指定为打开的文件描述符，以及支
   持 *dir_fd*、*follow_symlinks* 和 *ns* 参数。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.walk(top, topdown=True, onerror=None, followlinks=False)

   生成目录树中的文件名，方式是按上->下或下->上顺序浏览目录树。对于以
   *top* 为根的目录树中的每个目录（包括 *top* 本身），它都会生成一个三
   元组 "(dirpath, dirnames, filenames)"。

   *dirpath* 是表示目录路径的字符串。 *dirnames* 是 *dirpath* 中子目录
   名称组成的列表 (excluding "'.'" and "'..'")。 *filenames* 是
   *dirpath* 中非目录文件名称组成的列表。 请注意列表中的名称不带路径部
   分。 要获取 *dirpath* 中文件或目录的完整路径（以 *top* 打头），请执
   行 "os.path.join(dirpath, name)"。 列表是否排序取决于具体文件系统。
   如果有文件或列表生成期间被移除或添加到 *dirpath* 目录中，是否要包括
   该文件的名称并没有规定。

   如果可选参数 *topdown* 为 "True" 或未指定，则在所有子目录的三元组之
   前生成父目录的三元组（目录是自上而下生成的）。如果 *topdown* 为
   "False"，则在所有子目录的三元组生成之后再生成父目录的三元组（目录是
   自下而上生成的）。无论 *topdown* 为何值，在生成目录及其子目录的元组
   之前，都将检索全部子目录列表。

   当 *topdown* 为 "True" 时，调用者可以就地修改 *dirnames* 列表（也许
   用到了 "del" 或切片），而 "walk()" 将仅仅递归到仍保留在 *dirnames*
   中的子目录内。这可用于减少搜索、加入特定的访问顺序，甚至可在继续
   "walk()" 之前告知 "walk()" 由调用者新建或重命名的目录的信息。当
   *topdown* 为 "False" 时，修改 *dirnames* 对 walk 的行为没有影响，因
   为在自下而上模式中，*dirnames* 中的目录是在 *dirpath* 本身之前生成
   的。

   默认将忽略 "scandir()" 调用中的错误。如果指定了可选参数 *onerror*，
   它应该是一个函数。出错时它会被调用，参数是一个 "OSError" 实例。它可
   以报告错误然后继续遍历，或者抛出异常然后中止遍历。注意，可以从异常
   对象的 "filename" 属性中获取出错的文件名。

   "walk()" 默认不会递归进指向目录的符号链接。可以在支持符号链接的系统
   上将 *followlinks* 设置为 "True"，以访问符号链接指向的目录。

   注解:

     注意，如果链接指向自身的父目录，则将 *followlinks* 设置为 "True"
     可能导致无限递归。"walk()" 不会记录它已经访问过的目录。

   注解:

     如果传入的是相对路径，请不要在恢复 "walk()" 之间更改当前工作目录
     。"walk()" 不会更改当前目录，并假定其调用者也不会更改当前目录。

   下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节
   数，CVS 子目录不会被遍历:

      import os
      from os.path import join, getsize
      for root, dirs, files in os.walk('python/Lib/email'):
          print(root, "consumes", end=" ")
          print(sum(getsize(join(root, name)) for name in files), end=" ")
          print("bytes in", len(files), "non-directory files")
          if 'CVS' in dirs:
              dirs.remove('CVS')  # don't visit CVS directories

   在下一个示例（"shutil.rmtree()" 的简单实现）中，必须使树自下而上遍
   历，因为 "rmdir()" 只允许在目录为空时删除目录:

      # Delete everything reachable from the directory named in "top",
      # assuming there are no symbolic links.
      # CAUTION:  This is dangerous!  For example, if top == '/', it
      # could delete all your disk files.
      import os
      for root, dirs, files in os.walk(top, topdown=False):
          for name in files:
              os.remove(os.path.join(root, name))
          for name in dirs:
              os.rmdir(os.path.join(root, name))

   引发一个 审计事件 "os.walk"，附带参数 "top", "topdown", "onerror",
   "followlinks"。

   在 3.5 版更改: 现在，本函数调用的是 "os.scandir()" 而不是
   "os.listdir()"，从而减少了调用 "os.stat()" 的次数而变得更快。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.fwalk(top='.', topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None)

   本方法的行为与 "walk()" 完全一样，除了它产生的是 4 元组 "(dirpath,
   dirnames, filenames, dirfd)"，并且它支持 "dir_fd"。

   *dirpath*、*dirnames* 和 *filenames* 与 "walk()" 输出的相同，
   *dirfd* 是指向目录 *dirpath* 的文件描述符。

   本函数始终支持 基于目录描述符的相对路径 和 不跟踪符号链接。但是请注
   意，与其他函数不同，"fwalk()" 的 *follow_symlinks* 的默认值为
   "False"。

   注解:

     由于 "fwalk()" 会生成文件描述符，而它们仅在下一个迭代步骤前有效，
     因此如果要将描述符保留更久，则应复制它们（比如使用 "dup()"）。

   下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节
   数，CVS 子目录不会被遍历:

      import os
      for root, dirs, files, rootfd in os.fwalk('python/Lib/email'):
          print(root, "consumes", end="")
          print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),
                end="")
          print("bytes in", len(files), "non-directory files")
          if 'CVS' in dirs:
              dirs.remove('CVS')  # don't visit CVS directories

   在下一个示例中，必须使树自下而上遍历，因为 "rmdir()" 只允许在目录为
   空时删除目录:

      # Delete everything reachable from the directory named in "top",
      # assuming there are no symbolic links.
      # CAUTION:  This is dangerous!  For example, if top == '/', it
      # could delete all your disk files.
      import os
      for root, dirs, files, rootfd in os.fwalk(top, topdown=False):
          for name in files:
              os.unlink(name, dir_fd=rootfd)
          for name in dirs:
              os.rmdir(name, dir_fd=rootfd)

   引发一个 审计事件 "os.fwalk"，附带参数 "top", "topdown", "onerror",
   "follow_symlinks", "dir_fd"。

   可用性: Unix。

   3.3 新版功能.

   在 3.6 版更改: 接受一个 *类路径对象*。

   在 3.7 版更改: 添加了对 "bytes" 类型路径的支持。

os.memfd_create(name[, flags=os.MFD_CLOEXEC])

   创建一个匿名文件，返回指向该文件的文件描述符。*flags* 必须是系统上
   可用的 "os.MFD_*" 常量之一（或将它们按位“或”组合起来）。新文件描述
   符默认是 不可继承的。

   *name* 提供的名称会被用作文件名，并且 "/proc/self/fd/" 目录中相应符
   号链接的目标将显示为该名称。显示的名称始终以 "memfd:" 为前缀，并且
   仅用于调试目的。名称不会影响文件描述符的行为，因此多个文件可以有相
   同的名称，不会有副作用。

   可用性：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。

   3.8 新版功能.

os.MFD_CLOEXEC
os.MFD_ALLOW_SEALING
os.MFD_HUGETLB
os.MFD_HUGE_SHIFT
os.MFD_HUGE_MASK
os.MFD_HUGE_64KB
os.MFD_HUGE_512KB
os.MFD_HUGE_1MB
os.MFD_HUGE_2MB
os.MFD_HUGE_8MB
os.MFD_HUGE_16MB
os.MFD_HUGE_32MB
os.MFD_HUGE_256MB
os.MFD_HUGE_512MB
os.MFD_HUGE_1GB
os.MFD_HUGE_2GB
os.MFD_HUGE_16GB

   以上标志位可以传递给 "memfd_create()"。

   可用性：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。
   "MFD_HUGE*" 标志仅在 Linux 4.14 及以上可用。

   3.8 新版功能.


Linux 扩展属性
--------------

3.3 新版功能.

这些函数仅在 Linux 上可用。

os.getxattr(path, attribute, *, follow_symlinks=True)

   返回 *path* 的扩展文件系统属性 *attribute* 的值。*attribute* 可以是
   bytes 或 str （直接传入或通过 "PathLike" 接口间接传入）。如果是 str
   ，则使用文件系统编码来编码字符串。

   本函数支持 指定文件描述符为参数 和 不跟踪符号链接。

   引发一个 审计事件 "os.getxattr"，附带参数 "path"、"attribute"。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *path* 和 *attribute*。

os.listxattr(path=None, *, follow_symlinks=True)

   返回一个列表，包含 *path* 的所有扩展文件系统属性。列表中的属性都表
   示为字符串，它们是根据文件系统编码解码出来的。如果 *path* 为 "None"
   ，则 "listxattr()" 将检查当前目录。

   本函数支持 指定文件描述符为参数 和 不跟踪符号链接。

   引发一个 审计事件 "os.listxattr"，附带参数 "path"。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.removexattr(path, attribute, *, follow_symlinks=True)

   从 *path* 中删除扩展文件系统属性 *attribute*。*attribute* 应该是
   bytes 或 str （直接传入或通过 "PathLike" 接口间接传入）。如果是 str
   ，则使用文件系统编码来编码字符串。

   本函数支持 指定文件描述符为参数 和 不跟踪符号链接。

   引发一个 审计事件 "os.removexattr"，附带参数 "path"、"attribute"。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *path* 和 *attribute*。

os.setxattr(path, attribute, value, flags=0, *, follow_symlinks=True)

   将 *path* 的扩展文件系统属性 *attribute* 设置为 *value*。
   *attribute* 必须是没有空字符的 bytes 或 str （直接传入或通过
   "PathLike" 接口间接传入）。如果是 str，则应使用文件系统编码进行编码
   。*flags* 可以是 "XATTR_REPLACE" 或 "XATTR_CREATE"。如果指定
   "XATTR_REPLACE" 而该属性不存在，则抛出 "EEXISTS" 异常。如果指定
   "XATTR_CREATE" 而该属性已经存在，则不会创建该属性，抛出 "ENODATA"
   异常。

   本函数支持 指定文件描述符为参数 和 不跟踪符号链接。

   注解:

     Linux kernel 2.6.39 以下版本的一个 bug 导致在某些文件系统上，
     flags 参数会被忽略。

   引发一个 审计事件 "os.setxattr"，附带参数 "path"、"attribute"、
   "value"、"flags"。

   在 3.6 版更改: 接受一个 *类路径对象* 作为 *path* 和 *attribute*。

os.XATTR_SIZE_MAX

   一条扩展属性的值的最大大小。在当前的 Linux 上是 64 KiB。

os.XATTR_CREATE

   这是 "setxattr()" 的 flags 参数的可取值，它表示该操作必须创建一个属
   性。

os.XATTR_REPLACE

   这是 "setxattr()" 的 flags 参数的可取值，它表示该操作必须替换现有属
   性。


进程管理
========

下列函数可用于创建和管理进程。

所有 "exec*" 函数都接受一个参数列表，用来给新程序加载到它的进程中。在
所有情况下，传递给新程序的第一个参数是程序本身的名称，而不是用户在命令
行上输入的参数。对于 C 程序员来说，这就是传递给 "main()" 函数的
"argv[0]"。例如，"os.execv('/bin/echo', ['foo', 'bar'])" 只会在标准输
出上打印 "bar"，而 "foo" 会被忽略。

os.abort()

   发送 "SIGABRT" 信号到当前进程。在 Unix 上，默认行为是生成一个核心转
   储。在 Windows 上，该进程立即返回退出代码 "3"。请注意，使用
   "signal.signal()" 可以为 "SIGABRT" 注册 Python 信号处理程序，而调用
   本函数将不会调用按前述方法注册的程序。

os.add_dll_directory(path)

   将路径添加到 DLL 搜索路径。

   当需要解析扩展模块的依赖时（扩展模块本身通过 sys.path 解析），会使
   用该搜索路径，"ctypes" 也会使用该搜索路径。

   要移除目录，可以在返回的对象上调用 **close()**，也可以在 "with" 语
   句内使用本方法。

   参阅 Microsoft 文档 获取如何加载 DLL 的信息。

   引发一个 审计事件 "os.add_dll_directory"，附带参数 "path"。

   可用性: Windows。

   3.8 新版功能: 早期版本的 CPython 解析 DLL 时用的是当前进程的默认行
   为。这会导致不一致，比如不是每次都会去搜索 "PATH" 和当前工作目录，
   且系统函数（如 "AddDllDirectory" ）失效。在 3.8 中，DLL 的两种主要
   加载方式现在可以显式覆盖进程的行为，以确保一致性。请参阅 移植说明
   了解如何更新你的库。

os.execl(path, arg0, arg1, ...)
os.execle(path, arg0, arg1, ..., env)
os.execlp(file, arg0, arg1, ...)
os.execlpe(file, arg0, arg1, ..., env)
os.execv(path, args)
os.execve(path, args, env)
os.execvp(file, args)
os.execvpe(file, args, env)

   这些函数都将执行一个新程序，以替换当前进程。它们没有返回值。在 Unix
   上，新程序会加载到当前进程中，且进程号与调用者相同。过程中的错误会
   被报告为 "OSError" 异常。

   当前进程会被立即替换。打开的文件对象和描述符都不会刷新，因此如果这
   些文件上可能缓冲了数据，则应在调用 "exec*" 函数之前使用
   "sys.stdout.flush()" 或 "os.fsync()" 刷新它们。

   "exec*" 函数的 "l" 和 "v" 变体不同在于命令行参数的传递方式。如果在
   编码时固定了参数数量，则 "l" 变体可能是最方便的，各参数作为
   "execl*()" 函数的附加参数传入即可。当参数数量可变时，"v" 变体更方便
   ，参数以列表或元组的形式作为 *args* 参数传递。在这两种情况下，子进
   程的第一个参数都应该是即将运行的命令名称，但这不是强制性的。

   结尾包含 "p" 的变体（"execlp()"、"execlpe()"、"execvp()" 和
   "execvpe()" ）将使用 "PATH" 环境变量来查找程序 *file*。当环境被替换
   时（使用下一段讨论的 "exec*e" 变体之一），"PATH" 变量将来自于新环境
   。其他变体 "execl()"、"execle()"、"execv()" 和 "execve()" 不使用
   "PATH" 变量来查找程序，因此 *path* 必须包含正确的绝对或相对路径。

   对于 "execle()"、"execlpe()"、"execve()" 和 "execvpe()" （都以 "e"
   结尾），*env* 参数是一个映射，用于定义新进程的环境变量（代替当前进
   程的环境变量）。而函数 "execl()"、"execlp()"、"execv()" 和
   "execvp()" 会将当前进程的环境变量过继给新进程。

   某些平台上的 "execve()" 可以将 *path* 指定为打开的文件描述符。当前
   平台可能不支持此功能，可以使用 "os.supports_fd" 检查它是否支持。如
   果不可用，则使用它会抛出 "NotImplementedError" 异常。

   引发一个 审计事件 "os.exec"，附带参数 "path"、"args"、"env"。

   可用性: Unix, Windows。

   3.3 新版功能: 新增支持将 "execve()" 的 *path* 参数指定为打开的文件
   描述符。

   在 3.6 版更改: 接受一个 *类路径对象*。

os._exit(n)

   以状态码 *n* 退出进程，不会调用清理处理程序，不会刷新 stdio，等等。

   注解:

     退出的标准方法是使用 "sys.exit(n)"。而 "_exit()" 通常只应在
     "fork()" 出的子进程中使用。

以下是已定义的退出代码，可以用于 "_exit()"，尽管它们不是必需的。这些退
出代码通常用于 Python 编写的系统程序，例如邮件服务器的外部命令传递程序
。

注解:

  其中部分退出代码在部分 Unix 平台上可能不可用，因为平台间存在差异。如
  果底层平台定义了这些常量，那上层也会定义。

os.EX_OK

   退出代码，表示未发生任何错误。

   可用性: Unix。

os.EX_USAGE

   退出代码，表示命令使用不正确，如给出的参数数量有误。

   可用性: Unix。

os.EX_DATAERR

   退出代码，表示输入数据不正确。

   可用性: Unix。

os.EX_NOINPUT

   退出代码，表示某个输入文件不存在或不可读。

   可用性: Unix。

os.EX_NOUSER

   退出代码，表示指定的用户不存在。

   可用性: Unix。

os.EX_NOHOST

   退出代码，表示指定的主机不存在。

   可用性: Unix。

os.EX_UNAVAILABLE

   退出代码，表示所需的服务不可用。

   可用性: Unix。

os.EX_SOFTWARE

   退出代码，表示检测到内部软件错误。

   可用性: Unix。

os.EX_OSERR

   退出代码，表示检测到操作系统错误，例如无法 fork 或创建管道。

   可用性: Unix。

os.EX_OSFILE

   退出代码，表示某些系统文件不存在、无法打开或发生其他错误。

   可用性: Unix。

os.EX_CANTCREAT

   退出代码，表示无法创建用户指定的输出文件。

   可用性: Unix。

os.EX_IOERR

   退出代码，表示对某些文件进行读写时发生错误。

   可用性: Unix。

os.EX_TEMPFAIL

   退出代码，表示发生了暂时性故障。它可能并非意味着真正的错误，例如在
   可重试的情况下无法建立网络连接。

   可用性: Unix。

os.EX_PROTOCOL

   退出代码，表示协议交换是非法的、无效的或无法解读的。

   可用性: Unix。

os.EX_NOPERM

   退出代码，表示没有足够的权限执行该操作（但不适用于文件系统问题）。

   可用性: Unix。

os.EX_CONFIG

   退出代码，表示发生某种配置错误。

   可用性: Unix。

os.EX_NOTFOUND

   退出代码，表示的内容类似于“找不到条目”。

   可用性: Unix。

os.fork()

   Fork 出一个子进程。在子进程中返回 "0"，在父进程中返回子进程的进程号
   。如果发生错误，则抛出 "OSError" 异常。

   注意，当从线程中使用 "fork()" 时，某些平台（包括 FreeBSD <= 6.3 和
   Cygwin）存在已知问题。

   引发一个 审计事件 "os.fork"，没有附带参数。

   在 3.8 版更改: 不再支持在子解释器中调用 "fork()" （将抛出
   "RuntimeError" 异常）。

   警告:

     有关 SSL 模块与 fork() 结合的应用，请参阅 "ssl"。

   可用性: Unix。

os.forkpty()

   Fork 出一个子进程，使用新的伪终端作为子进程的控制终端。返回一对
   "(pid, fd)"，其中 *pid* 在子进程中为 "0"，这是父进程中新子进程的进
   程号，而 *fd* 是伪终端主设备的文件描述符。对于更便于移植的方法，请
   使用 "pty" 模块。如果发生错误，则抛出 "OSError" 异常。

   引发一个 审计事件 "os.forkpty"，没有附带参数。

   在 3.8 版更改: 不再支持在子解释器中调用 "forkpty()" （将抛出
   "RuntimeError" 异常）。

   可用性: 某些 Unix。

os.kill(pid, sig)

   将信号 *sig* 发送至进程 *pid*。特定平台上可用的信号常量定义在
   "signal" 模块中。

   Windows： "signal.CTRL_C_EVENT" 和 "signal.CTRL_BREAK_EVENT" 信号是
   特殊信号，只能发送给共享同一个控制台窗口的控制台进程，如某些子进程
   。*sig* 取任何其他值将导致该进程被 TerminateProcess API 无条件终止
   ，且退出代码为 *sig*。Windows 版本的 "kill()" 还需要传入待结束进程
   的句柄。

   另请参阅 "signal.pthread_kill()"。

   引发一个 审计事件 "os.kill"，附带参数 "pid"、"sig"。

   3.2 新版功能: Windows 支持。

os.killpg(pgid, sig)

   将信号 *sig* 发送给进程组 *pgid*。

   引发一个 审计事件 "os.killpg"，附带参数 "pgid"、"sig"。

   可用性: Unix。

os.nice(increment)

   将进程的优先级（nice 值）增加 *increment*，返回新的 nice 值。

   可用性: Unix。

os.pidfd_open(pid, flags=0)

   返回一个文件描述符，它指向进程 *pid*。该描述符可用于管理进程，避免
   出现竞争和信号。*flags* 参数提供给将来扩展使用，当前没有定义标志值
   。

   更多详细信息请参阅 *pidfd_open(2)* 手册页。

   可用性: Linux 5.3+。

   3.9 新版功能.

os.plock(op)

   将程序段锁定到内存中。*op* 的值（定义在 "<sys/lock.h>" 中）决定了哪
   些段被锁定。

   可用性: Unix。

os.popen(cmd, mode='r', buffering=-1)

   打开一个管道，它通往 / 接受自命令 *cmd*。返回值是连接到管道的文件对
   象，根据 *mode* 是 "'r'" （默认）还是 "'w'" 决定该对象可以读取还是
   写入。*buffering* 参数与内置函数 "open()" 相应的参数含义相同。返回
   的文件对象只能读写文本字符串，不能是字节类型。

   如果子进程成功退出，则 "close" 方法返回 "None"。如果发生错误，则返
   回子进程的返回码。在 POSIX 系统上，如果返回码为正，则它就是进程返回
   值左移一个字节后的值。如果返回码为负，则进程是被信号终止的，返回码
   取反后就是该信号。（例如，如果子进程被终止，则返回值可能是 "-
   signal.SIGKILL"。）在 Windows 系统上，返回值包含子进程的返回码（有
   符号整数）。

   在 Unix 上，"waitstatus_to_exitcode()" 可以将 "close" 方法的返回值
   （即退出状态，不能是 "None"）转换为退出码。在 Windows 上，"close"
   方法的结果直接就是退出码（或 "None" ）。

   本方法是使用 "subprocess.Popen" 实现的，如需更强大的方法来管理和沟
   通子进程，请参阅该类的文档。

os.posix_spawn(path, argv, env, *, file_actions=None, setpgroup=None, resetids=False, setsid=False, setsigmask=(), setsigdef=(), scheduler=None)

   包装 "posix_spawn()" C 库 API，使其可以从 Python 调用。

   大多数用户应使用 "subprocess.run()" 代替 "posix_spawn()"。

   仅位置参数 (Positional-only arguments) *path*、*args* 和 *env* 与
   "execve()" 中的类似。

   *path* 形参是可执行文件的路径，*path* 中应当包含目录。 使用
   "posix_spawnp()" 可传入不带目录的可执行文件。

   *file_actions* 参数可以是由元组组成的序列，序列描述了对子进程中指定
   文件描述符采取的操作，这些操作会在 C 库实现的 "fork()" 和 "exec()"
   步骤间完成。每个元组的第一个元素必须是下面列出的三个类型指示符之一
   ，用于描述元组剩余的元素：

   os.POSIX_SPAWN_OPEN

      ("os.POSIX_SPAWN_OPEN", *fd*, *path*, *flags*, *mode*)

      执行 "os.dup2(os.open(path, flags, mode), fd)"。

   os.POSIX_SPAWN_CLOSE

      ("os.POSIX_SPAWN_CLOSE", *fd*)

      执行 "os.close(fd)"。

   os.POSIX_SPAWN_DUP2

      ("os.POSIX_SPAWN_DUP2", *fd*, *new_fd*)

      执行 "os.dup2(fd, new_fd)"。

   这些元组对应于 C 库 "posix_spawn_file_actions_addopen()"，
   "posix_spawn_file_actions_addclose()" 和
   "posix_spawn_file_actions_adddup2()" API 调用，它们为调用
   "posix_spawn()" 自身做准备。

   *setpgroup* 参数将子进程的进程组设置为指定值。如果指定值为 0，则子
   进程的进程组 ID 将与其进程 ID 相同。如果未设置 *setpgroup* 值，则子
   进程将继承父进程的进程组 ID。本参数对应于 C 库
   "POSIX_SPAWN_SETPGROUP" 标志。

   如果 *resetids* 参数为 "True"，则会将子进程的有效用户 ID 和有效组
   ID 重置为父进程的实际用户 ID 和实际组 ID。如果该参数为 "False"，则
   子进程保留父进程的有效用户 ID 和有效组 ID。无论哪种情况，若在可执行
   文件上启用了 “设置用户 ID” 和 “设置组 ID” 权限位，它们将覆盖有效用
   户 ID 和有效组 ID 的设置。本参数对应于 C 库 "POSIX_SPAWN_RESETIDS"
   标志。

   如果 *setsid* 参数为 "True"，它将为 *posix_spawn* 新建一个会话 ID。
   *setsid* 需要 "POSIX_SPAWN_SETSID" 或 "POSIX_SPAWN_SETSID_NP" 标志
   ，否则会抛出 "NotImplementedError" 异常。

   *setsigmask* 参数将信号掩码设置为指定的信号集合。如果未使用该参数，
   则子进程将继承父进程的信号掩码。本参数对应于 C 库
   "POSIX_SPAWN_SETSIGMASK" 标志。

   *sigdef* 参数将集合中所有信号的操作全部重置为默认。本参数对应于 C
   库 "POSIX_SPAWN_SETSIGDEF" 标志。

   *scheduler* 参数必须是一个元组，其中包含调度器策略（可选）以及携带
   了调度器参数的 "sched_param" 实例。在调度器策略所在位置为 "None" 表
   示未提供该值。本参数是 C 库 "POSIX_SPAWN_SETSCHEDPARAM" 和
   "POSIX_SPAWN_SETSCHEDULER" 标志的组合。

   引发一个 审计事件 "os.posix_spawn"，附带参数 "path"、"argv"、"env"
   。

   3.8 新版功能.

   可用性: Unix。

os.posix_spawnp(path, argv, env, *, file_actions=None, setpgroup=None, resetids=False, setsid=False, setsigmask=(), setsigdef=(), scheduler=None)

   包装 "posix_spawnp()" C 库 API，使其可以从 Python 调用。

   与 "posix_spawn()" 相似，但是系统会在 "PATH" 环境变量指定的目录列表
   中搜索可执行文件 *executable* （与 "execvp(3)" 相同）。

   引发一个 审计事件 "os.posix_spawn"，附带参数 "path"、"argv"、"env"
   。

   3.8 新版功能.

   可用性: 请参阅 "posix_spawn()" 文档。

os.register_at_fork(*, before=None, after_in_parent=None, after_in_child=None)

   注册可调用对象，在使用 "os.fork()" 或类似的进程克隆 API 派生新的子
   进程时，这些对象会运行。参数是可选的，且为仅关键字 (Keyword-only)
   参数。每个参数指定一个不同的调用点。

   * *before* 是一个函数，在 fork 子进程前调用。

   * *after_in_parent* 是一个函数，在 fork 子进程后从父进程调用。

   * *after_in_child* 是一个函数，从子进程中调用。

   只有希望控制权回到 Python 解释器时，才进行这些调用。典型的 "子进程"
   启动时不会触发它们，因为子进程不会重新进入解释器。

   在注册的函数中，用于 fork 前运行的函数将按与注册相反的顺序调用。用
   于 fork 后（从父进程或子进程）运行的函数按注册顺序调用。

   注意，第三方 C 代码的 "fork()" 调用可能不会调用这些函数，除非它显式
   调用了 "PyOS_BeforeFork()"、"PyOS_AfterFork_Parent()" 和
   "PyOS_AfterFork_Child()"。

   函数注册后无法注销。

   可用性: Unix。

   3.7 新版功能.

os.spawnl(mode, path, ...)
os.spawnle(mode, path, ..., env)
os.spawnlp(mode, file, ...)
os.spawnlpe(mode, file, ..., env)
os.spawnv(mode, path, args)
os.spawnve(mode, path, args, env)
os.spawnvp(mode, file, args)
os.spawnvpe(mode, file, args, env)

   在新进程中执行程序 *path*。

   （注意，"subprocess" 模块提供了更强大的工具来生成新进程并跟踪执行结
   果，使用该模块比使用这些函数更好。尤其应当检查 使用 subprocess 模块
   替换旧函数 部分。）

   *mode* 为 "P_NOWAIT" 时，本函数返回新进程的进程号。*mode* 为
   "P_WAIT" 时，如果进程正常退出，返回退出代码，如果被终止，返回
   "-signal"，其中 *signal* 是终止进程的信号。在 Windows 上，进程号实
   际上是进程句柄，因此可以与 "waitpid()" 函数一起使用。

   注意在 VxWorks 上，新进程被终止时，本函数不会返回 "-signal"，而是会
   抛出 OSError 异常。

   "spawn*" 函数的 "l" 和 "v" 变体不同在于命令行参数的传递方式。如果在
   编码时固定了参数数量，则 "l" 变体可能是最方便的，各参数作为
   "spawnl*()" 函数的附加参数传入即可。当参数数量可变时，"v" 变体更方
   便，参数以列表或元组的形式作为 *args* 参数传递。在这两种情况下，子
   进程的第一个参数都必须是即将运行的命令名称。

   结尾包含第二个 "p" 的变体（"spawnlp()"、"spawnlpe()"、"spawnvp()"
   和 "spawnvpe()"）将使用 "PATH" 环境变量来查找程序 *file*。当环境被
   替换时（使用下一段讨论的 "spawn*e" 变体之一），"PATH" 变量将来自于
   新环境。其他变体 "spawnl()"、"spawnle()"、"spawnv()" 和 "spawnve()"
   不使用 "PATH" 变量来查找程序，因此 *path* 必须包含正确的绝对或相对
   路径。

   对于 "spawnle()"、"spawnlpe()"、"spawnve()" 和 "spawnvpe()" （都以
   "e" 结尾），*env* 参数是一个映射，用于定义新进程的环境变量（代替当
   前进程的环境变量）。而函数 "spawnl()"、"spawnlp()"、"spawnv()" 和
   "spawnvp()" 会将当前进程的环境变量过继给新进程。注意，*env* 字典中
   的键和值必须是字符串。无效的键或值将导致函数出错，返回值为 "127"。

   例如，以下对 "spawnlp()" 和 "spawnvpe()" 的调用是等效的:

      import os
      os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')

      L = ['cp', 'index.html', '/dev/null']
      os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)

   引发一个 审计事件 "os.spawn"，附带参数 "mode"、"path"、"args"、
   "env"。

   可用性: Unix, Windows。"spawnlp()"、"spawnlpe()"、"spawnvp()" 和
   "spawnvpe()" 在 Windows 上不可用。"spawnle()" 和 "spawnve()" 在
   Windows 上不是线程安全的，建议使用 "subprocess" 模块替代。

   在 3.6 版更改: 接受一个 *类路径对象*。

os.P_NOWAIT
os.P_NOWAITO

   "spawn*" 系列函数的 *mode* 参数的可取值。如果给出这些值中的任何一个
   ，则 "spawn*()" 函数将在创建新进程后立即返回，且返回值为进程号。

   可用性: Unix, Windows。

os.P_WAIT

   "spawn*" 系列函数的 *mode* 参数的可取值。如果将 *mode* 指定为该值，
   则 "spawn*()" 函数将在新进程运行完毕后返回，运行成功则返回进程的退
   出代码，被信号终止则返回 "-signal"。

   可用性: Unix, Windows。

os.P_DETACH
os.P_OVERLAY

   "spawn*" 系列函数的 *mode* 参数的可取值。它们比上面列出的值可移植性
   差。"P_DETACH" 与 "P_NOWAIT" 相似，但是新进程会与父进程的控制台脱离
   。使用 "P_OVERLAY" 则会替换当前进程，"spawn*" 函数将不会返回。

   可用性: Windows。

os.startfile(path[, operation])

   使用已关联的应用程序打开文件。

   当 *operation* 未指定或指定为 "'open'" 时，这类似于在 Windows 资源
   管理器中双击文件，或在交互式命令行中将文件名作为 **start** 命令的参
   数：通过扩展名相关联的应用程序（如果有）打开文件。

   当指定另一个 *operation* 时，它必须是一个“命令动词” ("command
   verb")，该词指定对文件执行的操作。Microsoft 文档中的常用动词有
   "'print'" 和 "'edit'" （用于文件），以及 "'explore'" 和 "'find'" （
   用于目录）。

   关联的应用程序启动后 "startfile()" 就会立即返回。本函数没有等待应用
   程序关闭的选项，也没有办法检索应用程序的退出状态。*path* 参数是基于
   当前目录的相对路径。如果要使用绝对路径，请确保第一个字符不是斜杠
   ("'/'")，是斜杠的话底层的 Win32 "ShellExecute()" 函数将失效。使用
   "os.path.normpath()" 函数确保路径已针对 Win32 正确编码。

   为了减少解释器的启动开销，直到第一次调用本函数后，才解析 Win32
   "ShellExecute()" 函数。如果无法解析该函数​​，则抛出
   "NotImplementedError" 异常。

   引发一个 审计事件 "os.startfile"，附带参数 "path"、"operation"。

   可用性: Windows。

os.system(command)

   在子 shell 中执行命令（字符串）。这是调用标准 C 函数 "system()" 来
   实现的，因此限制条件与该函数相同。对 "sys.stdin" 等的更改不会反映在
   执行命令的环境中。*command* 产生的任何输出将被发送到解释器标准输出
   流。

   在 Unix 上，返回值是进程的退出状态，编码格式与为 "wait()" 指定的格
   式相同。注意，POSIX 没有指定 C 函数 "system()" 返回值的含义，因此
   Python 函数的返回值与系统有关。

   在 Windows 上，返回值是运行 *command* 后系统 Shell 返回的值。该
   Shell 由 Windows 环境变量 "COMSPEC": 给出：通常是 **cmd.exe**，它会
   返回命令的退出状态。在使用非原生 Shell 的系统上，请查阅 Shell 的文
   档。

   "subprocess" 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用
   该模块比使用本函数更好。参阅 "subprocess" 文档中的 使用 subprocess
   模块替换旧函数 部分以获取有用的帮助。

   在 Unix 上，"waitstatus_to_exitcode()" 可以将返回值（即退出状态）转
   换为退出码。在 Windows 上，返回值就是退出码。

   引发一个 审计事件 "os.system"，附带参数 "command"。

   可用性: Unix, Windows。

os.times()

   返回当前的全局进程时间。返回值是一个有 5 个属性的对象：

   * "user" - 用户时间

   * "system" - 系统时间

   * "children_user" - 所有子进程的用户时间

   * "children_system" - 所有子进程的系统时间

   * "elapsed" - 从过去的固定时间点起，经过的真实时间

   为了向后兼容，该对象的行为也类似于五元组，按照 "user"，"system"，
   "children_user"，"children_system" 和 "elapsed" 顺序组成。

   在 Unix 上请参阅 *times(2)* 和 *times(3)* 手册页，在 Windows 上请参
   阅 the GetProcessTimes MSDN 。在 Windows 上，只有 "user" 和
   "system" 是已知的，其他属性均为零。

   可用性: Unix, Windows。

   在 3.3 版更改: 返回结果的类型由元组变成一个类似元组的对象，同时具有
   命名的属性。

os.wait()

   等待子进程执行完毕，返回一个元组，包含其 pid 和退出状态指示：一个
   16 位数字，其低字节是终止该进程的信号编号，高字节是退出状态码（信号
   编号为零的情况下），如果生成了核心文件，则低字节的高位会置位。

   可以使用 "waitstatus_to_exitcode()" 来将退出状态转换为退出码。

   可用性: Unix。

   参见: "waitpid()" 可以等待特定的子进程执行完毕，且支持更多选项。

os.waitid(idtype, id, options)

   等待一个或多个子进程执行完毕。*idtype* 可以是 "P_PID", "P_PGID",
   "P_ALL", 或 "P_PIDFD" （Linux 可用）。*id* 指定要等待的 pid。
   *options* 是由 "WEXITED"、"WSTOPPED" 或 "WCONTINUED" 中的一个或多个
   进行或运算构造的，且额外可以与 "WNOHANG" 或 "WNOWAIT" 进行或运算。
   返回值是一个对象，对应着 "siginfo_t" 结构体中的数据，即： "si_pid",
   "si_uid", "si_signo", "si_status", "si_code" 或 "None" （如果指定了
   "WNOHANG" 且没有子进程处于等待状态）。

   可用性: Unix。

   3.3 新版功能.

os.P_PID
os.P_PGID
os.P_ALL

   "waitid()" 的 *idtype* 参数的可取值。它们影响 *id* 的解释方式。

   可用性: Unix。

   3.3 新版功能.

os.P_PIDFD

   这是仅 Linux 上存在的一种 *idtype*，它表示 *id* 是指向一个进程的文
   件描述符。

   可用性: Linux 5.4+

   3.9 新版功能.

os.WEXITED
os.WSTOPPED
os.WNOWAIT

   用于 "waitid()" 的 *options* 参数的标志位，指定要等待的子进程信号。

   可用性: Unix。

   3.3 新版功能.

os.CLD_EXITED
os.CLD_KILLED
os.CLD_DUMPED
os.CLD_TRAPPED
os.CLD_STOPPED
os.CLD_CONTINUED

   "waitid()" 返回的结果中，"si_code" 的可取值。

   可用性: Unix。

   3.3 新版功能.

   在 3.9 版更改: 添加了 "CLD_KILLED" 和 "CLD_STOPPED" 值。

os.waitpid(pid, options)

   本函数的细节在 Unix 和 Windows 上有不同之处。

   在 Unix 上：等待进程号为 *pid* 的子进程执行完毕，返回一个元组，内含
   其进程 ID 和退出状态指示（编码与 "wait()" 相同）。调用的语义受整数
   *options* 的影响，常规操作下该值应为 "0"。

   如果 *pid* 大于 "0"，则 "waitpid()" 会获取该指定进程的状态信息。如
   果 *pid* 为 "0"，则获取当前进程所在进程组中的所有子进程的状态。如果
   *pid* 为 "-1"，则获取当前进程的子进程状态。如果 *pid* 小于 "-1"，则
   获取进程组 "-pid" （ *pid* 的绝对值）中所有进程的状态。

   当系统调用返回 -1 时，将抛出带有错误码的 "OSError" 异常。

   在 Windows 上：等待句柄为 *pid* 的进程执行完毕，返回一个元组，内含
   *pid* 以及左移 8 位后的退出状态码（移位简化了跨平台使用本函数）。小
   于或等于 "0" 的 *pid* 在 Windows 上没有特殊含义，且会抛出异常。整数
   值 *options* 无效。*pid* 可以指向任何 ID 已知的进程，不一定是子进程
   。调用 "spawn*" 函数时传入 "P_NOWAIT" 将返回合适的进程句柄。

   可以使用 "waitstatus_to_exitcode()" 来将退出状态转换为退出码。

   在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函
   数现在会重试系统调用，而不是触发 "InterruptedError" 异常 (原因详见
   **PEP 475**)。

os.wait3(options)

   与 "waitpid()" 相似，差别在于没有进程 ID 参数，且返回一个 3 元组，
   其中包括子进程 ID，退出状态指示和资源使用信息。关于资源使用信息的详
   情，请参考 "resource"."getrusage()"。option 参数与传入 "waitpid()"
   和 "wait4()" 的相同。

   可以使用 "waitstatus_to_exitcode()" 来将退出状态转换为退出码。

   可用性: Unix。

os.wait4(pid, options)

   与 "waitpid()" 相似，差别在本方法返回一个 3 元组，其中包括子进程 ID
   ，退出状态指示和资源使用信息。关于资源使用信息的详情，请参考
   "resource"."getrusage()"。"wait4()" 的参数与 "waitpid()" 的参数相同
   。

   可以使用 "waitstatus_to_exitcode()" 来将退出状态转换为退出码。

   可用性: Unix。

os.waitstatus_to_exitcode(status)

   将等待状态转换为退出码。

   在 Unix 上：

   * 如果进程正常退出（当 "WIFEXITED(status)" 为真值），则返回进程退出
     状态 (返回 "WEXITSTATUS(status)"): 结果值大于等于 0。

   * 如果进程被信号终止（当 "WIFSIGNALED(status)" 为真值），则返回
     "-signum" 其中 *signum* 为导致进程终止的信号数值 (返回
     "-WTERMSIG(status)"): 结果值小于 0。

   * 否则将抛出 "ValueError" 异常。

   在 Windows 上，返回 *status* 右移 8 位的结果。

   在 Unix 上，如果进程正被追踪或 "waitpid()" 附带 "WUNTRACED" 选项被
   调用，则调用者必须先检查 "WIFSTOPPED(status)" 是否为真值。 如果
   "WIFSTOPPED(status)" 为真值则此函数不可被调用。

   参见:

     "WIFEXITED()", "WEXITSTATUS()", "WIFSIGNALED()", "WTERMSIG()",
     "WIFSTOPPED()", "WSTOPSIG()" 函数。

   3.9 新版功能.

os.WNOHANG

   用于 "waitpid()" 的选项，如果没有立即可用的子进程状态，则立即返回。
   在这种情况下，函数返回 "(0, 0)"。

   可用性: Unix。

os.WCONTINUED

   被任务控制 (job control) 停止的子进程，如果上次报告状态后已恢复运行
   ，则此选项将报告这些子进程。

   可用性: 部分 Unix 系统。

os.WUNTRACED

   已停止的子进程，如果自停止以来尚未报告其当前状态，则此选项将报告这
   些子进程。

   可用性: Unix。

下列函数采用进程状态码作为参数，状态码由 "system()"、"wait()" 或
"waitpid()" 返回。它们可用于确定进程上发生的操作。

os.WCOREDUMP(status)

   如果为该进程生成了核心转储，返回 "True"，否则返回 "False"。

   此函数应当仅在 "WIFSIGNALED()" 为真值时使用。

   可用性: Unix。

os.WIFCONTINUED(status)

   如果一个已停止的子进程通过传送 "SIGCONT" 获得恢复（如果该进程是从任
   务控制停止后再继续的）则返回 "True"，否则返回 "False"。

   参见 "WCONTINUED" 选项。

   可用性: Unix。

os.WIFSTOPPED(status)

   如果进程是通过传送一个信号来停止的则返回 "True"，否则返回 "False"。

   "WIFSTOPPED()" 只有在当 "waitpid()" 调用是通过使用 "WUNTRACED" 选项
   来完成或者当该进程正被追踪时 (参见 *ptrace(2)*) 才返回 "True"。

   可用性: Unix。

os.WIFSIGNALED(status)

   如果进程是通过一个信号来终止的则返回 "True" ，否则返回 "False"。

   可用性: Unix。

os.WIFEXITED(status)

   如果进程正常终止退出则返回 "True"，也就是说通过调用 "exit()" 或
   "_exit()"，或者通过从 "main()" 返回；在其他情况下则返回 "False"。

   可用性: Unix。

os.WEXITSTATUS(status)

   返回进程退出状态。

   此函数应当仅在 "WIFEXITED()" 为真值时使用。

   可用性: Unix。

os.WSTOPSIG(status)

   返回导致进程停止的信号。

   此函数应当仅在 "WIFSTOPPED()" 为真值时使用。

   可用性: Unix。

os.WTERMSIG(status)

   返回导致进程终止的信号的编号。

   此函数应当仅在 "WIFSIGNALED()" 为真值时使用。

   可用性: Unix。


调度器接口
==========

这些函数控制操作系统如何为进程分配 CPU 时间。 它们仅在某些 Unix 平台上
可用。 更多细节信息请查阅你所用 Unix 的指南页面。

3.3 新版功能.

以下调度策略如果被操作系统支持就会对外公开。

os.SCHED_OTHER

   默认调度策略。

os.SCHED_BATCH

   用于 CPU 密集型进程的调度策略，它会尽量为计算机中的其余任务保留交互
   性。

os.SCHED_IDLE

   用于极低优先级的后台任务的调度策略。

os.SCHED_SPORADIC

   用于偶发型服务程序的调度策略。

os.SCHED_FIFO

   先进先出的调度策略。

os.SCHED_RR

   循环式的调度策略。

os.SCHED_RESET_ON_FORK

   此旗标可与任何其他调度策略进行 OR 运算。 当带有此旗标的进程设置分叉
   时，其子进程的调度策略和优先级会被重置为默认值。

class os.sched_param(sched_priority)

   这个类表示在 "sched_setparam()", "sched_setscheduler()" 和
   "sched_getparam()" 中使用的可修改调度形参。 它属于不可变对象。

   目前它只有一个可能的形参：

   sched_priority

      一个调度策略的调度优先级。

os.sched_get_priority_min(policy)

   获取 *policy* 的最小优先级数值。 *policy* 是以上调度策略常量之一。

os.sched_get_priority_max(policy)

   获取 *policy* 的最高优先级数值。 *policy* 是以上调度策略常量之一。

os.sched_setscheduler(pid, policy, param)

   设置 PID 为 *pid* 的进程的调度策略。*pid* 为 0 指的是调用本方法的进
   程。*policy* 是以上调度策略常量之一。*param* 是一个 "sched_param"
   实例。

os.sched_getscheduler(pid)

   返回 PID 为 *pid* 的进程的调度策略。*pid* 为 0 指的是调用本方法的进
   程。返回的结果是以上调度策略常量之一。

os.sched_setparam(pid, param)

   设置 PID 为 *pid* 的进程的某个调度参数。*pid* 为 0 指的是调用本方法
   的进程。*param* 是一个 "sched_param" 实例。

os.sched_getparam(pid)

   返回 PID 为 *pid* 的进程的调度参数为一个 "sched_param" 实例。*pid*
   为 0 指的是调用本方法的进程。

os.sched_rr_get_interval(pid)

   返回 PID 为 *pid* 的进程在时间片轮转调度下的时间片长度（单位为秒）
   。*pid* 为 0 指的是调用本方法的进程。

os.sched_yield()

   自愿放弃 CPU。

os.sched_setaffinity(pid, mask)

   将 PID 为 *pid* 的进程（为零则为当前进程）限制到一组 CPU 上。*mask*
   是整数的可迭代对象，表示应将进程限制在其中的一组 CPU。

os.sched_getaffinity(pid)

   返回 PID 为 *pid* 的进程（为零则为当前进程）被限制到的那一组 CPU。


其他系统信息
============

os.confstr(name)

   返回字符串格式的系统配置信息。*name* 指定要查找的配置名称，它可以是
   字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX，Unix
   95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已
   定义的名称在 "confstr_names" 字典的键中给出。对于未包含在该映射中的
   配置名称，也可以传递一个整数作为 *name*。

   如果 *name* 指定的配置值未定义，返回 "None"。

   如果 *name* 是一个字符串且不是已定义的名称，将抛出 "ValueError" 异
   常。如果当前系统不支持 *name* 指定的配置名称，即使该名称存在于
   "confstr_names"，也会抛出 "OSError" 异常，错误码为 "errno.EINVAL"。

   可用性: Unix。

os.confstr_names

   字典，表示映射关系，为 "confstr()" 可接受名称与操作系统为这些名称定
   义的整数值之间的映射。这可用于判断系统已定义了哪些名称。

   可用性: Unix。

os.cpu_count()

   返回系统的 CPU 数量。不确定则返回 "None"。

   该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由
   "len(os.sched_getaffinity(0))" 方法获得。

   3.4 新版功能.

os.getloadavg()

   返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数。无法获得平均
   负载则抛出 "OSError" 异常。

   可用性: Unix。

os.sysconf(name)

   返回整数格式的系统配置信息。如果 *name* 指定的配置值未定义，返回
   "-1"。对 "confstr()" 的 *name* 参数的注释在此处也适用。当前已知的配
   置名称在 "sysconf_names" 字典中提供。

   可用性: Unix。

os.sysconf_names

   字典，表示映射关系，为 "sysconf()" 可接受名称与操作系统为这些名称定
   义的整数值之间的映射。这可用于判断系统已定义了哪些名称。

   可用性: Unix。

以下数据值用于支持对路径本身的操作。所有平台都有定义。

对路径的高级操作在 "os.path" 模块中定义。

os.curdir

   操作系统用来表示当前目录的常量字符串。在 Windows 和 POSIX 上是
   "'.'"。在 "os.path" 中也可用。

os.pardir

   操作系统用来表示父目录的常量字符串。在 Windows 和 POSIX 上是 "'..'"
   。在 "os.path" 中也可用。

os.sep

   操作系统用来分隔路径不同部分的字符。在 POSIX 上是 "'/'"，在 Windows
   上是是 "'\\'"。注意，仅了解它不足以能解析或连接路径，请使用
   "os.path.split()" 和 "os.path.join()"，但它有时是有用的。在
   "os.path" 中也可用。

os.altsep

   操作系统用来分隔路径不同部分的替代字符。如果仅存在一个分隔符，则为
   "None"。在 "sep" 是反斜杠的 Windows 系统上，该值被设为 "'/'"。在
   "os.path" 中也可用。

os.extsep

   分隔基本文件名与扩展名的字符，如 "os.py" 中的 "'.'"。在 "os.path"
   中也可用。

os.pathsep

   操作系统通常用于分隔搜索路径（如 "PATH"）中不同部分的字符，如 POSIX
   上是 "':'"，Windows 上是 "';'"。在 "os.path" 中也可用。

os.defpath

   在环境变量没有 "'PATH'" 键的情况下，"exec*p*" and "spawn*p*" 使用的
   默认搜索路径。在 "os.path" 中也可用。

os.linesep

   当前平台用于分隔（或终止）行的字符串。它可以是单个字符，如 POSIX 上
   是 "'\n'"，也可以是多个字符，如 Windows 上是 "'\r\n'"。在写入以文本
   模式（默认模式）打开的文件时，请不要使用 *os.linesep* 作为行终止符
   ，请在所有平台上都使用一个 "'\n'" 代替。

os.devnull

   空设备的文件路径。如 POSIX 上为 "'/dev/null'"，Windows 上为 "'nul'"
   。在 "os.path" 中也可用。

os.RTLD_LAZY
os.RTLD_NOW
os.RTLD_GLOBAL
os.RTLD_LOCAL
os.RTLD_NODELETE
os.RTLD_NOLOAD
os.RTLD_DEEPBIND

   "setdlopenflags()" 和 "getdlopenflags()" 函数所使用的标志。请参阅
   Unix 手册页 *dlopen(3)* 获取不同标志的含义。

   3.3 新版功能.


随机数
======

os.getrandom(size, flags=0)

   获得最多为 *size* 的随机字节。本函数返回的字节数可能少于请求的字节
   数。

   这些字节可用于为用户空间的随机数生成器提供种子，或用于加密目的。

   "getrandom()" 依赖于从设备驱动程序和其他环境噪声源收集的熵。不必要
   地读取大量数据将对使用 "/dev/random" 和 "/dev/urandom" 设备的其他用
   户产生负面影响。

   flags 参数是一个位掩码，可以是零个或多个下列值以或运算组合：
   "os.GRND_RANDOM" 和 "GRND_NONBLOCK"。

   另请参阅 Linux getrandom() 手册页 。

   可用性：Linux 3.17 或更高版本。

   3.6 新版功能.

os.urandom(size)

   返回大小为 *size* 的字符串，它是适合加密使用的随机字节。

   本函数从系统指定的随机源获取随机字节。对于加密应用程序，返回的数据
   应有足够的不可预测性，尽管其确切的品质取决于操作系统的实现。

   在 Linux 上，如果 "getrandom()" 系统调用可用，它将以阻塞模式使用：
   阻塞直到系统的 urandom 熵池初始化完毕（内核收集了 128 位熵）。原理
   请参阅 **PEP 524**。在 Linux 上，"getrandom()" 可以以非阻塞模式（使
   用 "GRND_NONBLOCK" 标志）获取随机字节，或者轮询直到系统的 urandom
   熵池初始化完毕。

   在类 Unix 系统上，随机字节是从 "/dev/urandom" 设备读取的。如果
   "/dev/urandom" 设备不可用或不可读，则抛出 "NotImplementedError" 异
   常。

   在 Windows 上将使用 "CryptGenRandom()"。

   参见:

     "secrets" 模块提供了更高级的功能。所在平台会提供随机数生成器，有
     关其易于使用的接口，请参阅 "random.SystemRandom"。

   在 3.6.0 版更改: 在 Linux 上，"getrandom()" 现在以阻塞模式使用，以
   提高安全性。

   在 3.5.2 版更改: 在 Linux 上，如果 "getrandom()" 系统调用阻塞（
   urandom 熵池尚未初始化完毕），则退回一步读取 "/dev/urandom"。

   在 3.5 版更改: 在 Linux 3.17 和更高版本上，现在使用 "getrandom()"
   系统调用（如果可用）。在 OpenBSD 5.6 和更高版本上，现在使用
   "getentropy()" C 函数。这些函数避免了使用内部文件描述符。

os.GRND_NONBLOCK

   默认情况下，从 "/dev/random" 读取时，如果没有可用的随机字节，则
   "getrandom()" 会阻塞；从 "/dev/urandom" 读取时，如果熵池尚未初始化
   ，则会阻塞。

   如果设置了 "GRND_NONBLOCK" 标志，则这些情况下 "getrandom()" 不会阻
   塞，而是立即抛出 "BlockingIOError" 异常。

   3.6 新版功能.

os.GRND_RANDOM

   如果设置了此标志位，那么将从 "/dev/random" 池而不是 "/dev/urandom"
   池中提取随机字节。

   3.6 新版功能.
