程序主要分为两部分
第一部分是表达式查错与预处理
第二部分是对表达式的计算
我们定义运算符为'+''-''*''/'中的一个
一个合法的表达式应具有以下特征：
	1.括号是合法的括号序列，即若将左括号视为1，右括号视为-1，所有位置的前缀和都大于0，且总和为0，每一个左括号都能找到唯一匹配的右括号
	2.数没有缺失，即每个运算符两侧都一定存在数或者表达式，特别地，负号可以作为一个数的前缀
	3.运算符没有赘余，即不存在直接相连的运算符，特别地，负号可以作为一个数的前缀
	4.数本身没有格式问题，即每个数至多存在一个小数点，且小数点前后均必须有数字
	5.不能除以0，这在预处理部分无法判断，会在计算时进行判断
在预处理时，直接对表达式的格式进行处理，并将字符串中的运算符与数字分离，同时添加一些习惯上省略的运算符，如乘号，接着进入表达式的计算部分。

首先我们发现，四则运算都是二元运算，而括号只是改变了运算的顺序，并没有参与到实际运算当中。因此一个简单的思路是：每次将当前表达式中优先级最低的运算符拿出来作为一个节点，然后将其左右拆分为两个新的表达式，并向下递归，直到建成一棵完整的二叉树（即表达式树），叶子节点是数字，剩下的节点都是运算符，从叶子向上逐层计算，就可以得到原表达式的值。
不难发现这样的树有两个性质：
	一是中序遍历表达式树，那么访问到所有运算符的顺序与原表达式中运算符的顺序相同
	二是表达式树中所有运算符的优先级满足小根堆的性质，即一个运算符的优先级一定大于它父亲的优先级
那么不难发现表达式树实际上就是一个笛卡尔树，于是可以用栈来模拟建树的过程，而不用真正去把树建出来，来完成表达式的计算
从右向左遍历预处理后的表达式，并用一个单调栈维护所有尚未进行计算的运算符以及右括号，由栈底到栈顶优先级依次升高。再用一个栈维护尚未计算的数。如果遍历到一个数，就将其压入存储数的栈中。如果扫到新的运算符优先级低于栈顶，就不断把栈顶运算符弹出，并从存储数的栈中取出栈顶的两个数进行相应的计算，把计算结果放回栈顶，直到运算符优先级高于栈顶。
特别地，如果遇到了左括号，那么就不断弹栈，计算，直到栈顶符号为右括号，再将栈顶弹出，就完成了对括号内表达式的计算
遍历结束后，再不断将弹栈，计算，直到存储符号的栈为空，此时存储数的栈中只会剩下一个数，这个数就是计算结果
至此，整个算法流程结束