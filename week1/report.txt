this file is encoded with utf-8
程序主要分为两部分
第一部分是表达式查错与预处理
第二部分是对表达式的计算
我们定义运算符为'+''-''*''/'中的一个
一个合法的表达式应具有以下特征：
	1.括号是合法的括号序列，即若将左括号视为1，右括号视为-1，所有位置的前缀和都大于0，且总和为0，每一个左括号都能找到唯一匹配的右括号
	2.数没有缺失，即每个运算符两侧都一定存在数或者表达式，特别地，负号左侧可以为左括号
	3.运算符没有赘余和缺失，即不存在直接相连的运算符，如果需要输入负数，需要在其周围加上括号，但右括号与左括号，数与左括号，右括号与数之间的乘号均可省略
	4.数本身没有格式问题，即每个数至多存在一个小数点，且小数点前后均必须有数字，允许存在前导0
	5.不能除以0，这在预处理部分无法判断，会在计算时进行判断
	6.可以包含任意数目的空格，但都会被忽略
	7.表达式中若出现除了数字、小数点、四则运算符、括号、空格之外的字符，都会被视为非法字符
例如，((-1)+2)(3*(-4))是一个合法的表达式
如果发现表达式中的错误，程序会给出错误类型以及具体的错误位置（在原字符串中，未忽略空格时的位置）
在预处理时，先去除表达式中的空格，再将字符串中的运算符与数字分离，同时添加上省略的乘号，在负数的前面加一个0，接着进入表达式的计算部分。

首先我们发现，四则运算都是二元运算，而括号只是改变了运算的顺序，并没有参与到实际运算当中。因此一个简单的思路是：每次将当前表达式中优先级最低的运算符拿出来作为一个节点，然后将其左右拆分为两个新的表达式，并向下递归，直到建成一棵完整的二叉树（即表达式树），叶子节点是数字，剩下的节点都是运算符，从叶子向上逐层计算，就可以得到原表达式的值。
不难发现这样的树有两个性质：
	一是中序遍历表达式树，那么访问到所有运算符的顺序与原表达式中运算符的顺序相同
	二是表达式树中所有运算符的优先级满足小根堆的性质，即一个运算符的优先级一定大于它父亲的优先级
那么不难发现表达式树实际上就是一个笛卡尔树，于是可以用栈来模拟建树的过程，而不用真正去把树建出来，来完成表达式的计算
从右向左遍历预处理后的表达式，并用一个单调栈维护所有尚未进行计算的运算符以及右括号，由栈底到栈顶优先级依次升高。再用一个栈维护尚未计算的数。如果遍历到一个数，就将其压入存储数的栈中。如果扫到新的运算符优先级低于栈顶，就不断把栈顶运算符弹出，并从存储数的栈中取出栈顶的两个数进行相应的计算，把计算结果放回栈顶，直到运算符优先级高于栈顶。
特别地，如果遇到了左括号，那么就不断弹栈，计算，直到栈顶符号为右括号，再将栈顶弹出，就完成了对括号内表达式的计算
遍历结束后，再不断弹栈，计算，直到存储符号的栈为空，此时存储数的栈中只会剩下一个数，这个数就是计算结果
至此，整个算法流程结束

仍然存在的问题：
	1.浮点数误差：例如1/(2-1.99-0.01)，并不会报错，是因为浮点误差导致除数略大于0
	2.本程序不能通过百练4132，原因猜测是输入数据中存在非法字符，删去第56，57行判断非法字符的语句后即可通过，因为无法获得输入数据而无法进一步研究