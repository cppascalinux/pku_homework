内置函数
********

Python 解释器内置了很多函数和类型，您可以在任何时候使用它们。以下按字
母表顺序列出它们。

+---------------------+-------------------+--------------------+--------------------+----------------------+
|                     |                   | 内置函数           |                    |                      |
|=====================|===================|====================|====================|======================|
| "abs()"             | "delattr()"       | "hash()"           | "memoryview()"     | "set()"              |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "all()"             | "dict()"          | "help()"           | "min()"            | "setattr()"          |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "any()"             | "dir()"           | "hex()"            | "next()"           | "slice()"            |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "ascii()"           | "divmod()"        | "id()"             | "object()"         | "sorted()"           |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "bin()"             | "enumerate()"     | "input()"          | "oct()"            | "staticmethod()"     |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "bool()"            | "eval()"          | "int()"            | "open()"           | "str()"              |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "breakpoint()"      | "exec()"          | "isinstance()"     | "ord()"            | "sum()"              |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "bytearray()"       | "filter()"        | "issubclass()"     | "pow()"            | "super()"            |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "bytes()"           | "float()"         | "iter()"           | "print()"          | "tuple()"            |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "callable()"        | "format()"        | "len()"            | "property()"       | "type()"             |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "chr()"             | "frozenset()"     | "list()"           | "range()"          | "vars()"             |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "classmethod()"     | "getattr()"       | "locals()"         | "repr()"           | "zip()"              |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "compile()"         | "globals()"       | "map()"            | "reversed()"       | "__import__()"       |
+---------------------+-------------------+--------------------+--------------------+----------------------+
| "complex()"         | "hasattr()"       | "max()"            | "round()"          |                      |
+---------------------+-------------------+--------------------+--------------------+----------------------+

abs(x)

   返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 "__abs__()"
   的对象。 如果参数是一个复数，则返回它的模。

all(iterable)

   如果 *iterable* 的所有元素均为真值（或可迭代对象为空）则返回 "True"
   。 等价于:

      def all(iterable):
          for element in iterable:
              if not element:
                  return False
          return True

any(iterable)

   如果 *iterable* 的任一元素为真值则返回 "True"。 如果可迭代对象为空
   ，返回 "False"。 等价于:

      def any(iterable):
          for element in iterable:
              if element:
                  return True
          return False

ascii(object)

   就像函数 "repr()"，返回一个对象可打印的字符串，但是 "repr()" 返回的
   字符串中非 ASCII 编码的字符，会使用 "\x"、"\u" 和 "\U" 来转义。生成
   的字符串和 Python 2 的 "repr()" 返回的结果相似。

bin(x)

   将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的
   Python 表达式。如果 *x* 不是 Python 的 "int" 对象，那它需要定义
   "__index__()"  方法返回一个整数。一些例子：

   >>> bin(3)
   '0b11'
   >>> bin(-10)
   '-0b1010'

   如果不一定需要前缀“0b”，还可以使用如下的方法。

   >>> format(14, '#b'), format(14, 'b')
   ('0b1110', '1110')
   >>> f'{14:#b}', f'{14:b}'
   ('0b1110', '1110')

   另见 "format()" 获取更多信息。

class bool([x])

   返回一个布尔值，"True" 或者 "False"。 *x* 使用标准的 真值测试过程
   来转换。如果 *x* 是假的或者被省略，返回 "False"；其他情况返回
   "True"。"bool" 类是 "int" 的子类（参见 数字类型 --- int, float,
   complex）。其他类不能继承自它。它只有 "False" 和 "True" 两个实例（
   参见 布尔值）。

   在 3.7 版更改: *x* 现在只能作为位置参数。

breakpoint(*args, **kws)

   此函数会在调用时将你陷入调试器中。具体来说，它调用
   "sys.breakpointhook()" ，直接传递 "args" 和 "kws" 。默认情况下，
   "sys.breakpointhook()" 调用 "pdb.set_trace()" 且没有参数。在这种情
   况下，它纯粹是一个便利函数，因此您不必显式导入 "pdb" 且键入尽可能少
   的代码即可进入调试器。但是， "sys.breakpointhook()" 可以设置为其他
   一些函数并被 "breakpoint()" 自动调用，以允许进入你想用的调试器。

   引发一个 审计事件 "builtins.breakpoint" 并附带参数 "breakpointhook"
   。

   3.7 新版功能.

class bytearray([source[, encoding[, errors]]])

   返回一个新的 bytes 数组。 "bytearray" 类是一个可变序列，包含范围为
   0 <= x < 256 的整数。它有可变序列大部分常见的方法，见 可变序列类型
   的描述；同时有 "bytes" 类型的大部分方法，参见 bytes 和 bytearray 操
   作。

   可选形参 *source* 可以用不同的方式来初始化数组：

   * 如果是一个 *string*，您必须提供 *encoding* 参数（*errors* 参数仍
     是可选的）；"bytearray()" 会使用 "str.encode()" 方法来将 string
     转变成 bytes。

   * 如果是一个 *integer*，会初始化大小为该数字的数组，并使用 null 字
     节填充。

   * 如果是一个遵循 缓冲区接口 的对象，该对象的只读缓冲区将被用来初始
     化字节数组。

   * 如果是一个 *iterable* 可迭代对象，它的元素的范围必须是 "0 <= x <
     256" 的整数，它会被用作数组的初始内容。

   如果没有实参，则创建大小为 0 的数组。

   另见 二进制序列类型 --- bytes, bytearray, memoryview 和 bytearray
   对象。

class bytes([source[, encoding[, errors]]])

   返回一个新的“bytes”对象， 是一个不可变序列，包含范围为 "0 <= x <
   256" 的整数。"bytes" 是 "bytearray" 的不可变版本 - 它有其中不改变序
   列的方法和相同的索引、切片操作。

   因此，构造函数的实参和 "bytearray()" 相同。

   字节对象还可以用字面值创建，参见 字符串和字节串字面值。

   另见 二进制序列类型 --- bytes, bytearray, memoryview，bytes 对象 和
   bytes 和 bytearray 操作。

callable(object)

   如果参数 *object* 是可调用的就返回 "True"，否则返回 "False"。 如果
   返回 "True"，调用仍可能失败，但如果返回 "False"，则调用 *object* 将
   肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果
   实例所属的类有 "__call__()" 则它就是可调用的。

   3.2 新版功能: 这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2
   被重新加入。

chr(i)

   返回 Unicode 码位为整数 *i* 的字符的字符串格式。例如，"chr(97)" 返
   回字符串 "'a'"，"chr(8364)" 返回字符串 "'€'"。这是 "ord()" 的逆函数
   。

   实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 *i*
   超过这个范围，会触发 "ValueError" 异常。

@classmethod

   把一个方法封装成类方法。

   一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第
   一个实参。请用以下习惯来声明类方法:

      class C:
          @classmethod
          def f(cls, arg1, arg2, ...): ...

   "@classmethod" 这样的形式称为函数的 *decorator* -- 详情参阅 函数定
   义。

   类方法的调用可以在类上进行 (例如 "C.f()") 也可以在实例上进行 (例如
   "C().f()")。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的
   派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。

   类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节
   中的 "staticmethod()"。 有关类方法的更多信息，请参阅 标准类型层级结
   构。

   在 3.9 版更改: 类方法现在可以包装其他 *描述器* 例如 "property()"。

compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)

   将 *source* 编译成代码或 AST 对象。代码对象可以被 "exec()" 或
   "eval()" 执行。*source* 可以是常规的字符串、字节字符串，或者 AST 对
   象。参见 "ast" 模块的文档了解如何使用 AST 对象。

   *filename* 实参需要是代码读取的文件名；如果代码不需要从文件中读取，
   可以传入一些可辨识的值（经常会使用 "'<string>'"）。

   *mode* 实参指定了编译代码必须用的模式。如果 *source* 是语句序列，可
   以是 "'exec'"；如果是单一表达式，可以是 "'eval'"；如果是单个交互式
   语句，可以是 "'single'"。（在最后一种情况下，如果表达式执行结果不是
   "None" 将会被打印出来。）

   可选参数 *flags* 和 *dont_inherit* 控制应当激活哪个 编译器选项 以及
   应当允许哪个 future 特性。 如果两者都未提供（或都为零）则代码会应用
   与调用 "compile()" 的代码相同的旗标来编译。 如果给出了 *flags* 参数
   而未给出 *dont_inherit* (或者为零) 则会在无论如何都将被使用的旗标之
   外还会额外使用 *flags* 参数所指定的编译器选项和 future 语句。 如果
   *dont_inherit* 为一个非零整数，则只使用 *flags* 参数 -- 外围代码中
   的旗标（future 特性和编译器选项）会被忽略。

   编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位
   OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在
   "__future__" 模块的 "_Feature" 实例的 "compiler_flag" 属性中找到。
   编译器旗标 可以在 "ast" 模块中查找带有 "PyCF_" 前缀的名称。

   *optimize* 实参指定编译器的优化级别；默认值 "-1"  选择与解释器的
   "-O" 选项相同的优化级别。显式级别为 "0" （没有优化；"__debug__"  为
   真）、"1" （断言被删除， "__debug__" 为假）或 "2" （文档字符串也被
   删除）。

   如果编译的源码不合法，此函数会触发 "SyntaxError" 异常；如果源码包含
   null 字节，则会触发 "ValueError" 异常。

   如果您想分析 Python 代码的 AST 表示，请参阅 "ast.parse()"。

   引发一个 审计事件 "compile" 附带参数 "source", "filename"。

   注解:

     在 "'single'"  或 "'eval'" 模式编译多行代码字符串时，输入必须以至
     少一个换行符结尾。 这使 "code" 模块更容易检测语句的完整性。

   警告:

     在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有
     可能因为 Python AST 编译器的栈深度限制而崩溃。

   在 3.2 版更改: 允许使用 Windows 和 Mac 的换行符。在 "'exec'" 模式不
   再需要以换行符结尾。增加了  *optimize* 形参。

   在 3.5 版更改: 之前 *source* 中包含 null 字节的话会触发 "TypeError"
   异常。

   3.8 新版功能: "ast.PyCF_ALLOW_TOP_LEVEL_AWAIT" 现在可在旗标中传入以
   启用对最高层级 "await", "async for" 和 "async with" 的支持。

class complex([real[, imag]])

   返回值为 *real* + *imag**1j 的复数，或将字符串或数字转换为复数。如
   果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有
   第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型
   （包括复数）。如果省略了 *imag*，则默认值为零，构造函数会像 "int"
   和 "float" 一样进行数值转换。如果两个实参都省略，则返回 "0j"。

   对于一个普通 Python 对象 "x"，"complex(x)" 会委托给
   "x.__complex__()"。  如果 "__complex__()" 未定义则将回退至
   "__float__()"。 如果 "__float__()" 未定义则将回退至 "__index__()"。

   注解:

     当从字符串转换时，字符串在 "+" 或 "-" 的周围必须不能有空格。例如
     "complex('1+2j')" 是合法的，但 "complex('1 + 2j')" 会触发
     "ValueError" 异常。

   数字类型 --- int, float, complex 描述了复数类型。

   在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。

   在 3.8 版更改: 如果 "__complex__()" 和 "__float__()" 未定义则回退至
   "__index__()"。

delattr(object, name)

   "setattr()" 相关的函数。实参是一个对象和一个字符串。该字符串必须是
   对象的某个属性。如果对象允许，该函数将删除指定的属性。例如
   "delattr(x, 'foobar')"  等价于 "del x.foobar" 。

class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)

   创建一个新的字典。"dict" 对象是一个字典类。参见 "dict" 和 映射类型
   --- dict 了解这个类。

   其他容器类型，请参见内置的 "list"、"set" 和 "tuple" 类，以及
   "collections" 模块。

dir([object])

   如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝
   试返回该对象的有效属性列表。

   如果对象有一个名为 "__dir__()" 的方法，那么该方法将被调用，并且必须
   返回一个属性列表。这允许实现自定义 "__getattr__()" 或
   "__getattribute__()" 函数的对象能够自定义 "dir()" 来报告它们的属性
   。

   如果对象不提供 "__dir__()"，这个函数会尝试从对象已定义的 "__dict__"
   属性和类型对象收集信息。结果列表并不总是完整的，如果对象有自定义
   "__getattr__()"，那结果可能不准确。

   默认的 "dir()" 机制对不同类型的对象行为不同，它会试图返回最相关而不
   是最全的信息：

   * 如果对象是模块对象，则列表包含模块的属性名称。

   * 如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所
     有基类的属性。

   * 否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类
     的所有基类的属性。

   返回的列表按字母表排序。例如：

   >>> import struct
   >>> dir()   # show the names in the module namespace  
   ['__builtins__', '__name__', 'struct']
   >>> dir(struct)   # show the names in the struct module 
   ['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
    '__initializing__', '__loader__', '__name__', '__package__',
    '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
    'unpack', 'unpack_from']
   >>> class Shape:
   ...     def __dir__(self):
   ...         return ['area', 'perimeter', 'location']
   >>> s = Shape()
   >>> dir(s)
   ['area', 'location', 'perimeter']

   注解:

     因为 "dir()" 主要是为了便于在交互式时使用，所以它会试图返回人们感
     兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为
     也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属
     性不包含在结果列表中。

divmod(a, b)

   它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数
   。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和
   "(a // b, a % b)" 一致。对于浮点数，结果是 "(q, a % b)" ，*q* 通常
   是 "math.floor(a / b)" 但可能会比 1 小。在任何情况下， "q * b + a %
   b" 和  *a* 基本相等；如果 "a % b" 非零，它的符号和 *b* 一样，并且
   "0 <= abs(a % b) < abs(b)" 。

enumerate(iterable, start=0)

   返回一个枚举对象。*iterable* 必须是一个序列，或 *iterator*，或其他
   支持迭代的对象。 "enumerate()" 返回的迭代器的 "__next__()" 方法返回
   一个元组，里面包含一个计数值（从 *start* 开始，默认为 0）和通过迭代
   *iterable* 获得的值。

   >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
   >>> list(enumerate(seasons))
   [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
   >>> list(enumerate(seasons, start=1))
   [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

   等价于:

      def enumerate(sequence, start=0):
          n = start
          for elem in sequence:
              yield n, elem
              n += 1

eval(expression[, globals[, locals]])

   实参是一个字符串，以及可选的 globals 和 locals。*globals* 实参必须
   是一个字典。*locals* 可以是任何映射对象。

   *expression* 参数会作为一个 Python 表达式（从技术上说是一个条件列表
   ）被解析并求值，并使用 *globals* 和 *locals* 字典作为全局和局部命名
   空间。 如果 *globals* 字典存在且不包含以 "__builtins__" 为键的值，
   则会在解析 *expression* 之前插入以此为键的对内置模块 "builtins" 的
   引用。 这意味着 *expression* 通常具有对标准 "builtins" 模块的完全访
   问权限且受限的环境会被传播。 如果省略 *locals* 字典则其默认值为
   *globals* 字典。 如果两个字典同时省略，则表达式执行时会使用
   "eval()" 被调用的环境中的 *globals* 和 *locals*。 请注意，*eval()*
   并没有对外围环境下的 (非局部) *嵌套作用域* 的访问权限。

   返回值就是表达式的求值结果。 语法错误将作为异常被报告。 例如：

   >>> x = 1
   >>> eval('x+1')
   2

   这个函数也可以用来执行任何代码对象（如 "compile()"  创建的）。这种
   情况下，参数是代码对象，而不是字符串。如果编译该对象时的 *mode* 实
   参是 "'exec'" 那么 "eval()" 返回值为 "None" 。

   提示： "exec()" 函数支持动态执行语句。 "globals()" 和 "locals()" 函
   数各自返回当前的全局和本地字典，因此您可以将它们传递给 "eval()" 或
   "exec()" 来使用。

   另外可以参阅 "ast.literal_eval()"，该函数可以安全执行仅包含文字的表
   达式字符串。

   引发一个 审计事件 "exec" 附带参数 "code_object"。

exec(object[, globals[, locals]])

   这个函数支持动态执行 Python 代码。*object* 必须是字符串或者代码对象
   。如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除
   非发生语法错误）。[1] 如果是代码对象，它将被直接执行。在任何情况下
   ，被执行的代码都需要和文件输入一样是有效的（见参考手册中关于文件输
   入的章节）。请注意即使在传递给 "exec()" 函数的代码的上下文中，
   "return" 和 "yield" 语句也不能在函数定义之外使用。该函数返回值是
   "None" 。

   无论哪种情况，如果省略了可选项，代码将在当前作用域内执行。 如果只提
   供了 *globals*，则它必须是一个字典（不能是字典的子类），该字典将同
   时被用于全局和局部变量。 如果同时提供了 *globals* 和 *locals*，它们
   会分别被用于全局和局部变量。 如果提供了 *locals*，则它可以是任何映
   射对象。 请记住在模块层级上，globals 和 locals 是同一个字典。 如果
   exec 得到两个单独对象作为 *globals* 和 *locals*，则代码将如同嵌入类
   定义的情况一样执行。

   如果 *globals* 字典不包含 "__builtins__" 键值，则将为该键插入对内建
   "builtins" 模块字典的引用。因此，在将执行的代码传递给 "exec()" 之前
   ，可以通过将自己的 "__builtins__" 字典插入到 *globals* 中来控制可以
   使用哪些内置代码。

   引发一个 审计事件 "exec" 附带参数 "code_object"。

   注解:

     内置 "globals()" 和 "locals()" 函数各自返回当前的全局和本地字典，
     因此可以将它们传递给 "exec()" 的第二个和第三个实参。

   注解:

     默认情况下，*locals* 的行为如下面 "locals()" 函数描述的一样：不要
     试图改变默认的 *locals* 字典。如果您想在 "exec()" 函数返回时知道
     代码对 *locals* 的变动，请明确地传递 *locals* 字典。

filter(function, iterable)

   用 *iterable*  中函数 *function* 返回真的那些元素，构建一个新的迭代
   器。*iterable* 可以是一个序列，一个支持迭代的容器，或一个迭代器。如
   果 *function* 是 "None" ，则会假设它是一个身份函数，即 *iterable*
   中所有返回假的元素会被移除。

   请注意， "filter(function, iterable)" 相当于一个生成器表达式，当
   function 不是 "None" 的时候为 "(item for item in iterable if
   function(item))"；function 是 "None" 的时候为 "(item for item in
   iterable if item)" 。

   请参阅 "itertools.filterfalse()" 了解，只有 *function* 返回 false
   时才选取 *iterable* 中元素的补充函数。

class float([x])

   返回从数字或字符串 *x* 生成的浮点数。

   如果实参是字符串，则它必须是包含十进制数字的字符串，字符串前面可以
   有符号，之前也可以有空格。可选的符号有 "'+'" 和 "'-'" ； "'+'" 对创
   建的值没有影响。实参也可以是 NaN（非数字）、正负无穷大的字符串。确
   切地说，除去首尾的空格后，输入必须遵循以下语法：

      sign           ::= "+" | "-"
      infinity       ::= "Infinity" | "inf"
      nan            ::= "nan"
      numeric_value  ::= floatnumber | infinity | nan
      numeric_string ::= [sign] numeric_value

   这里， "floatnumber" 是 Python 浮点数的字符串形式，详见 浮点数字面
   值。字母大小写都可以，例如，“inf”、“Inf”、“INFINITY”、“iNfINity” 都
   可以表示正无穷大。

   另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点
   精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发
   "OverflowError"。

   对于一个普通 Python 对象 "x"，"float(x)" 会委托给 "x.__float__()"。
   如果 "__float__()" 未定义则将回退至 "__index__()"。

   如果没有实参，则返回 "0.0" 。

   例如:

      >>> float('+1.23')
      1.23
      >>> float('   -12345\n')
      -12345.0
      >>> float('1e-003')
      0.001
      >>> float('+1E6')
      1000000.0
      >>> float('-Infinity')
      -inf

   数字类型 --- int, float, complex 描述了浮点类型。

   在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。

   在 3.7 版更改: *x* 现在只能作为位置参数。

   在 3.8 版更改: 如果 "__float__()" 未定义则回退至 "__index__()"。

format(value[, format_spec])

   将 *value* 转换为 *format_spec* 控制的“格式化”表示。*format_spec*
   的解释取决于 *value* 实参的类型，但是大多数内置类型使用标准格式化语
   法：格式规格迷你语言。

   默认的 *format_spec* 是一个空字符串，它通常和调用 "str(value)" 的结
   果相同。

   调用 "format(value, format_spec)" 会转换成
   "type(value).__format__(value, format_spec)" ，所以实例字典中的
   "__format__()" 方法将不会调用。如果搜索到 "object" 有这个方法但
   *format_spec* 不为空，*format_spec* 或返回值不是字符串，会触发
   "TypeError" 异常。

   在 3.4 版更改: 当 *format_spec* 不是空字符串时，
   "object().__format__(format_spec)" 会触发  "TypeError"。

class frozenset([iterable])

   返回一个新的 "frozenset" 对象，它包含可选参数 *iterable* 中的元素。
   "frozenset" 是一个内置的类。有关此类的文档，请参阅 "frozenset" 和
   集合类型 --- set, frozenset。

   请参阅内建的 "set"、"list"、"tuple" 和 "dict" 类，以及
   "collections" 模块来了解其它的容器。

getattr(object, name[, default])

   返回对象命名属性的值。*name* 必须是字符串。如果该字符串是对象的属性
   之一，则返回该属性的值。例如， "getattr(x, 'foobar')" 等同于
   "x.foobar"。如果指定的属性不存在，且提供了 *default* 值，则返回它，
   否则触发 "AttributeError"。

globals()

   返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中
   ，不是调用它的模块，而是定义它的模块）。

hasattr(object, name)

   该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则
   返回 "True"，否则返回 "False"。（此功能是通过调用 "getattr(object,
   name)" 看是否有 "AttributeError" 异常来实现的。）

hash(object)

   返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元
   素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它
   们类型不同，如 1 和 1.0）。

   注解:

     如果对象实现了自己的 "__hash__()" 方法，请注意，"hash()" 根据机器
     的字长来截断返回值。另请参阅 "__hash__()"。

help([object])

   启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释
   器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函
   数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助
   信息。如果实参是其他任意对象，则会生成该对象的帮助页。

   请注意如果在函数的形参列表中出现了斜杠 (/)，则它在发起调用 "help()"
   的时候意味着斜杠之前的均为仅限位置形参。 更多相关信息，请参阅 有关
   仅限位置形参的 FAQ 条目。

   该函数通过 "site" 模块加入到内置命名空间。

   在 3.4 版更改: "pydoc" 和 "inspect" 的变更使得可调用对象的签名信息
   更加全面和一致。

hex(x)

   将整数转换为以“0x”为前缀的小写十六进制字符串。如果 *x* 不是 Python
   "int" 对象，则必须定义返回整数的 "__index__()" 方法。一些例子：

   >>> hex(255)
   '0xff'
   >>> hex(-42)
   '-0x2a'

   如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀
   ，则可以使用如下方法：

   >>> '%#x' % 255, '%x' % 255, '%X' % 255
   ('0xff', 'ff', 'FF')
   >>> format(255, '#x'), format(255, 'x'), format(255, 'X')
   ('0xff', 'ff', 'FF')
   >>> f'{255:#x}', f'{255:x}', f'{255:X}'
   ('0xff', 'ff', 'FF')

   另见 "format()" 获取更多信息。

   另请参阅 "int()" 将十六进制字符串转换为以 16 为基数的整数。

   注解:

     如果要获取浮点数的十六进制字符串形式，请使用 "float.hex()" 方法。

id(object)

   返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一
   且恒定的。两个生命期不重叠的对象可能具有相同的 "id()" 值。

   **CPython implementation detail:** This is the address of the
   object in memory.

   引发一个 审计事件 "builtins.id"，附带参数 "id"。

input([prompt])

   如果存在 *prompt* 实参，则将其写入标准输出，末尾不带换行符。接下来
   ，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返
   回。当读取到 EOF 时，则触发 "EOFError"。例如:

      >>> s = input('--> ')  
      --> Monty Python's Flying Circus
      >>> s  
      "Monty Python's Flying Circus"

   如果加载了 "readline" 模块，"input()" 将使用它来提供复杂的行编辑和
   历史记录功能。

   引发一个 审计事件 "builtins.input" 附带参数 "prompt"。

   在成功读取输入之后引发一个审计事件 "builtins.input/result" 附带结果
   。

class int([x])
class int(x, base=10)

   返回一个基于数字或字符串 *x* 构造的整数对象，或者在未给出参数时返回
   "0"。 如果 *x* 定义了 "__int__()"，"int(x)" 将返回 "x.__int__()"。
   如果 *x* 定义了 "__index__()"，它将返回 "x.__index__()"。 如果 *x*
   定义了 "__trunc__()"，它将返回 "x.__trunc__()"。 对于浮点数，它将向
   零舍入。

   如果 *x* 不是数字，或者有 *base* 参数，*x* 必须是字符串、"bytes"、
   表示进制为 *base* 的 整数字面值 的 "bytearray" 实例。该文字前可以有
   "+" 或 "-" （中间不能有空格），前后可以有空格。一个进制为 n 的数字
   包含 0 到 n-1 的数，其中 "a" 到 "z" （或 "A" 到 "Z" ）表示 10 到 35
   。默认的 *base* 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可
   以在代码中用 "0b"/"0B" 、 "0o"/"0O" 、 "0x"/"0X" 前缀来表示。进制为
   0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中
   的一个。所以 "int('010', 0)" 是非法的，但 "int('010')" 和
   "int('010', 8)" 是合法的。

   整数类型定义请参阅 数字类型 --- int, float, complex 。

   在 3.4 版更改: 如果 *base* 不是 "int" 的实例，但 *base* 对象有
   "base.__index__" 方法，则会调用该方法来获取进制数。以前的版本使用
   "base.__int__" 而不是 "base.__index__"。

   在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。

   在 3.7 版更改: *x* 现在只能作为位置参数。

   在 3.8 版更改: 如果 "__int__()" 未定义则回退至 "__index__()"。

isinstance(object, classinfo)

   如果参数 *object* 是参数 *classinfo* 的实例或者是其 (直接、间接或 *
   虚拟*) 子类则返回 "True"。 如果 *object* 不是给定类型的对象，函数将
   总是返回 "False"。 如果 *classinfo* 是类型对象元组（或由其他此类元
   组递归组成的元组），那么如果 *object* 是其中任何一个类型的实例就返
   回 "True"。 如果 *classinfo* 既不是类型，也不是类型元组或类型元组的
   元组，则将引发 "TypeError" 异常。

issubclass(class, classinfo)

   如果 *class* 是 *classinfo* 的 (直接、间接或 *虚拟*) 子类则返回
   "True"。 类会被视作其自身的子类。 *classinfo* 也以是类对象的元组，
   在此情况下 *classinfo* 中的每个条目都将被检查。 在任何其他情况下，
   都将引发 "TypeError" 异常。

iter(object[, sentinel])

   返回一个 *iterator* 对象。根据是否存在第二个实参，第一个实参的解释
   是非常不同的。如果没有第二个实参，*object* 必须是支持迭代协议（有
   "__iter__()" 方法）的集合对象，或必须支持序列协议（有
   "__getitem__()" 方法，且数字参数从 "0" 开始）。如果它不支持这些协议
   ，会触发 "TypeError"。如果有第二个实参 *sentinel*，那么 *object* 必
   须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的
   "__next__()" 方法时都会不带实参地调用 *object*；如果返回的结果是
   *sentinel* 则触发 "StopIteration"，否则返回调用结果。

   另请参阅 迭代器类型。

   适合 "iter()" 的第二种形式的应用之一是构建块读取器。 例如，从二进制
   数据库文件中读取固定宽度的块，直至到达文件的末尾:

      from functools import partial
      with open('mydata.db', 'rb') as f:
          for block in iter(partial(f.read, 64), b''):
              process_block(block)

len(s)

   返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple
   、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。

   **CPython implementation detail:** "len" 对于大于 "sys.maxsize" 的
   长度如 "range(2 ** 100)" 会引发 "OverflowError"。

class list([iterable])

   虽然被称为函数，"list" 实际上是一种可变序列类型，详情请参阅 列表 和
   序列类型 --- list, tuple, range。

locals()

   更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调
   用 "locals()" 时将返回自由变量。 请注意在模块层级上，"locals()" 和
   "globals()" 是同一个字典。

   注解:

     不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量
     的值。

map(function, iterable, ...)

   返回一个将 *function* 应用于 *iterable* 中每一项并输出其结果的迭代
   器。 如果传入了额外的 *iterable* 参数，*function* 必须接受相同个数
   的实参并被应用于从所有可迭代对象中并行获取的项。 当有多个可迭代对象
   时，最短的可迭代对象耗尽则整个迭代就将结束。 对于函数的输入已经是参
   数元组的情况，请参阅 "itertools.starmap()"。

max(iterable, *[, key, default])
max(arg1, arg2, *args[, key])

   返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。

   如果只提供了一个位置参数，它必须是非空 *iterable*，返回可迭代对象中
   最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。

   有两个可选只能用关键字的实参。*key* 实参指定排序函数用的参数，如传
   给 "list.sort()" 的。*default* 实参是当可迭代对象为空时返回的值。如
   果可迭代对象为空，并且没有给 *default* ，则会触发 "ValueError"。

   如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工
   具如 "sorted(iterable, key=keyfunc, reverse=True)[0]" 和
   "heapq.nlargest(1, iterable, key=keyfunc)" 保持一致。

   3.4 新版功能: keyword-only 实参 *default* 。

   在 3.8 版更改: *key* 可以为 "None"。

class memoryview(obj)

   返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 内存视图。

min(iterable, *[, key, default])
min(arg1, arg2, *args[, key])

   返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。

   如果只提供了一个位置参数，它必须是 *iterable*，返回可迭代对象中最小
   的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。

   有两个可选只能用关键字的实参。*key* 实参指定排序函数用的参数，如传
   给 "list.sort()" 的。*default* 实参是当可迭代对象为空时返回的值。如
   果可迭代对象为空，并且没有给 *default* ，则会触发 "ValueError"。

   如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工
   具如 "sorted(iterable, key=keyfunc)[0]" 和 "heapq.nsmallest(1,
   iterable, key=keyfunc)" 保持一致。

   3.4 新版功能: keyword-only 实参 *default* 。

   在 3.8 版更改: *key* 可以为 "None"。

next(iterator[, default])

   通过调用 *iterator* 的 "__next__()" 方法获取下一个元素。如果迭代器
   耗尽，则返回给定的 *default*，如果没有默认值则触发 "StopIteration"
   。

class object

   返回一个没有特征的新对象。"object" 是所有类的基类。它具有所有
   Python 类实例的通用方法。这个函数不接受任何实参。

   注解:

     由于 "object" 没有 "__dict__"，因此无法将任意属性赋给 "object" 的
     实例。

oct(x)

   将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的
   Python 表达式。如果 *x* 不是 Python 的 "int" 对象，那它需要定义
   "__index__()"  方法返回一个整数。一些例子：

   >>> oct(8)
   '0o10'
   >>> oct(-56)
   '-0o70'

   如果要将整数转换为八进制字符串，并可选择有无“0o”前缀，则可以使用如
   下方法：

   >>> '%#o' % 10, '%o' % 10
   ('0o12', '12')
   >>> format(10, '#o'), format(10, 'o')
   ('0o12', '12')
   >>> f'{10:#o}', f'{10:o}'
   ('0o12', '12')

   另见 "format()" 获取更多信息。

open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

   打开 *file* 并返回对应的 *file object*。 如果该文件不能被打开，则引
   发 "OSError"。 请参阅 读写文件 获取此函数的更多用法示例。

   *file* 是一个 *path-like object*，表示将要打开的文件的路径（绝对路
   径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述
   符。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非
   *closefd* 被设为 "False" 。）

   *mode* 是一个可选字符串，用于指定打开文件的模式。默认值是 "'r'"  ，
   这意味着它以文本模式打开并读取。其他常见模式有：写入 "'w'" （截断已
   经存在的文件）；排它性创建 "'x'" ；追加写 "'a'" （在 *一些*  Unix
   系统上，无论当前的文件指针在什么位置，*所有* 写入都会追加到文件末尾
   ）。在文本模式，如果 *encoding* 没有指定，则根据平台来决定使用的编
   码：使用 "locale.getpreferredencoding(False)" 来获取本地编码。（要
   读取和写入原始字节，请使用二进制模式并不要指定 *encoding*。）可用的
   模式有：

   +-----------+-----------------------------------------------------------------+
   | 字符      | 意义                                                            |
   |===========|=================================================================|
   | "'r'"     | 读取（默认）                                                    |
   +-----------+-----------------------------------------------------------------+
   | "'w'"     | 写入，并先截断文件                                              |
   +-----------+-----------------------------------------------------------------+
   | "'x'"     | 排它性创建，如果文件已存在则失败                                |
   +-----------+-----------------------------------------------------------------+
   | "'a'"     | 写入，如果文件存在则在末尾追加                                  |
   +-----------+-----------------------------------------------------------------+
   | "'b'"     | 二进制模式                                                      |
   +-----------+-----------------------------------------------------------------+
   | "'t'"     | 文本模式（默认）                                                |
   +-----------+-----------------------------------------------------------------+
   | "'+'"     | 打开用于更新（读取与写入）                                      |
   +-----------+-----------------------------------------------------------------+

   默认模式为 "'r'" (打开用于读取文本，与 "'rt'" 同义)。 模式 "'w+'"
   与 "'w+b'" 将打开文件并清空内容。 模式 "'r+'" 与 "'r+b'" 将打开文件
   并不清空内容。

   正如在 概述 中提到的，Python区分二进制和文本I/O。以二进制模式打开的
   文件（包括 *mode* 参数中的 "'b'" ）返回的内容为 "bytes`对象，不进行
   任何解码。在文本模式下（默认情况下，或者在 *mode* 参数中包含 `"'t'`
   ）时，文件内容返回为 "str" ，首先使用指定的 *encoding* （如果给定）
   或者使用平台默认的的字节编码解码。

   此外还允许使用一个模式字符 "'U'"，该字符已不再具有任何效果，并被视
   为已弃用。 之前它会在文本模式中启用 *universal newlines*，这在
   Python 3.0 中成为默认行为。 请参阅 newline 形参的文档了解更多细节。

   注解:

     Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完
     成，因此与平台无关。

   *buffering* 是一个可选的整数，用于设置缓冲策略。传递0以切换缓冲关闭
   （仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），并且>1
   的整数以指示固定大小的块缓冲区的大小（以字节为单位）。如果没有给出
   *buffering* 参数，则默认缓冲策略的工作方式如下:

   * 二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小
     ，尝试确定底层设备的“块大小”或使用 "io.DEFAULT_BUFFER_SIZE"。在许
     多系统上，缓冲区的长度通常为4096或8192字节。

   * “交互式”文本文件（ "isatty()" 返回 "True" 的文件）使用行缓冲。其
     他文本文件使用上述策略用于二进制文件。

   *encoding* 是用于解码或编码文件的编码的名称。这应该只在文本模式下使
   用。默认编码是依赖于平台的（不 管 "locale.getpreferredencoding()"
   返回何值），但可以使用任何Python支持的 *text encoding* 。有关支持的
   编码列表，请参阅 "codecs" 模块。

   *errors* 是一个可选的字符串参数，用于指定如何处理编码和解码错误 -
   这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 错误处
   理方案 ），但是使用 "codecs.register_error()" 注册的任何错误处理名
   称也是有效的。标准名称包括:

   * 如果存在编码错误，"'strict'" 会引发 "ValueError" 异常。 默认值
     "None" 具有相同的效果。

   * "'ignore'" 忽略错误。请注意，忽略编码错误可能会导致数据丢失。

   * "'replace'" 会将替换标记（例如 "'?'" ）插入有错误数据的地方。

   * "'surrogateescape'" 将表示任何不正确的字节作为Unicode专用区中的代
     码点，范围从U+DC80到U+DCFF。当在写入数据时使用 "surrogateescape"
     错误处理程序时，这些私有代码点将被转回到相同的字节中。这对于处理
     未知编码的文件很有用。

   * 只有在写入文件时才支持 "'xmlcharrefreplace'"。编码不支持的字符将
     替换为相应的XML字符引用 "&#nnn;"。

   * "'backslashreplace'" 用Python的反向转义序列替换格式错误的数据。

   * "'namereplace'" （也只在编写时支持）用 "\N{...}" 转义序列替换不支
     持的字符。

   *newline* 控制 *universal newlines* 模式如何生效（它仅适用于文本模
   式）。它可以是 "None"，"''"，"'\n'"，"'\r'" 和 "'\r\n'"。它的工作原
   理:

   * 从流中读取输入时，如果 *newline* 为 "None"，则启用通用换行模式。
     输入中的行可以以 "'\n'"，"'\r'" 或 "'\r\n'" 结尾，这些行被翻译成
     "'\n'" 在返回呼叫者之前。如果它是 "''"，则启用通用换行模式，但行
     结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由
     给定字符串终止，并且行结尾将返回给未调用的调用者。

   * 将输出写入流时，如果 *newline* 为 "None"，则写入的任何 "'\n'" 字
     符都将转换为系统默认行分隔符 "os.linesep"。如果 *newline* 是 "''"
     或 "'\n'"，则不进行翻译。如果 *newline* 是任何其他合法值，则写入
     的任何 "'\n'" 字符将被转换为给定的字符串。

   如果 *closefd* 是 "False" 并且给出了文件描述符而不是文件名，那么当
   文件关闭时，底层文件描述符将保持打开状态。如果给出文件名则
   *closefd* 必须为 "True" （默认值），否则将引发错误。

   可以通过传递可调用的 *opener* 来使用自定义开启器。然后通过使用参数
   （ *file*，*flags* ）调用 *opener* 获得文件对象的基础文件描述符。
   *opener* 必须返回一个打开的文件描述符（使用 "os.open" as *opener*
   时与传递 "None" 的效果相同）。

   新创建的文件是 不可继承的。

   下面的示例使用 "os.open()" 函数的 dir_fd 的形参，从给定的目录中用相
   对路径打开文件:

      >>> import os
      >>> dir_fd = os.open('somedir', os.O_RDONLY)
      >>> def opener(path, flags):
      ...     return os.open(path, flags, dir_fd=dir_fd)
      ...
      >>> with open('spamspam.txt', 'w', opener=opener) as f:
      ...     print('This will be written to somedir/spamspam.txt', file=f)
      ...
      >>> os.close(dir_fd)  # don't leak a file descriptor

   "open()" 函数所返回的 *file object* 类型取决于所用模式。 当使用
   "open()" 以文本模式 ("'w'", "'r'", "'wt'", "'rt'" 等) 打开文件时，
   它将返回 "io.TextIOBase" (特别是 "io.TextIOWrapper") 的一个子类。
   当使用缓冲以二进制模式打开文件时，返回的类是 "io.BufferedIOBase" 的
   一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回
   "io.BufferedReader"；在写入二进制和追加二进制模式下，它将返回
   "io.BufferedWriter"，而在读/写模式下，它将返回 "io.BufferedRandom"
   。 当禁用缓冲时，则会返回原始流，即 "io.RawIOBase" 的一个子类
   "io.FileIO"。

   另请参阅文件操作模块，例如 "fileinput"、"io" （声明了 "open()"）、
   "os"、"os.path"、"tempfile" 和 "shutil"。

   引发一个 审计事件 "open" 附带参数 "file", "mode", "flags"。

   "mode" 与 "flags" 参数可以在原始调用的基础上被修改或传递。

      在 3.3 版更改:

      * 增加了 *opener* 形参。

      * 增加了 "'x'" 模式。

      * 过去触发的 "IOError"，现在是 "OSError" 的别名。

      * 如果文件已存在但使用了排它性创建模式（ "'x'" ），现在会触发
        "FileExistsError"。

      在 3.4 版更改:

      * 文件现在禁止继承。

   Deprecated since version 3.4, will be removed in version 3.10:
   "'U'" 模式。

      在 3.5 版更改:

      * 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重
        试系统调用，而不是触发 "InterruptedError" 异常（原因详见 **PEP
        475**）。

      * 增加了 "'namereplace'" 错误处理接口。

      在 3.6 版更改:

      * 增加对实现了 "os.PathLike" 对象的支持。

      * 在 Windows 上，打开一个控制台缓冲区将返回 "io.RawIOBase" 的子
        类，而不是 "io.FileIO"。

ord(c)

   对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例
   如 "ord('a')" 返回整数 "97"， "ord('€')" （欧元符号）返回 "8364" 。
   这是 "chr()" 的逆函数。

pow(base, exp[, mod])

   返回 *base* 的 *exp* 次幂；如果 *mod* 存在，则返回 *base* 的 *exp*
   次幂对 *mod* 取余（比 "pow(base, exp) % mod" 更高效）。 两参数形式
   "pow(base, exp)" 等价于乘方运算符: "base**exp"。

   参数必须具有数值类型。 对于混用的操作数类型，则将应用双目算术运算符
   的类型强制转换规则。 对于 "int" 操作数，结果具有与操作数相同的类型
   （强制转换后），除非第二个参数为负值；在这种情况下，所有参数将被转
   换为浮点数并输出浮点数结果。 例如，"10**2" 返回 "100"，但 "10**-2"
   返回 "0.01"。

   对于 "int" 操作数 *base* 和 *exp*，如果给出 *mod*，则 *mod* 必须为
   整数类型并且 *mod* 必须不为零。 如果给出 *mod* 并且 *exp* 为负值，
   则 *base* 必须相对于 *mod* 不可整除。 在这种情况下，将会返回
   "pow(inv_base, -exp, mod)"，其中 *inv_base* 为 *base* 的倒数对
   *mod* 取余。

   下面的例子是 "38" 的倒数对 "97" 取余:

      >>> pow(38, -1, mod=97)
      23
      >>> 23 * 38 % 97 == 1
      True

   在 3.8 版更改: 对于 "int" 操作数，三参数形式的 "pow" 现在允许第二个
   参数为负值，即可以计算倒数的余数。

   在 3.8 版更改: 允许关键字参数。 之前只支持位置参数。

print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)

   将 *objects* 打印到 *file* 指定的文本流，以 *sep* 分隔并在末尾加上
   *end*。 *sep*, *end*, *file* 和 *flush* 如果存在，它们必须以关键字
   参数的形式给出。

   所有非关键字参数都会被转换为字符串，就像是执行了 "str()" 一样，并会
   被写入到流，以 *sep* 且在末尾加上 *end*。 *sep* 和 *end* 都必须为字
   符串；它们也可以为 "None"，这意味着使用默认值。 如果没有给出
   *objects*，则 "print()" 将只写入 *end*。

   *file* 参数必须是一个具有 "write(string)" 方法的对象；如果参数不存
   在或为 "None"，则将使用 "sys.stdout"。 由于要打印的参数会被转换为文
   本字符串，因此 "print()" 不能用于二进制模式的文件对象。 对于这些对
   象，应改用 "file.write(...)"。

   输出是否被缓存通常决定于 *file*，但如果 *flush* 关键字参数为真值，
   流会被强制刷新。

   在 3.3 版更改: 增加了 *flush* 关键字参数。

class property(fget=None, fset=None, fdel=None, doc=None)

   返回 property 属性。

   *fget* 是获取属性值的函数。 *fset* 是用于设置属性值的函数。 *fdel*
   是用于删除属性值的函数。并且 *doc* 为属性对象创建文档字符串。

   一个典型的用法是定义一个托管属性 "x":

      class C:
          def __init__(self):
              self._x = None

          def getx(self):
              return self._x

          def setx(self, value):
              self._x = value

          def delx(self):
              del self._x

          x = property(getx, setx, delx, "I'm the 'x' property.")

   如果 *c* 是 *C* 的实例，"c.x" 将调用getter，"c.x = value" 将调用
   setter， "del c.x" 将调用deleter。

   如果给出，*doc* 将成为该 property 属性的文档字符串。 否则该
   property 将拷贝 *fget* 的文档字符串（如果存在）。 这令使用
   "property()" 作为 *decorator* 来创建只读的特征属性可以很容易地实现:

      class Parrot:
          def __init__(self):
              self._voltage = 100000

          @property
          def voltage(self):
              """Get the current voltage."""
              return self._voltage

   以上 "@property" 装饰器会将 "voltage()" 方法转化为一个具有相同名称
   的只读属性的 "getter"，并将 *voltage* 的文档字符串设置为 "Get the
   current voltage."

   特征属性对象具有 "getter", "setter" 以及 "deleter" 方法，它们可用作
   装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。
   这最好是用一个例子来解释:

      class C:
          def __init__(self):
              self._x = None

          @property
          def x(self):
              """I'm the 'x' property."""
              return self._x

          @x.setter
          def x(self, value):
              self._x = value

          @x.deleter
          def x(self):
              del self._x

   上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性
   相同的名称 (在本例中为 "x"。)

   返回的特征属性对象同样具有与构造器参数相对应的属性 "fget", "fset"
   和 "fdel"。

   在 3.5 版更改: 特征属性对象的文档字符串现在是可写的。

class range(stop)
class range(start, stop[, step])

   虽然被称为函数，但 "range" 实际上是一个不可变的序列类型，参见在
   range 对象 与 序列类型 --- list, tuple, range 中的文档说明。

repr(object)

   返回包含一个对象的可打印表示形式的字符串。 对于许多类型来说，该函数
   会尝试返回的字符串将会与该对象被传递给 "eval()" 时所生成的对象具有
   相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包
   含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义
   "__repr__()" 方法来控制此函数为它的实例所返回的内容。

reversed(seq)

   返回一个反向的 *iterator*。 *seq* 必须是一个具有 "__reversed__()"
   方法的对象或者是支持该序列协议（具有从 "0" 开始的整数类型参数的
   "__len__()" 方法和 "__getitem__()" 方法）。

round(number[, ndigits])

   返回 *number* 舍入到小数点后 *ndigits* 位精度的值。 如果 *ndigits*
   被省略或为 "None"，则返回最接近输入值的整数。

   对于支持 "round()" 的内置类型，值会被舍入到最接近的 10 的负
   *ndigits* 次幂的倍数；如果与两个倍数的距离相等，则选择偶数 (因此，
   "round(0.5)" 和 "round(-0.5)" 均为 "0" 而 "round(1.5)" 为 "2")。 任
   何整数值都可作为有效的 *ndigits* (正数、零或负数)。 如果 *ndigits*
   被省略或为 "None" 则返回值将为整数。 否则返回值与 *number* 的类型相
   同。

   对于一般的 Python 对象 "number", "round" 将委托给
   "number.__round__"。

   注解:

     对浮点数执行 "round()" 的行为可能会令人惊讶：例如，"round(2.675,
     2)" 将给出 "2.67" 而不是期望的 "2.68"。 这不算是程序错误：这一结
     果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅
     浮点算术：争议和限制 了解更多信息。

class set([iterable])

   返回一个新的 "set" 对象，可以选择带有从 *iterable* 获取的元素。
   "set" 是一个内置类型。 请查看 "set" 和 集合类型 --- set, frozenset
   获取关于这个类的文档。

   有关其他容器请参看内置的 "frozenset", "list", "tuple" 和 "dict" 类
   ，以及 "collections" 模块。

setattr(object, name, value)

   此函数与 "getattr()" 两相对应。 其参数为一个对象、一个字符串和一个
   任意值。 字符串指定一个现有属性或者新增属性。 函数会将值赋给该属性
   ，只要对象允许这种操作。 例如，"setattr(x, 'foobar', 123)" 等价于
   "x.foobar = 123"。

class slice(stop)
class slice(start, stop[, step])

   返回一个表示由 "range(start, stop, step)" 所指定索引集的 *slice* 对
   象。 其中 *start* 和 *step* 参数默认为 "None"。 切片对象具有仅会返
   回对应参数值（或其默认值）的只读数据属性 "start", "stop" 和 "step"
   。 它们没有其他的显式功能；不过它们会被 NumPy 以及其他第三方扩展所
   使用。 切片对象也会在使用扩展索引语法时被生成。 例如:
   "a[start:stop:step]" 或 "a[start:stop, i]"。 请参阅
   "itertools.islice()" 了解返回迭代器的一种替代版本。

sorted(iterable, *, key=None, reverse=False)

   根据 *iterable* 中的项返回一个新的已排序列表。

   具有两个可选参数，它们都必须指定为关键字参数。

   *key* 指定带有单个参数的函数，用于从 *iterable* 的每个元素中提取用
   于比较的键 (例如 "key=str.lower")。 默认值为 "None" (直接比较元素)
   。

   *reverse* 为一个布尔值。 如果设为 "True"，则每个列表元素将按反向顺
   序比较进行排序。

   使用 "functools.cmp_to_key()" 可将老式的 *cmp* 函数转换为 *key* 函
   数。

   内置的 "sorted()" 确保是稳定的。 如果一个排序确保不会改变比较结果相
   等的元素的相对顺序就称其为稳定的 --- 这有利于进行多重排序（例如先按
   部门、再按薪级排序）。

   有关排序示例和简要排序教程，请参阅 排序指南 。

@staticmethod

   将方法转换为静态方法。

   静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法

      class C:
          @staticmethod
          def f(arg1, arg2, ...): ...

   "@staticmethod" 这样的形式称为函数的 *decorator* -- 详情参阅 函数定
   义。

   静态方法的调用可以在类上进行 (例如 "C.f()") 也可以在实例上进行 (例
   如 "C().f()")。

   Python中的静态方法与Java或C ++中的静态方法类似。另请参阅
   "classmethod()" ，用于创建备用类构造函数的变体。

   像所有装饰器一样，也可以像常规函数一样调用 "staticmethod" ，并对其
   结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免
   自动转换为实例方法。对于这些情况，请使用此语法:

      class C:
          builtin_open = staticmethod(open)

   想了解更多有关静态方法的信息，请参阅 标准类型层级结构 。

class str(object='')
class str(object=b'', encoding='utf-8', errors='strict')

   返回一个 "str" 版本的 *object* 。有关详细信息，请参阅 "str()" 。

   "str" 是内置字符串 *class* 。更多关于字符串的信息查看 文本序列类型
   --- str。

sum(iterable, /, start=0)

   从 *start* 开始自左向右对 *iterable* 的项求和并返回总计值。
   *iterable* 的项通常为数字，而 start 值则不允许为字符串。

   对某些用例来说，存在 "sum()" 的更好替代。 拼接字符串序列的更好更快
   方式是调用 "''.join(sequence)"。 要以扩展精度对浮点值求和，请参阅
   "math.fsum()"。 要拼接一系列可迭代对象，请考虑使用
   "itertools.chain()"。

   在 3.8 版更改: *start* 形参可用关键字参数形式来指定。

super([type[, object-or-type]])

   返回一个代理对象，它会将方法调用委托给 *type* 的父类或兄弟类。 这对
   于访问已在类中被重载的继承方法很有用。

   *object-or-type* 确定用于搜索的 *method resolution order*。 搜索会
   从 *type* 之后的类开始。

   举例来说，如果 *object-or-type* 的 "__mro__" 为 "D -> B -> C -> A
   -> object" 并且 *type* 的值为 "B"，则 "super()" 将会搜索 "C -> A ->
   object"。

   *object-or-type* 的 "__mro__" 属性列出了 "getattr()" 和 "super()"
   所共同使用的方法解析搜索顺序。 该属性是动态的，可以在任何继承层级结
   构发生更新的时候被改变。

   如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一
   个对象，则 "isinstance(obj, type)" 必须为真值。 如果第二个参数为一
   个类型，则 "issubclass(type2, type)" 必须为真值（这适用于类方法）。

   *super* 有两个典型用例。 在具有单继承的类层级结构中，*super* 可用来
   引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与
   其他编程语言中 *super* 的用法非常相似。

   第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独
   有，在静态编译语言或仅支持单继承的语言中是不存在的。 这使得实现“菱
   形图”成为可能，在这时会有多个基类实现相同的方法。 好的设计强制要求
   这种方法在每个情况下具有相同的调用签名（因为调用顺序是在运行时确定
   的，也因为该顺序要适应类层级结构的更改，还因为该顺序可能包含在运行
   时之前未知的兄弟类）。

   对于以上两个用例，典型的超类调用看起来是这样的:

      class C(B):
          def method(self, arg):
              super().method(arg)    # This does the same thing as:
                                     # super(C, self).method(arg)

   除了方法查找之外，"super()" 也可用于属性查找。 一个可能的应用场合是
   在上级或同级类中调用 *描述器*。

   请注意 "super()" 是作为显式加点属性查找的绑定过程的一部分来实现的，
   例如 "super().__getitem__(name)"。 它做到这一点是通过实现自己的
   "__getattribute__()" 方法，这样就能以可预测的顺序搜索类，并且支持协
   作多重继承。 对应地，"super()" 在像 "super()[name]" 这样使用语句或
   操作符进行隐式查找时则未被定义。

   还要注意的是，除了零个参数的形式以外，"super()" 并不限于在方法内部
   使用。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式
   仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定
   义的类，还需要让普通方法访问当前实例。

   对于有关如何使用 "super()" 来如何设计协作类的实用建议，请参阅 使用
   super() 的指南。

class tuple([iterable])

   虽然被称为函数，但 "tuple" 实际上是一个不可变的序列类型，参见在 元
   组 与 序列类型 --- list, tuple, range 中的文档说明。

class type(object)
class type(name, bases, dict)

   传入一个参数时，返回 *object* 的类型。 返回值是一个 type 对象，通常
   与 "object.__class__" 所返回的对象相同。

   推荐使用 "isinstance()" 内置函数来检测对象的类型，因为它会考虑子类
   的情况。

   传入三个参数时，返回一个新的 type 对象。 这在本质上是 "class" 语句
   的一种动态形式。 *name* 字符串即类名并且会成为 "__name__" 属性；
   *bases* 元组列出基类并且会成为 "__bases__" 属性；而 *dict* 字典为包
   含类主体定义的命名空间并且会被复制到一个标准字典成为 "__dict__" 属
   性。 例如，下面两条语句会创建相同的 "type" 对象:

   >>> class X:
   ...     a = 1
   ...
   >>> X = type('X', (object,), dict(a=1))

   另请参阅 类型对象。

   在 3.6 版更改: "type" 的子类如果未重载 "type.__new__"，将不再能使用
   一个参数的形式来获取对象的类型。

vars([object])

   返回模块、类、实例或任何其它具有 "__dict__" 属性的对象的 "__dict__"
   属性。

   模块和实例这样的对象具有可更新的 "__dict__" 属性；但是，其它对象的
   "__dict__" 属性可能会设为限制写入（例如，类会使用
   "types.MappingProxyType" 来防止直接更新字典）。

   不带参数时，"vars()" 的行为类似 "locals()"。 请注意，locals 字典仅
   对于读取起作用，因为对 locals 字典的更新会被忽略。

   如果指定了一个对象但它没有 "__dict__" 属性（例如，当它所属的类定义
   了 "__slots__" 属性时）则会引发 "TypeError" 异常。

zip(*iterables)

   创建一个聚合了来自每个可迭代对象中的元素的迭代器。

   返回一个元组的迭代器，其中的第 *i* 个元组包含来自每个参数序列或可迭
   代对象的第 *i* 个元素。 当所输入可迭代对象中最短的一个被耗尽时，迭
   代器将停止迭代。 当只有一个可迭代对象参数时，它将返回一个单元组的迭
   代器。 不带参数时，它将返回一个空迭代器。 相当于:

      def zip(*iterables):
          # zip('ABCD', 'xy') --> Ax By
          sentinel = object()
          iterators = [iter(it) for it in iterables]
          while iterators:
              result = []
              for it in iterators:
                  elem = next(it, sentinel)
                  if elem is sentinel:
                      return
                  result.append(elem)
              yield tuple(result)

   函数会保证可迭代对象按从左至右的顺序被求值。 使得可以通过
   "zip(*[iter(s)]*n)" 这样的惯用形式将一系列数据聚类为长度为 n 的分组
   。 这将重复 *同样的* 迭代器 "n" 次，以便每个输出的元组具有第 "n" 次
   调用该迭代器的结果。 它的作用效果就是将输入拆分为长度为 n 的数据块
   。

   当你不用关心较长可迭代对象末尾不匹配的值时，则 "zip()" 只须使用长度
   不相等的输入即可。 如果那些值很重要，则应改用
   "itertools.zip_longest()"。

   "zip()" 与 "*" 运算符相结合可以用来拆解一个列表:

      >>> x = [1, 2, 3]
      >>> y = [4, 5, 6]
      >>> zipped = zip(x, y)
      >>> list(zipped)
      [(1, 4), (2, 5), (3, 6)]
      >>> x2, y2 = zip(*zip(x, y))
      >>> x == list(x2) and y == list(y2)
      True

__import__(name, globals=None, locals=None, fromlist=(), level=0)

   注解:

     与 "importlib.import_module()" 不同，这是一个日常 Python 编程中不
     需要用到的高级函数。

   此函数会由 "import" 语句发起调用。 它可以被替换 (通过导入
   "builtins" 模块并赋值给 "builtins.__import__") 以便修改 "import" 语
   句的语义，但是 **强烈** 不建议这样做，因为使用导入钩子 (参见 **PEP
   302**) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码
   都会假定所用的是默认实现。 同样也不建议直接使用 "__import__()" 而应
   该用 "importlib.import_module()"。

   该函数会导入 *name* 模块，有可能使用给定的 *globals* 和 *locals* 来
   确定如何在包的上下文中解读名称。 *fromlist* 给出了应该从由 *name*
   指定的模块导入对象或子模块的名称。 标准实现完全不使用其 *locals* 参
   数，而仅使用 *globals* 参数来确定 "import" 语句的包上下文。

   *level* 指定是使用绝对还是相对导入。 "0" (默认值) 意味着仅执行绝对
   导入。 *level* 为正数值表示相对于模块调用 "__import__()" 的目录，将
   要搜索的父目录层数 (详情参见 **PEP 328**)。

   当 *name* 变量的形式为 "package.module" 时，通常将会返回最高层级的
   包（第一个点号之前的名称），而 *不是* 以 *name* 命名的模块。 但是，
   当给出了非空的 *fromlist* 参数时，则将返回以 *name* 命名的模块。

   例如，语句 "import spam" 的结果将为与以下代码作用相同的字节码:

      spam = __import__('spam', globals(), locals(), [], 0)

   语句 "import spam.ham" 的结果将为以下调用:

      spam = __import__('spam.ham', globals(), locals(), [], 0)

   请注意在这里 "__import__()" 是如何返回顶层模块的，因为这是通过
   "import" 语句被绑定到特定名称的对象。

   另一方面，语句 "from spam.ham import eggs, sausage as saus" 的结果
   将为

      _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
      eggs = _temp.eggs
      saus = _temp.sausage

   在这里， "spam.ham" 模块会由 "__import__()" 返回。 要导入的对象将从
   此对象中提取并赋值给它们对应的名称。

   如果您只想按名称导入模块（可能在包中），请使用
   "importlib.import_module()"

   在 3.3 版更改: Negative values for *level* are no longer supported
   (which also changes the default value to 0).

   在 3.9 版更改: 当使用了命令行参数 "-E" 或 "-I" 时，环境变量
   "PYTHONCASEOK" 现在将被忽略。

-[ 脚注 ]-

[1] 解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用
    换行符转换模式转换 Windows 或 Mac 风格的换行符。
