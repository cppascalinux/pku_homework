"__future__" --- Future 语句定义
********************************

**源代码：** Lib/__future__.py

======================================================================

"__future__" 是一个真正的模块，这主要有 3 个原因：

* 避免混淆已有的分析 import 语句并查找 import 的模块的工具。

* 确保 future 语句 在 2.1 之前的版本运行时至少能抛出 runtime 异常（
  import "__future__" 会失败，因为 2.1 版本之前没有这个模块）。

* 当引入不兼容的修改时，可以记录其引入的时间以及强制使用的时间。这是一
  种可执行的文档，并且可以通过 import "__future__" 来做程序性的检查。

"__future__.py" 中的每一条语句都是以下格式的：

   FeatureName = _Feature(OptionalRelease, MandatoryRelease,
                          CompilerFlag)

通常 *OptionalRelease* 要比 *MandatoryRelease* 小，并且都是和
"sys.version_info" 格式一致的 5 元素元组。

   (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
    PY_MINOR_VERSION, # the 1; an int
    PY_MICRO_VERSION, # the 0; an int
    PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; string
    PY_RELEASE_SERIAL # the 3; an int
   )

*OptionalRelease* 记录了一个特性首次发布时的 Python 版本。

在 *MandatoryRelases* 还没有发布时，*MandatoryRelease* 表示该特性会变
成语言的一部分的预测时间。

其他情况下，*MandatoryRelease* 用来记录这个特性是何时成为语言的一部分
的。从该版本往后，使用该特性将不需要 future 语句，不过很多人还是会加上
对应的 import。

*MandatoryRelease* 也可能是 "None", 表示这个特性已经被撤销。

"_Feature" 类的实例有两个对应的方法，"getOptionalRelease()" 和
"getMandatoryRelease()"。

*CompilerFlag* 是一个（位）标记，对于动态编译的代码，需要将这个标记作
为第四个参数传入内建函数 "compile()" 中以开启对应的特性。这个标记存储
在 "_Feature" 类实例的 "compiler_flag" 属性中。

"__future__" 中不会删除特性的描述。从 Python 2.1 中首次加入以来，通过
这种方式引入了以下特性：

+--------------------+---------------+----------------+-----------------------------------------------+
| 特性               | 可选版本      | 强制加入版本   | 效果                                          |
|====================|===============|================|===============================================|
| nested_scopes      | 2.1.0b1       | 2.2            | **PEP 227**: *Statically Nested Scopes*       |
+--------------------+---------------+----------------+-----------------------------------------------+
| generators         | 2.2.0a1       | 2.3            | **PEP 255**: *Simple Generators*              |
+--------------------+---------------+----------------+-----------------------------------------------+
| division           | 2.2.0a2       | 3.0            | **PEP 238**: *Changing the Division Operator* |
+--------------------+---------------+----------------+-----------------------------------------------+
| absolute_import    | 2.5.0a1       | 3.0            | **PEP 328**: *Imports: Multi-Line and         |
|                    |               |                | Absolute/Relative*                            |
+--------------------+---------------+----------------+-----------------------------------------------+
| with_statement     | 2.5.0a1       | 2.6            | **PEP 343**: *The "with" Statement*           |
+--------------------+---------------+----------------+-----------------------------------------------+
| print_function     | 2.6.0a2       | 3.0            | **PEP 3105**: *Make print a function*         |
+--------------------+---------------+----------------+-----------------------------------------------+
| unicode_literals   | 2.6.0a2       | 3.0            | **PEP 3112**: *Bytes literals in Python 3000* |
+--------------------+---------------+----------------+-----------------------------------------------+
| generator_stop     | 3.5.0b1       | 3.7            | **PEP 479**: *StopIteration handling inside   |
|                    |               |                | generators*                                   |
+--------------------+---------------+----------------+-----------------------------------------------+
| annotations        | 3.7.0b1       | 3.10           | **PEP 563**: *Postponed evaluation of         |
|                    |               |                | annotations*                                  |
+--------------------+---------------+----------------+-----------------------------------------------+

参见:

  future 语句
     编译器怎样处理 future import。
