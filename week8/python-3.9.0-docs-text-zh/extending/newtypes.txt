3. 定义扩展类型：已分类主题
***************************

本章节目标是提供一个各种你可以实现的类型方法及其功能的简短介绍。

这是C类型 "PyTypeObject" 的定义，省略了只用于调试构建的字段:

   typedef struct _typeobject {
       PyObject_VAR_HEAD
       const char *tp_name; /* For printing, in format "<module>.<name>" */
       Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

       /* Methods to implement standard operations */

       destructor tp_dealloc;
       Py_ssize_t tp_vectorcall_offset;
       getattrfunc tp_getattr;
       setattrfunc tp_setattr;
       PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)
                                       or tp_reserved (Python 3) */
       reprfunc tp_repr;

       /* Method suites for standard classes */

       PyNumberMethods *tp_as_number;
       PySequenceMethods *tp_as_sequence;
       PyMappingMethods *tp_as_mapping;

       /* More standard operations (here for binary compatibility) */

       hashfunc tp_hash;
       ternaryfunc tp_call;
       reprfunc tp_str;
       getattrofunc tp_getattro;
       setattrofunc tp_setattro;

       /* Functions to access object as input/output buffer */
       PyBufferProcs *tp_as_buffer;

       /* Flags to define presence of optional/expanded features */
       unsigned long tp_flags;

       const char *tp_doc; /* Documentation string */

       /* call function for all accessible objects */
       traverseproc tp_traverse;

       /* delete references to contained objects */
       inquiry tp_clear;

       /* rich comparisons */
       richcmpfunc tp_richcompare;

       /* weak reference enabler */
       Py_ssize_t tp_weaklistoffset;

       /* Iterators */
       getiterfunc tp_iter;
       iternextfunc tp_iternext;

       /* Attribute descriptor and subclassing stuff */
       struct PyMethodDef *tp_methods;
       struct PyMemberDef *tp_members;
       struct PyGetSetDef *tp_getset;
       struct _typeobject *tp_base;
       PyObject *tp_dict;
       descrgetfunc tp_descr_get;
       descrsetfunc tp_descr_set;
       Py_ssize_t tp_dictoffset;
       initproc tp_init;
       allocfunc tp_alloc;
       newfunc tp_new;
       freefunc tp_free; /* Low-level free-memory routine */
       inquiry tp_is_gc; /* For PyObject_IS_GC */
       PyObject *tp_bases;
       PyObject *tp_mro; /* method resolution order */
       PyObject *tp_cache;
       PyObject *tp_subclasses;
       PyObject *tp_weaklist;
       destructor tp_del;

       /* Type attribute cache version tag. Added in version 2.6 */
       unsigned int tp_version_tag;

       destructor tp_finalize;

   } PyTypeObject;

这里有 *很多* 方法。但是不要太担心，如果你要定义一个类型，通常只需要实
现少量的方法。

正如你猜到的一样，我们正要一步一步详细介绍各种处理程序。因为有大量的历
史包袱影响字段的排序，所以我们不会根据它们在结构体里定义的顺序讲解。通
常非常容易找到一个包含你需要的字段的例子，然后改变值去适应你新的类型。

   const char *tp_name; /* For printing */

类型的名字 - 上一章提到过的，会出现在很多地方，几乎全部都是为了诊断目
的。尝试选择一个好名字，对于诊断很有帮助。

   Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

这些字段告诉运行时在创造这个类型的新对象时需要分配多少内存。Python为了
可变长度的结构（想下：字符串，元组）有些内置支持，这是 "tp_itemsize"
字段存在的原由。这部分稍后解释。

   const char *tp_doc;

这里你可以放置一段字符串（或者它的地址），当你想在Python脚本引用
"obj.__doc__" 时返回这段文档字符串。

现在我们来看一下基本类型方法 - 大多数扩展类型将实现的方法。


3.1. 终结和内存释放
===================

   destructor tp_dealloc;

当您的类型实例的引用计数减少为零并且Python解释器想要回收它时，将调用此
函数。如果你的类型有内存可供释放或执行其他清理，你可以把它放在这里。
对象本身也需要在这里释放。 以下是此函数的示例：

   static void
   newdatatype_dealloc(newdatatypeobject *obj)
   {
       free(obj->obj_UnderlyingDatatypePtr);
       Py_TYPE(obj)->tp_free(obj);
   }

一个重要的释放器函数实现要求是把所有未决异常放着不动。这很重要是因为释
放器会被解释器频繁的调用，当栈异常退出时(而非正常返回)，不会有任何办法
保护释放器看到一个异常尚未被设置。此事释放器的任何行为都会导致额外增加
的Python代码来检查异常是否被设置。这可能导致解释器的误导性错误。正确的
保护方法是，在任何不安全的操作前，保存未决异常，然后在其完成后恢复。者
可以通过 "PyErr_Fetch()" 和 "PyErr_Restore()" 函数来实现:

   static void
   my_dealloc(PyObject *obj)
   {
       MyObject *self = (MyObject *) obj;
       PyObject *cbresult;

       if (self->my_callback != NULL) {
           PyObject *err_type, *err_value, *err_traceback;

           /* This saves the current exception state */
           PyErr_Fetch(&err_type, &err_value, &err_traceback);

           cbresult = PyObject_CallNoArgs(self->my_callback);
           if (cbresult == NULL)
               PyErr_WriteUnraisable(self->my_callback);
           else
               Py_DECREF(cbresult);

           /* This restores the saved exception state */
           PyErr_Restore(err_type, err_value, err_traceback);

           Py_DECREF(self->my_callback);
       }
       Py_TYPE(obj)->tp_free((PyObject*)self);
   }

注解:

  There are limitations to what you can safely do in a deallocator
  function. First, if your type supports garbage collection (using
  "tp_traverse" and/or "tp_clear"), some of the object's members can
  have been cleared or finalized by the time "tp_dealloc" is called.
  Second, in "tp_dealloc", your object is in an unstable state: its
  reference count is equal to zero.  Any call to a non-trivial object
  or API (as in the example above) might end up calling "tp_dealloc"
  again, causing a double free and a crash.从 Python 3.4 开始，推荐不
  要在 "tp_dealloc" 放复杂的终结代码，而是使用新的 "tp_finalize" 类型
  方法。

  参见: **PEP 442** 解释了新的终结方案。


3.2. 对象展示
=============

在 Python 中，有两种方式可以生成对象的文本表示: "repr()" 函数和
"str()" 函数。 ("print()" 函数会直接调用 "str()"。) 这些处理程序都是可
选的。

   reprfunc tp_repr;
   reprfunc tp_str;

"tp_repr" 处理程序应该返回一个字符串对象，其中包含调用它的实例的表示形
式。 下面是一个简单的例子:

   static PyObject *
   newdatatype_repr(newdatatypeobject * obj)
   {
       return PyUnicode_FromFormat("Repr-ified_newdatatype{{size:%d}}",
                                   obj->obj_UnderlyingDatatypePtr->size);
   }

如果没有指定 "tp_repr" 处理程序，解释器将提供一个使用 "tp_name" 的表示
形式以及对象的惟一标识值。

The "tp_str" handler is to "str()" what the "tp_repr" handler
described above is to "repr()"; that is, it is called when Python code
calls "str()" on an instance of your object.  Its implementation is
very similar to the "tp_repr" function, but the resulting string is
intended for human consumption.  If "tp_str" is not specified, the
"tp_repr" handler is used instead.

下面是一个简单的例子:

   static PyObject *
   newdatatype_str(newdatatypeobject * obj)
   {
       return PyUnicode_FromFormat("Stringified_newdatatype{{size:%d}}",
                                   obj->obj_UnderlyingDatatypePtr->size);
   }


3.3. 属性管理
=============

For every object which can support attributes, the corresponding type
must provide the functions that control how the attributes are
resolved.  There needs to be a function which can retrieve attributes
(if any are defined), and another to set attributes (if setting
attributes is allowed).  Removing an attribute is a special case, for
which the new value passed to the handler is "NULL".

Python supports two pairs of attribute handlers; a type that supports
attributes only needs to implement the functions for one pair.  The
difference is that one pair takes the name of the attribute as a
"char*", while the other accepts a "PyObject*".  Each type can use
whichever pair makes more sense for the implementation's convenience.

   getattrfunc  tp_getattr;        /* char * version */
   setattrfunc  tp_setattr;
   /* ... */
   getattrofunc tp_getattro;       /* PyObject * version */
   setattrofunc tp_setattro;

If accessing attributes of an object is always a simple operation
(this will be explained shortly), there are generic implementations
which can be used to provide the "PyObject*" version of the attribute
management functions. The actual need for type-specific attribute
handlers almost completely disappeared starting with Python 2.2,
though there are many examples which have not been updated to use some
of the new generic mechanism that is available.


3.3.1. 泛型属性管理
-------------------

Most extension types only use *simple* attributes.  So, what makes the
attributes simple?  There are only a couple of conditions that must be
met:

1. The name of the attributes must be known when "PyType_Ready()" is
   called.

2. 不需要特殊的处理来记录属性是否被查找或设置，也不需要根据值采取操作
   。

请注意，此列表不对属性的值、值的计算时间或相关数据的存储方式施加任何限
制。

When "PyType_Ready()" is called, it uses three tables referenced by
the type object to create *descriptor*s which are placed in the
dictionary of the type object.  Each descriptor controls access to one
attribute of the instance object.  Each of the tables is optional; if
all three are "NULL", instances of the type will only have attributes
that are inherited from their base type, and should leave the
"tp_getattro" and "tp_setattro" fields "NULL" as well, allowing the
base type to handle attributes.

表被声明为object::类型的三个字段:

   struct PyMethodDef *tp_methods;
   struct PyMemberDef *tp_members;
   struct PyGetSetDef *tp_getset;

If "tp_methods" is not "NULL", it must refer to an array of
"PyMethodDef" structures.  Each entry in the table is an instance of
this structure:

   typedef struct PyMethodDef {
       const char  *ml_name;       /* method name */
       PyCFunction  ml_meth;       /* implementation function */
       int          ml_flags;      /* flags */
       const char  *ml_doc;        /* docstring */
   } PyMethodDef;

One entry should be defined for each method provided by the type; no
entries are needed for methods inherited from a base type.  One
additional entry is needed at the end; it is a sentinel that marks the
end of the array.  The "ml_name" field of the sentinel must be "NULL".

The second table is used to define attributes which map directly to
data stored in the instance.  A variety of primitive C types are
supported, and access may be read-only or read-write.  The structures
in the table are defined as:

   typedef struct PyMemberDef {
       const char *name;
       int         type;
       int         offset;
       int         flags;
       const char *doc;
   } PyMemberDef;

For each entry in the table, a *descriptor* will be constructed and
added to the type which will be able to extract a value from the
instance structure.  The "type" field should contain one of the type
codes defined in the "structmember.h" header; the value will be used
to determine how to convert Python values to and from C values.  The
"flags" field is used to store flags which control how the attribute
can be accessed.

以下标志常量定义在:file: ' structmember.h ';它们可以使用bitwise-OR组合
。

+-----------------------------+------------------------------------------------+
| 常数                        | 意义                                           |
|=============================|================================================|
| "READONLY"                  | 没有可写的                                     |
+-----------------------------+------------------------------------------------+
| "READ_RESTRICTED"           | Not readable in restricted mode.               |
+-----------------------------+------------------------------------------------+
| "WRITE_RESTRICTED"          | Not writable in restricted mode.               |
+-----------------------------+------------------------------------------------+
| "RESTRICTED"                | 在受限模式下不可读，也不可写。                 |
+-----------------------------+------------------------------------------------+

An interesting advantage of using the "tp_members" table to build
descriptors that are used at runtime is that any attribute defined
this way can have an associated doc string simply by providing the
text in the table.  An application can use the introspection API to
retrieve the descriptor from the class object, and get the doc string
using its "__doc__" attribute.

As with the "tp_methods" table, a sentinel entry with a "name" value
of "NULL" is required.


3.3.2. Type-specific Attribute Management
-----------------------------------------

For simplicity, only the "char*" version will be demonstrated here;
the type of the name parameter is the only difference between the
"char*" and "PyObject*" flavors of the interface. This example
effectively does the same thing as the generic example above, but does
not use the generic support added in Python 2.2.  It explains how the
handler functions are called, so that if you do need to extend their
functionality, you'll understand what needs to be done.

The "tp_getattr" handler is called when the object requires an
attribute look-up.  It is called in the same situations where the
"__getattr__()" method of a class would be called.

例如：

   static PyObject *
   newdatatype_getattr(newdatatypeobject *obj, char *name)
   {
       if (strcmp(name, "data") == 0)
       {
           return PyLong_FromLong(obj->data);
       }

       PyErr_Format(PyExc_AttributeError,
                    "'%.50s' object has no attribute '%.400s'",
                    tp->tp_name, name);
       return NULL;
   }

The "tp_setattr" handler is called when the "__setattr__()" or
"__delattr__()" method of a class instance would be called.  When an
attribute should be deleted, the third parameter will be "NULL".  Here
is an example that simply raises an exception; if this were really all
you wanted, the "tp_setattr" handler should be set to "NULL".

   static int
   newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v)
   {
       PyErr_Format(PyExc_RuntimeError, "Read-only attribute: %s", name);
       return -1;
   }


3.4. Object Comparison
======================

   richcmpfunc tp_richcompare;

The "tp_richcompare" handler is called when comparisons are needed.
It is analogous to the rich comparison methods, like "__lt__()", and
also called by "PyObject_RichCompare()" and
"PyObject_RichCompareBool()".

This function is called with two Python objects and the operator as
arguments, where the operator is one of "Py_EQ", "Py_NE", "Py_LE",
"Py_GT", "Py_LT" or "Py_GT".  It should compare the two objects with
respect to the specified operator and return "Py_True" or "Py_False"
if the comparison is successful, "Py_NotImplemented" to indicate that
comparison is not implemented and the other object's comparison method
should be tried, or "NULL" if an exception was set.

Here is a sample implementation, for a datatype that is considered
equal if the size of an internal pointer is equal:

   static PyObject *
   newdatatype_richcmp(PyObject *obj1, PyObject *obj2, int op)
   {
       PyObject *result;
       int c, size1, size2;

       /* code to make sure that both arguments are of type
          newdatatype omitted */

       size1 = obj1->obj_UnderlyingDatatypePtr->size;
       size2 = obj2->obj_UnderlyingDatatypePtr->size;

       switch (op) {
       case Py_LT: c = size1 <  size2; break;
       case Py_LE: c = size1 <= size2; break;
       case Py_EQ: c = size1 == size2; break;
       case Py_NE: c = size1 != size2; break;
       case Py_GT: c = size1 >  size2; break;
       case Py_GE: c = size1 >= size2; break;
       }
       result = c ? Py_True : Py_False;
       Py_INCREF(result);
       return result;
    }


3.5. Abstract Protocol Support
==============================

Python supports a variety of *abstract* 'protocols;' the specific
interfaces provided to use these interfaces are documented in 抽象对象
层.

A number of these abstract interfaces were defined early in the
development of the Python implementation.  In particular, the number,
mapping, and sequence protocols have been part of Python since the
beginning.  Other protocols have been added over time.  For protocols
which depend on several handler routines from the type implementation,
the older protocols have been defined as optional blocks of handlers
referenced by the type object.  For newer protocols there are
additional slots in the main type object, with a flag bit being set to
indicate that the slots are present and should be checked by the
interpreter.  (The flag bit does not indicate that the slot values are
non-"NULL". The flag may be set to indicate the presence of a slot,
but a slot may still be unfilled.)

   PyNumberMethods   *tp_as_number;
   PySequenceMethods *tp_as_sequence;
   PyMappingMethods  *tp_as_mapping;

If you wish your object to be able to act like a number, a sequence,
or a mapping object, then you place the address of a structure that
implements the C type "PyNumberMethods", "PySequenceMethods", or
"PyMappingMethods", respectively. It is up to you to fill in this
structure with appropriate values. You can find examples of the use of
each of these in the "Objects" directory of the Python source
distribution.

   hashfunc tp_hash;

This function, if you choose to provide it, should return a hash
number for an instance of your data type. Here is a simple example:

   static Py_hash_t
   newdatatype_hash(newdatatypeobject *obj)
   {
       Py_hash_t result;
       result = obj->some_size + 32767 * obj->some_number;
       if (result == -1)
          result = -2;
       return result;
   }

"Py_hash_t" is a signed integer type with a platform-varying width.
Returning "-1" from "tp_hash" indicates an error, which is why you
should be careful to avoid returning it when hash computation is
successful, as seen above.

   ternaryfunc tp_call;

This function is called when an instance of your data type is
"called", for example, if "obj1" is an instance of your data type and
the Python script contains "obj1('hello')", the "tp_call" handler is
invoked.

This function takes three arguments:

1. *self* is the instance of the data type which is the subject of the
   call. If the call is "obj1('hello')", then *self* is "obj1".

2. *args* is a tuple containing the arguments to the call.  You can
   use "PyArg_ParseTuple()" to extract the arguments.

3. *kwds* is a dictionary of keyword arguments that were passed. If
   this is non-"NULL" and you support keyword arguments, use
   "PyArg_ParseTupleAndKeywords()" to extract the arguments.  If you
   do not want to support keyword arguments and this is non-"NULL",
   raise a "TypeError" with a message saying that keyword arguments
   are not supported.

Here is a toy "tp_call" implementation:

   static PyObject *
   newdatatype_call(newdatatypeobject *self, PyObject *args, PyObject *kwds)
   {
       PyObject *result;
       const char *arg1;
       const char *arg2;
       const char *arg3;

       if (!PyArg_ParseTuple(args, "sss:call", &arg1, &arg2, &arg3)) {
           return NULL;
       }
       result = PyUnicode_FromFormat(
           "Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\n",
           obj->obj_UnderlyingDatatypePtr->size,
           arg1, arg2, arg3);
       return result;
   }

   /* Iterators */
   getiterfunc tp_iter;
   iternextfunc tp_iternext;

These functions provide support for the iterator protocol.  Both
handlers take exactly one parameter, the instance for which they are
being called, and return a new reference.  In the case of an error,
they should set an exception and return "NULL".  "tp_iter" corresponds
to the Python "__iter__()" method, while "tp_iternext" corresponds to
the Python "__next__()" method.

Any *iterable* object must implement the "tp_iter" handler, which must
return an *iterator* object.  Here the same guidelines apply as for
Python classes:

* For collections (such as lists and tuples) which can support
  multiple independent iterators, a new iterator should be created and
  returned by each call to "tp_iter".

* Objects which can only be iterated over once (usually due to side
  effects of iteration, such as file objects) can implement "tp_iter"
  by returning a new reference to themselves -- and should also
  therefore implement the "tp_iternext"  handler.

Any *iterator* object should implement both "tp_iter" and
"tp_iternext".  An iterator's "tp_iter" handler should return a new
reference to the iterator.  Its "tp_iternext" handler should return a
new reference to the next object in the iteration, if there is one. If
the iteration has reached the end, "tp_iternext" may return "NULL"
without setting an exception, or it may set "StopIteration" *in
addition* to returning "NULL"; avoiding the exception can yield
slightly better performance.  If an actual error occurs, "tp_iternext"
should always set an exception and return "NULL".


3.6. Weak Reference Support
===========================

One of the goals of Python's weak reference implementation is to allow
any type to participate in the weak reference mechanism without
incurring the overhead on performance-critical objects (such as
numbers).

参见: Documentation for the "weakref" module.

For an object to be weakly referencable, the extension type must do
two things:

1. Include a "PyObject*" field in the C object structure dedicated to
   the weak reference mechanism.  The object's constructor should
   leave it "NULL" (which is automatic when using the default
   "tp_alloc").

2. Set the "tp_weaklistoffset" type member to the offset of the
   aforementioned field in the C object structure, so that the
   interpreter knows how to access and modify that field.

Concretely, here is how a trivial object structure would be augmented
with the required field:

   typedef struct {
       PyObject_HEAD
       PyObject *weakreflist;  /* List of weak references */
   } TrivialObject;

And the corresponding member in the statically-declared type object:

   static PyTypeObject TrivialType = {
       PyVarObject_HEAD_INIT(NULL, 0)
       /* ... other members omitted for brevity ... */
       .tp_weaklistoffset = offsetof(TrivialObject, weakreflist),
   };

The only further addition is that "tp_dealloc" needs to clear any weak
references (by calling "PyObject_ClearWeakRefs()") if the field is
non-"NULL":

   static void
   Trivial_dealloc(TrivialObject *self)
   {
       /* Clear weakrefs first before calling any destructors */
       if (self->weakreflist != NULL)
           PyObject_ClearWeakRefs((PyObject *) self);
       /* ... remainder of destruction code omitted for brevity ... */
       Py_TYPE(self)->tp_free((PyObject *) self);
   }


3.7. 更多建议
=============

In order to learn how to implement any specific method for your new
data type, get the *CPython* source code.  Go to the "Objects"
directory, then search the C source files for "tp_" plus the function
you want (for example, "tp_richcompare").  You will find examples of
the function you want to implement.

When you need to verify that an object is a concrete instance of the
type you are implementing, use the "PyObject_TypeCheck()" function.  A
sample of its use might be something like the following:

   if (!PyObject_TypeCheck(some_object, &MyType)) {
       PyErr_SetString(PyExc_TypeError, "arg #1 not a mything");
       return NULL;
   }

参见:

  下载CPython源代码版本。
     https://www.python.org/downloads/source/

  GitHub上开发CPython源代码的CPython项目。
     https://github.com/python/cpython
