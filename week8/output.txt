{Q001001001En:"General Python FAQ==>General Information==>What is Python?"}
{A001001001En:"Python is an interpreted, interactive, object-oriented programming
language.  It incorporates modules, exceptions, dynamic typing, very
high level dynamic data types, and classes.  It supports multiple
programming paradigms beyond object-oriented programming, such as
procedural and functional programming. Python combines remarkable
power with very clear syntax. It has interfaces to many system calls
and libraries, as well as to various window systems, and is extensible
in C or C++.  It is also usable as an extension language for
applications that need a programmable interface. Finally, Python is
portable: it runs on many Unix variants including Linux and macOS, and
on Windows.

To find out more, start with The Python Tutorial.  The Beginner's
Guide to Python links to other introductory tutorials and resources
for learning Python."}
{Q001001001Zh:"Python常见问题==>一般信息==>什么是 Python？"}
{A001001001Zh:"Python 是一种解释型、交互式、面向对象的编程语言。 它包含了模块、异常、
动态类型、高层级动态数据类型以及类等特性。 在面向对象编程以外它还支持
多种编程范式，例如过程式和函数式编程等。 Python 结合了超强的功能和极清
晰的语法。 它带有许多系统调用和库以及多种窗口系统的接口，并且能用 C 或
C++ 来进行扩展。 它还可用作需要可编程接口的应用程序的扩展语言。 最后，
Python 非常易于移植：它可以在包括 Linux 和 macOS 在内的许多 Unix 变种
以及 Windows 上运行。

要了解更多详情，请先查看 Python 教程。 Python 新手指南 提供了学习
Python 的其他入门教程及资源的链接。"}
{Q001001002En:"General Python FAQ==>General Information==>What is the Python Software Foundation?"}
{A001001002En:"The Python Software Foundation is an independent non-profit
organization that holds the copyright on Python versions 2.1 and
newer.  The PSF's mission is to advance open source technology related
to the Python programming language and to publicize the use of Python.
The PSF's home page is at https://www.python.org/psf/.

Donations to the PSF are tax-exempt in the US.  If you use Python and
find it helpful, please contribute via the PSF donation page."}
{Q001001002Zh:"Python常见问题==>一般信息==>什么是 Python 软件基金会？"}
{A001001002Zh:"Python 软件基金会（Python Software Foundation，简称 PSF）是一个独立的
非盈利组织，它拥有 Python 2.1 及以上各版本的版权。 PSF 的使命是推进与
Python 编程语言相关的开源技术，并推广 Python 的使用。 PSF 的主页是
https://www.python.org/psf/。

向 PSF 提供捐助在美国是免税的。 如果你在使用 Python 并且感觉它对你很有
帮助，可以通过 PSF 捐助页 进行捐助。"}
{Q001001003En:"General Python FAQ==>General Information==>Are there copyright restrictions on the use of Python?"}
{A001001003En:"You can do anything you want with the source, as long as you leave the
copyrights in and display those copyrights in any documentation about
Python that you produce.  If you honor the copyright rules, it's OK to
use Python for commercial use, to sell copies of Python in source or
binary form (modified or unmodified), or to sell products that
incorporate Python in some form.  We would still like to know about
all commercial use of Python, of course.

See the PSF license page to find further explanations and a link to
the full text of the license.

The Python logo is trademarked, and in certain cases permission is
required to use it.  Consult the Trademark Usage Policy for more
information."}
{Q001001003Zh:"Python常见问题==>一般信息==>使用 Python 是否存在版权限制？"}
{A001001003Zh:"你可以任意使用源码，只要你保留版权信息并在你基于 Python 的产品文档中显
示该版权信息。 如果你遵守此版权规则，就可以将 Python 用于商业领域，以
源码或二进制码的形式（不论是否经过修改）销售 Python 的副本，或是以某种
形式包含了 Python 的产品。 当然，我们仍然希望获知所有对 Python 的商业
使用。

请参阅 PSF 许可页 以查看进一步的说明以及许可的完整文本内容的链接。

Python 的徽标是注册商标，在某些情况下需要获得允许方可使用。 请参阅 商
标使用政策 了解详情。"}
{Q001001004En:"General Python FAQ==>General Information==>Why was Python created in the first place?"}
{A001001004En:"Here's a *very* brief summary of what started it all, written by Guido
van Rossum:

   I had extensive experience with implementing an interpreted
   language in the ABC group at CWI, and from working with this group
   I had learned a lot about language design.  This is the origin of
   many Python features, including the use of indentation for
   statement grouping and the inclusion of very-high-level data types
   (although the details are all different in Python).

   I had a number of gripes about the ABC language, but also liked
   many of its features.  It was impossible to extend the ABC language
   (or its implementation) to remedy my complaints -- in fact its lack
   of extensibility was one of its biggest problems.  I had some
   experience with using Modula-2+ and talked with the designers of
   Modula-3 and read the Modula-3 report. Modula-3 is the origin of
   the syntax and semantics used for exceptions, and some other Python
   features.

   I was working in the Amoeba distributed operating system group at
   CWI.  We needed a better way to do system administration than by
   writing either C programs or Bourne shell scripts, since Amoeba had
   its own system call interface which wasn't easily accessible from
   the Bourne shell.  My experience with error handling in Amoeba made
   me acutely aware of the importance of exceptions as a programming
   language feature.

   It occurred to me that a scripting language with a syntax like ABC
   but with access to the Amoeba system calls would fill the need.  I
   realized that it would be foolish to write an Amoeba-specific
   language, so I decided that I needed a language that was generally
   extensible.

   During the 1989 Christmas holidays, I had a lot of time on my hand,
   so I decided to give it a try.  During the next year, while still
   mostly working on it in my own time, Python was used in the Amoeba
   project with increasing success, and the feedback from colleagues
   made me add many early improvements.

   In February 1991, after just over a year of development, I decided
   to post to USENET.  The rest is in the "Misc/HISTORY" file."}
{Q001001004Zh:"Python常见问题==>一般信息==>创造 Python 的最初理由是什么？"}
{A001001004Zh:"以下是有关最初缘起的一份 *非常* 简短的摘要，由 Guido van Rossum 本人撰
写:

   我在 CWI 的 ABC 部门时在实现解释型语言方面积累了丰富经验，通过与这
   个部门成员的协同工作，我学到了大量有关语言设计的知识。 这是许多
   Python 特性的最初来源，包括使用缩进来组织语句以及包含非常高层级的数
   据结构（虽然在 Python 中具体的实现细节完全不同）。

   我对 ABC 语言有过许多抱怨，但同时也很喜欢它的许多特性。 没有可能通
   过扩展 ABC 语言（或它的实现）来弥补我的不满 —— 实际上缺乏可扩展性就
   是它最大的问题之一。 我也有一些使用 Modula-2+ 的经验，并曾与
   Modula-3 的设计者进行交流，还阅读了 Modula-3 的报告。 Modula-3 是
   Python 中异常机制所用语法和语义，以及其他一些语言特性的最初来源。

   我还曾在 CWI 的 Amoeba 分布式操作系统部门工作。 当时我们需要有一种
   比编写 C 程序或 Bash 脚本更好的方式来进行系统管理，因为 Amoeba 有它
   自己的系统调用接口，并且无法方便地通过 Bash 来访问。 我在 Amoeba 中
   处理错误的经验令我深刻地意识到异常处理在编程语言特性当中的重要地位
   。

   我发现，某种具有 ABC 式的语法而又能访问 Amoeba 系统调用的脚本语言将
   可满足需求。 我意识到编写一种 Amoeba 专属的语言是愚蠢的，所以我决定
   编写一种具有全面可扩展性的语言。

   在 1989 年的圣诞假期中，我手头的时间非常充裕，因此我决定开始尝试一
   下。 在接下来的一年里，虽然我仍然主要用我的业余时间来做这件事，但
   Python 在 Amoeba 项目中的使用获得了很大的成功，来自同事的反馈让我得
   以增加了许多早期的改进。

   到 1991 年 2 月，经过一年多的开发，我决定将其发布到 USENET。 之后的
   事情就都可以在 "Misc/HISTORY" 文件里面看了。"}
{Q001001005En:"General Python FAQ==>General Information==>What is Python good for?"}
{A001001005En:"Python is a high-level general-purpose programming language that can
be applied to many different classes of problems.

The language comes with a large standard library that covers areas
such as string processing (regular expressions, Unicode, calculating
differences between files), Internet protocols (HTTP, FTP, SMTP, XML-
RPC, POP, IMAP, CGI programming), software engineering (unit testing,
logging, profiling, parsing Python code), and operating system
interfaces (system calls, filesystems, TCP/IP sockets).  Look at the
table of contents for The Python Standard Library to get an idea of
what's available.  A wide variety of third-party extensions are also
available.  Consult the Python Package Index to find packages of
interest to you."}
{Q001001005Zh:"Python常见问题==>一般信息==>Python 适合做什么？"}
{A001001005Zh:"Python 是一种高层级的多用途编程语言，可用于解决许多不同门类的问题。

该语言附带一个庞大的标准库，涵盖了字符串处理（正则表达式，Unicode，比
较文件间的差异等），因特网协议（HTTP，FTP，SMTP，XML-RPC，POP，IMAP，
CGI 编程等），软件工程（单元测试，日志记录，性能分析，Python 代码解析
等），以及操作系统接口（系统调用，文件系统，TCP/IP 套接字等）。 请查看
Python 标准库 的目录以了解所有可用的内容。 此外还可以获取到各种各样的
第三方扩展。 请访问 Python 包索引 来查找你感兴趣的软件包。"}
{Q001001006En:"General Python FAQ==>General Information==>How does the Python version numbering scheme work?"}
{A001001006En:"Python versions are numbered A.B.C or A.B.  A is the major version
number -- it is only incremented for really major changes in the
language.  B is the minor version number, incremented for less earth-
shattering changes.  C is the micro-level -- it is incremented for
each bugfix release.  See **PEP 6** for more information about bugfix
releases.

Not all releases are bugfix releases.  In the run-up to a new major
release, a series of development releases are made, denoted as alpha,
beta, or release candidate.  Alphas are early releases in which
interfaces aren't yet finalized; it's not unexpected to see an
interface change between two alpha releases. Betas are more stable,
preserving existing interfaces but possibly adding new modules, and
release candidates are frozen, making no changes except as needed to
fix critical bugs.

Alpha, beta and release candidate versions have an additional suffix.
The suffix for an alpha version is "aN" for some small number N, the
suffix for a beta version is "bN" for some small number N, and the
suffix for a release candidate version is "rcN" for some small number
N.  In other words, all versions labeled 2.0aN precede the versions
labeled 2.0bN, which precede versions labeled 2.0rcN, and *those*
precede 2.0.

You may also find version numbers with a "+" suffix, e.g. "2.2+".
These are unreleased versions, built directly from the CPython
development repository.  In practice, after a final minor release is
made, the version is incremented to the next minor version, which
becomes the "a0" version, e.g. "2.4a0".

See also the documentation for "sys.version", "sys.hexversion", and
"sys.version_info"."}
{Q001001006Zh:"Python常见问题==>一般信息==>Python 版本的编号形式是怎样的？"}
{A001001006Zh:"Python 版本的编号形式是 A.B.C 或 A.B。 A 称为大版本号 —— 它仅在对语言
特性进行非常重大改变时才会递增。 B 称为小版本号，它会在语言特性发生较
小改变时递增。 C 称为微版本号 —— 它会在每次发布问题修正时递增。 请参阅
**PEP 6** 了解有关问题修正发布版的详情。

发布版本并非都是问题修正版本。 在新的主要发布版本开发过程中，还会发布
一系列的开发版，它们以 alpha (a), beta (b) 或 release candidate (rc)
来标示。 其中 alpha 版是早期发布的测试版，它的接口并未最终确定；在两个
alpha 发布版本间出现接口的改变并不意外。 而 beta 版更为稳定，它会保留
现有的接口，但也可能增加新的模块，release candidate 版则会保持冻结状态
不会再进行改变，除非有重大问题需要修正。

以上 alpha, beta 和 release candidate 版本会附加一个后缀。 用于 alpha
版本的后缀是带有一个小数字 N 的“aN”，beta 版本的后缀是带有一个小数字 N
的“bN”，而 release candidate 版本的后缀是带有一个小数字 N 的“rcN”。 换
句话说，所有标记为 2.0aN 的版本都早于标记为 2.0bN 的版本，后者又都早于
标记为 2.0rcN 的版本，而 *它们* 全都早于 2.0。

你还可能看到带有“+”后缀的版本号，例如“2.2+”。 这表示未发布版本，直接基
于 CPython 开发代码仓库构建。 在实际操作中，当一个小版本最终发布后，未
发布版本号会递增到下一个小版本号，成为“a0”版本，例如“2.4a0”。

另请参阅 "sys.version", "sys.hexversion" 以及 "sys.version_info" 的文
档。"}
{Q001001007En:"General Python FAQ==>General Information==>How do I obtain a copy of the Python source?"}
{A001001007En:"The latest Python source distribution is always available from
python.org, at https://www.python.org/downloads/.  The latest
development sources can be obtained at
https://github.com/python/cpython/.

The source distribution is a gzipped tar file containing the complete
C source, Sphinx-formatted documentation, Python library modules,
example programs, and several useful pieces of freely distributable
software.  The source will compile and run out of the box on most UNIX
platforms.

Consult the Getting Started section of the Python Developer's Guide
for more information on getting the source code and compiling it."}
{Q001001007Zh:"Python常见问题==>一般信息==>我应如何获取一份 Python 源代码的副本？"}
{A001001007Zh:"最新的 Python 发布版源代码总能从 python.org 获取，下载页链接为
https://www.python.org/downloads/。 最新的开发版源代码可以在
https://github.com/python/cpython/ 获取。

发布版源代码是一个以 gzip 压缩的 tar 文件，其中包含完整的 C 源代码、
Sphinx 格式的文档、Python 库模块、示例程序以及一些有用的自由分发软件。
该源代码将可在大多数 UNIX 类平台上直接编译并运行。

请参阅 Python 开发者指南的初步上手部分 了解有关获取源代码并进行编译的
更多信息。"}
{Q001001008En:"General Python FAQ==>General Information==>How do I get documentation on Python?"}
{A001001008En:"The standard documentation for the current stable version of Python is
available at https://docs.python.org/3/.  PDF, plain text, and
downloadable HTML versions are also available at
https://docs.python.org/3/download.html.

The documentation is written in reStructuredText and processed by the
Sphinx documentation tool.  The reStructuredText source for the
documentation is part of the Python source distribution."}
{Q001001008Zh:"Python常见问题==>一般信息==>我应如何获取 Python 的文档？"}
{A001001008Zh:"当前的 Python 稳定版本的标准文档可在 https://docs.python.org/3/ 查看。
也可在 https://docs.python.org/3/download.html 获取PDF、纯文本以及可下
载的 HTML 版本。

文档以 reStructuredText 格式撰写，并使用 Sphinx 文档工具 生成。 文档的
reStructuredText 源文件是 Python 源代码发布版的一部分。"}
{Q001001009En:"General Python FAQ==>General Information==>I've never programmed before. Is there a Python tutorial?"}
{A001001009En:"There are numerous tutorials and books available.  The standard
documentation includes The Python Tutorial.

Consult the Beginner's Guide to find information for beginning Python
programmers, including lists of tutorials."}
{Q001001009Zh:"Python常见问题==>一般信息==>我之前从未接触过编程。 哪里有 Python 的教程？"}
{A001001009Zh:"有许多可选择的教程和书籍。 标准文档中也包含有 Python 教程。

请参阅 新手指南 以获取针对 Python 编程初学者的信息，包括教程的清单。"}
{Q001001010En:"General Python FAQ==>General Information==>Is there a newsgroup or mailing list devoted to Python?"}
{A001001010En:"There is a newsgroup, *comp.lang.python*, and a mailing list, python-
list.  The newsgroup and mailing list are gatewayed into each other --
if you can read news it's unnecessary to subscribe to the mailing
list. *comp.lang.python* is high-traffic, receiving hundreds of
postings every day, and Usenet readers are often more able to cope
with this volume.

Announcements of new software releases and events can be found in
comp.lang.python.announce, a low-traffic moderated list that receives
about five postings per day.  It's available as the python-announce
mailing list.

More info about other mailing lists and newsgroups can be found at
https://www.python.org/community/lists/."}
{Q001001010Zh:"Python常见问题==>一般信息==>是否有专门针对 Python 的新闻组或邮件列表？"}
{A001001010Zh:"有一个新闻组 *comp.lang.python* 和一个邮件列表 python-list。 新闻组和
邮件列表是彼此互通的 —— 如果你可以阅读新闻就不必再订阅邮件列表。
*comp.lang.python* 的流量很大，每天会收到数以百计的发帖，Usenet 使用者
通常更擅长处理这样大的流量。

有关新软件发布和活动的公告可以在 comp.lang.python.announce 中找到，这
是个严格管理的低流量列表，每天会收到五个左右的发帖。 可以在 Python 公
告邮件列表 页面进行订阅。

有关其他邮件列表和新闻组的更多信息可以在
https://www.python.org/community/lists/ 找到。"}
{Q001001011En:"General Python FAQ==>General Information==>How do I get a beta test version of Python?"}
{A001001011En:"Alpha and beta releases are available from
https://www.python.org/downloads/.  All releases are announced on the
comp.lang.python and comp.lang.python.announce newsgroups and on the
Python home page at https://www.python.org/; an RSS feed of news is
available.

You can also access the development version of Python through Git.
See The Python Developer's Guide for details."}
{Q001001011Zh:"Python常见问题==>一般信息==>我应如何获取 Python 的公开测试版本？"}
{A001001011Zh:"可以从 https://www.python.org/downloads/ 下载 alpha 和 beta 发布版。
所有发布版都会在 comp.lang.python 和 comp.lang.python.announce 新闻组
以及 Python 主页 https://www.python.org/ 上进行公告；并会推送到 RSS 新
闻源。

你还可以通过 Git 访问 Python 的开发版。 请参阅 Python 开发者指南 了解
详情。"}
{Q001001012En:"General Python FAQ==>General Information==>How do I submit bug reports and patches for Python?"}
{A001001012En:"To report a bug or submit a patch, please use the Roundup installation
at https://bugs.python.org/.

You must have a Roundup account to report bugs; this makes it possible
for us to contact you if we have follow-up questions.  It will also
enable Roundup to send you updates as we act on your bug. If you had
previously used SourceForge to report bugs to Python, you can obtain
your Roundup password through Roundup's password reset procedure.

For more information on how Python is developed, consult the Python
Developer's Guide."}
{Q001001012Zh:"Python常见问题==>一般信息==>我应如何为 Python 提交错误报告和补丁？"}
{A001001012Zh:"要报告错误或提交补丁，请使用安装于 https://bugs.python.org/ 上的
Roundup。

你必须拥有一个 Roundup 账号才能报告错误；这样我们就可以在有后续问题时
与你联系。 这也使得 Roundup 能在我们处理所报告的错误时向你发送更新消息
。 如果你之前使用过 SourceForge 向 Python 报告错误，你可以通过 Roundup
的 密码重置操作 来获取你的 Roundup 密码。

有关 Python 开发流程的更多信息，请参阅 Python 开发者指南。"}
{Q001001013En:"General Python FAQ==>General Information==>Are there any published articles about Python that I can reference?"}
{A001001013En:"It's probably best to cite your favorite book about Python.

The very first article about Python was written in 1991 and is now
quite outdated.

   Guido van Rossum and Jelke de Boer, "Interactively Testing Remote
   Servers Using the Python Programming Language", CWI Quarterly,
   Volume 4, Issue 4 (December 1991), Amsterdam, pp 283--303."}
{Q001001013Zh:"Python常见问题==>一般信息==>是否有任何公开发表的 Python 相关文章可以供我参考引用？"}
{A001001013Zh:"可能作为参考文献的最好方式还是引用你喜欢的 Python 相关书籍。

第一篇有关 Python 的文章写于 1991 年，现在其内容已经相当过时了。

   Guido van Rossum 与 Jelke de Boer, "使用 Python 编程语言交互式地测
   试远程服务器", CWI 季刊, 第 4 卷, 第 4 期 (1991 年 12 月), 阿姆斯特
   丹, 第 283--303 页。"}
{Q001001014En:"General Python FAQ==>General Information==>Are there any books on Python?"}
{A001001014En:"Yes, there are many, and more are being published.  See the python.org
wiki at https://wiki.python.org/moin/PythonBooks for a list.

You can also search online bookstores for "Python" and filter out the
Monty Python references; or perhaps search for "Python" and
"language"."}
{Q001001014Zh:"Python常见问题==>一般信息==>是否有任何 Python 相关的书籍？"}
{A001001014Zh:"是的，相关的书籍很多，还有更多即将发行。 请访问 python.org 的 wiki 页
面 https://wiki.python.org/moin/PythonBooks 获取一份清单。

你也可以到各大在线书店搜索 "Python" 并过滤掉对 Monty Python 的引用；或
者也可以搜索 "Python" 加 "language"。"}
{Q001001015En:"General Python FAQ==>General Information==>Where in the world is www.python.org located?"}
{A001001015En:"The Python project's infrastructure is located all over the world and
is managed by the Python Infrastructure Team. Details here."}
{Q001001015Zh:"Python常见问题==>一般信息==>www.python.org 具体位于世界上的哪个地点？"}
{A001001015Zh:"Python 项目的基础架构分布于世界各地并由 Python 基础架构团队负责管理。
详情请访问 这里。"}
{Q001001016En:"General Python FAQ==>General Information==>Why is it called Python?"}
{A001001016En:"When he began implementing Python, Guido van Rossum was also reading
the published scripts from "Monty Python's Flying Circus", a BBC
comedy series from the 1970s.  Van Rossum thought he needed a name
that was short, unique, and slightly mysterious, so he decided to call
the language Python."}
{Q001001016Zh:"Python常见问题==>一般信息==>为何命名为 Python？"}
{A001001016Zh:"在着手编写 Python 实现的时候，Guido van Rossum 同时还阅读了刚出版的
"Monty Python 的飞行马戏团" 剧本，这是一部自 1970 年代开始播出的 BBC
系列喜剧。 Van Rossum 觉得他需要选择一个简短、独特而又略显神秘的名字，
于是他决定将这个新语言命名为 Python。"}
{Q001001017En:"General Python FAQ==>General Information==>Do I have to like "Monty Python's Flying Circus"?"}
{A001001017En:"No, but it helps.  :)"}
{Q001001017Zh:"Python常见问题==>一般信息==>我必须喜欢 "Monty Python 的飞行马戏团" 吗？"}
{A001001017Zh:"不必，但这对学习会有帮助。 :)"}
{Q001002001En:"General Python FAQ==>Python in the real world==>How stable is Python?"}
{A001002001En:"Very stable.  New, stable releases have been coming out roughly every
6 to 18 months since 1991, and this seems likely to continue.  As of
version 3.9, Python will have a major new release every 12 months
(**PEP 602**).

The developers issue "bugfix" releases of older versions, so the
stability of existing releases gradually improves.  Bugfix releases,
indicated by a third component of the version number (e.g. 3.5.3,
3.6.2), are managed for stability; only fixes for known problems are
included in a bugfix release, and it's guaranteed that interfaces will
remain the same throughout a series of bugfix releases.

The latest stable releases can always be found on the Python download
page.  There are two production-ready versions of Python: 2.x and 3.x.
The recommended version is 3.x, which is supported by most widely used
libraries.  Although 2.x is still widely used, it is not maintained
anymore."}
{Q001002001Zh:"Python常见问题==>现实世界中的 Python==>Python 有多稳定？"}
{A001002001Zh:"非常稳定。 自 1991 年起大约每隔 6 到 18 个月就会推出新的稳定发布版，这
种状态看来还还持续。 从 3.9 版开始，Python 将会每隔 12 个月推出一个新
的主要发布版 (**PEP 602**)。

开发者也会推出旧版本的“问题修正”发布版，因此现有发布版的稳定性还会逐步
提升。 问题修正发布版会以版本号第三部分的数字来标示（例如 3.5.3, 3.6.2
），用于稳定性的管理；只有对已知问题的修正会包含在问题修正发布版中，同
一系列的问题修正发布版中的接口确定将会始终保持一致。

最后的稳定版本总是可以在 Python 下载页 中找到。 有两个生产环境可用的
Python　版本：2.x 和 3.x。 推荐的版本是 3.x，大多数被广泛使用的库都支
持它。 虽然 2.x 也仍然被广泛使用，但是 它已经停止维护。"}
{Q001002002En:"General Python FAQ==>Python in the real world==>How many people are using Python?"}
{A001002002En:"There are probably millions of users, though it's difficult to obtain
an exact count.

Python is available for free download, so there are no sales figures,
and it's available from many different sites and packaged with many
Linux distributions, so download statistics don't tell the whole story
either.

The comp.lang.python newsgroup is very active, but not all Python
users post to the group or even read it."}
{Q001002002Zh:"Python常见问题==>现实世界中的 Python==>有多少人在使用 Python？"}
{A001002002Zh:"使用者应该数以百万计，但很难获得一个精确的数字。

Python 可以免费下载，因此并不存在销量数据，此外它也可以从许多不同网站
获取，并且包含于许多 Linux 发行版之中，因此下载量统计同样无法完全说明
问题。

comp.lang.python 新闻组非常活跃，但不是所有 Python 用户都会在新闻组发
帖，许多人甚至不会阅读新闻组。"}
{Q001002003En:"General Python FAQ==>Python in the real world==>Have any significant projects been done in Python?"}
{A001002003En:"See https://www.python.org/about/success for a list of projects that
use Python. Consulting the proceedings for past Python conferences
will reveal contributions from many different companies and
organizations.

High-profile Python projects include the Mailman mailing list manager
and the Zope application server.  Several Linux distributions, most
notably Red Hat, have written part or all of their installer and
system administration software in Python.  Companies that use Python
internally include Google, Yahoo, and Lucasfilm Ltd."}
{Q001002003Zh:"Python常见问题==>现实世界中的 Python==>有哪些重要的项目是用 Python 开发的？"}
{A001002003Zh:"请访问 https://www.python.org/about/success 查看使用了 Python 的项目列
表。 阅览 历次 Python 会议 的日程纪要可以看到许多不同公司和组织所做的
贡献。

高水准的 Python 项目包括 Mailman 邮件列表管理器 和 Zope 应用服务器。
多个 Linux 发行版，其中最著名的有 Red Hat 均已使用 Python 来编写部分或
全部的安装程序和系统管理软件。 在内部使用 Python 的大公司包括了
Google, Yahoo 以及 Lucasfilm 等。"}
{Q001002004En:"General Python FAQ==>Python in the real world==>What new developments are expected for Python in the future?"}
{A001002004En:"See https://www.python.org/dev/peps/ for the Python Enhancement
Proposals (PEPs). PEPs are design documents describing a suggested new
feature for Python, providing a concise technical specification and a
rationale.  Look for a PEP titled "Python X.Y Release Schedule", where
X.Y is a version that hasn't been publicly released yet.

New development is discussed on the python-dev mailing list."}
{Q001002004Zh:"Python常见问题==>现实世界中的 Python==>在未来可以期待 Python 将有什么新进展？"}
{A001002004Zh:"请访问 https://www.python.org/dev/peps/ 查看 Python 增强提议（PEP）。
PEP  是为 Python 加入某种新特性的提议进行描述的设计文档，其中会提供简
明的技术规格说明与基本原理。 可以查找标题为“Python X.Y Release
Schedule”的 PEP，其中 X.Y 是某个尚未公开发布的版本。

新版本的开发会在 python-dev 邮件列表 中进行讨论。"}
{Q001002005En:"General Python FAQ==>Python in the real world==>Is it reasonable to propose incompatible changes to Python?"}
{A001002005En:"In general, no.  There are already millions of lines of Python code
around the world, so any change in the language that invalidates more
than a very small fraction of existing programs has to be frowned
upon.  Even if you can provide a conversion program, there's still the
problem of updating all documentation; many books have been written
about Python, and we don't want to invalidate them all at a single
stroke.

Providing a gradual upgrade path is necessary if a feature has to be
changed. **PEP 5** describes the procedure followed for introducing
backward-incompatible changes while minimizing disruption for users."}
{Q001002005Zh:"Python常见问题==>现实世界中的 Python==>提议对 Python 加入不兼容的更改是否合理？"}
{A001002005Zh:"通常来说是不合理的。 世界上已存在的 Python 代码数以亿计，因此，任何对
该语言的更改即便仅会使得现有程序中极少的一部分失效也是难以令人接受的。
就算你可以提供一个转换程序，也仍然存在需要更新全部文档的问题；另外还有
大量已出版的 Python 书籍，我们不希望让它们在一瞬间全部变成废纸。

如果必须更改某个特性，则应该提供渐进式的升级路径。 **PEP 5** 描述了引
入向后不兼容的更改所需遵循的流程，以尽可能减少对用户的干扰。"}
{Q001002006En:"General Python FAQ==>Python in the real world==>Is Python a good language for beginning programmers?"}
{A001002006En:"Yes.

It is still common to start students with a procedural and statically
typed language such as Pascal, C, or a subset of C++ or Java.
Students may be better served by learning Python as their first
language.  Python has a very simple and consistent syntax and a large
standard library and, most importantly, using Python in a beginning
programming course lets students concentrate on important programming
skills such as problem decomposition and data type design.  With
Python, students can be quickly introduced to basic concepts such as
loops and procedures.  They can probably even work with user-defined
objects in their very first course.

For a student who has never programmed before, using a statically
typed language seems unnatural.  It presents additional complexity
that the student must master and slows the pace of the course.  The
students are trying to learn to think like a computer, decompose
problems, design consistent interfaces, and encapsulate data.  While
learning to use a statically typed language is important in the long
term, it is not necessarily the best topic to address in the students'
first programming course.

Many other aspects of Python make it a good first language.  Like
Java, Python has a large standard library so that students can be
assigned programming projects very early in the course that *do*
something.  Assignments aren't restricted to the standard four-
function calculator and check balancing programs.  By using the
standard library, students can gain the satisfaction of working on
realistic applications as they learn the fundamentals of programming.
Using the standard library also teaches students about code reuse.
Third-party modules such as PyGame are also helpful in extending the
students' reach.

Python's interactive interpreter enables students to test language
features while they're programming.  They can keep a window with the
interpreter running while they enter their program's source in another
window.  If they can't remember the methods for a list, they can do
something like this:

   >>> L = []
   >>> dir(L) 
   ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
   '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
   '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__',
   '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',
   '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
   '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',
   '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear',
   'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',
   'reverse', 'sort']
   >>> [d for d in dir(L) if '__' not in d]
   ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

   >>> help(L.append)
   Help on built-in function append:

   append(...)
       L.append(object) -> None -- append object to end

   >>> L.append(1)
   >>> L
   [1]

With the interpreter, documentation is never far from the student as
they are programming.

There are also good IDEs for Python.  IDLE is a cross-platform IDE for
Python that is written in Python using Tkinter.  PythonWin is a
Windows-specific IDE. Emacs users will be happy to know that there is
a very good Python mode for Emacs.  All of these programming
environments provide syntax highlighting, auto-indenting, and access
to the interactive interpreter while coding.  Consult the Python wiki
for a full list of Python editing environments.

If you want to discuss Python's use in education, you may be
interested in joining the edu-sig mailing list."}
{Q001002006Zh:"Python常见问题==>现实世界中的 Python==>Python 是一种对编程初学者友好的语言吗？"}
{A001002006Zh:"当然。

从过程式、静态类型的编程语言例如 Pascal, C 或者 C++ 以及 Java 的某一子
集开始引导学生入门仍然是常见的做法。 但以  Python 作为第一种编程语言进
行学习对学生可能更有利。Python 具有非常简单和一致的语法和庞大的标准库
，而且最重要的是，在编程入门教学中使用 Python 可以让学生专注于更重要的
编程技能，例如问题分解与数据类型设计。 使用 Python，可以快速向学生介绍
基本概念例如循环与过程等。 他们甚至有可能在第一次课里就开始接触用户自
定义对象。

对于之前从未接触过编程的学生来说，使用静态类型语言会感觉不够自然。 这
会给学生带来必须掌握的额外复杂性，并减慢教学的进度。 学生需要尝试像计
算机一样思考，分解问题，设计一致的接口并封装数据。 虽然从长远来看，学
习和使用一种静态类型语言是很重要的，但这并不是最适宜在学生的第一次编程
课上就进行探讨的主题。

还有许多其他方面的特点使得 Python 成为很好的入门语言。 像 Java 一样，
Python 拥有一个庞大的标准库，因此可以在课程非常早期的阶段就给学生布置
一些 *实用* 的编程项目。 编程作业不必仅限于标准四则运算和账目检查程序
。 通过使用标准库，学生可以在学习编程基础知识的同时开发真正的应用，从
而获得更大的满足感。 使用标准库还能使学生了解代码重用的概念。 而像
PyGame 这样的第三方模块同样有助于扩大学生的接触领域。

Python 的解释器使学生能够在编程时测试语言特性。 他们可以在一个窗口中输
入程序源代码的同时开启一个解释器运行窗口。 如果他们不记得列表有哪些方
法，他们这以这样做:

   >>> L = []
   >>> dir(L) 
   ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
   '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
   '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__',
   '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',
   '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
   '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',
   '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear',
   'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',
   'reverse', 'sort']
   >>> [d for d in dir(L) if '__' not in d]
   ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

   >>> help(L.append)
   Help on built-in function append:

   append(...)
       L.append(object) -> None -- append object to end

   >>> L.append(1)
   >>> L
   [1]

通过使用解释器，学生编写程序时参考文档总是能伴随在他们身边。

Python 还拥有很好的 IDE。 IDLE 是一个跨平台的 Python IDE，它基于
Tkinter 库，使用 Python 语言编写。  PythonWin 是一个 Windows 专属的
IDE。 Emacs 用户将高兴地了解到 Emacs 具有非常好的 Python 模式。  所有
这些编程环境都提供语法高亮，自动缩进以及在编写代码时使用交互式解释器等
功能。 请访问 Python wiki 查看 Python 编程环境的完整列表。

如果你想要讨论 Python 在教育中的使用，你可能会有兴趣加入 edu-sig 邮件
列表。"}
{Q002001001En:"Programming FAQ==>General Questions==>Is there a source code level debugger with breakpoints, single-stepping, etc.?"}
{A002001001En:"Yes.

Several debuggers for Python are described below, and the built-in
function "breakpoint()" allows you to drop into any of them.

The pdb module is a simple but adequate console-mode debugger for
Python. It is part of the standard Python library, and is "documented
in the Library Reference Manual". You can also write your own debugger
by using the code for pdb as an example.

The IDLE interactive development environment, which is part of the
standard Python distribution (normally available as
Tools/scripts/idle), includes a graphical debugger.

PythonWin is a Python IDE that includes a GUI debugger based on pdb.
The Pythonwin debugger colors breakpoints and has quite a few cool
features such as debugging non-Pythonwin programs.  Pythonwin is
available as part of the Python for Windows Extensions project and as
a part of the ActivePython distribution (see
https://www.activestate.com/activepython).

Eric is an IDE built on PyQt and the Scintilla editing component.

Pydb is a version of the standard Python debugger pdb, modified for
use with DDD (Data Display Debugger), a popular graphical debugger
front end.  Pydb can be found at http://bashdb.sourceforge.net/pydb/
and DDD can be found at https://www.gnu.org/software/ddd.

There are a number of commercial Python IDEs that include graphical
debuggers. They include:

* Wing IDE (https://wingware.com/)

* Komodo IDE (https://komodoide.com/)

* PyCharm (https://www.jetbrains.com/pycharm/)"}
{Q002001001Zh:"编程常见问题==>一般问题==>Python 有没有提供断点与单步调试等功能的，源码层次的调试器？"}
{A002001001Zh:"有的。

以下介绍了一些 Python 的调试器，内置函数 "breakpoint()" 允许你使用其中
的任何一种。

pdb 模块是一个简单但是够用的控制台模式 Python 调试器。 它是标准 Python
库的一部分，并且 "已收录于库参考手册"。 你也可以通过使用 pdb 代码作为
样例来编写你自己的调试器。

作为标准 Python 发行版附带组件的 IDLE 交互式环境（通常位于
Tools/scripts/idle）中包含一个图形化的调试器。

PythonWin 是一个包含有基于 pdb 的 GUI 调试器的 Python IDE。 Pythonwin
调试器会为断点加上颜色，并具有许多很棒的特性，例如也可以非 Pythonwin
程序。 Pythonwin 是 Python for Windows Extensions 项目的一部分，也是
ActivePython 发行版的一部分（参见
https://www.activestate.com/activepython）。

Eric 是一个基于PyQt和Scintilla编辑组件构建的IDE。

Pydb是标准Python调试器pdb的一个版本，经过修改后可与DDD（数据显示调试器
）一起使用，DDD是一种流行的图形化调试器前端。 Pydb可以在
http://bashdb.sourceforge.net/pydb/ 找到，DDD可以在
https://www.gnu.org/software/ddd 找到。

有许多商业Python IDE包括图形调试器。他们包括：

* Wing IDE (https://wingware.com/)

* Komodo IDE (https://komodoide.com/)

* PyCharm (https://www.jetbrains.com/pycharm/)"}
{Q002001002En:"Programming FAQ==>General Questions==>Are there tools to help find bugs or perform static analysis?"}
{A002001002En:"Yes.

Pylint and Pyflakes do basic checking that will help you catch bugs
sooner.

Static type checkers such as Mypy, Pyre, and Pytype can check type
hints in Python source code."}
{Q002001002Zh:"编程常见问题==>一般问题==>是否有能帮助寻找漏洞或执行静态分析的工具？"}
{A002001002Zh:"有的。

Pylint 和 Pyflakes 可进行基本检查来帮助你尽早捕捉漏洞。

静态类型检查器，例如 Mypy 、 Pyre 和 Pytype 可以检查Python源代码中的类
型提示。"}
{Q002001003En:"Programming FAQ==>General Questions==>How can I create a stand-alone binary from a Python script?"}
{A002001003En:"You don't need the ability to compile Python to C code if all you want
is a stand-alone program that users can download and run without
having to install the Python distribution first.  There are a number
of tools that determine the set of modules required by a program and
bind these modules together with a Python binary to produce a single
executable.

One is to use the freeze tool, which is included in the Python source
tree as "Tools/freeze". It converts Python byte code to C arrays; a C
compiler you can embed all your modules into a new program, which is
then linked with the standard Python modules.

It works by scanning your source recursively for import statements (in
both forms) and looking for the modules in the standard Python path as
well as in the source directory (for built-in modules).  It then turns
the bytecode for modules written in Python into C code (array
initializers that can be turned into code objects using the marshal
module) and creates a custom-made config file that only contains those
built-in modules which are actually used in the program.  It then
compiles the generated C code and links it with the rest of the Python
interpreter to form a self-contained binary which acts exactly like
your script.

Obviously, freeze requires a C compiler.  There are several other
utilities which don't. One is Thomas Heller's py2exe (Windows only) at

   http://www.py2exe.org/

Another tool is Anthony Tuininga's cx_Freeze."}
{Q002001003Zh:"编程常见问题==>一般问题==>我如何能够通过一个 Python 脚本创建一个独立运行的二进制文件？"}
{A002001003Zh:"如果你想要的只是一个独立的程序，用户可以下载和运行而不必先安装Python发
行版，你就不需要将Python编译成C代码。有许多工具可以确定程序所需的模块
集，并将这些模块与Python二进制文件绑定在一起以生成单个可执行文件。

一种是使用冻结工具，它包含在Python源代码树 "Tools/freeze" 中。它将
Python字节代码转换为C数组；一个C编译器，你可以将所有模块嵌入到一个新程
序中，然后将其与标准Python模块链接。

它的工作原理是递归扫描源代码以获取import语句（两种形式），并在标准
Python路径和源目录（用于内置模块）中查找模块。 然后，它将用Python编写
的模块的字节码转换为C代码（可以使用编组模块转换为代码对象的数组初始化
器），并创建一个定制的配置文件，该文件仅包含程序中实际使用的内置模块。
然后，它编译生成的C代码并将其与Python解释器的其余部分链接，以形成一个
独立的二进制文件，其行为与你的脚本完全相同。

显然， freeze 需要一个C编译器。有几个其他实用工具不需要。 一个是Thomas
Heller的py2exe（仅限Windows）

   http://www.py2exe.org/

另一个工具是 Anthony Tuininga 的 cx_Freeze。"}
{Q002001004En:"Programming FAQ==>General Questions==>Are there coding standards or a style guide for Python programs?"}
{A002001004En:"Yes.  The coding style required for standard library modules is
documented as **PEP 8**."}
{Q002001004Zh:"编程常见问题==>一般问题==>是否有 Python 程序规范代码标准或风格指南？"}
{A002001004Zh:"有的。 请参阅标准库模块所要求的代码风格描述文档 **PEP 8** 。"}
{Q002002001En:"Programming FAQ==>Core Language==>Why am I getting an UnboundLocalError when the variable has a value?"}
{A002002001En:"It can be a surprise to get the UnboundLocalError in previously
working code when it is modified by adding an assignment statement
somewhere in the body of a function.

This code:

>>> x = 10
>>> def bar():
...     print(x)
>>> bar()
10

works, but this code:

>>> x = 10
>>> def foo():
...     print(x)
...     x += 1

results in an UnboundLocalError:

>>> foo()
Traceback (most recent call last):
  ...
UnboundLocalError: local variable 'x' referenced before assignment

This is because when you make an assignment to a variable in a scope,
that variable becomes local to that scope and shadows any similarly
named variable in the outer scope.  Since the last statement in foo
assigns a new value to "x", the compiler recognizes it as a local
variable.  Consequently when the earlier "print(x)" attempts to print
the uninitialized local variable and an error results.

In the example above you can access the outer scope variable by
declaring it global:

>>> x = 10
>>> def foobar():
...     global x
...     print(x)
...     x += 1
>>> foobar()
10

This explicit declaration is required in order to remind you that
(unlike the superficially analogous situation with class and instance
variables) you are actually modifying the value of the variable in the
outer scope:

>>> print(x)
11

You can do a similar thing in a nested scope using the "nonlocal"
keyword:

>>> def foo():
...    x = 10
...    def bar():
...        nonlocal x
...        print(x)
...        x += 1
...    bar()
...    print(x)
>>> foo()
10
11"}
{Q002002001Zh:"编程常见问题==>核心语言==>当变量有值时，为什么会出现UnboundLocalError？"}
{A002002001Zh:"通过在函数体中的某处添加赋值语句，导致以前正常工作的代码被修改而得到
UnboundLocalError 会令人感到意外。

以下代码：

>>> x = 10
>>> def bar():
...     print(x)
>>> bar()
10

正常工作，但是以下代码

>>> x = 10
>>> def foo():
...     print(x)
...     x += 1

会得到一个 UnboundLocalError ：

>>> foo()
Traceback (most recent call last):
  ...
UnboundLocalError: local variable 'x' referenced before assignment

这是因为当你对作用域中的变量进行赋值时，该变量将成为该作用域的局部变量
，并在外部作用域中隐藏任何类似命名的变量。由于foo中的最后一个语句为
"x" 分配了一个新值，编译器会将其识别为局部变量。因此，当先前的
"print(x)" 尝试打印未初始化的局部变量时会导致错误。

在上面的示例中，你可以通过将其声明为全局来访问外部作用域变量：

>>> x = 10
>>> def foobar():
...     global x
...     print(x)
...     x += 1
>>> foobar()
10

这个显式声明是必需的，以便提醒你（与类和实例变量的表面类似情况不同），
你实际上是在外部作用域中修改变量的值

>>> print(x)
11

你可以使用 "nonlocal" 关键字在嵌套作用域中执行类似的操作：

>>> def foo():
...    x = 10
...    def bar():
...        nonlocal x
...        print(x)
...        x += 1
...    bar()
...    print(x)
>>> foo()
10
11"}
{Q002002002En:"Programming FAQ==>Core Language==>What are the rules for local and global variables in Python?"}
{A002002002En:"In Python, variables that are only referenced inside a function are
implicitly global.  If a variable is assigned a value anywhere within
the function's body, it's assumed to be a local unless explicitly
declared as global.

Though a bit surprising at first, a moment's consideration explains
this.  On one hand, requiring "global" for assigned variables provides
a bar against unintended side-effects.  On the other hand, if "global"
was required for all global references, you'd be using "global" all
the time.  You'd have to declare as global every reference to a built-
in function or to a component of an imported module.  This clutter
would defeat the usefulness of the "global" declaration for
identifying side-effects."}
{Q002002002Zh:"编程常见问题==>核心语言==>Python中的局部变量和全局变量有哪些规则？"}
{A002002002Zh:"在Python中，仅在函数内引用的变量是隐式全局变量。如果在函数体内的任何位
置为变量赋值，则除非明确声明为全局，否则将其视为局部值。

虽然起初有点令人惊讶，但片刻考虑就可以解释。一方面，要求 "global" 表示
已分配的变量可以防止意外的副作用。另一方面，如果所有全局引用都需要
"global" ，那么你一直都在使用 "global" 。你必须将对内置函数或导入模块
的组件的每个引用声明为全局。这种杂乱会破坏 "global" 声明用于识别副作用
的有用性。"}
{Q002002003En:"Programming FAQ==>Core Language==>Why do lambdas defined in a loop with different values all return the same result?"}
{A002002003En:"Assume you use a for loop to define a few different lambdas (or even
plain functions), e.g.:

   >>> squares = []
   >>> for x in range(5):
   ...     squares.append(lambda: x**2)

This gives you a list that contains 5 lambdas that calculate "x**2".
You might expect that, when called, they would return, respectively,
"0", "1", "4", "9", and "16".  However, when you actually try you will
see that they all return "16":

   >>> squares[2]()
   16
   >>> squares[4]()
   16

This happens because "x" is not local to the lambdas, but is defined
in the outer scope, and it is accessed when the lambda is called ---
not when it is defined.  At the end of the loop, the value of "x" is
"4", so all the functions now return "4**2", i.e. "16".  You can also
verify this by changing the value of "x" and see how the results of
the lambdas change:

   >>> x = 8
   >>> squares[2]()
   64

In order to avoid this, you need to save the values in variables local
to the lambdas, so that they don't rely on the value of the global
"x":

   >>> squares = []
   >>> for x in range(5):
   ...     squares.append(lambda n=x: n**2)

Here, "n=x" creates a new variable "n" local to the lambda and
computed when the lambda is defined so that it has the same value that
"x" had at that point in the loop.  This means that the value of "n"
will be "0" in the first lambda, "1" in the second, "2" in the third,
and so on. Therefore each lambda will now return the correct result:

   >>> squares[2]()
   4
   >>> squares[4]()
   16

Note that this behaviour is not peculiar to lambdas, but applies to
regular functions too."}
{Q002002003Zh:"编程常见问题==>核心语言==>为什么在具有不同值的循环中定义的lambdas都返回相同的结果？"}
{A002002003Zh:"假设你使用for循环来定义几个不同的 lambda （甚至是普通函数），例如：:

   >>> squares = []
   >>> for x in range(5):
   ...     squares.append(lambda: x**2)

这给你一个包含5个lambdas的列表，它们计算 "x**2" 。你可能会期望，当它们
被调用时，它们将分别返回 "0" 、 "1" 、 "4" 、 "9" 和 "16" 。但是，当你
真正尝试时，你会看到它们都返回 "16" 。:

   >>> squares[2]()
   16
   >>> squares[4]()
   16

发生这种情况是因为 "x" 不是lambdas的内部变量，而是在外部作用域中定义，
并且在调用lambda时访问它 - 而不是在定义它时。 在循环结束时， "x" 的值
是 "4" ，所以所有的函数现在返回 "4**2" ，即 "16" 。你还可以通过更改
"x" 的值来验证这一点，并查看lambdas的结果如何变化:

   >>> x = 8
   >>> squares[2]()
   64

为了避免这种情况，你需要将值保存在lambdas的局部变量中，这样它们就不依
赖于全局``x`` 的值

   >>> squares = []
   >>> for x in range(5):
   ...     squares.append(lambda n=x: n**2)

这里， "n=x" 在lambda本地创建一个新的变量 "n" ，并在定义lambda时计算，
使它具有与 "x" 在循环中该点相同的值。这意味着 "n" 的值在第一个lambda中
为 "0" ，在第二个lambda中为 "1" ，在第三个中为 "2" ，依此类推。因此每
个lambda现在将返回正确的结果:

   >>> squares[2]()
   4
   >>> squares[4]()
   16

请注意，这种行为并不是lambda所特有的，但也适用于常规函数。"}
{Q002002004En:"Programming FAQ==>Core Language==>How do I share global variables across modules?"}
{A002002004En:"The canonical way to share information across modules within a single
program is to create a special module (often called config or cfg).
Just import the config module in all modules of your application; the
module then becomes available as a global name.  Because there is only
one instance of each module, any changes made to the module object get
reflected everywhere.  For example:

config.py:

   x = 0   # Default value of the 'x' configuration setting

mod.py:

   import config
   config.x = 1

main.py:

   import config
   import mod
   print(config.x)

Note that using a module is also the basis for implementing the
Singleton design pattern, for the same reason."}
{Q002002004Zh:"编程常见问题==>核心语言==>如何跨模块共享全局变量？"}
{A002002004Zh:"在单个程序中跨模块共享信息的规范方法是创建一个特殊模块（通常称为config
或cfg）。只需在应用程序的所有模块中导入配置模块；然后该模块可用作全局
名称。因为每个模块只有一个实例，所以对模块对象所做的任何更改都会在任何
地方反映出来。 例如：

config.py:

   x = 0   # Default value of the 'x' configuration setting

mod.py:

   import config
   config.x = 1

main.py:

   import config
   import mod
   print(config.x)

请注意，出于同样的原因，使用模块也是实现Singleton设计模式的基础。"}
{Q002002005En:"Programming FAQ==>Core Language==>What are the "best practices" for using import in a module?"}
{A002002005En:"In general, don't use "from modulename import *".  Doing so clutters
the importer's namespace, and makes it much harder for linters to
detect undefined names.

Import modules at the top of a file.  Doing so makes it clear what
other modules your code requires and avoids questions of whether the
module name is in scope. Using one import per line makes it easy to
add and delete module imports, but using multiple imports per line
uses less screen space.

It's good practice if you import modules in the following order:

1. standard library modules -- e.g. "sys", "os", "getopt", "re"

2. third-party library modules (anything installed in Python's site-
   packages directory) -- e.g. mx.DateTime, ZODB, PIL.Image, etc.

3. locally-developed modules

It is sometimes necessary to move imports to a function or class to
avoid problems with circular imports.  Gordon McMillan says:

   Circular imports are fine where both modules use the "import
   <module>" form of import.  They fail when the 2nd module wants to
   grab a name out of the first ("from module import name") and the
   import is at the top level.  That's because names in the 1st are
   not yet available, because the first module is busy importing the
   2nd.

In this case, if the second module is only used in one function, then
the import can easily be moved into that function.  By the time the
import is called, the first module will have finished initializing,
and the second module can do its import.

It may also be necessary to move imports out of the top level of code
if some of the modules are platform-specific.  In that case, it may
not even be possible to import all of the modules at the top of the
file.  In this case, importing the correct modules in the
corresponding platform-specific code is a good option.

Only move imports into a local scope, such as inside a function
definition, if it's necessary to solve a problem such as avoiding a
circular import or are trying to reduce the initialization time of a
module.  This technique is especially helpful if many of the imports
are unnecessary depending on how the program executes.  You may also
want to move imports into a function if the modules are only ever used
in that function.  Note that loading a module the first time may be
expensive because of the one time initialization of the module, but
loading a module multiple times is virtually free, costing only a
couple of dictionary lookups.  Even if the module name has gone out of
scope, the module is probably available in "sys.modules"."}
{Q002002005Zh:"编程常见问题==>核心语言==>导入模块的“最佳实践”是什么？"}
{A002002005Zh:"通常，不要使用 "from modulename import *" 。这样做会使导入器的命名空间
变得混乱，并且使得连接器更难以检测未定义的名称。

在文件的顶部导入模块。这样做可以清楚地了解代码所需的其他模块，并避免了
模块名称是否在范围内的问题。每行导入一个模块可以轻松添加和删除导入的模
块，但每行导入多个模块会占用更少的屏幕空间。

如果按以下顺序导入模块，这是一种很好的做法：

1. 标准库模块 -- 例如： "sys", "os", "getopt", "re"

2. 第三方库模块（安装在Python的site-packages目录中的任何内容） --  例
   如mx.DateTime，ZODB，PIL.Image等

3. 本地开发的模块

有时需要将模块导入语句移动到函数或类里面，以避免循环导入问题。Gordon
McMillan 说：

   当两个模块都使用  "import <module>" 的导入形式时，循环导入就可以了
   。但是当第 2 个模块想从第 1 个模块中获取一个名称 ("from module
   import name") 并且导入位于顶层时，就会出错。 这是因为第 1 个模块中
   的名称还不可用，因为第 1 个模块正在忙着导入第 2 个模块。

在这种情况下，如果第二个模块仅用于一个函数，则可以轻松地将模块导入语句
移动到该函数中。调用导入时，第一个模块将完成初始化，第二个模块可以进行
导入。

如果某些模块是特定于平台的，则可能还需要将模块导入语句移出顶级代码。在
这种情况下，甚至可能无法导入文件顶部的所有模块。在这种情况下，在相应的
特定于平台的代码中导入正确的模块是一个很好的选择。

只有当需要解决诸如避免循环导入或试图减少模块初始化时间的问题时，才可以
将导入移动到本地范围，例如在函数定义中。如果根据程序的执行方式，许多导
入是不必要的，这种技术尤其有用。如果仅在某个函数中使用模块，您还可能希
望将导入移到该函数中。请注意，第一次加载模块可能会因为模块的一次初始化
而代价高昂，但多次加载模块实际上是免费的，只需进行几次字典查找。即使模
块名称超出了作用域，模块也可能在 "sys.modules" 中可用。"}
{Q002002006En:"Programming FAQ==>Core Language==>Why are default values shared between objects?"}
{A002002006En:"This type of bug commonly bites neophyte programmers.  Consider this
function:

   def foo(mydict={}):  # Danger: shared reference to one dict for all calls
       ... compute something ...
       mydict[key] = value
       return mydict

The first time you call this function, "mydict" contains a single
item.  The second time, "mydict" contains two items because when
"foo()" begins executing, "mydict" starts out with an item already in
it.

It is often expected that a function call creates new objects for
default values. This is not what happens. Default values are created
exactly once, when the function is defined.  If that object is
changed, like the dictionary in this example, subsequent calls to the
function will refer to this changed object.

By definition, immutable objects such as numbers, strings, tuples, and
"None", are safe from change. Changes to mutable objects such as
dictionaries, lists, and class instances can lead to confusion.

Because of this feature, it is good programming practice to not use
mutable objects as default values.  Instead, use "None" as the default
value and inside the function, check if the parameter is "None" and
create a new list/dictionary/whatever if it is.  For example, don't
write:

   def foo(mydict={}):
       ...

but:

   def foo(mydict=None):
       if mydict is None:
           mydict = {}  # create a new dict for local namespace

This feature can be useful.  When you have a function that's time-
consuming to compute, a common technique is to cache the parameters
and the resulting value of each call to the function, and return the
cached value if the same value is requested again.  This is called
"memoizing", and can be implemented like this:

   # Callers can only provide two parameters and optionally pass _cache by keyword
   def expensive(arg1, arg2, *, _cache={}):
       if (arg1, arg2) in _cache:
           return _cache[(arg1, arg2)]

       # Calculate the value
       result = ... expensive computation ...
       _cache[(arg1, arg2)] = result           # Store result in the cache
       return result

You could use a global variable containing a dictionary instead of the
default value; it's a matter of taste."}
{Q002002006Zh:"编程常见问题==>核心语言==>为什么对象之间会共享默认值？"}
{A002002006Zh:"这种类型的缺陷通常会惹恼新手程序员。考虑这个函数

   def foo(mydict={}):  # Danger: shared reference to one dict for all calls
       ... compute something ...
       mydict[key] = value
       return mydict

第一次调用此函数时，"mydict" 包含一项。第二次，"mydict" 包含两项，因为
当 "foo()" 开始执行时， "mydict" 中已经有一项了。

函数调用经常被期望为默认值创建新的对象。 但实际情况并非如此。 默认值会
在函数定义时一次性地创建。 如果对象发生改变，就如本示例中的字典那样，
则对函数的后续调用将会引用这个被改变的对象。

按照定义，不可变对象例如数字、字符串、元组和 "None" 因为不可变所以是安
全的。 对可变对象例如字典、列表和类实例的改变则可能造成迷惑。

由于这一特性，在编程中应遵循的一项好习惯是不使用可变对象作为默认值。
而应使用 "None" 作为默认值和函数中的值，检查值为 "None" 的形参并创建相
应的列表、字典或其他可变对象。 例如，不要这样写:

   def foo(mydict={}):
       ...

而要这样写:

   def foo(mydict=None):
       if mydict is None:
           mydict = {}  # create a new dict for local namespace

这一特性有时会很有用处。 当你有一个需要进行大量耗时计算的函数时，一个
常见技巧是将每次调用函数的参数和结果值缓存起来，并在同样的值被再次请求
时返回缓存的值。 这称为“记忆”，具体实现方式可以是这样的:

   # Callers can only provide two parameters and optionally pass _cache by keyword
   def expensive(arg1, arg2, *, _cache={}):
       if (arg1, arg2) in _cache:
           return _cache[(arg1, arg2)]

       # Calculate the value
       result = ... expensive computation ...
       _cache[(arg1, arg2)] = result           # Store result in the cache
       return result

你也可以使用包含一个字典的全局变量而不使用参数默认值；这完全取决于个人
偏好。"}
{Q002002007En:"Programming FAQ==>Core Language==>How can I pass optional or keyword parameters from one function to another?"}
{A002002007En:"Collect the arguments using the "*" and "**" specifiers in the
function's parameter list; this gives you the positional arguments as
a tuple and the keyword arguments as a dictionary.  You can then pass
these arguments when calling another function by using "*" and "**":

   def f(x, *args, **kwargs):
       ...
       kwargs['width'] = '14.3c'
       ...
       g(x, *args, **kwargs)"}
{Q002002007Zh:"编程常见问题==>核心语言==>如何将可选参数或关键字参数从一个函数传递到另一个函数？"}
{A002002007Zh:"使用函数参数列表中的 "*" 和 "**" 说明符收集参数;这会将位置参数作为元组
，将关键字参数作为字典。然后，您可以使用 "*" 和 "**" 调用另一个函数时
传递这些参数：

   def f(x, *args, **kwargs):
       ...
       kwargs['width'] = '14.3c'
       ...
       g(x, *args, **kwargs)"}
{Q002002008En:"Programming FAQ==>Core Language==>What is the difference between arguments and parameters?"}
{A002002008En:"*Parameters* are defined by the names that appear in a function
definition, whereas *arguments* are the values actually passed to a
function when calling it.  Parameters define what types of arguments a
function can accept.  For example, given the function definition:

   def func(foo, bar=None, **kwargs):
       pass

*foo*, *bar* and *kwargs* are parameters of "func".  However, when
calling "func", for example:

   func(42, bar=314, extra=somevar)

the values "42", "314", and "somevar" are arguments."}
{Q002002008Zh:"编程常见问题==>核心语言==>形参和实参之间有什么区别？"}
{A002002008Zh:"*形参* 是指出现在函数定义中的名称，而 *实参* 则是在调用函数时实际传入
的值。 形参定义了一个函数能接受何种类型的实参。 例如，对于以下函数定义
:

   def func(foo, bar=None, **kwargs):
       pass

*foo*, *bar* 和 *kwargs* 是 "func" 的形参。 但是，在调用 "func" 时，例
如：

   func(42, bar=314, extra=somevar)

实际的值 "42", "314" 和 "somevar" 则是实参。"}
{Q002002009En:"Programming FAQ==>Core Language==>Why did changing list 'y' also change list 'x'?"}
{A002002009En:"If you wrote code like:

   >>> x = []
   >>> y = x
   >>> y.append(10)
   >>> y
   [10]
   >>> x
   [10]

you might be wondering why appending an element to "y" changed "x"
too.

There are two factors that produce this result:

1. Variables are simply names that refer to objects.  Doing "y = x"
   doesn't create a copy of the list -- it creates a new variable "y"
   that refers to the same object "x" refers to.  This means that
   there is only one object (the list), and both "x" and "y" refer to
   it.

2. Lists are *mutable*, which means that you can change their content.

After the call to "append()", the content of the mutable object has
changed from "[]" to "[10]".  Since both the variables refer to the
same object, using either name accesses the modified value "[10]".

If we instead assign an immutable object to "x":

   >>> x = 5  # ints are immutable
   >>> y = x
   >>> x = x + 1  # 5 can't be mutated, we are creating a new object here
   >>> x
   6
   >>> y
   5

we can see that in this case "x" and "y" are not equal anymore.  This
is because integers are *immutable*, and when we do "x = x + 1" we are
not mutating the int "5" by incrementing its value; instead, we are
creating a new object (the int "6") and assigning it to "x" (that is,
changing which object "x" refers to).  After this assignment we have
two objects (the ints "6" and "5") and two variables that refer to
them ("x" now refers to "6" but "y" still refers to "5").

Some operations (for example "y.append(10)" and "y.sort()") mutate the
object, whereas superficially similar operations (for example "y = y +
[10]" and "sorted(y)") create a new object.  In general in Python (and
in all cases in the standard library) a method that mutates an object
will return "None" to help avoid getting the two types of operations
confused.  So if you mistakenly write "y.sort()" thinking it will give
you a sorted copy of "y", you'll instead end up with "None", which
will likely cause your program to generate an easily diagnosed error.

However, there is one class of operations where the same operation
sometimes has different behaviors with different types:  the augmented
assignment operators.  For example, "+=" mutates lists but not tuples
or ints ("a_list += [1, 2, 3]" is equivalent to "a_list.extend([1, 2,
3])" and mutates "a_list", whereas "some_tuple += (1, 2, 3)" and
"some_int += 1" create new objects).

In other words:

* If we have a mutable object ("list", "dict", "set", etc.), we can
  use some specific operations to mutate it and all the variables that
  refer to it will see the change.

* If we have an immutable object ("str", "int", "tuple", etc.), all
  the variables that refer to it will always see the same value, but
  operations that transform that value into a new value always return
  a new object.

If you want to know if two variables refer to the same object or not,
you can use the "is" operator, or the built-in function "id()"."}
{Q002002009Zh:"编程常见问题==>核心语言==>为什么更改列表 'y' 也会更改列表 'x'？"}
{A002002009Zh:"如果你编写的代码就像下面一样：

   >>> x = []
   >>> y = x
   >>> y.append(10)
   >>> y
   [10]
   >>> x
   [10]

你可能想知道为什么追加一个元素也改变了x。

产生这种结果有两个因素：

1. 变量只是指向具体对象的名称。 执行 "y = x" 并不会为列表创建一个副本
   —— 它只是创建了一个新变量 "y" 指向 "x" 所指向的同一对象。 这意味着
   只存在一个对象（列表），"x" 和 "y" 都是对它的引用。

2. 列表属于 *mutable* 对象，这意味着你可以改变它的内容。

在调用 "append()" 之后，这个可变对象的内容由 "[]" 变为 "[10]"。 由于两
个变量都指向同一对象，因此使用任何一个名称所访问到的都是修改后的值
"[10]"。

如果我们改为将不可变对象赋值给 "x":

   >>> x = 5  # ints are immutable
   >>> y = x
   >>> x = x + 1  # 5 can't be mutated, we are creating a new object here
   >>> x
   6
   >>> y
   5

我们可以看到在此情况下 "x" 和 "y" 就不再相等了。 这是因为整数是
*immutable* 对象，当我们执行 "x = x + 1" 时我们并不是改变了 "5" 这个对
象的值；而是创建了一个新的对象 (整数 "6") 并将其赋值给 "x" (也就是改变
了 "x" 所指向的对象)。 在赋值之后我们就有了两个对象 (整数 "6" 和 "5")
以及分别指向它们的两个变量 ("x" 现在指向 "6" 而 "y" 仍然指向 "5")。

某些操作 (例如 "y.append(10)" 和 "y.sort()") 是改变原对象，而看上去相
似的另一些操作 (例如 "y = y + [10]" 和 "sorted(y)") 则是创建新对象。
通常在 Python 中 (以及在标准库的所有代码中) 会改变原对象的方法将返回
"None" 以帮助避免混淆这两种不同类型的操作。 因此如果你错误地使用了
"y.sort()" 并期望它将返回一个经过排序的 "y" 的副本，你得到的结果将会是
"None"，这将导致你的程序产生一个容易诊断的错误。

但是，还存在一类操作，不同的类型执行相同的操作会有不同的行为：那就是增
强赋值运算符。 例如，"+=" 会原地改变列表，但不会改变元组或整数
("a_list += [1, 2, 3]" 与 "a_list.extend([1, 2, 3])" 一样都会改变
"a_list"，而 "some_tuple += (1, 2, 3)" 和 "some_int += 1" 则会创建新的
对象)。

换而言之：

* 如果我们有一个可变对象 ("list", "dict", "set" 等等)，我们可以使用某
  些特定的操作来改变它，所有指向它的变量都会显示它的改变。

* 如果我们有一个不可变对象 ("str", "int", "tuple" 等等)，所有指向它的
  变量都将显示相同样的值，但凡是会改变这个值的操作将总是返回一个新对象
  。

如果你想知道两个变量是否指向相同的对象，你可以使用 "is" 运算符，或内置
函数 "id()"。"}
{Q002002010En:"Programming FAQ==>Core Language==>How do I write a function with output parameters (call by reference)?"}
{A002002010En:"Remember that arguments are passed by assignment in Python.  Since
assignment just creates references to objects, there's no alias
between an argument name in the caller and callee, and so no call-by-
reference per se.  You can achieve the desired effect in a number of
ways.

1. By returning a tuple of the results:

      >>> def func1(a, b):
      ...     a = 'new-value'        # a and b are local names
      ...     b = b + 1              # assigned to new objects
      ...     return a, b            # return new values
      ...
      >>> x, y = 'old-value', 99
      >>> func1(x, y)
      ('new-value', 100)

   This is almost always the clearest solution.

2. By using global variables.  This isn't thread-safe, and is not
   recommended.

3. By passing a mutable (changeable in-place) object:

      >>> def func2(a):
      ...     a[0] = 'new-value'     # 'a' references a mutable list
      ...     a[1] = a[1] + 1        # changes a shared object
      ...
      >>> args = ['old-value', 99]
      >>> func2(args)
      >>> args
      ['new-value', 100]

4. By passing in a dictionary that gets mutated:

      >>> def func3(args):
      ...     args['a'] = 'new-value'     # args is a mutable dictionary
      ...     args['b'] = args['b'] + 1   # change it in-place
      ...
      >>> args = {'a': 'old-value', 'b': 99}
      >>> func3(args)
      >>> args
      {'a': 'new-value', 'b': 100}

5. Or bundle up values in a class instance:

      >>> class Namespace:
      ...     def __init__(self, /, **args):
      ...         for key, value in args.items():
      ...             setattr(self, key, value)
      ...
      >>> def func4(args):
      ...     args.a = 'new-value'        # args is a mutable Namespace
      ...     args.b = args.b + 1         # change object in-place
      ...
      >>> args = Namespace(a='old-value', b=99)
      >>> func4(args)
      >>> vars(args)
      {'a': 'new-value', 'b': 100}

   There's almost never a good reason to get this complicated.

Your best choice is to return a tuple containing the multiple results."}
{Q002002010Zh:"编程常见问题==>核心语言==>如何编写带输出参数的函数（通过引用调用）？"}
{A002002010Zh:"请记住在 Python 中参数是通过赋值来传递的。 由于赋值只是创建了对象的引
用，因此在调用者和被调用者的参数名称之间没有别名，所以本身是没有按引用
调用的。 你可以通过多种方式实现所需的效果。

1. 通过返回一个结果元组:

      >>> def func1(a, b):
      ...     a = 'new-value'        # a and b are local names
      ...     b = b + 1              # assigned to new objects
      ...     return a, b            # return new values
      ...
      >>> x, y = 'old-value', 99
      >>> func1(x, y)
      ('new-value', 100)

   这几乎总是最清晰明了的解决方案。

2. 通过使用全局变量。 这种方式不是线程安全的，而且也不受推荐。

3. 通过传递一个可变 (即可原地修改的) 对象:

      >>> def func2(a):
      ...     a[0] = 'new-value'     # 'a' references a mutable list
      ...     a[1] = a[1] + 1        # changes a shared object
      ...
      >>> args = ['old-value', 99]
      >>> func2(args)
      >>> args
      ['new-value', 100]

4. 通过传递一个会被改变的字典:

      >>> def func3(args):
      ...     args['a'] = 'new-value'     # args is a mutable dictionary
      ...     args['b'] = args['b'] + 1   # change it in-place
      ...
      >>> args = {'a': 'old-value', 'b': 99}
      >>> func3(args)
      >>> args
      {'a': 'new-value', 'b': 100}

5. 或者在一个类实例中捆绑值:

      >>> class Namespace:
      ...     def __init__(self, /, **args):
      ...         for key, value in args.items():
      ...             setattr(self, key, value)
      ...
      >>> def func4(args):
      ...     args.a = 'new-value'        # args is a mutable Namespace
      ...     args.b = args.b + 1         # change object in-place
      ...
      >>> args = Namespace(a='old-value', b=99)
      >>> func4(args)
      >>> vars(args)
      {'a': 'new-value', 'b': 100}

   几乎没有任何适当理由将问题如此复杂化。

你的最佳选择是返回一个包含多个结果的元组。"}
{Q002002011En:"Programming FAQ==>Core Language==>How do you make a higher order function in Python?"}
{A002002011En:"You have two choices: you can use nested scopes or you can use
callable objects. For example, suppose you wanted to define
"linear(a,b)" which returns a function "f(x)" that computes the value
"a*x+b".  Using nested scopes:

   def linear(a, b):
       def result(x):
           return a * x + b
       return result

Or using a callable object:

   class linear:

       def __init__(self, a, b):
           self.a, self.b = a, b

       def __call__(self, x):
           return self.a * x + self.b

In both cases,

   taxes = linear(0.3, 2)

gives a callable object where "taxes(10e6) == 0.3 * 10e6 + 2".

The callable object approach has the disadvantage that it is a bit
slower and results in slightly longer code.  However, note that a
collection of callables can share their signature via inheritance:

   class exponential(linear):
       # __init__ inherited
       def __call__(self, x):
           return self.a * (x ** self.b)

Object can encapsulate state for several methods:

   class counter:

       value = 0

       def set(self, x):
           self.value = x

       def up(self):
           self.value = self.value + 1

       def down(self):
           self.value = self.value - 1

   count = counter()
   inc, dec, reset = count.up, count.down, count.set

Here "inc()", "dec()" and "reset()" act like functions which share the
same counting variable."}
{Q002002011Zh:"编程常见问题==>核心语言==>如何在Python中创建高阶函数？"}
{A002002011Zh:"你有两种选择：使用嵌套作用域，或者使用可调用对象。 例如，假设你想要定
义 "linear(a,b)" 使其返回一个函数 "f(x)" 来设计 "a*x+b" 的值。 可以使
用以下嵌套作用域:

   def linear(a, b):
       def result(x):
           return a * x + b
       return result

或使用一个可调用对象:

   class linear:

       def __init__(self, a, b):
           self.a, self.b = a, b

       def __call__(self, x):
           return self.a * x + self.b

在两种情况下，:

   taxes = linear(0.3, 2)

都会给出一个可调用对象，使得 "taxes(10e6) == 0.3 * 10e6 + 2".

可调用对象方式的缺点是速度略慢且生成的代码略长。 但是，请注意一组可调
用对象能够通过继承来共享签名:

   class exponential(linear):
       # __init__ inherited
       def __call__(self, x):
           return self.a * (x ** self.b)

对象可以封装多个方法的状态:

   class counter:

       value = 0

       def set(self, x):
           self.value = x

       def up(self):
           self.value = self.value + 1

       def down(self):
           self.value = self.value - 1

   count = counter()
   inc, dec, reset = count.up, count.down, count.set

这里 "inc()", "dec()" 和 "reset()" 将表现为共享同一计数变量的多个函数
。"}
{Q002002012En:"Programming FAQ==>Core Language==>How do I copy an object in Python?"}
{A002002012En:"In general, try "copy.copy()" or "copy.deepcopy()" for the general
case. Not all objects can be copied, but most can.

Some objects can be copied more easily.  Dictionaries have a "copy()"
method:

   newdict = olddict.copy()

Sequences can be copied by slicing:

   new_l = l[:]"}
{Q002002012Zh:"编程常见问题==>核心语言==>如何在Python中复制对象？"}
{A002002012Zh:"一般来说，通常情况下请尝试 "copy.copy()" 或 "copy.deepcopy()"。 不是所
有对象都可以复制，但多数都是可以的。

某些对象可以方便地复制。 例如字典具有 "copy()" 方法:

   newdict = olddict.copy()

序列可以通过切片来复制:

   new_l = l[:]"}
{Q002002013En:"Programming FAQ==>Core Language==>How can I find the methods or attributes of an object?"}
{A002002013En:"For an instance x of a user-defined class, "dir(x)" returns an
alphabetized list of the names containing the instance attributes and
methods and attributes defined by its class."}
{Q002002013Zh:"编程常见问题==>核心语言==>如何找到对象的方法或属性？"}
{A002002013Zh:"对于一个用户自定义类的实例 x，"dir(x)" 将返回一个按字母顺序排序的包含
实例属性和方法及其类所定义的属性名称的列表。"}
{Q002002014En:"Programming FAQ==>Core Language==>How can my code discover the name of an object?"}
{A002002014En:"Generally speaking, it can't, because objects don't really have names.
Essentially, assignment always binds a name to a value; the same is
true of "def" and "class" statements, but in that case the value is a
callable. Consider the following code:

   >>> class A:
   ...     pass
   ...
   >>> B = A
   >>> a = B()
   >>> b = a
   >>> print(b)
   <__main__.A object at 0x16D07CC>
   >>> print(a)
   <__main__.A object at 0x16D07CC>

Arguably the class has a name: even though it is bound to two names
and invoked through the name B the created instance is still reported
as an instance of class A.  However, it is impossible to say whether
the instance's name is a or b, since both names are bound to the same
value.

Generally speaking it should not be necessary for your code to "know
the names" of particular values. Unless you are deliberately writing
introspective programs, this is usually an indication that a change of
approach might be beneficial.

In comp.lang.python, Fredrik Lundh once gave an excellent analogy in
answer to this question:

   The same way as you get the name of that cat you found on your
   porch: the cat (object) itself cannot tell you its name, and it
   doesn't really care -- so the only way to find out what it's called
   is to ask all your neighbours (namespaces) if it's their cat
   (object)...

   ....and don't be surprised if you'll find that it's known by many
   names, or no name at all!"}
{Q002002014Zh:"编程常见问题==>核心语言==>我的代码如何才能发现对象的名称？"}
{A002002014Zh:"通常来说是做不到的，因为对象并不真正具有名称。 在本质上，赋值总是会将
一个名称绑定到某个值；"def" 和 "class" 语句也是如此，但在这种情况下该
值是一个可调用对象。 考虑以下代码:

   >>> class A:
   ...     pass
   ...
   >>> B = A
   >>> a = B()
   >>> b = a
   >>> print(b)
   <__main__.A object at 0x16D07CC>
   >>> print(a)
   <__main__.A object at 0x16D07CC>

不严谨地讲，该类有一个名称：虽然它是绑定了两个名称并通过名称 B 发起调
用，所创建的实例仍然被视为类 A 的一个实例。 但是实例的名称则无法确定地
说是 a 或是 b，因为有两个名称被绑定到了同一个值。

一般来说你的代码应该没有必要“知道”特定值的名称。 除非你是在编写特殊的
内省程序，出现这样的问题通常表明如果改变方式可能会更有利。

在 comp.lang.python 中，Fredrik Lundh 在回答这样的问题时曾经给出过一个
绝佳的类比：

   跟你找出在你家门廊见到的某只猫的名字所用的办法一样：猫（对象）自己
   无法告诉你它的名字，它根本就不在乎 —— 所以找出它叫什么名字的唯一办
   法是问你的所有邻居（命名空间）那是不是他们的猫（对象）……

   ……并且如果你发现它有很多名字或根本没有名字也不必觉得惊讶！"}
{Q002002015En:"Programming FAQ==>Core Language==>What's up with the comma operator's precedence?"}
{A002002015En:"Comma is not an operator in Python.  Consider this session:

   >>> "a" in "b", "a"
   (False, 'a')

Since the comma is not an operator, but a separator between
expressions the above is evaluated as if you had entered:

   ("a" in "b"), "a"

not:

   "a" in ("b", "a")

The same is true of the various assignment operators ("=", "+=" etc).
They are not truly operators but syntactic delimiters in assignment
statements."}
{Q002002015Zh:"编程常见问题==>核心语言==>逗号运算符的优先级是什么？"}
{A002002015Zh:"逗号在 Python 中不是运算符。 考虑这个例子:

   >>> "a" in "b", "a"
   (False, 'a')

由于逗号不是运算符而是表达式之间的分隔符，以上代码的含义就相当于:

   ("a" in "b"), "a"

而不是:

   "a" in ("b", "a")

对于各种赋值运算符 ("=", "+=" 等) 来说同样如此。 它们并不是真正的运算
符而是赋值语句中的语法分隔符。"}
{Q002002016En:"Programming FAQ==>Core Language==>Is there an equivalent of C's "?:" ternary operator?"}
{A002002016En:"Yes, there is. The syntax is as follows:

   [on_true] if [expression] else [on_false]

   x, y = 50, 25
   small = x if x < y else y

Before this syntax was introduced in Python 2.5, a common idiom was to
use logical operators:

   [expression] and [on_true] or [on_false]

However, this idiom is unsafe, as it can give wrong results when
*on_true* has a false boolean value.  Therefore, it is always better
to use the "... if ... else ..." form."}
{Q002002016Zh:"编程常见问题==>核心语言==>是否有与 C 的 "?:" 三目运算符等价的东西？"}
{A002002016Zh:"有的。 相应语法如下:

   [on_true] if [expression] else [on_false]

   x, y = 50, 25
   small = x if x < y else y

在 Python 2.5 引入此语法之前，常见的做法是使用逻辑运算符:

   [expression] and [on_true] or [on_false]

然而这种做法并不保险，因为当 *on_true* 具有布尔假值时将会给出错误的结
果。 所以，使用 "... if ... else ..." 形式总是会更好。"}
{Q002002017En:"Programming FAQ==>Core Language==>Is it possible to write obfuscated one-liners in Python?"}
{A002002017En:"Yes.  Usually this is done by nesting "lambda" within "lambda".  See
the following three examples, due to Ulf Bartelt:

   from functools import reduce

   # Primes < 1000
   print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,
   map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))

   # First 10 Fibonacci numbers
   print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:
   f(x,f), range(10))))

   # Mandelbrot set
   print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,
   Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,
   Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,
   i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y
   >=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(
   64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy
   ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))
   #    \___ ___/  \___ ___/  |   |   |__ lines on screen
   #        V          V      |   |______ columns on screen
   #        |          |      |__________ maximum of "iterations"
   #        |          |_________________ range on y axis
   #        |____________________________ range on x axis

Don't try this at home, kids!"}
{Q002002017Zh:"编程常见问题==>核心语言==>是否可以用Python编写混淆的单行程序?"}
{A002002017Zh:"可以。通常是在 "lambda" 中嵌套 "lambda" 来实现的。请参阅以下三个来自
Ulf Bartelt 的示例代码：

   from functools import reduce

   # Primes < 1000
   print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,
   map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))

   # First 10 Fibonacci numbers
   print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:
   f(x,f), range(10))))

   # Mandelbrot set
   print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,
   Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,
   Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,
   i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y
   >=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(
   64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy
   ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))
   #    \___ ___/  \___ ___/  |   |   |__ lines on screen
   #        V          V      |   |______ columns on screen
   #        |          |      |__________ maximum of "iterations"
   #        |          |_________________ range on y axis
   #        |____________________________ range on x axis

请不要在家里尝试，骚年！"}
{Q002002018En:"Programming FAQ==>Core Language==>What does the slash(/) in the parameter list of a function mean?"}
{A002002018En:"A slash in the argument list of a function denotes that the parameters
prior to it are positional-only.  Positional-only parameters are the
ones without an externally-usable name.  Upon calling a function that
accepts positional-only parameters, arguments are mapped to parameters
based solely on their position. For example, "divmod()" is a function
that accepts positional-only parameters. Its documentation looks like
this:

   >>> help(divmod)
   Help on built-in function divmod in module builtins:

   divmod(x, y, /)
       Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.

The slash at the end of the parameter list means that both parameters
are positional-only. Thus, calling "divmod()" with keyword arguments
would lead to an error:

   >>> divmod(x=3, y=4)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: divmod() takes no keyword arguments"}
{Q002002018Zh:"编程常见问题==>核心语言==>函数参数列表中的斜杠（/）是什么意思？"}
{A002002018Zh:"函数参数列表中的斜杠表示在它之前的形参是仅限位置形参。 仅限位置形参没
有外部可用的名称。  在调用接受仅限位置形参的函数时，参数只会基于它们的
位置被映射到形参。 例如，"divmod()" 是一个接受仅限位置形参的函数。 它
的文档是这样的:

   >>> help(divmod)
   Help on built-in function divmod in module builtins:

   divmod(x, y, /)
       Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.

在形参列表末尾的斜杠意味着两个形参都是仅限位置形参。 因此，附带关键字
参数调用 "divmod()" 将会导致报错:

   >>> divmod(x=3, y=4)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: divmod() takes no keyword arguments"}
{Q002003001En:"Programming FAQ==>Numbers and strings==>How do I specify hexadecimal and octal integers?"}
{A002003001En:"To specify an octal digit, precede the octal value with a zero, and
then a lower or uppercase "o".  For example, to set the variable "a"
to the octal value "10" (8 in decimal), type:

   >>> a = 0o10
   >>> a
   8

Hexadecimal is just as easy.  Simply precede the hexadecimal number
with a zero, and then a lower or uppercase "x".  Hexadecimal digits
can be specified in lower or uppercase.  For example, in the Python
interpreter:

   >>> a = 0xa5
   >>> a
   165
   >>> b = 0XB2
   >>> b
   178"}
{Q002003001Zh:"编程常见问题==>数字和字符串==>如何指定十六进制和八进制整数？"}
{A002003001Zh:"要指定一个八进制数码，则在八进制值之前加一个零和一个小写或大写字母 "o"
作为前缀。 例如，要将变量 "a" 设为八进制的 "10" (十进制的 8)，就输入:

   >>> a = 0o10
   >>> a
   8

十六进制数也同样简单。 只要在十六进制数之前加一个零和一个小写或大写字
母 "x"。 十六进制数码中的字母可以为大写或小写。 例如在 Python 解释器中
输入:

   >>> a = 0xa5
   >>> a
   165
   >>> b = 0XB2
   >>> b
   178"}
{Q002003002En:"Programming FAQ==>Numbers and strings==>Why does -22 // 10 return -3?"}
{A002003002En:"It's primarily driven by the desire that "i % j" have the same sign as
"j". If you want that, and also want:

   i == (i // j) * j + (i % j)

then integer division has to return the floor.  C also requires that
identity to hold, and then compilers that truncate "i // j" need to
make "i % j" have the same sign as "i".

There are few real use cases for "i % j" when "j" is negative.  When
"j" is positive, there are many, and in virtually all of them it's
more useful for "i % j" to be ">= 0".  If the clock says 10 now, what
did it say 200 hours ago?  "-190 % 12 == 2" is useful; "-190 % 12 ==
-10" is a bug waiting to bite."}
{Q002003002Zh:"编程常见问题==>数字和字符串==>为什么-22 // 10返回-3？"}
{A002003002Zh:"这主要是为了让 "i % j" 的正负与 "j" 一致，如果你想要这样的结果，并且又
想要:

   i == (i // j) * j + (i % j)

那么整除就必须向下取整。 C 同样要求保持一致，并且编译器在截短 "i // j"
的结果值时需要使 "i % j" 的正负与 "i" 一致。

对于 "i % j" 来说 "j" 为负值的应用场景实际上是非常少的。 而 "j" 为正值
的情况则非常多，并且实际上在所有情况下让 "i % j" 的结果为 ">= 0" 会更
有用处。 如果现在时间为 10 时，那么 200 小时前应是几时？ "-190 % 12 ==
2" 是有用处的；"-190 % 12 == -10" 则是会导致意外的漏洞。"}
{Q002003003En:"Programming FAQ==>Numbers and strings==>How do I convert a string to a number?"}
{A002003003En:"For integers, use the built-in "int()" type constructor, e.g.
"int('144') == 144".  Similarly, "float()" converts to floating-point,
e.g. "float('144') == 144.0".

By default, these interpret the number as decimal, so that
"int('0144') == 144" holds true, and "int('0x144')" raises
"ValueError". "int(string, base)" takes the base to convert from as a
second optional argument, so "int( '0x144', 16) == 324".  If the base
is specified as 0, the number is interpreted using Python's rules: a
leading '0o' indicates octal, and '0x' indicates a hex number.

Do not use the built-in function "eval()" if all you need is to
convert strings to numbers.  "eval()" will be significantly slower and
it presents a security risk: someone could pass you a Python
expression that might have unwanted side effects.  For example,
someone could pass "__import__('os').system("rm -rf $HOME")" which
would erase your home directory.

"eval()" also has the effect of interpreting numbers as Python
expressions, so that e.g. "eval('09')" gives a syntax error because
Python does not allow leading '0' in a decimal number (except '0')."}
{Q002003003Zh:"编程常见问题==>数字和字符串==>如何将字符串转换为数字？"}
{A002003003Zh:"对于整数，可使用内置的 "int()" 类型构造器，例如 "int('144') == 144"。
类似地，可使用 "float()" 转换为浮点数，例如 "float('144') == 144.0"。

默认情况下，这些操作会将数字按十进制来解读，因此 "int('0144') == 144"
为真值，而 "int('0x144')" 会引发 "ValueError"。 "int(string, base)" 接
受第二个可选参数指定转换的基数，例如 "int( '0x144', 16) == 324"。 如果
指定基数为 0，则按 Python 规则解读数字：前缀 '0o' 表示八进制，而 '0x'
表示十六进制。

如果你只是想将字符串转为数字，请不要使用内置函数 "eval()"。 "eval()"
的速度会慢很多并且有安全风险：别人可能会传入具有你不想要的附带效果的
Python 表达式。 例如，别人可以传入 "__import__('os').system("rm -rf
$HOME")" 这将删除你的家目录。

"eval()" 还具有将数字解读为 Python 表达式的效果，这样 "eval('09')" 将
会导致语法错误，因为 Python 不允许十进制数的首位是 '0' ('0' 除外)。"}
{Q002003004En:"Programming FAQ==>Numbers and strings==>How do I convert a number to a string?"}
{A002003004En:"To convert, e.g., the number 144 to the string '144', use the built-in
type constructor "str()".  If you want a hexadecimal or octal
representation, use the built-in functions "hex()" or "oct()".  For
fancy formatting, see the Formatted string literals and Format String
Syntax sections, e.g. ""{:04d}".format(144)" yields "'0144'" and
""{:.3f}".format(1.0/3.0)" yields "'0.333'"."}
{Q002003004Zh:"编程常见问题==>数字和字符串==>如何将数字转换为字符串？"}
{A002003004Zh:"例如要将数字 144 转换为字符串 '144'，可使用内置类型构造器 "str()"。 如
果想要表示为十六进制或八进制数，可使用内置函数 "hex()" 或 "oct()"。 想
要更好地格式化，请参阅 格式化字符串字面值 和 格式字符串语法 等小节，例
如 ""{:04d}".format(144)" 生成 "'0144'" 而 ""{:.3f}".format(1.0/3.0)"
生成 "'0.333'"。"}
{Q002003005En:"Programming FAQ==>Numbers and strings==>How do I modify a string in place?"}
{A002003005En:"You can't, because strings are immutable.  In most situations, you
should simply construct a new string from the various parts you want
to assemble it from.  However, if you need an object with the ability
to modify in-place unicode data, try using an "io.StringIO" object or
the "array" module:

   >>> import io
   >>> s = "Hello, world"
   >>> sio = io.StringIO(s)
   >>> sio.getvalue()
   'Hello, world'
   >>> sio.seek(7)
   7
   >>> sio.write("there!")
   6
   >>> sio.getvalue()
   'Hello, there!'

   >>> import array
   >>> a = array.array('u', s)
   >>> print(a)
   array('u', 'Hello, world')
   >>> a[0] = 'y'
   >>> print(a)
   array('u', 'yello, world')
   >>> a.tounicode()
   'yello, world'"}
{Q002003005Zh:"编程常见问题==>数字和字符串==>如何修改字符串？"}
{A002003005Zh:"无法修改，因为字符串是不可变对象。 在大多数情况下，你应该使用你想要的
各种部分来构造一个新字符串。 但是，如果你想要一个可以原地修改 Unicode
数据的对象，可尝试使用 "io.StringIO" 对象或 "array" 模块:

   >>> import io
   >>> s = "Hello, world"
   >>> sio = io.StringIO(s)
   >>> sio.getvalue()
   'Hello, world'
   >>> sio.seek(7)
   7
   >>> sio.write("there!")
   6
   >>> sio.getvalue()
   'Hello, there!'

   >>> import array
   >>> a = array.array('u', s)
   >>> print(a)
   array('u', 'Hello, world')
   >>> a[0] = 'y'
   >>> print(a)
   array('u', 'yello, world')
   >>> a.tounicode()
   'yello, world'"}
{Q002003006En:"Programming FAQ==>Numbers and strings==>How do I use strings to call functions/methods?"}
{A002003006En:"There are various techniques.

* The best is to use a dictionary that maps strings to functions.  The
  primary advantage of this technique is that the strings do not need
  to match the names of the functions.  This is also the primary
  technique used to emulate a case construct:

     def a():
         pass

     def b():
         pass

     dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs

     dispatch[get_input()]()  # Note trailing parens to call function

* Use the built-in function "getattr()":

     import foo
     getattr(foo, 'bar')()

  Note that "getattr()" works on any object, including classes, class
  instances, modules, and so on.

  This is used in several places in the standard library, like this:

     class Foo:
         def do_foo(self):
             ...

         def do_bar(self):
             ...

     f = getattr(foo_instance, 'do_' + opname)
     f()

* Use "locals()" to resolve the function name:

     def myFunc():
         print("hello")

     fname = "myFunc"

     f = locals()[fname]
     f()"}
{Q002003006Zh:"编程常见问题==>数字和字符串==>如何使用字符串调用函数/方法？"}
{A002003006Zh:"有多种技巧可供选择。

* 最好的做法是使用一个将字符串映射到函数的字典。 这一技巧的主要优势在
  于字符串不必与函数名称一致。 这也是用于模拟其他语言中 case 结构的主
  要技巧:

     def a():
         pass

     def b():
         pass

     dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs

     dispatch[get_input()]()  # Note trailing parens to call function

* 使用内置函数 "getattr()"

     import foo
     getattr(foo, 'bar')()

  请注意 "getattr()" 可用于任何对象，包括类、类实例、模块等等。

  在标准库中多次使用了这个技巧，例如:

     class Foo:
         def do_foo(self):
             ...

         def do_bar(self):
             ...

     f = getattr(foo_instance, 'do_' + opname)
     f()

* 使用 "locals()" 来解析出函数名:

     def myFunc():
         print("hello")

     fname = "myFunc"

     f = locals()[fname]
     f()"}
{Q002003007En:"Programming FAQ==>Numbers and strings==>Is there an equivalent to Perl's chomp() for removing trailing newlines from strings?"}
{A002003007En:"You can use "S.rstrip("\r\n")" to remove all occurrences of any line
terminator from the end of the string "S" without removing other
trailing whitespace.  If the string "S" represents more than one line,
with several empty lines at the end, the line terminators for all the
blank lines will be removed:

   >>> lines = ("line 1 \r\n"
   ...          "\r\n"
   ...          "\r\n")
   >>> lines.rstrip("\n\r")
   'line 1 '

Since this is typically only desired when reading text one line at a
time, using "S.rstrip()" this way works well."}
{Q002003007Zh:"编程常见问题==>数字和字符串==>是否有与Perl 的chomp() 等效的方法，用于从字符串中删除尾随换行符？"}
{A002003007Zh:"可以使用 "S.rstrip("\r\n")" 从字符串 "S" 的末尾删除所有的换行符，而不
删除其他尾随空格。如果字符串 "S" 表示多行，且末尾有几个空行，则将删除
所有空行的换行符：

   >>> lines = ("line 1 \r\n"
   ...          "\r\n"
   ...          "\r\n")
   >>> lines.rstrip("\n\r")
   'line 1 '

由于通常只在一次读取一行文本时才需要这样做，所以使用 "S.rstrip()" 这种
方式工作得很好。"}
{Q002003008En:"Programming FAQ==>Numbers and strings==>Is there a scanf() or sscanf() equivalent?"}
{A002003008En:"Not as such.

For simple input parsing, the easiest approach is usually to split the
line into whitespace-delimited words using the "split()" method of
string objects and then convert decimal strings to numeric values
using "int()" or "float()".  "split()" supports an optional "sep"
parameter which is useful if the line uses something other than
whitespace as a separator.

For more complicated input parsing, regular expressions are more
powerful than C's "sscanf()" and better suited for the task."}
{Q002003008Zh:"编程常见问题==>数字和字符串==>是否有 scanf() 或 sscanf() 的对应物？"}
{A002003008Zh:"没有这样的对应物。

对于简单的输入解析，最方便的做法通常是使用字符串对象的 "split()" 方法
将一行内容拆解为以空格分隔的单词，然后使用 "int()" 或 "float()" 将表示
十进制数的字符串转换为数值。 "split()" 支持可选的 "sep" 形参，适用于内
容行使用空格符以外的分隔符的情况。

以于更复杂的输入解析，正则表达式会比 C 的 "sscanf()" 更强大，也更适合
此类任务。"}
{Q002003009En:"Programming FAQ==>Numbers and strings==>What does 'UnicodeDecodeError' or 'UnicodeEncodeError' error  mean?"}
{A002003009En:"See the Unicode HOWTO."}
{Q002003009Zh:"编程常见问题==>数字和字符串==>'UnicodeDecodeError' 或 'UnicodeEncodeError' 错误是什么意思？"}
{A002003009Zh:"见 Unicode 指南"}
{Q002004001En:"Programming FAQ==>Performance==>My program is too slow. How do I speed it up?"}
{A002004001En:"That's a tough one, in general.  First, here are a list of things to
remember before diving further:

* Performance characteristics vary across Python implementations.
  This FAQ focuses on *CPython*.

* Behaviour can vary across operating systems, especially when talking
  about I/O or multi-threading.

* You should always find the hot spots in your program *before*
  attempting to optimize any code (see the "profile" module).

* Writing benchmark scripts will allow you to iterate quickly when
  searching for improvements (see the "timeit" module).

* It is highly recommended to have good code coverage (through unit
  testing or any other technique) before potentially introducing
  regressions hidden in sophisticated optimizations.

That being said, there are many tricks to speed up Python code.  Here
are some general principles which go a long way towards reaching
acceptable performance levels:

* Making your algorithms faster (or changing to faster ones) can yield
  much larger benefits than trying to sprinkle micro-optimization
  tricks all over your code.

* Use the right data structures.  Study documentation for the Built-in
  Types and the "collections" module.

* When the standard library provides a primitive for doing something,
  it is likely (although not guaranteed) to be faster than any
  alternative you may come up with.  This is doubly true for
  primitives written in C, such as builtins and some extension types.
  For example, be sure to use either the "list.sort()" built-in method
  or the related "sorted()" function to do sorting (and see the
  Sorting HOW TO for examples of moderately advanced usage).

* Abstractions tend to create indirections and force the interpreter
  to work more.  If the levels of indirection outweigh the amount of
  useful work done, your program will be slower.  You should avoid
  excessive abstraction, especially under the form of tiny functions
  or methods (which are also often detrimental to readability).

If you have reached the limit of what pure Python can allow, there are
tools to take you further away.  For example, Cython can compile a
slightly modified version of Python code into a C extension, and can
be used on many different platforms.  Cython can take advantage of
compilation (and optional type annotations) to make your code
significantly faster than when interpreted.  If you are confident in
your C programming skills, you can also write a C extension module
yourself.

See also: The wiki page devoted to performance tips."}
{Q002004001Zh:"编程常见问题==>性能==>我的程序太慢了。该如何加快速度？"}
{A002004001Zh:"总的来说，这是个棘手的问题。首先，下面列出了深入了解前需要记住的事情：

* 不同的 Python 实现具有不同的性能特点。 本 FAQ 着重解答的是 *CPython*
  。

* 行为可能因操作系统而异，尤其是在谈论 I / O 或多线程时。

* 在尝试优化任何代码 *前* ，应始终找到程序中的热点（请参阅 "profile"
  模块）。

* 编写基准脚本将允许您在搜索改进时快速迭代（请参阅 "timeit" 模块）。

* 强烈建议在可能引入隐藏在复杂优化中的回归之前，要有良好的代码覆盖率（
  通过单元测试或任何其他技术）。

话虽如此，加速Python代码有很多技巧。以下是一些可以达到可接受的性能水平
的一般原则：

* 使您的算法更快（或更改为更快的算法）可以产生比尝试在代码中使用微优化
  技巧更大的好处。

* 使用正确的数据结构。参考文档 内置类型 和 "collections" 模块。

* 当标准库提供用于执行某些操作的原语时，可能（尽管不能保证）比您可能提
  出的任何替代方案更快。对于用C编写的原语，例如内置函数和一些扩展类型
  ，这是真的。例如，请确保使用 "list.sort()" 内置方法或相关的
  "sorted()" 函数进行排序（有关适度高级用法的示例，请参阅 排序指南 ）
  。

* 抽象倾向于创造间接性并迫使翻译更多地工作。如果间接级别超过完成的有用
  工作量，则程序将变慢。你应该避免过度抽象，特别是在微小的功能或方法的
  形式下（这通常也会对可读性产生不利影响）。

如果你已经达到纯 Python 允许的限制，那么有一些工具可以让你走得更远。
例如， Cython 可以将稍微修改的 Python 代码版本编译为 C 扩展，并且可以
在许多不同的平台上使用。 Cython 可以利用编译（和可选的类型注释）来使代
码明显快于解释运行时的速度。 如果您对 C 编程技能有信心，也可以自己 编
写 C 扩展模块 。

参见: 专门介绍 性能提示 的wiki页面。"}
{Q002004002En:"Programming FAQ==>Performance==>What is the most efficient way to concatenate many strings together?"}
{A002004002En:""str" and "bytes" objects are immutable, therefore concatenating many
strings together is inefficient as each concatenation creates a new
object.  In the general case, the total runtime cost is quadratic in
the total string length.

To accumulate many "str" objects, the recommended idiom is to place
them into a list and call "str.join()" at the end:

   chunks = []
   for s in my_strings:
       chunks.append(s)
   result = ''.join(chunks)

(another reasonably efficient idiom is to use "io.StringIO")

To accumulate many "bytes" objects, the recommended idiom is to extend
a "bytearray" object using in-place concatenation (the "+=" operator):

   result = bytearray()
   for b in my_bytes_objects:
       result += b"}
{Q002004002Zh:"编程常见问题==>性能==>将多个字符串连接在一起的最有效方法是什么？"}
{A002004002Zh:""str" 和 "bytes" 对象是不可变的，因此将多个字符串连接在一起效率很低，
因为每个连接都会创建一个新对象。在一般情况下，总运行时间是总字符串长度
的二次方。

要连接多个 "str" 对象，通常推荐的用法是将它们放入一个列表中并在结尾处
调用 "str.join()" ：

   chunks = []
   for s in my_strings:
       chunks.append(s)
   result = ''.join(chunks)

（另一个合理有效的惯用方法是 "io.StringIO" ）

要连接多个 "str" 对象，建议使用本地连接（ "+=" 运算符）扩展
"bytearray" 对象：

   result = bytearray()
   for b in my_bytes_objects:
       result += b"}
{Q002005001En:"Programming FAQ==>Sequences (Tuples/Lists)==>How do I convert between tuples and lists?"}
{A002005001En:"The type constructor "tuple(seq)" converts any sequence (actually, any
iterable) into a tuple with the same items in the same order.

For example, "tuple([1, 2, 3])" yields "(1, 2, 3)" and "tuple('abc')"
yields "('a', 'b', 'c')".  If the argument is a tuple, it does not
make a copy but returns the same object, so it is cheap to call
"tuple()" when you aren't sure that an object is already a tuple.

The type constructor "list(seq)" converts any sequence or iterable
into a list with the same items in the same order.  For example,
"list((1, 2, 3))" yields "[1, 2, 3]" and "list('abc')" yields "['a',
'b', 'c']".  If the argument is a list, it makes a copy just like
"seq[:]" would."}
{Q002005001Zh:"编程常见问题==>序列（元组/列表）==>如何在元组和列表之间进行转换？"}
{A002005001Zh:"类型构造器 "tuple(seq)" 可将任意序列（实际上是任意可迭代对象）转换为具
有相同排列顺序的相同条目的元组。

例如，"tuple([1, 2, 3])" 产生 "(1, 2, 3)" 而 "tuple('abc')" 产生
"('a', 'b', 'c')"。 如果参数为一个元组，它不会创建副本而是返回同一对象
，因此如果你不确定某个对象是否为元组时也可简单地调用 "tuple()"。

类型构造器 "list(seq)" 可将任意序列或可迭代对象转换为具有相同排列顺序
的相同条目的列表。 例如，"list((1, 2, 3))" 产生 "[1, 2, 3]" 而
"list('abc')" 产生 "['a', 'b', 'c']"。 如果参数为一个列表，它会像
"seq[:]" 那样创建一个副本。"}
{Q002005002En:"Programming FAQ==>Sequences (Tuples/Lists)==>What's a negative index?"}
{A002005002En:"Python sequences are indexed with positive numbers and negative
numbers.  For positive numbers 0 is the first index 1 is the second
index and so forth.  For negative indices -1 is the last index and -2
is the penultimate (next to last) index and so forth.  Think of
"seq[-n]" as the same as "seq[len(seq)-n]".

Using negative indices can be very convenient.  For example "S[:-1]"
is all of the string except for its last character, which is useful
for removing the trailing newline from a string."}
{Q002005002Zh:"编程常见问题==>序列（元组/列表）==>什么是负数序号？"}
{A002005002Zh:"Python 序列使用正数或负数作为序号或称索引号。 对于正数序号，第一个序号
为 0 而 1 为第二个序号，依此类推。 对于负数序号，倒数第一个序号为 -1
而倒数第二个序号为 -2，依此类推。 可以认为 "seq[-n]" 就相当于
"seq[len(seq)-n]"。

使用负数序号有时会很方便。 例如 "S[:-1]" 就是原字符串去掉最后一个字符
，这可以用来移除某个字符串末尾的换行符。"}
{Q002005003En:"Programming FAQ==>Sequences (Tuples/Lists)==>How do I iterate over a sequence in reverse order?"}
{A002005003En:"Use the "reversed()" built-in function:

   for x in reversed(sequence):
       ...  # do something with x ...

This won't touch your original sequence, but build a new copy with
reversed order to iterate over."}
{Q002005003Zh:"编程常见问题==>序列（元组/列表）==>如何以相反的顺序迭代序列？"}
{A002005003Zh:"使用 "reversed()" 内置函数:

   for x in reversed(sequence):
       ...  # do something with x ...

这不会修改您的原始序列，而是构建一个反向顺序的新副本以进行迭代。"}
{Q002005004En:"Programming FAQ==>Sequences (Tuples/Lists)==>How do you remove duplicates from a list?"}
{A002005004En:"See the Python Cookbook for a long discussion of many ways to do this:

   https://code.activestate.com/recipes/52560/

If you don't mind reordering the list, sort it and then scan from the
end of the list, deleting duplicates as you go:

   if mylist:
       mylist.sort()
       last = mylist[-1]
       for i in range(len(mylist)-2, -1, -1):
           if last == mylist[i]:
               del mylist[i]
           else:
               last = mylist[i]

If all elements of the list may be used as set keys (i.e. they are all
*hashable*) this is often faster

   mylist = list(set(mylist))

This converts the list into a set, thereby removing duplicates, and
then back into a list."}
{Q002005004Zh:"编程常见问题==>序列（元组/列表）==>如何从列表中删除重复项？"}
{A002005004Zh:"有关执行此操作的许多方法的详细讨论，请参阅 Python Cookbook:

   https://code.activestate.com/recipes/52560/

如果您不介意重新排序列表，请对其进行排序，然后从列表末尾进行扫描，删除
重复项：

   if mylist:
       mylist.sort()
       last = mylist[-1]
       for i in range(len(mylist)-2, -1, -1):
           if last == mylist[i]:
               del mylist[i]
           else:
               last = mylist[i]

如果列表的所有元素都可以用作设置键（即：它们都是 *hashable* ），这通常
会更快:

   mylist = list(set(mylist))

这会将列表转换为集合，从而删除重复项，然后返回到列表中。"}
{Q002005005En:"Programming FAQ==>Sequences (Tuples/Lists)==>How do you remove multiple items from a list"}
{A002005005En:"As with removing duplicates, explicitly iterating in reverse with a
delete condition is one possibility.  However, it is easier and faster
to use slice replacement with an implicit or explicit forward
iteration. Here are three variations.:

   mylist[:] = filter(keep_function, mylist)
   mylist[:] = (x for x in mylist if keep_condition)
   mylist[:] = [x for x in mylist if keep_condition]

The list comprehension may be fastest."}
{Q002005005Zh:"编程常见问题==>序列（元组/列表）==>如何从列表中删除多个项？"}
{A002005005Zh:"对于删除重复项，一种可能的做法是设置删除条件显式地进行反向迭代。但是更
容易也更快速的做法是进行隐式或显式的正向迭代并使用切片替代。 以下列出
了三种方式。:

   mylist[:] = filter(keep_function, mylist)
   mylist[:] = (x for x in mylist if keep_condition)
   mylist[:] = [x for x in mylist if keep_condition]

列表推导式可能是最快的。"}
{Q002005006En:"Programming FAQ==>Sequences (Tuples/Lists)==>How do you make an array in Python?"}
{A002005006En:"Use a list:

   ["this", 1, "is", "an", "array"]

Lists are equivalent to C or Pascal arrays in their time complexity;
the primary difference is that a Python list can contain objects of
many different types.

The "array" module also provides methods for creating arrays of fixed
types with compact representations, but they are slower to index than
lists.  Also note that the Numeric extensions and others define array-
like structures with various characteristics as well.

To get Lisp-style linked lists, you can emulate cons cells using
tuples:

   lisp_list = ("like",  ("this",  ("example", None) ) )

If mutability is desired, you could use lists instead of tuples.  Here
the analogue of lisp car is "lisp_list[0]" and the analogue of cdr is
"lisp_list[1]".  Only do this if you're sure you really need to,
because it's usually a lot slower than using Python lists."}
{Q002005006Zh:"编程常见问题==>序列（元组/列表）==>如何在Python中创建数组？"}
{A002005006Zh:"使用列表:

   ["this", 1, "is", "an", "array"]

列表在时间复杂度方面相当于C或Pascal数组；主要区别在于，python列表可以
包含许多不同类型的对象。

"array" 模块还提供了创建具有紧凑表示的固定类型的数组的方法，但它的索引
速度比列表慢。还要注意，数字扩展和其他扩展还定义了具有各种特性的类似数
组的结构。

要获取Lisp样式的列表，可以使用元组模拟cons单元：

   lisp_list = ("like",  ("this",  ("example", None) ) )

如果需要可变性，可以使用列表而不是元组。这里模拟lisp car的是
"lisp_list[0]" ，模拟cdr的是 "lisp_list[1]" 。只有在你确定真的需要的时
候才这样做，因为它通常比使用Python列表慢得多。"}
{Q002005007En:"Programming FAQ==>Sequences (Tuples/Lists)==>How do I create a multidimensional list?"}
{A002005007En:"You probably tried to make a multidimensional array like this:

   >>> A = [[None] * 2] * 3

This looks correct if you print it:

   >>> A
   [[None, None], [None, None], [None, None]]

But when you assign a value, it shows up in multiple places:

   >>> A[0][0] = 5
   >>> A
   [[5, None], [5, None], [5, None]]

The reason is that replicating a list with "*" doesn't create copies,
it only creates references to the existing objects.  The "*3" creates
a list containing 3 references to the same list of length two.
Changes to one row will show in all rows, which is almost certainly
not what you want.

The suggested approach is to create a list of the desired length first
and then fill in each element with a newly created list:

   A = [None] * 3
   for i in range(3):
       A[i] = [None] * 2

This generates a list containing 3 different lists of length two.  You
can also use a list comprehension:

   w, h = 2, 3
   A = [[None] * w for i in range(h)]

Or, you can use an extension that provides a matrix datatype; NumPy is
the best known."}
{Q002005007Zh:"编程常见问题==>序列（元组/列表）==>如何创建多维列表？"}
{A002005007Zh:"你可能试图制作一个像这样的多维数组:

   >>> A = [[None] * 2] * 3

如果你打印它，看起来是正确的：

   >>> A
   [[None, None], [None, None], [None, None]]

但是，当你给某一项赋值时，会同时在多个位置显示变化：

   >>> A[0][0] = 5
   >>> A
   [[5, None], [5, None], [5, None]]

其中的原因在于使用 "*" 对列表执行重复操作并不是创建副本，它只是创建现
有对象的引用。 "*3" 创建了对长度为二的同一列表的 3 个引用。 对某一行的
改变会作用于所有行，通常这一定不是你所希望的。

建议的做法是先创建一个所需长度的列表，然后其中的元素再以一个新创建的列
表来填充:

   A = [None] * 3
   for i in range(3):
       A[i] = [None] * 2

这样就生成了一个包含 3 个长度为二的不同列表的列表。 你也可以使用列表推
导式:

   w, h = 2, 3
   A = [[None] * w for i in range(h)]

或者你还可以使用提供矩阵类型的扩展包；其中最著名的是 NumPy。"}
{Q002005008En:"Programming FAQ==>Sequences (Tuples/Lists)==>How do I apply a method to a sequence of objects?"}
{A002005008En:"Use a list comprehension:

   result = [obj.method() for obj in mylist]"}
{Q002005008Zh:"编程常见问题==>序列（元组/列表）==>如何将方法应用于一系列对象？"}
{A002005008Zh:"可以使用列表推导式：

   result = [obj.method() for obj in mylist]"}
{Q002005009En:"Programming FAQ==>Sequences (Tuples/Lists)==>Why does a_tuple[i] += ['item'] raise an exception when the addition works?"}
{A002005009En:"This is because of a combination of the fact that augmented assignment
operators are *assignment* operators, and the difference between
mutable and immutable objects in Python.

This discussion applies in general when augmented assignment operators
are applied to elements of a tuple that point to mutable objects, but
we'll use a "list" and "+=" as our exemplar.

If you wrote:

   >>> a_tuple = (1, 2)
   >>> a_tuple[0] += 1
   Traceback (most recent call last):
      ...
   TypeError: 'tuple' object does not support item assignment

The reason for the exception should be immediately clear: "1" is added
to the object "a_tuple[0]" points to ("1"), producing the result
object, "2", but when we attempt to assign the result of the
computation, "2", to element "0" of the tuple, we get an error because
we can't change what an element of a tuple points to.

Under the covers, what this augmented assignment statement is doing is
approximately this:

   >>> result = a_tuple[0] + 1
   >>> a_tuple[0] = result
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

It is the assignment part of the operation that produces the error,
since a tuple is immutable.

When you write something like:

   >>> a_tuple = (['foo'], 'bar')
   >>> a_tuple[0] += ['item']
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

The exception is a bit more surprising, and even more surprising is
the fact that even though there was an error, the append worked:

   >>> a_tuple[0]
   ['foo', 'item']

To see why this happens, you need to know that (a) if an object
implements an "__iadd__" magic method, it gets called when the "+="
augmented assignment is executed, and its return value is what gets
used in the assignment statement; and (b) for lists, "__iadd__" is
equivalent to calling "extend" on the list and returning the list.
That's why we say that for lists, "+=" is a "shorthand" for
"list.extend":

   >>> a_list = []
   >>> a_list += [1]
   >>> a_list
   [1]

This is equivalent to:

   >>> result = a_list.__iadd__([1])
   >>> a_list = result

The object pointed to by a_list has been mutated, and the pointer to
the mutated object is assigned back to "a_list".  The end result of
the assignment is a no-op, since it is a pointer to the same object
that "a_list" was previously pointing to, but the assignment still
happens.

Thus, in our tuple example what is happening is equivalent to:

   >>> result = a_tuple[0].__iadd__(['item'])
   >>> a_tuple[0] = result
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

The "__iadd__" succeeds, and thus the list is extended, but even
though "result" points to the same object that "a_tuple[0]" already
points to, that final assignment still results in an error, because
tuples are immutable."}
{Q002005009Zh:"编程常见问题==>序列（元组/列表）==>为什么 a_tuple[i] += ['item'] 会在执行加法时引发异常？"}
{A002005009Zh:"这是由两个事实共同导致的结果，一是增强赋值运算符属于 *赋值* 运算符，二
是在 Python 中存在可变和不可变两种不同的对象。

此处的讨论在任何对元组中指向可变对象的元素使用增强赋值运算符的情况都是
普遍成立的，但在此我们只以 "list" 和 "+=" 来举例。

如果你写成这样:

   >>> a_tuple = (1, 2)
   >>> a_tuple[0] += 1
   Traceback (most recent call last):
      ...
   TypeError: 'tuple' object does not support item assignment

发生异常的原因是显而易见的: "1" 会与对象 "a_tuple[0]" 相加，而该对象为
("1")，得到结果对象 "2"，但当我们试图将运算结果 "2" 赋值给元组的 "0"
号元素时就将报错，因为我们不能改变元组的元素所指向的对象。

在表层之处，以上增强赋值语句所做的大致是这样:

   >>> result = a_tuple[0] + 1
   >>> a_tuple[0] = result
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

由于元组是不可变的，因此操作的赋值部分会引发错误。

当你这样写的时候:

   >>> a_tuple = (['foo'], 'bar')
   >>> a_tuple[0] += ['item']
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

发生异常会令人略感吃惊，还有一个更为令人吃惊的事实：虽然有报错，但是添
加操作却生效了:

   >>> a_tuple[0]
   ['foo', 'item']

要明白为何会这样，你需要知道 (a) 如果一个对象实现了 "__iadd__" 魔术方
法，它会在执行 "+=" 增强赋值时被调用，并且其返回值将用于该赋值语句；
(b) 对于列表来说，"__iadd__" 等价于在列表上调用 "extend" 并返回该列表
。 因此对于列表我们可以说 "+=" 就是 "list.extend" 的“快捷方式”:

   >>> a_list = []
   >>> a_list += [1]
   >>> a_list
   [1]

这相当于:

   >>> result = a_list.__iadd__([1])
   >>> a_list = result

a_list 所引用的对象已被修改，而引用被修改对象的指针又重新被赋值给
"a_list"。 赋值的最终结果没有变化，因为它是引用 "a_list" 之前所引用的
同一对象的指针，但仍然发生了赋值操作。

因此，在我们的元组示例中，发生的事情等同于：

   >>> result = a_tuple[0].__iadd__(['item'])
   >>> a_tuple[0] = result
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

"__iadd__" 成功执行，因此列表得到了扩充，但是虽然 "result" 指向了
"a_tuple[0]" 已经指向的同一对象，最后的赋值仍然导致了报错，因为元组是
不可变的。"}
{Q002005010En:"Programming FAQ==>Sequences (Tuples/Lists)==>I want to do a complicated sort: can you do a Schwartzian Transform in Python?"}
{A002005010En:"The technique, attributed to Randal Schwartz of the Perl community,
sorts the elements of a list by a metric which maps each element to
its "sort value". In Python, use the "key" argument for the
"list.sort()" method:

   Isorted = L[:]
   Isorted.sort(key=lambda s: int(s[10:15]))"}
{Q002005010Zh:"编程常见问题==>序列（元组/列表）==>我想做一个复杂的排序：你能用Python做一个Schwartzian变换吗？"}
{A002005010Zh:"该技术归功于Perl社区的 Randal Schwartz，它通过将每个元素映射到其 "排序
值（sort value）" 的度量对列表中的元素进行排序。在Python中，使用
"list.sort()" 方法的 "key" 参数：

   Isorted = L[:]
   Isorted.sort(key=lambda s: int(s[10:15]))"}
{Q002005011En:"Programming FAQ==>Sequences (Tuples/Lists)==>How can I sort one list by values from another list?"}
{A002005011En:"Merge them into an iterator of tuples, sort the resulting list, and
then pick out the element you want.

   >>> list1 = ["what", "I'm", "sorting", "by"]
   >>> list2 = ["something", "else", "to", "sort"]
   >>> pairs = zip(list1, list2)
   >>> pairs = sorted(pairs)
   >>> pairs
   [("I'm", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]
   >>> result = [x[1] for x in pairs]
   >>> result
   ['else', 'sort', 'to', 'something']"}
{Q002005011Zh:"编程常见问题==>序列（元组/列表）==>如何按其他列表中的值对一个列表进行排序？"}
{A002005011Zh:"将它们合并到元组的迭代器中，对结果列表进行排序，然后选择所需的元素。

   >>> list1 = ["what", "I'm", "sorting", "by"]
   >>> list2 = ["something", "else", "to", "sort"]
   >>> pairs = zip(list1, list2)
   >>> pairs = sorted(pairs)
   >>> pairs
   [("I'm", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]
   >>> result = [x[1] for x in pairs]
   >>> result
   ['else', 'sort', 'to', 'something']"}
{Q002006001En:"Programming FAQ==>Objects==>What is a class?"}
{A002006001En:"A class is the particular object type created by executing a class
statement. Class objects are used as templates to create instance
objects, which embody both the data (attributes) and code (methods)
specific to a datatype.

A class can be based on one or more other classes, called its base
class(es). It then inherits the attributes and methods of its base
classes. This allows an object model to be successively refined by
inheritance.  You might have a generic "Mailbox" class that provides
basic accessor methods for a mailbox, and subclasses such as
"MboxMailbox", "MaildirMailbox", "OutlookMailbox" that handle various
specific mailbox formats."}
{Q002006001Zh:"编程常见问题==>对象==>什么是类？"}
{A002006001Zh:""类" 是通过执行类语句创建的特定对象类型。"类对象" 被当作模板来创建实例
对象，实例对象包含了特定于数据类型的数据（属性）和代码（方法）。

类可以基于一个或多个的其他类，称之为基类（ES），它继承基类的属性和方法
，这样就可以通过继承来连续地细化对象模型。例如：您可能有一个 "Mailbox"
类提供邮箱的基本访问方法.，它的子类 "MboxMailbox", "MaildirMailbox",
"OutlookMailbox" 用于处理各种特定邮箱格式。"}
{Q002006002En:"Programming FAQ==>Objects==>What is a method?"}
{A002006002En:"A method is a function on some object "x" that you normally call as
"x.name(arguments...)".  Methods are defined as functions inside the
class definition:

   class C:
       def meth(self, arg):
           return arg * 2 + self.attribute"}
{Q002006002Zh:"编程常见问题==>对象==>什么是方法？"}
{A002006002Zh:""方法" 实际上就是类定义中的函数。对于某个对象 "x" 上的方法，通常称为
"x.name(arguments...)" 。

   class C:
       def meth(self, arg):
           return arg * 2 + self.attribute"}
{Q002006003En:"Programming FAQ==>Objects==>What is self?"}
{A002006003En:"Self is merely a conventional name for the first argument of a method.
A method defined as "meth(self, a, b, c)" should be called as
"x.meth(a, b, c)" for some instance "x" of the class in which the
definition occurs; the called method will think it is called as
"meth(x, a, b, c)".

See also Why must 'self' be used explicitly in method definitions and
calls?."}
{Q002006003Zh:"编程常见问题==>对象==>什么是 self ？"}
{A002006003Zh:"Self 只是 "方法" 的第一个参数的常规名称。例如：对于某个类的某个实例
"x" ，其方法 "meth(self, a, b, c)" 实际上应该被称为 "x.meth(a, b, c)"
；对于被调用的方法会被称为 "meth(x, a, b, c)" 。

另请参阅 为什么必须在方法定义和调用中显式使用“self”？ 。"}
{Q002006004En:"Programming FAQ==>Objects==>How do I check if an object is an instance of a given class or of a subclass of it?"}
{A002006004En:"Use the built-in function "isinstance(obj, cls)".  You can check if an
object is an instance of any of a number of classes by providing a
tuple instead of a single class, e.g. "isinstance(obj, (class1,
class2, ...))", and can also check whether an object is one of
Python's built-in types, e.g. "isinstance(obj, str)" or
"isinstance(obj, (int, float, complex))".

Note that most programs do not use "isinstance()" on user-defined
classes very often.  If you are developing the classes yourself, a
more proper object-oriented style is to define methods on the classes
that encapsulate a particular behaviour, instead of checking the
object's class and doing a different thing based on what class it is.
For example, if you have a function that does something:

   def search(obj):
       if isinstance(obj, Mailbox):
           ...  # code to search a mailbox
       elif isinstance(obj, Document):
           ...  # code to search a document
       elif ...

A better approach is to define a "search()" method on all the classes
and just call it:

   class Mailbox:
       def search(self):
           ...  # code to search a mailbox

   class Document:
       def search(self):
           ...  # code to search a document

   obj.search()"}
{Q002006004Zh:"编程常见问题==>对象==>如何检查对象是否为给定类或其子类的一个实例？"}
{A002006004Zh:"可使用内置函数 "isinstance(obj, cls)"。 你可以提供一个元组而不是单个类
来检查某个对象是否为任意多个类当中某一个类的实例，例如
"isinstance(obj, (class1, class2, ...))"，也可以检查某个对象是否为
Python 内置类型当中某一个类型的对象，例如 "isinstance(obj, str)" 或
"isinstance(obj, (int, float, complex))"。

请注意大多数程序不会经常对用户自定义类使用 "isinstance()"。 如果是你自
已开发的类，更正确的面向对象风格是在类中定义方法来封装特定的行为，而不
是检查对象的类并根据它属于什么类来做不同的事。 例如，如果你有一个执行
某些操作的函数:

   def search(obj):
       if isinstance(obj, Mailbox):
           ...  # code to search a mailbox
       elif isinstance(obj, Document):
           ...  # code to search a document
       elif ...

更好的方法是在所有类上定义一个 "search()" 方法，然后调用它：

   class Mailbox:
       def search(self):
           ...  # code to search a mailbox

   class Document:
       def search(self):
           ...  # code to search a document

   obj.search()"}
{Q002006005En:"Programming FAQ==>Objects==>What is delegation?"}
{A002006005En:"Delegation is an object oriented technique (also called a design
pattern). Let's say you have an object "x" and want to change the
behaviour of just one of its methods.  You can create a new class that
provides a new implementation of the method you're interested in
changing and delegates all other methods to the corresponding method
of "x".

Python programmers can easily implement delegation.  For example, the
following class implements a class that behaves like a file but
converts all written data to uppercase:

   class UpperOut:

       def __init__(self, outfile):
           self._outfile = outfile

       def write(self, s):
           self._outfile.write(s.upper())

       def __getattr__(self, name):
           return getattr(self._outfile, name)

Here the "UpperOut" class redefines the "write()" method to convert
the argument string to uppercase before calling the underlying
"self._outfile.write()" method.  All other methods are delegated to
the underlying "self._outfile" object.  The delegation is accomplished
via the "__getattr__" method; consult the language reference for more
information about controlling attribute access.

Note that for more general cases delegation can get trickier. When
attributes must be set as well as retrieved, the class must define a
"__setattr__()" method too, and it must do so carefully.  The basic
implementation of "__setattr__()" is roughly equivalent to the
following:

   class X:
       ...
       def __setattr__(self, name, value):
           self.__dict__[name] = value
       ...

Most "__setattr__()" implementations must modify "self.__dict__" to
store local state for self without causing an infinite recursion."}
{Q002006005Zh:"编程常见问题==>对象==>什么是委托？"}
{A002006005Zh:"委托是一种面向对象的技巧（也称为设计模式）。 假设您有一个对象 "x" 并且
想要改变其中一个方法的行为。 您可以创建一个新类，它提供您感兴趣的方法
的新实现，并将所有其他方法委托给 "x" 的相应方法。

Python程序员可以轻松实现委托。 例如，以下类实现了一个类，该类的行为类
似于文件，但将所有写入的数据转换为大写：

   class UpperOut:

       def __init__(self, outfile):
           self._outfile = outfile

       def write(self, s):
           self._outfile.write(s.upper())

       def __getattr__(self, name):
           return getattr(self._outfile, name)

在这里 "UpperOut" 类重新定义了 "write()" 方法在调用下层的
"self._outfile.write()" 方法之前将参数字符串转换为大写形式。 所有其他
方法都被委托给下层的 "self._outfile" 对象。 委托是通过 "__getattr__"
方法来完成的；请参阅 语言参考 了解有关控制属性访问的更多信息。

请注意对于更一般的情况来说，委托可能包含更多细节问题。 当某些属性既需
要读取又需要设置时，类还必须定义 "__setattr__()" 方法，并且这样做必须
小心谨慎。 "__setattr__()" 的基本实现大致相当于以下代码:

   class X:
       ...
       def __setattr__(self, name, value):
           self.__dict__[name] = value
       ...

大多数 "__setattr__()" 实现必须修改 "self.__dict__" 来为自身保存局部状
态而又不至于造成无限递归。"}
{Q002006006En:"Programming FAQ==>Objects==>How do I call a method defined in a base class from a derived class that overrides it?"}
{A002006006En:"Use the built-in "super()" function:

   class Derived(Base):
       def meth(self):
           super(Derived, self).meth()

For version prior to 3.0, you may be using classic classes: For a
class definition such as "class Derived(Base): ..." you can call
method "meth()" defined in "Base" (or one of "Base"'s base classes) as
"Base.meth(self, arguments...)".  Here, "Base.meth" is an unbound
method, so you need to provide the "self" argument."}
{Q002006006Zh:"编程常见问题==>对象==>如何从覆盖基类的派生类调用基类中定义的方法?"}
{A002006006Zh:"使用内置的 "super()" 函数：

   class Derived(Base):
       def meth(self):
           super(Derived, self).meth()

对于 Python 3.0之前的版本，您可能正在使用经典类：对于诸如 "class
Derived(Base): ..." 之类的类定义，可以将在 "Base" (或 "Base" 中的一个
的基类）中定义的方法 "meth()" 调用为 "Base.meth(self, arguments...)"
。这里， "Base.meth" 是一个未绑定的方法，因此您需要提供 "self" 参数。"}
{Q002006007En:"Programming FAQ==>Objects==>How can I organize my code to make it easier to change the base class?"}
{A002006007En:"You could assign the base class to an alias and derive from the alias.
Then all you have to change is the value assigned to the alias.
Incidentally, this trick is also handy if you want to decide
dynamically (e.g. depending on availability of resources) which base
class to use.  Example:

   class Base:
       ...

   BaseAlias = Base

   class Derived(BaseAlias):
       ..."}
{Q002006007Zh:"编程常见问题==>对象==>如何组织代码以便更改基类？"}
{A002006007Zh:"你可以为基类赋一个别名并基于该别名进行派生。 这样你需要修改的内容就都
是赋给该别名的值。 顺便提一下，如果你想要动态地决定（例如根据资源的可
用性）应使用哪个基类，这个技巧也非常方便。 例如:

   class Base:
       ...

   BaseAlias = Base

   class Derived(BaseAlias):
       ..."}
{Q002006008En:"Programming FAQ==>Objects==>How do I create static class data and static class methods?"}
{A002006008En:"Both static data and static methods (in the sense of C++ or Java) are
supported in Python.

For static data, simply define a class attribute.  To assign a new
value to the attribute, you have to explicitly use the class name in
the assignment:

   class C:
       count = 0   # number of times C.__init__ called

       def __init__(self):
           C.count = C.count + 1

       def getcount(self):
           return C.count  # or return self.count

"c.count" also refers to "C.count" for any "c" such that
"isinstance(c, C)" holds, unless overridden by "c" itself or by some
class on the base-class search path from "c.__class__" back to "C".

Caution: within a method of C, an assignment like "self.count = 42"
creates a new and unrelated instance named "count" in "self"'s own
dict.  Rebinding of a class-static data name must always specify the
class whether inside a method or not:

   C.count = 314

Static methods are possible:

   class C:
       @staticmethod
       def static(arg1, arg2, arg3):
           # No 'self' parameter!
           ...

However, a far more straightforward way to get the effect of a static
method is via a simple module-level function:

   def getcount():
       return C.count

If your code is structured so as to define one class (or tightly
related class hierarchy) per module, this supplies the desired
encapsulation."}
{Q002006008Zh:"编程常见问题==>对象==>如何创建静态类数据和静态类方法？"}
{A002006008Zh:"Python支持静态数据和静态方法（在C ++或Java的意义上）。

对于静态数据，只需定义一个类属性。要为属性分配新值，就必须在赋值中显式
使用类名：

   class C:
       count = 0   # number of times C.__init__ called

       def __init__(self):
           C.count = C.count + 1

       def getcount(self):
           return C.count  # or return self.count

对于任意 "c" 来说只要 "isinstance(c, C)" 为真，则 "c.count" 同样也指向
"C.count"，除非被 "c" 自身，或者从 "c.__class__" 回到 "C" 的基类搜索路
径上的某个类所重载。

注意：在 C 的某个方法内部，像 "self.count = 42" 这样的赋值将在 "self"
自身的字典中新建一个名为 "count" 的不相关实例。 想要重新绑定类静态数据
名称就必须总是指明类名，无论是在方法内部还是外部:

   C.count = 314

静态方法是可行的：

   class C:
       @staticmethod
       def static(arg1, arg2, arg3):
           # No 'self' parameter!
           ...

然而，获得静态方法效果的更直接的方法是通过一个简单的模块级函数：

   def getcount():
       return C.count

如果您的代码是结构化的，以便为每个模块定义一个类（或紧密相关的类层次结
构），那么这就提供了所需的封装。"}
{Q002006009En:"Programming FAQ==>Objects==>How can I overload constructors (or methods) in Python?"}
{A002006009En:"This answer actually applies to all methods, but the question usually
comes up first in the context of constructors.

In C++ you'd write

   class C {
       C() { cout << "No arguments\n"; }
       C(int i) { cout << "Argument is " << i << "\n"; }
   }

In Python you have to write a single constructor that catches all
cases using default arguments.  For example:

   class C:
       def __init__(self, i=None):
           if i is None:
               print("No arguments")
           else:
               print("Argument is", i)

This is not entirely equivalent, but close enough in practice.

You could also try a variable-length argument list, e.g.

   def __init__(self, *args):
       ...

The same approach works for all method definitions."}
{Q002006009Zh:"编程常见问题==>对象==>如何在Python中重载构造函数（或方法）？"}
{A002006009Zh:"这个答案实际上适用于所有方法，但问题通常首先出现在构造函数的上下文中。

在C ++中，你会这样写

   class C {
       C() { cout << "No arguments\n"; }
       C(int i) { cout << "Argument is " << i << "\n"; }
   }

在Python中，您必须编写一个构造函数，使用默认参数捕获所有情况。例如：

   class C:
       def __init__(self, i=None):
           if i is None:
               print("No arguments")
           else:
               print("Argument is", i)

这不完全等同，但在实践中足够接近。

你也可以尝试一个可变长度的参数列表，例如:

   def __init__(self, *args):
       ...

相同的方法适用于所有方法定义。"}
{Q002006010En:"Programming FAQ==>Objects==>I try to use __spam and I get an error about _SomeClassName__spam."}
{A002006010En:"Variable names with double leading underscores are "mangled" to
provide a simple but effective way to define class private variables.
Any identifier of the form "__spam" (at least two leading underscores,
at most one trailing underscore) is textually replaced with
"_classname__spam", where "classname" is the current class name with
any leading underscores stripped.

This doesn't guarantee privacy: an outside user can still deliberately
access the "_classname__spam" attribute, and private values are
visible in the object's "__dict__".  Many Python programmers never
bother to use private variable names at all."}
{Q002006010Zh:"编程常见问题==>对象==>我尝试使用 __spam ，但是得到一个关于 _SomeClassName__spam 的错误信息。"}
{A002006010Zh:"以双下划线打头的变量会被“更名”以提供一种定义类私有变量的简单而有效的方
式。 任何形式为 "__spam" 的标识符（至少前缀两个下划线，至多后缀一个下
划线）文本会被替换为 "_classname__spam"，其中 "classname" 为去除了全部
前缀下划线的当前类名称。

这并不能保证私密性：外部用户仍然可以访问 "_classname__spam" 属性，私有
变量值也在对象的 "__dict__" 中可见。 许多 Python 程序员从来都不使用这
种私有变量名称。"}
{Q002006011En:"Programming FAQ==>Objects==>My class defines __del__ but it is not called when I delete the object."}
{A002006011En:"There are several possible reasons for this.

The del statement does not necessarily call "__del__()" -- it simply
decrements the object's reference count, and if this reaches zero
"__del__()" is called.

If your data structures contain circular links (e.g. a tree where each
child has a parent reference and each parent has a list of children)
the reference counts will never go back to zero.  Once in a while
Python runs an algorithm to detect such cycles, but the garbage
collector might run some time after the last reference to your data
structure vanishes, so your "__del__()" method may be called at an
inconvenient and random time. This is inconvenient if you're trying to
reproduce a problem. Worse, the order in which object's "__del__()"
methods are executed is arbitrary.  You can run "gc.collect()" to
force a collection, but there *are* pathological cases where objects
will never be collected.

Despite the cycle collector, it's still a good idea to define an
explicit "close()" method on objects to be called whenever you're done
with them.  The "close()" method can then remove attributes that refer
to subobjects.  Don't call "__del__()" directly -- "__del__()" should
call "close()" and "close()" should make sure that it can be called
more than once for the same object.

Another way to avoid cyclical references is to use the "weakref"
module, which allows you to point to objects without incrementing
their reference count. Tree data structures, for instance, should use
weak references for their parent and sibling references (if they need
them!).

Finally, if your "__del__()" method raises an exception, a warning
message is printed to "sys.stderr"."}
{Q002006011Zh:"编程常见问题==>对象==>类定义了 __del__ 方法，但是删除对象时没有调用它。"}
{A002006011Zh:"这有几个可能的原因。

del 语句不一定调用 "__del__()" —— 它只是减少对象的引用计数，如果（引用
计数）达到零，才会调用 "__del__()"。

如果数据结构包含循环链接（例如，每个子级都有一个父级引用，每个父级都有
一个子级列表的树），则引用计数将永远不会返回零。尽管Python 偶尔会运行
一个算法来检测这样的循环，但在数据结构的引用计数清零后，垃圾收集器可能
需要一段时间来运行，因此 "__del__()" 方法可能会在不方便和随机的时间被
调用。这对于重现一个问题，是非常不方便的。更糟糕的是，对象 "__del__()"
的方法执行顺序是任意的。虽然可以运行 "gc.collect()" 来强制回收，但在一
些病态的情况下，对象永远不会被回收。

尽管有循环收集器，但在对象上定义一个显式的 "close()" 方法以便在用完之
后调用它仍然是一个好主意。 这样 "close()" 方法可以随即删除引用子对象的
属性。 不要直接调用 "__del__()" —— 应该由 "__del__()" 调用 "close()"，
并且 "close()" 能确保可以被同一对象多次地调用。

另一种避免循环引用的方法是使用 "weakref" 模块，该模块允许您指向对象而
不增加其引用计数。例如，树状数据结构应该对其父级和同级引用使用弱引用（
如果需要的话！）

最后，如果 "__del__()" 方法引发异常，会将警告消息打印到 "sys.stderr"
。"}
{Q002006012En:"Programming FAQ==>Objects==>How do I get a list of all instances of a given class?"}
{A002006012En:"Python does not keep track of all instances of a class (or of a built-
in type). You can program the class's constructor to keep track of all
instances by keeping a list of weak references to each instance."}
{Q002006012Zh:"编程常见问题==>对象==>如何获取给定类的所有实例的列表？"}
{A002006012Zh:"Python不跟踪类（或内置类型）的所有实例。您可以对类的构造函数进行编程，
以通过保留每个实例的弱引用列表来跟踪所有实例。"}
{Q002006013En:"Programming FAQ==>Objects==>Why does the result of "id()" appear to be not unique?"}
{A002006013En:"The "id()" builtin returns an integer that is guaranteed to be unique
during the lifetime of the object.  Since in CPython, this is the
object's memory address, it happens frequently that after an object is
deleted from memory, the next freshly created object is allocated at
the same position in memory.  This is illustrated by this example:

>>> id(1000) 
13901272
>>> id(2000) 
13901272

The two ids belong to different integer objects that are created
before, and deleted immediately after execution of the "id()" call.
To be sure that objects whose id you want to examine are still alive,
create another reference to the object:

>>> a = 1000; b = 2000
>>> id(a) 
13901272
>>> id(b) 
13891296"}
{Q002006013Zh:"编程常见问题==>对象==>为什么 "id()" 的结果看起来不是唯一的？"}
{A002006013Zh:""id()" 返回一个整数，该整数在对象的生命周期内保证是唯一的。因为在
CPython中，这是对象的内存地址，所以经常发生在从内存中删除对象之后，下
一个新创建的对象被分配在内存中的相同位置。这个例子说明了这一点：

>>> id(1000) 
13901272
>>> id(2000) 
13901272

这两个id属于之前创建的不同整数对象，并在执行 "id()" 调用后立即删除。要
确保要检查其id的对象仍处于活动状态，请创建对该对象的另一个引用：

>>> a = 1000; b = 2000
>>> id(a) 
13901272
>>> id(b) 
13891296"}
{Q002007001En:"Programming FAQ==>Modules==>How do I create a .pyc file?"}
{A002007001En:"When a module is imported for the first time (or when the source file
has changed since the current compiled file was created) a ".pyc" file
containing the compiled code should be created in a "__pycache__"
subdirectory of the directory containing the ".py" file.  The ".pyc"
file will have a filename that starts with the same name as the ".py"
file, and ends with ".pyc", with a middle component that depends on
the particular "python" binary that created it.  (See **PEP 3147** for
details.)

One reason that a ".pyc" file may not be created is a permissions
problem with the directory containing the source file, meaning that
the "__pycache__" subdirectory cannot be created. This can happen, for
example, if you develop as one user but run as another, such as if you
are testing with a web server.

Unless the "PYTHONDONTWRITEBYTECODE" environment variable is set,
creation of a .pyc file is automatic if you're importing a module and
Python has the ability (permissions, free space, etc...) to create a
"__pycache__" subdirectory and write the compiled module to that
subdirectory.

Running Python on a top level script is not considered an import and
no ".pyc" will be created.  For example, if you have a top-level
module "foo.py" that imports another module "xyz.py", when you run
"foo" (by typing "python foo.py" as a shell command), a ".pyc" will be
created for "xyz" because "xyz" is imported, but no ".pyc" file will
be created for "foo" since "foo.py" isn't being imported.

If you need to create a ".pyc" file for "foo" -- that is, to create a
".pyc" file for a module that is not imported -- you can, using the
"py_compile" and "compileall" modules.

The "py_compile" module can manually compile any module.  One way is
to use the "compile()" function in that module interactively:

   >>> import py_compile
   >>> py_compile.compile('foo.py')                 

This will write the ".pyc" to a "__pycache__" subdirectory in the same
location as "foo.py" (or you can override that with the optional
parameter "cfile").

You can also automatically compile all files in a directory or
directories using the "compileall" module.  You can do it from the
shell prompt by running "compileall.py" and providing the path of a
directory containing Python files to compile:

   python -m compileall ."}
{Q002007001Zh:"编程常见问题==>模块==>如何创建 .pyc 文件？"}
{A002007001Zh:"当一个模块首次被导入时（或自当前已编译文件创建后源文件被修改时），将会
在对应 ".py" 文件所在目录的 "__pycache__" 子目录下创建一个包含已编译代
码的 ".pyc" 文件。 该 ".pyc" 文件的文件名的开头部分将与对应 ".py" 文件
名相同，并以 ".pyc" 为后缀，中间部门则是基于创建它的特定 "python" 二进
制代码版本。 （详情参见 **PEP 3147**。）

无法创建 ".pyc" 文件的可能原因是包含源文件的目录存在权限问题，这意味着
"__pycache__" 子目录无法被创建。 举例来说，如果你以某一用户来开发程序
但以另一用户身份来运行程序时就可能发生问题，测试 Web 服务器就属于这种
情况。

除非设置了 "PYTHONDONTWRITEBYTECODE" 环境变量，否则当你导入模块并且
Python 具有创建 "__pycache__" 子目录并将已编译模块写入该子目录的能力（
权限、存储空间等等）时就会自动创建 .pyc 文件。

在最高层级运行的 Python 脚本不被视为导入，因此不会创建 ".pyc" 文件。
例如，如果你有一个最高层级模块文件 "foo.py"，它又导入了另一个模块
"xyz.py"，当你运行 "foo" 模块 (通过输入终端命令 "python foo.py")，则将
为 "xyz" 创建一个 ".pyc"，因为 "xyz" 是被导入的，但不会为 "foo" 创建
".pyc" 文件，因为 "foo.py" 不是被导入的。

如果你需要为 "foo" 创建 ".pyc" 文件 —— 即为不是被导入的模块创建 ".pyc"
文件 —— 你可以使用 "py_compile" 和 "compileall" 模块。

"py_compile" 模块能够手动编译任意模块。 一种做法是交互式地使用该模块中
的 "compile()" 函数:

   >>> import py_compile
   >>> py_compile.compile('foo.py')                 

这将会将  ".pyc" 文件写入与 "foo.py" 相同位置下的 "__pycache__" 子目录
（或者你也可以通过可选参数 "cfile" 来重载该行为）。

你还可以使用 "compileall" 模块自动编译一个目录或多个目录下的所有文件。
具体做法可以是在命令行提示符中运行 "compileall.py" 并提供包含要编译
Python 文件的目录路径:

   python -m compileall ."}
{Q002007002En:"Programming FAQ==>Modules==>How do I find the current module name?"}
{A002007002En:"A module can find out its own module name by looking at the predefined
global variable "__name__".  If this has the value "'__main__'", the
program is running as a script.  Many modules that are usually used by
importing them also provide a command-line interface or a self-test,
and only execute this code after checking "__name__":

   def main():
       print('Running test...')
       ...

   if __name__ == '__main__':
       main()"}
{Q002007002Zh:"编程常见问题==>模块==>如何找到当前模块名称？"}
{A002007002Zh:"模块可以通过查看预定义的全局变量 "__name__" 找到自己的模块名称。如果它
的值为 "'__main__'" ，程序将作为脚本运行。通常，通过导入使用的许多模块
也提供命令行界面或自检，并且只在检查 "__name__" 之后，才执行之后的代码
:

   def main():
       print('Running test...')
       ...

   if __name__ == '__main__':
       main()"}
{Q002007003En:"Programming FAQ==>Modules==>How can I have modules that mutually import each other?"}
{A002007003En:"Suppose you have the following modules:

foo.py:

   from bar import bar_var
   foo_var = 1

bar.py:

   from foo import foo_var
   bar_var = 2

The problem is that the interpreter will perform the following steps:

* main imports foo

* Empty globals for foo are created

* foo is compiled and starts executing

* foo imports bar

* Empty globals for bar are created

* bar is compiled and starts executing

* bar imports foo (which is a no-op since there already is a module
  named foo)

* bar.foo_var = foo.foo_var

The last step fails, because Python isn't done with interpreting "foo"
yet and the global symbol dictionary for "foo" is still empty.

The same thing happens when you use "import foo", and then try to
access "foo.foo_var" in global code.

There are (at least) three possible workarounds for this problem.

Guido van Rossum recommends avoiding all uses of "from <module> import
...", and placing all code inside functions.  Initializations of
global variables and class variables should use constants or built-in
functions only.  This means everything from an imported module is
referenced as "<module>.<name>".

Jim Roskind suggests performing steps in the following order in each
module:

* exports (globals, functions, and classes that don't need imported
  base classes)

* "import" statements

* active code (including globals that are initialized from imported
  values).

van Rossum doesn't like this approach much because the imports appear
in a strange place, but it does work.

Matthias Urlichs recommends restructuring your code so that the
recursive import is not necessary in the first place.

These solutions are not mutually exclusive."}
{Q002007003Zh:"编程常见问题==>模块==>如何让模块相互导入？"}
{A002007003Zh:"假设您有以下模块：

foo.py:

   from bar import bar_var
   foo_var = 1

bar.py:

   from foo import foo_var
   bar_var = 2

问题是解释器将执行以下步骤：

* 首先导入foo

* 创建用于foo的空全局变量

* foo被编译并开始执行

* foo 导入 bar

* 创建了用于bar 的空全局变量

* bar被编译并开始执行

* bar导入foo（这是一个空操作（no-op ），因为已经有一个名为foo的模块）

* bar.foo_var = foo.foo_var

最后一步失败了，因为Python还没有解释foo，而foo的全局符号字典仍然是空的
。

当你使用 "import foo" ，然后尝试在全局代码中访问 "foo.foo_var" 时，会
发生同样的事情。

这个问题有（至少）三种可能的解决方法。

Guido van Rossum 建议避免使用 "from <module> import ..." ，并将所有代
码放在函数中。全局变量和类变量的初始化只能使用常量或内置函数。这意味着
导入模块中的所有内容都被引用为 "<module>.<name>" 。

Jim Roskind建议在每个模块中按以下顺序执行步骤：

* 导出（全局变量，函数和不需要导入基类的类）

* "导入" 声明

* 活动代码（包括从导入值初始化的全局变量）。

van Rossum不喜欢这种方法，因为导入出现在一个陌生的地方，但这种方法确实
有效。

Matthias Urlichs建议重构代码，以便首先不需要递归导入。

这些解决方案并不相互排斥。"}
{Q002007004En:"Programming FAQ==>Modules==>__import__('x.y.z') returns <module 'x'>; how do I get z?"}
{A002007004En:"Consider using the convenience function "import_module()" from
"importlib" instead:

   z = importlib.import_module('x.y.z')"}
{Q002007004Zh:"编程常见问题==>模块==>__import__('x.y.z') 返回 <module 'x'>; 如何获取z?"}
{A002007004Zh:"考虑使用 "importlib" 中的函数 "import_module()" ：

   z = importlib.import_module('x.y.z')"}
{Q002007005En:"Programming FAQ==>Modules==>When I edit an imported module and reimport it, the changes don't show up.  Why does this happen?"}
{A002007005En:"For reasons of efficiency as well as consistency, Python only reads
the module file on the first time a module is imported.  If it didn't,
in a program consisting of many modules where each one imports the
same basic module, the basic module would be parsed and re-parsed many
times.  To force re-reading of a changed module, do this:

   import importlib
   import modname
   importlib.reload(modname)

Warning: this technique is not 100% fool-proof.  In particular,
modules containing statements like

   from modname import some_objects

will continue to work with the old version of the imported objects.
If the module contains class definitions, existing class instances
will *not* be updated to use the new class definition.  This can
result in the following paradoxical behaviour:

   >>> import importlib
   >>> import cls
   >>> c = cls.C()                # Create an instance of C
   >>> importlib.reload(cls)
   <module 'cls' from 'cls.py'>
   >>> isinstance(c, cls.C)       # isinstance is false?!?
   False

The nature of the problem is made clear if you print out the
"identity" of the class objects:

   >>> hex(id(c.__class__))
   '0x7352a0'
   >>> hex(id(cls.C))
   '0x4198d0'"}
{Q002007005Zh:"编程常见问题==>模块==>当我编辑了导入过的模块并重新导入它时，这些变化没有显示出来。为什么会这样？"}
{A002007005Zh:"出于效率和一致性的原因，Python仅在第一次导入模块时读取模块文件。如果不
这么做，在一个由许多模块组成的程序中，每个模块都会导入相同的基本模块，
那么基本模块将被解析和重新解析多次。要强制重新读取已更改的模块，请执行
以下操作:

   import importlib
   import modname
   importlib.reload(modname)

警告：这种技术不是100％万无一失。特别是包含如下语句的模块

   from modname import some_objects

将继续使用旧版本的导入对象。如果模块包含类定义，则不会更新现有的类实例
以使用新的类定义。这可能导致以下矛盾行为:

   >>> import importlib
   >>> import cls
   >>> c = cls.C()                # Create an instance of C
   >>> importlib.reload(cls)
   <module 'cls' from 'cls.py'>
   >>> isinstance(c, cls.C)       # isinstance is false?!?
   False

如果打印出类对象的“标识”，问题的本质就会明确：

   >>> hex(id(c.__class__))
   '0x7352a0'
   >>> hex(id(cls.C))
   '0x4198d0'"}
{Q003001En:"Design and History FAQ==>Why does Python use indentation for grouping of statements?"}
{A003001En:"Guido van Rossum believes that using indentation for grouping is
extremely elegant and contributes a lot to the clarity of the average
Python program. Most people learn to love this feature after a while.

Since there are no begin/end brackets there cannot be a disagreement
between grouping perceived by the parser and the human reader.
Occasionally C programmers will encounter a fragment of code like
this:

   if (x <= y)
           x++;
           y--;
   z++;

Only the "x++" statement is executed if the condition is true, but the
indentation leads many to believe otherwise.  Even experienced C
programmers will sometimes stare at it a long time wondering as to why
"y" is being decremented even for "x > y".

Because there are no begin/end brackets, Python is much less prone to
coding-style conflicts.  In C there are many different ways to place
the braces. After becoming used to reading and writing code using a
particular style, it is normal to feel somewhat uneasy when reading
(or being required to write) in a different one.

Many coding styles place begin/end brackets on a line by themselves.
This makes programs considerably longer and wastes valuable screen
space, making it harder to get a good overview of a program.  Ideally,
a function should fit on one screen (say, 20--30 lines).  20 lines of
Python can do a lot more work than 20 lines of C.  This is not solely
due to the lack of begin/end brackets -- the lack of declarations and
the high-level data types are also responsible -- but the indentation-
based syntax certainly helps."}
{Q003001Zh:"设计和历史常见问题==>为什么Python使用缩进来分组语句？"}
{A003001Zh:"Guido van Rossum 认为使用缩进进行分组非常优雅，并且大大提高了普通
Python程序的清晰度。大多数人在一段时间后就学会并喜欢上这个功能。

由于没有开始/结束括号，因此解析器感知的分组与人类读者之间不会存在分歧
。偶尔C程序员会遇到像这样的代码片段:

   if (x <= y)
           x++;
           y--;
   z++;

如果条件为真，则只执行 "x++" 语句，但缩进会使你认为情况并非如此。 即使
是经验丰富的 C 程序员有时也会长久地盯着它发呆，不明白为什么在 "x > y``
时 ``y" 也会减少。

因为没有开始/结束花括号，所以 Python 更不容易发生编码风格冲突。 在 C
中有许多不同的放置花括号的方式。 在习惯了阅读和编写某种特定风格的代码
之后，当阅读（或被要求编写）另一种风格的代码时通常都会令人感觉有点不舒
服）。

许多编码风格将开始/结束括号单独放在一行上。这使得程序相当长，浪费了宝
贵的屏幕空间，使得更难以对程序进行全面的了解。理想情况下，函数应该适合
一个屏幕（例如，20--30行）。 20行Python可以完成比20行C更多的工作。这不
仅仅是由于缺少开始/结束括号 -- 缺少声明和高级数据类型也是其中的原因
-- 但缩进基于语法肯定有帮助。"}
{Q003002En:"Design and History FAQ==>Why am I getting strange results with simple arithmetic operations?"}
{A003002En:"See the next question."}
{Q003002Zh:"设计和历史常见问题==>为什么简单的算术运算得到奇怪的结果？"}
{A003002Zh:"请看下一个问题。"}
{Q003003En:"Design and History FAQ==>Why are floating-point calculations so inaccurate?"}
{A003003En:"Users are often surprised by results like this:

   >>> 1.2 - 1.0
   0.19999999999999996

and think it is a bug in Python.  It's not.  This has little to do
with Python, and much more to do with how the underlying platform
handles floating-point numbers.

The "float" type in CPython uses a C "double" for storage.  A "float"
object's value is stored in binary floating-point with a fixed
precision (typically 53 bits) and Python uses C operations, which in
turn rely on the hardware implementation in the processor, to perform
floating-point operations. This means that as far as floating-point
operations are concerned, Python behaves like many popular languages
including C and Java.

Many numbers that can be written easily in decimal notation cannot be
expressed exactly in binary floating-point.  For example, after:

   >>> x = 1.2

the value stored for "x" is a (very good) approximation to the decimal
value "1.2", but is not exactly equal to it.  On a typical machine,
the actual stored value is:

   1.0011001100110011001100110011001100110011001100110011 (binary)

which is exactly:

   1.1999999999999999555910790149937383830547332763671875 (decimal)

The typical precision of 53 bits provides Python floats with 15--16
decimal digits of accuracy.

For a fuller explanation, please see the floating point arithmetic
chapter in the Python tutorial."}
{Q003003Zh:"设计和历史常见问题==>为什么浮点计算不准确？"}
{A003003Zh:"用户经常对这样的结果感到惊讶:

   >>> 1.2 - 1.0
   0.19999999999999996

并且认为这是 Python中的一个 bug。其实不是这样。这与 Python 关系不大，
而与底层平台如何处理浮点数字关系更大。

CPython 中的 "float" 类型使用C语言的 "double" 类型进行存储。 "float"
对象的值是以固定的精度（通常为 53 位）存储的二进制浮点数，由于 Python
使用 C 操作，而后者依赖于处理器中的硬件实现来执行浮点运算。 这意味着就
浮点运算而言，Python 的行为类似于许多流行的语言，包括 C 和 Java。

许多可以轻松地用十进制表示的数字不能用二进制浮点表示。例如，在输入以下
语句后:

   >>> x = 1.2

为 "x" 存储的值是与十进制的值 "1.2" (非常接近) 的近似值，但不完全等于
它。 在典型的机器上，实际存储的值是：

   1.0011001100110011001100110011001100110011001100110011 (binary)

它对应于十进制数值:

   1.1999999999999999555910790149937383830547332763671875 (decimal)

典型的 53 位精度为 Python 浮点数提供了 15-16 位小数的精度。

要获得更完整的解释，请参阅 Python 教程中的 浮点算术  一章。"}
{Q003004En:"Design and History FAQ==>Why are Python strings immutable?"}
{A003004En:"There are several advantages.

One is performance: knowing that a string is immutable means we can
allocate space for it at creation time, and the storage requirements
are fixed and unchanging.  This is also one of the reasons for the
distinction between tuples and lists.

Another advantage is that strings in Python are considered as
"elemental" as numbers.  No amount of activity will change the value 8
to anything else, and in Python, no amount of activity will change the
string "eight" to anything else."}
{Q003004Zh:"设计和历史常见问题==>为什么Python字符串是不可变的？"}
{A003004Zh:"有几个优点。

一个是性能：知道字符串是不可变的，意味着我们可以在创建时为它分配空间，
并且存储需求是固定不变的。这也是元组和列表之间区别的原因之一。

另一个优点是，Python 中的字符串被视为与数字一样“基本”。 任何动作都不会
将值 8 更改为其他值，在 Python 中，任何动作都不会将字符串 "8" 更改为其
他值。"}
{Q003005En:"Design and History FAQ==>Why must 'self' be used explicitly in method definitions and calls?"}
{A003005En:"The idea was borrowed from Modula-3.  It turns out to be very useful,
for a variety of reasons.

First, it's more obvious that you are using a method or instance
attribute instead of a local variable.  Reading "self.x" or
"self.meth()" makes it absolutely clear that an instance variable or
method is used even if you don't know the class definition by heart.
In C++, you can sort of tell by the lack of a local variable
declaration (assuming globals are rare or easily recognizable) -- but
in Python, there are no local variable declarations, so you'd have to
look up the class definition to be sure.  Some C++ and Java coding
standards call for instance attributes to have an "m_" prefix, so this
explicitness is still useful in those languages, too.

Second, it means that no special syntax is necessary if you want to
explicitly reference or call the method from a particular class.  In
C++, if you want to use a method from a base class which is overridden
in a derived class, you have to use the "::" operator -- in Python you
can write "baseclass.methodname(self, <argument list>)".  This is
particularly useful for "__init__()" methods, and in general in cases
where a derived class method wants to extend the base class method of
the same name and thus has to call the base class method somehow.

Finally, for instance variables it solves a syntactic problem with
assignment: since local variables in Python are (by definition!) those
variables to which a value is assigned in a function body (and that
aren't explicitly declared global), there has to be some way to tell
the interpreter that an assignment was meant to assign to an instance
variable instead of to a local variable, and it should preferably be
syntactic (for efficiency reasons).  C++ does this through
declarations, but Python doesn't have declarations and it would be a
pity having to introduce them just for this purpose.  Using the
explicit "self.var" solves this nicely.  Similarly, for using instance
variables, having to write "self.var" means that references to
unqualified names inside a method don't have to search the instance's
directories.  To put it another way, local variables and instance
variables live in two different namespaces, and you need to tell
Python which namespace to use."}
{Q003005Zh:"设计和历史常见问题==>为什么必须在方法定义和调用中显式使用“self”？"}
{A003005Zh:"这个想法借鉴了 Modula-3 语言。 出于多种原因它被证明是非常有用的。

首先，更明显的显示出，使用的是方法或实例属性而不是局部变量。 阅读
"self.x" 或 "self.meth()" 可以清楚地表明，即使您不知道类的定义，也会使
用实例变量或方法。在 C++ 中，可以通过缺少局部变量声明来判断（假设全局
变量很少见或容易识别） —— 但是在 Python 中没有局部变量声明，所以必须查
找类定义才能确定。 一些 C++ 和 Java 编码标准要求实例属性具有 "m_" 前缀
，因此这种显式性在这些语言中仍然有用。

其次，这意味着如果要显式引用或从特定类调用该方法，不需要特殊语法。 在
C++ 中，如果你想使用在派生类中重写基类中的方法，你必须使用 "::" 运算符
-- 在 Python 中你可以编写 "baseclass.methodname(self, <argument
list>)"。 这对于 "__init__()" 方法非常有用，特别是在派生类方法想要扩展
同名的基类方法，而必须以某种方式调用基类方法时。

最后，它解决了变量赋值的语法问题：为了 Python 中的局部变量（根据定义！
）在函数体中赋值的那些变量（并且没有明确声明为全局）赋值，就必须以某种
方式告诉解释器一个赋值是为了分配一个实例变量而不是一个局部变量，它最好
是通过语法实现的（出于效率原因）。 C++ 通过声明来做到这一点，但是
Python 没有声明，仅仅为了这个目的而引入它们会很可惜。 使用显式的
"self.var" 很好地解决了这个问题。 类似地，对于使用实例变量，必须编写
"self.var" 意味着对方法内部的非限定名称的引用不必搜索实例的目录。 换句
话说，局部变量和实例变量存在于两个不同的命名空间中，您需要告诉 Python
使用哪个命名空间。"}
{Q003006En:"Design and History FAQ==>Why can't I use an assignment in an expression?"}
{A003006En:"Starting in Python 3.8, you can!

Assignment expressions using the walrus operator *:=* assign a
variable in an expression:

   while chunk := fp.read(200):
      print(chunk)

See **PEP 572** for more information."}
{Q003006Zh:"设计和历史常见问题==>为什么不能在表达式中赋值？"}
{A003006Zh:"自 Python 3.8 开始，你能做到的！

赋值表达式使用海象运算符 *:=* 在表达式中为变量赋值:

   while chunk := fp.read(200):
      print(chunk)

请参阅 **PEP 572** 了解详情。"}
{Q003007En:"Design and History FAQ==>Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?"}
{A003007En:"As Guido said:

   (a) For some operations, prefix notation just reads better than
   postfix -- prefix (and infix!) operations have a long tradition in
   mathematics which likes notations where the visuals help the
   mathematician thinking about a problem. Compare the easy with which
   we rewrite a formula like x*(a+b) into x*a + x*b to the clumsiness
   of doing the same thing using a raw OO notation.

   (b) When I read code that says len(x) I *know* that it is asking
   for the length of something. This tells me two things: the result
   is an integer, and the argument is some kind of container. To the
   contrary, when I read x.len(), I have to already know that x is
   some kind of container implementing an interface or inheriting from
   a class that has a standard len(). Witness the confusion we
   occasionally have when a class that is not implementing a mapping
   has a get() or keys() method, or something that isn't a file has a
   write() method.

   -- https://mail.python.org/pipermail/python-3000/2006-November/004
   643.html"}
{Q003007Zh:"设计和历史常见问题==>为什么Python对某些功能（例如list.index()）使用方法来实现，而其他功能（例如len(List)）使用函数实现？"}
{A003007Zh:"正如Guido所说：

   (a) 对于某些操作，前缀表示法比后缀更容易阅读 -- 前缀（和中缀！）运
   算在数学中有着悠久的传统，就像在视觉上帮助数学家思考问题的记法。比
   较一下我们将 x*(a+b) 这样的公式改写为 x*a+x*b 的容易程度，以及使用
   原始OO符号做相同事情的笨拙程度。

   (b)  当读到写有len(X)的代码时，就知道它要求的是某件东西的长度。这告
   诉我们两件事：结果是一个整数，参数是某种容器。相反，当阅读x.len()时
   ，必须已经知道x是某种实现接口的容器，或者是从具有标准len()的类继承
   的容器。当没有实现映射的类有get()或key()方法，或者不是文件的类有
   write()方法时，我们偶尔会感到困惑。

   -- https://mail.python.org/pipermail/python-3000/2006-November/004
   643.html"}
{Q003008En:"Design and History FAQ==>Why is join() a string method instead of a list or tuple method?"}
{A003008En:"Strings became much more like other standard types starting in Python
1.6, when methods were added which give the same functionality that
has always been available using the functions of the string module.
Most of these new methods have been widely accepted, but the one which
appears to make some programmers feel uncomfortable is:

   ", ".join(['1', '2', '4', '8', '16'])

which gives the result:

   "1, 2, 4, 8, 16"

There are two common arguments against this usage.

The first runs along the lines of: "It looks really ugly using a
method of a string literal (string constant)", to which the answer is
that it might, but a string literal is just a fixed value. If the
methods are to be allowed on names bound to strings there is no
logical reason to make them unavailable on literals.

The second objection is typically cast as: "I am really telling a
sequence to join its members together with a string constant".  Sadly,
you aren't.  For some reason there seems to be much less difficulty
with having "split()" as a string method, since in that case it is
easy to see that

   "1, 2, 4, 8, 16".split(", ")

is an instruction to a string literal to return the substrings
delimited by the given separator (or, by default, arbitrary runs of
white space).

"join()" is a string method because in using it you are telling the
separator string to iterate over a sequence of strings and insert
itself between adjacent elements.  This method can be used with any
argument which obeys the rules for sequence objects, including any new
classes you might define yourself. Similar methods exist for bytes and
bytearray objects."}
{Q003008Zh:"设计和历史常见问题==>为什么 join()是一个字符串方法而不是列表或元组方法？"}
{A003008Zh:"从Python 1.6开始，字符串变得更像其他标准类型，当添加方法时，这些方法提
供的功能与始终使用String模块的函数时提供的功能相同。这些新方法中的大多
数已被广泛接受，但似乎让一些程序员感到不舒服的一种方法是：

   ", ".join(['1', '2', '4', '8', '16'])

结果如下:

   "1, 2, 4, 8, 16"

反对这种用法有两个常见的论点。

第一条是这样的：“使用字符串文本(String Constant)的方法看起来真的很难看
”，答案是也许吧，但是字符串文本只是一个固定值。如果在绑定到字符串的名
称上允许使用这些方法，则没有逻辑上的理由使其在文字上不可用。

第二个异议通常是这样的：“我实际上是在告诉序列使用字符串常量将其成员连
接在一起”。遗憾的是并非如此。出于某种原因，把 "split()" 作为一个字符串
方法似乎要容易得多，因为在这种情况下，很容易看到:

   "1, 2, 4, 8, 16".split(", ")

是对字符串文本的指令，用于返回由给定分隔符分隔的子字符串（或在默认情况
下，返回任意空格）。

"join()" 是字符串方法，因为在使用该方法时，您告诉分隔符字符串去迭代一
个字符串序列，并在相邻元素之间插入自身。此方法的参数可以是任何遵循序列
规则的对象，包括您自己定义的任何新的类。对于字节和字节数组对象也有类似
的方法。"}
{Q003009En:"Design and History FAQ==>How fast are exceptions?"}
{A003009En:"A try/except block is extremely efficient if no exceptions are raised.
Actually catching an exception is expensive.  In versions of Python
prior to 2.0 it was common to use this idiom:

   try:
       value = mydict[key]
   except KeyError:
       mydict[key] = getvalue(key)
       value = mydict[key]

This only made sense when you expected the dict to have the key almost
all the time.  If that wasn't the case, you coded it like this:

   if key in mydict:
       value = mydict[key]
   else:
       value = mydict[key] = getvalue(key)

For this specific case, you could also use "value =
dict.setdefault(key, getvalue(key))", but only if the "getvalue()"
call is cheap enough because it is evaluated in all cases."}
{Q003009Zh:"设计和历史常见问题==>异常有多快？"}
{A003009Zh:"如果没有引发异常，则try/except块的效率极高。实际上捕获异常是昂贵的。在
2.0之前的Python版本中，通常使用这个习惯用法:

   try:
       value = mydict[key]
   except KeyError:
       mydict[key] = getvalue(key)
       value = mydict[key]

只有当你期望dict在任何时候都有key时，这才有意义。如果不是这样的话，你
就是应该这样编码：

   if key in mydict:
       value = mydict[key]
   else:
       value = mydict[key] = getvalue(key)

对于这种特定的情况，您还可以使用 "value = dict.setdefault(key,
getvalue(key))"，但前提是调用 "getvalue()" 足够便宜，因为在所有情况下
都会对其进行评估。"}
{Q003010En:"Design and History FAQ==>Why isn't there a switch or case statement in Python?"}
{A003010En:"You can do this easily enough with a sequence of "if... elif...
elif... else". There have been some proposals for switch statement
syntax, but there is no consensus (yet) on whether and how to do range
tests.  See **PEP 275** for complete details and the current status.

For cases where you need to choose from a very large number of
possibilities, you can create a dictionary mapping case values to
functions to call.  For example:

   def function_1(...):
       ...

   functions = {'a': function_1,
                'b': function_2,
                'c': self.method_1, ...}

   func = functions[value]
   func()

For calling methods on objects, you can simplify yet further by using
the "getattr()" built-in to retrieve methods with a particular name:

   def visit_a(self, ...):
       ...
   ...

   def dispatch(self, value):
       method_name = 'visit_' + str(value)
       method = getattr(self, method_name)
       method()

It's suggested that you use a prefix for the method names, such as
"visit_" in this example.  Without such a prefix, if values are coming
from an untrusted source, an attacker would be able to call any method
on your object."}
{Q003010Zh:"设计和历史常见问题==>为什么Python中没有switch或case语句？"}
{A003010Zh:"你可以通过一系列 "if... elif... elif... else".轻松完成这项工作。对于
switch语句语法已经有了一些建议，但尚未就是否以及如何进行范围测试达成共
识。有关完整的详细信息和当前状态，请参阅 **PEP 275** 。

对于需要从大量可能性中进行选择的情况，可以创建一个字典，将case 值映射
到要调用的函数。例如：

   def function_1(...):
       ...

   functions = {'a': function_1,
                'b': function_2,
                'c': self.method_1, ...}

   func = functions[value]
   func()

对于对象调用方法，可以通过使用 "getattr()" 内置检索具有特定名称的方法
来进一步简化：

   def visit_a(self, ...):
       ...
   ...

   def dispatch(self, value):
       method_name = 'visit_' + str(value)
       method = getattr(self, method_name)
       method()

建议对方法名使用前缀，例如本例中的 "visit_" 。如果没有这样的前缀，如果
值来自不受信任的源，攻击者将能够调用对象上的任何方法。"}
{Q003011En:"Design and History FAQ==>Can't you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?"}
{A003011En:"Answer 1: Unfortunately, the interpreter pushes at least one C stack
frame for each Python stack frame.  Also, extensions can call back
into Python at almost random moments.  Therefore, a complete threads
implementation requires thread support for C.

Answer 2: Fortunately, there is Stackless Python, which has a
completely redesigned interpreter loop that avoids the C stack."}
{Q003011Zh:"设计和历史常见问题==>难道不能在解释器中模拟线程，而非得依赖特定于操作系统的线程实现吗？"}
{A003011Zh:"答案1： 不幸的是，解释器为每个Python堆栈帧推送至少一个C堆栈帧。此外，
扩展可以随时回调Python。因此，一个完整的线程实现需要对C的线程支持。

答案2： 幸运的是， Stackless Python 有一个完全重新设计的解释器循环，可
以避免C堆栈。"}
{Q003012En:"Design and History FAQ==>Why can't lambda expressions contain statements?"}
{A003012En:"Python lambda expressions cannot contain statements because Python's
syntactic framework can't handle statements nested inside expressions.
However, in Python, this is not a serious problem.  Unlike lambda
forms in other languages, where they add functionality, Python lambdas
are only a shorthand notation if you're too lazy to define a function.

Functions are already first class objects in Python, and can be
declared in a local scope.  Therefore the only advantage of using a
lambda instead of a locally-defined function is that you don't need to
invent a name for the function -- but that's just a local variable to
which the function object (which is exactly the same type of object
that a lambda expression yields) is assigned!"}
{Q003012Zh:"设计和历史常见问题==>为什么lambda表达式不能包含语句？"}
{A003012Zh:"Python的 lambda表达式不能包含语句，因为Python的语法框架不能处理嵌套在
表达式内部的语句。然而，在Python中，这并不是一个严重的问题。与其他语言
中添加功能的lambda表单不同，Python的 lambdas只是一种速记符号，如果您懒
得定义函数的话。

函数已经是Python中的第一类对象，可以在本地范围内声明。 因此，使用
lambda而不是本地定义的函数的唯一优点是你不需要为函数创建一个名称 -- 这
只是一个分配了函数对象(与lambda表达式生成的对象类型完全相同)的局部变量
！"}
{Q003013En:"Design and History FAQ==>Can Python be compiled to machine code, C or some other language?"}
{A003013En:"Cython compiles a modified version of Python with optional annotations
into C extensions.  Nuitka is an up-and-coming compiler of Python into
C++ code, aiming to support the full Python language. For compiling to
Java you can consider VOC."}
{Q003013Zh:"设计和历史常见问题==>可以将Python编译为机器代码，C或其他语言吗？"}
{A003013Zh:"Cython 将带有可选注释的Python修改版本编译到C扩展中。 Nuitka 是一个将
Python编译成 C++ 代码的新兴编译器，旨在支持完整的Python语言。要编译成
Java，可以考虑 VOC 。"}
{Q003014En:"Design and History FAQ==>How does Python manage memory?"}
{A003014En:"The details of Python memory management depend on the implementation.
The standard implementation of Python, *CPython*, uses reference
counting to detect inaccessible objects, and another mechanism to
collect reference cycles, periodically executing a cycle detection
algorithm which looks for inaccessible cycles and deletes the objects
involved. The "gc" module provides functions to perform a garbage
collection, obtain debugging statistics, and tune the collector's
parameters.

Other implementations (such as Jython or PyPy), however, can rely on a
different mechanism such as a full-blown garbage collector.  This
difference can cause some subtle porting problems if your Python code
depends on the behavior of the reference counting implementation.

In some Python implementations, the following code (which is fine in
CPython) will probably run out of file descriptors:

   for file in very_long_list_of_files:
       f = open(file)
       c = f.read(1)

Indeed, using CPython's reference counting and destructor scheme, each
new assignment to *f* closes the previous file.  With a traditional
GC, however, those file objects will only get collected (and closed)
at varying and possibly long intervals.

If you want to write code that will work with any Python
implementation, you should explicitly close the file or use the "with"
statement; this will work regardless of memory management scheme:

   for file in very_long_list_of_files:
       with open(file) as f:
           c = f.read(1)"}
{Q003014Zh:"设计和历史常见问题==>Python如何管理内存？"}
{A003014Zh:"Python 内存管理的细节取决于实现。 Python 的标准实现 *CPython* 使用引用
计数来检测不可访问的对象，并使用另一种机制来收集引用循环，定期执行循环
检测算法来查找不可访问的循环并删除所涉及的对象。 "gc" 模块提供了执行垃
圾回收、获取调试统计信息和优化收集器参数的函数。

但是，其他实现(如  Jython  或  PyPy )，)可以依赖不同的机制，如完全的垃
圾回收器 。如果你的Python代码依赖于引用计数实现的行为，则这种差异可能
会导致一些微妙的移植问题。

在一些Python实现中，以下代码（在CPython中工作的很好）可能会耗尽文件描
述符:

   for file in very_long_list_of_files:
       f = open(file)
       c = f.read(1)

实际上，使用CPython的引用计数和析构函数方案， 每个新赋值的 *f* 都会关
闭前一个文件。然而，对于传统的GC，这些文件对象只能以不同的时间间隔（可
能很长的时间间隔）被收集（和关闭）。

如果要编写可用于任何python实现的代码，则应显式关闭该文件或使用  "with"
语句；无论内存管理方案如何，这都有效：

   for file in very_long_list_of_files:
       with open(file) as f:
           c = f.read(1)"}
{Q003015En:"Design and History FAQ==>Why doesn't CPython use a more traditional garbage collection scheme?"}
{A003015En:"For one thing, this is not a C standard feature and hence it's not
portable. (Yes, we know about the Boehm GC library.  It has bits of
assembler code for *most* common platforms, not for all of them, and
although it is mostly transparent, it isn't completely transparent;
patches are required to get Python to work with it.)

Traditional GC also becomes a problem when Python is embedded into
other applications.  While in a standalone Python it's fine to replace
the standard malloc() and free() with versions provided by the GC
library, an application embedding Python may want to have its *own*
substitute for malloc() and free(), and may not want Python's.  Right
now, CPython works with anything that implements malloc() and free()
properly."}
{Q003015Zh:"设计和历史常见问题==>为什么CPython不使用更传统的垃圾回收方案？"}
{A003015Zh:"首先，这不是C标准特性，因此不能移植。(是的，我们知道Boehm GC库。它包含
了 *大多数* 常见平台（但不是所有平台）的汇编代码，尽管它基本上是透明的
，但也不是完全透明的; 要让Python使用它，需要使用补丁。)

当Python嵌入到其他应用程序中时，传统的GC也成为一个问题。在独立的Python
中，可以用GC库提供的版本替换标准的malloc()和free()，嵌入Python的应用程
序可能希望用 *它自己* 替代malloc()和free()，而可能不需要Python的。现在
，CPython可以正确地实现malloc()和free()。"}
{Q003016En:"Design and History FAQ==>Why isn't all memory freed when CPython exits?"}
{A003016En:"Objects referenced from the global namespaces of Python modules are
not always deallocated when Python exits.  This may happen if there
are circular references.  There are also certain bits of memory that
are allocated by the C library that are impossible to free (e.g. a
tool like Purify will complain about these).  Python is, however,
aggressive about cleaning up memory on exit and does try to destroy
every single object.

If you want to force Python to delete certain things on deallocation
use the "atexit" module to run a function that will force those
deletions."}
{Q003016Zh:"设计和历史常见问题==>CPython退出时为什么不释放所有内存？"}
{A003016Zh:"当Python退出时，从全局命名空间或Python模块引用的对象并不总是被释放。
如果存在循环引用，则可能发生这种情况 C库分配的某些内存也是不可能释放的
（例如像Purify这样的工具会抱怨这些内容）。 但是，Python在退出时清理内
存并尝试销毁每个对象。

如果要强制 Python 在释放时删除某些内容，请使用 "atexit" 模块运行一个函
数，强制删除这些内容。"}
{Q003017En:"Design and History FAQ==>Why are there separate tuple and list data types?"}
{A003017En:"Lists and tuples, while similar in many respects, are generally used
in fundamentally different ways.  Tuples can be thought of as being
similar to Pascal records or C structs; they're small collections of
related data which may be of different types which are operated on as
a group.  For example, a Cartesian coordinate is appropriately
represented as a tuple of two or three numbers.

Lists, on the other hand, are more like arrays in other languages.
They tend to hold a varying number of objects all of which have the
same type and which are operated on one-by-one.  For example,
"os.listdir('.')" returns a list of strings representing the files in
the current directory.  Functions which operate on this output would
generally not break if you added another file or two to the directory.

Tuples are immutable, meaning that once a tuple has been created, you
can't replace any of its elements with a new value.  Lists are
mutable, meaning that you can always change a list's elements.  Only
immutable elements can be used as dictionary keys, and hence only
tuples and not lists can be used as keys."}
{Q003017Zh:"设计和历史常见问题==>为什么有单独的元组和列表数据类型？"}
{A003017Zh:"虽然列表和元组在许多方面是相似的，但它们的使用方式通常是完全不同的。可
以认为元组类似于Pascal记录或C结构；它们是相关数据的小集合，可以是不同
类型的数据，可以作为一个组进行操作。例如，笛卡尔坐标适当地表示为两个或
三个数字的元组。

另一方面，列表更像其他语言中的数组。它们倾向于持有不同数量的对象，所有
对象都具有相同的类型，并且逐个操作。例如， "os.listdir('.')" 返回表示
当前目录中的文件的字符串列表。如果向目录中添加了一两个文件，对此输出进
行操作的函数通常不会中断。

元组是不可变的，这意味着一旦创建了元组，就不能用新值替换它的任何元素。
列表是可变的，这意味着您始终可以更改列表的元素。只有不变元素可以用作字
典的key，因此只能将元组和非列表用作key。"}
{Q003018En:"Design and History FAQ==>How are lists implemented in CPython?"}
{A003018En:"CPython's lists are really variable-length arrays, not Lisp-style
linked lists. The implementation uses a contiguous array of references
to other objects, and keeps a pointer to this array and the array's
length in a list head structure.

This makes indexing a list "a[i]" an operation whose cost is
independent of the size of the list or the value of the index.

When items are appended or inserted, the array of references is
resized.  Some cleverness is applied to improve the performance of
appending items repeatedly; when the array must be grown, some extra
space is allocated so the next few times don't require an actual
resize."}
{Q003018Zh:"设计和历史常见问题==>列表是如何在CPython中实现的？"}
{A003018Zh:"CPython的列表实际上是可变长度的数组，而不是lisp风格的链表。该实现使用
对其他对象的引用的连续数组，并在列表头结构中保留指向该数组和数组长度的
指针。

这使得索引列表 "a[i]" 的操作成本与列表的大小或索引的值无关。

当添加或插入项时，将调整引用数组的大小。并采用了一些巧妙的方法来提高重
复添加项的性能; 当数组必须增长时，会分配一些额外的空间，以便在接下来的
几次中不需要实际调整大小。"}
{Q003019En:"Design and History FAQ==>How are dictionaries implemented in CPython?"}
{A003019En:"CPython's dictionaries are implemented as resizable hash tables.
Compared to B-trees, this gives better performance for lookup (the
most common operation by far) under most circumstances, and the
implementation is simpler.

Dictionaries work by computing a hash code for each key stored in the
dictionary using the "hash()" built-in function.  The hash code varies
widely depending on the key and a per-process seed; for example,
"Python" could hash to -539294296 while "python", a string that
differs by a single bit, could hash to 1142331976.  The hash code is
then used to calculate a location in an internal array where the value
will be stored.  Assuming that you're storing keys that all have
different hash values, this means that dictionaries take constant time
-- O(1), in Big-O notation -- to retrieve a key."}
{Q003019Zh:"设计和历史常见问题==>字典是如何在CPython中实现的？"}
{A003019Zh:"CPython的字典实现为可调整大小的哈希表。与B-树相比，这在大多数情况下为
查找（目前最常见的操作）提供了更好的性能，并且实现更简单。

字典的工作方式是使用 "hash()" 内置函数计算字典中存储的每个键的hash代码
。hash代码根据键和每个进程的种子而变化很大；例如，"Python" 的hash值为
-539294296，而"python"(一个按位不同的字符串)的hash值为1142331976。然后
，hash代码用于计算内部数组中将存储该值的位置。假设您存储的键都具有不同
的hash值，这意味着字典需要恒定的时间 -- O(1)，用Big-O表示法 -- 来检索
一个键。"}
{Q003020En:"Design and History FAQ==>Why must dictionary keys be immutable?"}
{A003020En:"The hash table implementation of dictionaries uses a hash value
calculated from the key value to find the key.  If the key were a
mutable object, its value could change, and thus its hash could also
change.  But since whoever changes the key object can't tell that it
was being used as a dictionary key, it can't move the entry around in
the dictionary.  Then, when you try to look up the same object in the
dictionary it won't be found because its hash value is different. If
you tried to look up the old value it wouldn't be found either,
because the value of the object found in that hash bin would be
different.

If you want a dictionary indexed with a list, simply convert the list
to a tuple first; the function "tuple(L)" creates a tuple with the
same entries as the list "L".  Tuples are immutable and can therefore
be used as dictionary keys.

Some unacceptable solutions that have been proposed:

* Hash lists by their address (object ID).  This doesn't work because
  if you construct a new list with the same value it won't be found;
  e.g.:

     mydict = {[1, 2]: '12'}
     print(mydict[[1, 2]])

  would raise a "KeyError" exception because the id of the "[1, 2]"
  used in the second line differs from that in the first line.  In
  other words, dictionary keys should be compared using "==", not
  using "is".

* Make a copy when using a list as a key.  This doesn't work because
  the list, being a mutable object, could contain a reference to
  itself, and then the copying code would run into an infinite loop.

* Allow lists as keys but tell the user not to modify them.  This
  would allow a class of hard-to-track bugs in programs when you
  forgot or modified a list by accident. It also invalidates an
  important invariant of dictionaries: every value in "d.keys()" is
  usable as a key of the dictionary.

* Mark lists as read-only once they are used as a dictionary key.  The
  problem is that it's not just the top-level object that could change
  its value; you could use a tuple containing a list as a key.
  Entering anything as a key into a dictionary would require marking
  all objects reachable from there as read-only -- and again, self-
  referential objects could cause an infinite loop.

There is a trick to get around this if you need to, but use it at your
own risk: You can wrap a mutable structure inside a class instance
which has both a "__eq__()" and a "__hash__()" method.  You must then
make sure that the hash value for all such wrapper objects that reside
in a dictionary (or other hash based structure), remain fixed while
the object is in the dictionary (or other structure).

   class ListWrapper:
       def __init__(self, the_list):
           self.the_list = the_list

       def __eq__(self, other):
           return self.the_list == other.the_list

       def __hash__(self):
           l = self.the_list
           result = 98767 - len(l)*555
           for i, el in enumerate(l):
               try:
                   result = result + (hash(el) % 9999999) * 1001 + i
               except Exception:
                   result = (result % 7777777) + i * 333
           return result

Note that the hash computation is complicated by the possibility that
some members of the list may be unhashable and also by the possibility
of arithmetic overflow.

Furthermore it must always be the case that if "o1 == o2" (ie
"o1.__eq__(o2) is True") then "hash(o1) == hash(o2)" (ie,
"o1.__hash__() == o2.__hash__()"), regardless of whether the object is
in a dictionary or not.  If you fail to meet these restrictions
dictionaries and other hash based structures will misbehave.

In the case of ListWrapper, whenever the wrapper object is in a
dictionary the wrapped list must not change to avoid anomalies.  Don't
do this unless you are prepared to think hard about the requirements
and the consequences of not meeting them correctly.  Consider yourself
warned."}
{Q003020Zh:"设计和历史常见问题==>为什么字典key必须是不可变的？"}
{A003020Zh:"字典的哈希表实现使用从键值计算的哈希值来查找键。如果键是可变对象，则其
值可能会发生变化，因此其哈希值也会发生变化。但是，由于无论谁更改键对象
都无法判断它是否被用作字典键值，因此无法在字典中修改条目。然后，当你尝
试在字典中查找相同的对象时，将无法找到它，因为其哈希值不同。如果你尝试
查找旧值，也不会找到它，因为在该哈希表中找到的对象的值会有所不同。

如果你想要一个用列表索引的字典，只需先将列表转换为元组；用函数
"tuple(L)" 创建一个元组，其条目与列表 "L" 相同。 元组是不可变的，因此
可以用作字典键。

已经提出的一些不可接受的解决方案：

* 哈希按其地址（对象ID）列出。这不起作用，因为如果你构造一个具有相同值
  的新列表，它将无法找到；例如:

     mydict = {[1, 2]: '12'}
     print(mydict[[1, 2]])

  会引发一个 "KeyError" 异常，因为第二行中使用的 "[1, 2]" 的 id 与第一
  行中的 id 不同。换句话说，应该使用 "==" 来比较字典键，而不是使用
  "is" 。

* 使用列表作为键时进行复制。这没有用的，因为作为可变对象的列表可以包含
  对自身的引用，然后复制代码将进入无限循环。

* 允许列表作为键，但告诉用户不要修改它们。当你意外忘记或修改列表时，这
  将产生程序中的一类难以跟踪的错误。它还使一个重要的字典不变量无效：
  "d.keys()" 中的每个值都可用作字典的键。

* 将列表用作字典键后，应标记为其只读。问题是，它不仅仅是可以改变其值的
  顶级对象；你可以使用包含列表作为键的元组。将任何内容作为键关联到字典
  中都需要将从那里可到达的所有对象标记为只读 —— 并且自引用对象可能会导
  致无限循环。

如果需要，可以使用以下方法来解决这个问题，但使用它需要你自担风险：你可
以将一个可变结构包装在一个类实例中，该实例同时具有 "__eq__()" 和
"__hash__()" 方法。然后，你必须确保驻留在字典（或其他基于 hash 的结构
）中的所有此类包装器对象的哈希值在对象位于字典（或其他结构）中时保持固
定。:

   class ListWrapper:
       def __init__(self, the_list):
           self.the_list = the_list

       def __eq__(self, other):
           return self.the_list == other.the_list

       def __hash__(self):
           l = self.the_list
           result = 98767 - len(l)*555
           for i, el in enumerate(l):
               try:
                   result = result + (hash(el) % 9999999) * 1001 + i
               except Exception:
                   result = (result % 7777777) + i * 333
           return result

注意，哈希计算由于列表的某些成员可能不可用以及算术溢出的可能性而变得复
杂。

此外，必须始终如此，如果 "o1 == o2" （即 "o1.__eq__(o2) is True" ）则
"hash(o1) == hash(o2)``（即 ``o1.__hash__() == o2.__hash__()" ），无论
对象是否在字典中。 如果你不能满足这些限制，字典和其他基于 hash 的结构
将会出错。

对于 ListWrapper ，只要包装器对象在字典中，包装列表就不能更改以避免异
常。除非你准备好认真考虑需求以及不正确地满足这些需求的后果，否则不要这
样做。请留意。"}
{Q003021En:"Design and History FAQ==>Why doesn't list.sort() return the sorted list?"}
{A003021En:"In situations where performance matters, making a copy of the list
just to sort it would be wasteful. Therefore, "list.sort()" sorts the
list in place. In order to remind you of that fact, it does not return
the sorted list.  This way, you won't be fooled into accidentally
overwriting a list when you need a sorted copy but also need to keep
the unsorted version around.

If you want to return a new list, use the built-in "sorted()" function
instead.  This function creates a new list from a provided iterable,
sorts it and returns it.  For example, here's how to iterate over the
keys of a dictionary in sorted order:

   for key in sorted(mydict):
       ...  # do whatever with mydict[key]..."}
{Q003021Zh:"设计和历史常见问题==>为什么 list.sort() 没有返回排序列表？"}
{A003021Zh:"在性能很重要的情况下，仅仅为了排序而复制一份列表将是一种浪费。因此，
"list.sort()" 对列表进行了适当的排序。为了提醒您这一事实，它不会返回已
排序的列表。这样，当您需要排序的副本，但也需要保留未排序的版本时，就不
会意外地覆盖列表。

如果要返回新列表，请使用内置 "sorted()" 函数。此函数从提供的可迭代列表
中创建新列表，对其进行排序并返回。例如，下面是如何迭代遍历字典并按keys
排序:

   for key in sorted(mydict):
       ...  # do whatever with mydict[key]..."}
{Q003022En:"Design and History FAQ==>How do you specify and enforce an interface spec in Python?"}
{A003022En:"An interface specification for a module as provided by languages such
as C++ and Java describes the prototypes for the methods and functions
of the module.  Many feel that compile-time enforcement of interface
specifications helps in the construction of large programs.

Python 2.6 adds an "abc" module that lets you define Abstract Base
Classes (ABCs).  You can then use "isinstance()" and "issubclass()" to
check whether an instance or a class implements a particular ABC.  The
"collections.abc" module defines a set of useful ABCs such as
"Iterable", "Container", and "MutableMapping".

For Python, many of the advantages of interface specifications can be
obtained by an appropriate test discipline for components.

A good test suite for a module can both provide a regression test and
serve as a module interface specification and a set of examples.  Many
Python modules can be run as a script to provide a simple "self test."
Even modules which use complex external interfaces can often be tested
in isolation using trivial "stub" emulations of the external
interface.  The "doctest" and "unittest" modules or third-party test
frameworks can be used to construct exhaustive test suites that
exercise every line of code in a module.

An appropriate testing discipline can help build large complex
applications in Python as well as having interface specifications
would.  In fact, it can be better because an interface specification
cannot test certain properties of a program.  For example, the
"append()" method is expected to add new elements to the end of some
internal list; an interface specification cannot test that your
"append()" implementation will actually do this correctly, but it's
trivial to check this property in a test suite.

Writing test suites is very helpful, and you might want to design your
code to make it easily tested. One increasingly popular technique,
test-driven development, calls for writing parts of the test suite
first, before you write any of the actual code.  Of course Python
allows you to be sloppy and not write test cases at all."}
{Q003022Zh:"设计和历史常见问题==>如何在Python中指定和实施接口规范？"}
{A003022Zh:"由C++和Java等语言提供的模块接口规范描述了模块的方法和函数的原型。许多
人认为接口规范的编译时强制执行有助于构建大型程序。

Python 2.6添加了一个 "abc" 模块，允许定义抽象基类 (ABCs)。然后可以使用
"isinstance()" 和 "issubclass()" 来检查实例或类是否实现了特定的ABC。
"collections.abc" 模块定义了一组有用的ABCs 例如 "Iterable" ，
"Container" , 和 "MutableMapping"

对于 Python，接口规范的许多好处可以通过组件的适当测试规程来获得。

一个好的模块测试套件既可以提供回归测试，也可以作为模块接口规范和一组示
例。许多Python模块可以作为脚本运行，以提供简单的“自我测试”。即使是使用
复杂外部接口的模块，也常常可以使用外部接口的简单“桩代码（stub）”模拟进
行隔离测试。可以使用 "doctest" 和 "unittest" 模块或第三方测试框架来构
造详尽的测试套件，以运行模块中的每一行代码。

适当的测试规程可以帮助在Python中构建大型的、复杂的应用程序以及接口规范
。事实上，它可能会更好，因为接口规范不能测试程序的某些属性。例如，
"append()" 方法将向一些内部列表的末尾添加新元素；接口规范不能测试您的
"append()" 实现是否能够正确执行此操作，但是在测试套件中检查这个属性是
很简单的。

编写测试套件非常有用，并且你可能希望将你的代码设计为易于测试。 一种日
益流行的技术是面向测试的开发，它要求在编写任何实际代码之前首先编写测试
套件的各个部分。 当然 Python 也允许你采用更粗率的方式，不必编写任何测
试用例。"}
{Q003023En:"Design and History FAQ==>Why is there no goto?"}
{A003023En:"You can use exceptions to provide a "structured goto" that even works
across function calls.  Many feel that exceptions can conveniently
emulate all reasonable uses of the "go" or "goto" constructs of C,
Fortran, and other languages.  For example:

   class label(Exception): pass  # declare a label

   try:
       ...
       if condition: raise label()  # goto label
       ...
   except label:  # where to goto
       pass
   ...

This doesn't allow you to jump into the middle of a loop, but that's
usually considered an abuse of goto anyway.  Use sparingly."}
{Q003023Zh:"设计和历史常见问题==>为什么没有goto？"}
{A003023Zh:"可以使用异常捕获来提供 “goto结构” ，甚至可以跨函数调用工作的 。许多人
认为异常捕获可以方便地模拟C，Fortran和其他语言的 "go" 或 "goto" 结构的
所有合理用法。例如:

   class label(Exception): pass  # declare a label

   try:
       ...
       if condition: raise label()  # goto label
       ...
   except label:  # where to goto
       pass
   ...

但是不允许你跳到循环的中间，这通常被认为是滥用goto。谨慎使用。"}
{Q003024En:"Design and History FAQ==>Why can't raw strings (r-strings) end with a backslash?"}
{A003024En:"More precisely, they can't end with an odd number of backslashes: the
unpaired backslash at the end escapes the closing quote character,
leaving an unterminated string.

Raw strings were designed to ease creating input for processors
(chiefly regular expression engines) that want to do their own
backslash escape processing. Such processors consider an unmatched
trailing backslash to be an error anyway, so raw strings disallow
that.  In return, they allow you to pass on the string quote character
by escaping it with a backslash.  These rules work well when r-strings
are used for their intended purpose.

If you're trying to build Windows pathnames, note that all Windows
system calls accept forward slashes too:

   f = open("/mydir/file.txt")  # works fine!

If you're trying to build a pathname for a DOS command, try e.g. one
of

   dir = r"\this\is\my\dos\dir" "\\"
   dir = r"\this\is\my\dos\dir\ "[:-1]
   dir = "\\this\\is\\my\\dos\\dir\\""}
{Q003024Zh:"设计和历史常见问题==>为什么原始字符串（r-strings）不能以反斜杠结尾？"}
{A003024Zh:"更准确地说，它们不能以奇数个反斜杠结束：结尾处的不成对反斜杠会转义结束
引号字符，留下未结束的字符串。

原始字符串的设计是为了方便想要执行自己的反斜杠转义处理的处理器(主要是
正则表达式引擎)创建输入。此类处理器将不匹配的尾随反斜杠视为错误，因此
原始字符串不允许这样做。反过来，允许通过使用引号字符转义反斜杠转义字符
串。当r-string用于它们的预期目的时，这些规则工作的很好。

如果您正在尝试构建Windows路径名，请注意所有Windows系统调用都使用正斜杠
:

   f = open("/mydir/file.txt")  # works fine!

如果您正在尝试为DOS命令构建路径名，请尝试以下示例

   dir = r"\this\is\my\dos\dir" "\\"
   dir = r"\this\is\my\dos\dir\ "[:-1]
   dir = "\\this\\is\\my\\dos\\dir\\""}
{Q003025En:"Design and History FAQ==>Why doesn't Python have a "with" statement for attribute assignments?"}
{A003025En:"Python has a 'with' statement that wraps the execution of a block,
calling code on the entrance and exit from the block.  Some languages
have a construct that looks like this:

   with obj:
       a = 1               # equivalent to obj.a = 1
       total = total + 1   # obj.total = obj.total + 1

In Python, such a construct would be ambiguous.

Other languages, such as Object Pascal, Delphi, and C++, use static
types, so it's possible to know, in an unambiguous way, what member is
being assigned to. This is the main point of static typing -- the
compiler *always* knows the scope of every variable at compile time.

Python uses dynamic types. It is impossible to know in advance which
attribute will be referenced at runtime. Member attributes may be
added or removed from objects on the fly. This makes it impossible to
know, from a simple reading, what attribute is being referenced: a
local one, a global one, or a member attribute?

For instance, take the following incomplete snippet:

   def foo(a):
       with a:
           print(x)

The snippet assumes that "a" must have a member attribute called "x".
However, there is nothing in Python that tells the interpreter this.
What should happen if "a" is, let us say, an integer?  If there is a
global variable named "x", will it be used inside the with block?  As
you see, the dynamic nature of Python makes such choices much harder.

The primary benefit of "with" and similar language features (reduction
of code volume) can, however, easily be achieved in Python by
assignment.  Instead of:

   function(args).mydict[index][index].a = 21
   function(args).mydict[index][index].b = 42
   function(args).mydict[index][index].c = 63

write this:

   ref = function(args).mydict[index][index]
   ref.a = 21
   ref.b = 42
   ref.c = 63

This also has the side-effect of increasing execution speed because
name bindings are resolved at run-time in Python, and the second
version only needs to perform the resolution once."}
{Q003025Zh:"设计和历史常见问题==>为什么Python没有属性赋值的“with”语句？"}
{A003025Zh:"Python 具有 'with' 语句，它能将一个代码块的执行包装起来，在进入和退出
代码块时调用特定的代码。 有些语言具有这样的结构:

   with obj:
       a = 1               # equivalent to obj.a = 1
       total = total + 1   # obj.total = obj.total + 1

在Python中，这样的结构是不明确的。

其他语言，如ObjectPascal、Delphi和C++ 使用静态类型，因此可以毫不含糊地
知道分配给什么成员。这是静态类型的要点 -- 编译器 *总是* 在编译时知道每
个变量的作用域。

Python使用动态类型。事先不可能知道在运行时引用哪个属性。可以动态地在对
象中添加或删除成员属性。这使得无法通过简单的阅读就知道引用的是什么属性
：局部属性、全局属性还是成员属性？

例如，采用以下不完整的代码段:

   def foo(a):
       with a:
           print(x)

该代码段假设 "a" 必须有一个名为 "x" 的成员属性。然而，Python中并没有告
诉解释器这一点。假设 "a" 是整数，会发生什么？如果有一个名为 "x" 的全局
变量，它是否会在with块中使用？如您所见，Python的动态特性使得这样的选择
更加困难。

然而，Python 可以通过赋值轻松实现 "with" 和类似语言特性（减少代码量）
的主要好处。代替:

   function(args).mydict[index][index].a = 21
   function(args).mydict[index][index].b = 42
   function(args).mydict[index][index].c = 63

写成这样:

   ref = function(args).mydict[index][index]
   ref.a = 21
   ref.b = 42
   ref.c = 63

这也具有提高执行速度的副作用，因为Python在运行时解析名称绑定，而第二个
版本只需要执行一次解析。"}
{Q003026En:"Design and History FAQ==>Why are colons required for the if/while/def/class statements?"}
{A003026En:"The colon is required primarily to enhance readability (one of the
results of the experimental ABC language).  Consider this:

   if a == b
       print(a)

versus

   if a == b:
       print(a)

Notice how the second one is slightly easier to read.  Notice further
how a colon sets off the example in this FAQ answer; it's a standard
usage in English.

Another minor reason is that the colon makes it easier for editors
with syntax highlighting; they can look for colons to decide when
indentation needs to be increased instead of having to do a more
elaborate parsing of the program text."}
{Q003026Zh:"设计和历史常见问题==>为什么 if/while/def/class语句需要冒号？"}
{A003026Zh:"冒号主要用于增强可读性(ABC语言实验的结果之一)。考虑一下这个:

   if a == b
       print(a)

与

   if a == b:
       print(a)

注意第二种方法稍微容易一些。请进一步注意，在这个FAQ解答的示例中，冒号
是如何设置的；这是英语中的标准用法。

另一个次要原因是冒号使带有语法突出显示的编辑器更容易工作；他们可以寻找
冒号来决定何时需要增加缩进，而不必对程序文本进行更精细的解析。"}
{Q003027En:"Design and History FAQ==>Why does Python allow commas at the end of lists and tuples?"}
{A003027En:"Python lets you add a trailing comma at the end of lists, tuples, and
dictionaries:

   [1, 2, 3,]
   ('a', 'b', 'c',)
   d = {
       "A": [1, 5],
       "B": [6, 7],  # last trailing comma is optional but good style
   }

There are several reasons to allow this.

When you have a literal value for a list, tuple, or dictionary spread
across multiple lines, it's easier to add more elements because you
don't have to remember to add a comma to the previous line.  The lines
can also be reordered without creating a syntax error.

Accidentally omitting the comma can lead to errors that are hard to
diagnose. For example:

   x = [
     "fee",
     "fie"
     "foo",
     "fum"
   ]

This list looks like it has four elements, but it actually contains
three: "fee", "fiefoo" and "fum".  Always adding the comma avoids this
source of error.

Allowing the trailing comma may also make programmatic code generation
easier."}
{Q003027Zh:"设计和历史常见问题==>为什么Python在列表和元组的末尾允许使用逗号？"}
{A003027Zh:"Python 允许您在列表，元组和字典的末尾添加一个尾随逗号:

   [1, 2, 3,]
   ('a', 'b', 'c',)
   d = {
       "A": [1, 5],
       "B": [6, 7],  # last trailing comma is optional but good style
   }

有几个理由允许这样做。

如果列表，元组或字典的字面值分布在多行中，则更容易添加更多元素，因为不
必记住在上一行中添加逗号。这些行也可以重新排序，而不会产生语法错误。

不小心省略逗号会导致难以诊断的错误。例如:

   x = [
     "fee",
     "fie"
     "foo",
     "fum"
   ]

这个列表看起来有四个元素，但实际上包含三个 : "fee", "fiefoo" 和 "fum"
。总是加上逗号可以避免这个错误的来源。

允许尾随逗号也可以使编程代码更容易生成。"}
{Q004001001En:"Library and Extension FAQ==>General Library Questions==>How do I find a module or application to perform task X?"}
{A004001001En:"Check the Library Reference to see if there's a relevant standard
library module.  (Eventually you'll learn what's in the standard
library and will be able to skip this step.)

For third-party packages, search the Python Package Index or try
Google or another Web search engine.  Searching for "Python" plus a
keyword or two for your topic of interest will usually find something
helpful."}
{Q004001001Zh:"代码库和插件 FAQ==>通用的代码库问题==>如何找到可以用来做 XXX 的模块或应用？"}
{A004001001Zh:"在 代码库参考 中查找是否有适合的标准库模块。（如果你已经了解标准库的内
容，可以跳过这一步）

对于第三方软件包，请搜索 Python Package Index 或是 Google 等其他搜索引
擎。用“Python”加上一两个你需要的关键字通常会找到有用的东西。"}
{Q004001002En:"Library and Extension FAQ==>General Library Questions==>Where is the math.py (socket.py, regex.py, etc.) source file?"}
{A004001002En:"If you can't find a source file for a module it may be a built-in or
dynamically loaded module implemented in C, C++ or other compiled
language. In this case you may not have the source file or it may be
something like "mathmodule.c", somewhere in a C source directory (not
on the Python Path).

There are (at least) three kinds of modules in Python:

1. modules written in Python (.py);

2. modules written in C and dynamically loaded (.dll, .pyd, .so, .sl,
   etc);

3. modules written in C and linked with the interpreter; to get a list
   of these, type:

      import sys
      print(sys.builtin_module_names)"}
{Q004001002Zh:"代码库和插件 FAQ==>通用的代码库问题==>math.py（socket.py，regex.py 等）的源文件在哪？"}
{A004001002Zh:"如果找不到模块的源文件，可能它是一个内建的模块，或是使用 C，C++ 或其他
编译型语言实现的动态加载模块。这种情况下可能是没有源码文件的，类似
"mathmodule.c" 这样的文件会存放在 C 代码目录中（但不在 Python 目录中）
。

Python 中（至少）有三类模块：

1. 使用 Python 编写的模块（.py)；

2. 使用 C 编写的动态加载模块（.dll，.pyd，.so，.sl 等）；

3. 使用 C 编写并链接到解释器的模块，要获取此列表，输入：

      import sys
      print(sys.builtin_module_names)"}
{Q004001003En:"Library and Extension FAQ==>General Library Questions==>How do I make a Python script executable on Unix?"}
{A004001003En:"You need to do two things: the script file's mode must be executable
and the first line must begin with "#!" followed by the path of the
Python interpreter.

The first is done by executing "chmod +x scriptfile" or perhaps "chmod
755 scriptfile".

The second can be done in a number of ways.  The most straightforward
way is to write

   #!/usr/local/bin/python

as the very first line of your file, using the pathname for where the
Python interpreter is installed on your platform.

If you would like the script to be independent of where the Python
interpreter lives, you can use the **env** program.  Almost all Unix
variants support the following, assuming the Python interpreter is in
a directory on the user's "PATH":

   #!/usr/bin/env python

*Don't* do this for CGI scripts.  The "PATH" variable for CGI scripts
is often very minimal, so you need to use the actual absolute pathname
of the interpreter.

Occasionally, a user's environment is so full that the
**/usr/bin/env** program fails; or there's no env program at all.  In
that case, you can try the following hack (due to Alex Rezinsky):

   #! /bin/sh
   """:"
   exec python $0 ${1+"$@"}
   """

The minor disadvantage is that this defines the script's __doc__
string. However, you can fix that by adding

   __doc__ = """...Whatever...""""}
{Q004001003Zh:"代码库和插件 FAQ==>通用的代码库问题==>在 Unix 中怎样让 Python 脚本可执行？"}
{A004001003Zh:"你需要做两件事：文件必须是可执行的，并且第一行需要以 "#!" 开头，后面跟
上 Python 解释器的路径。

第一点可以用执行 "chmod +x scriptfile" 或是 "chmod 755 scriptfile" 做
到。

第二点有很多种做法，最直接的方式是：

   #!/usr/local/bin/python

在文件第一行，使用你所在平台上的 Python 解释器的路径。

如果你希望脚本不依赖 Python 解释器的具体路径，你也可以使用 **env** 程
序。假设你的 Python 解释器所在目录已经添加到了 "PATH" 环境变量中，几乎
所有的类 Unix 系统都支持下面的写法：

   #!/usr/bin/env python

*不要* 在 CGI 脚本中这样做。CGI 脚本的 "PATH" 环境变量通常会非常精简，
所以你必须使用解释器的完整绝对路径。

有时候，用户的环境变量如果太长，可能会导致 **/usr/bin/env** 执行失败；
又或者甚至根本就不存在 env 程序。在这种情况下，你可以尝试使用下面的
hack 方法（来自 Alex Rezinsky）：

   #! /bin/sh
   """:"
   exec python $0 ${1+"$@"}
   """

这样做有一个小小的缺点，它会定义脚本的 __doc__ 字符串。不过可以这样修
复：

   __doc__ = """...Whatever...""""}
{Q004001004En:"Library and Extension FAQ==>General Library Questions==>Is there a curses/termcap package for Python?"}
{A004001004En:"For Unix variants: The standard Python source distribution comes with
a curses module in the Modules subdirectory, though it's not compiled
by default. (Note that this is not available in the Windows
distribution -- there is no curses module for Windows.)

The "curses" module supports basic curses features as well as many
additional functions from ncurses and SYSV curses such as colour,
alternative character set support, pads, and mouse support. This means
the module isn't compatible with operating systems that only have BSD
curses, but there don't seem to be any currently maintained OSes that
fall into this category.

For Windows: use the consolelib module."}
{Q004001004Zh:"代码库和插件 FAQ==>通用的代码库问题==>Python 中有 curses/termcap 包吗？"}
{A004001004Zh:"对于类 Unix 系统：标准 Python 源码发行版会在 Modules 子目录中附带
curses 模块，但默认并不会编译。（注意：在 Windows 平台下不可用 ——
Windows 中没有 curses 模块。）

"curses" 模块支持基本的 curses 特性，同时也支持 ncurses 和 SYSV curses
中的很多额外功能，比如颜色、不同的字符集支持、填充和鼠标支持。这意味着
这个模块不兼容只有 BSD curses 模块的操作系统，但是目前仍在维护的系统应
该都不会存在这种情况。

对于 Windows 平台：使用 consolelib 模块."}
{Q004001005En:"Library and Extension FAQ==>General Library Questions==>Is there an equivalent to C's onexit() in Python?"}
{A004001005En:"The "atexit" module provides a register function that is similar to
C's "onexit()"."}
{Q004001005Zh:"代码库和插件 FAQ==>通用的代码库问题==>Python 中存在类似 C 的 onexit() 函数的东西吗？"}
{A004001005Zh:""atexit" 模块提供了一个与 C 的 "onexit()" 函数类似的注册函数。"}
{Q004001006En:"Library and Extension FAQ==>General Library Questions==>Why don't my signal handlers work?"}
{A004001006En:"The most common problem is that the signal handler is declared with
the wrong argument list.  It is called as

   handler(signum, frame)

so it should be declared with two parameters:

   def handler(signum, frame):
       ..."}
{Q004001006Zh:"代码库和插件 FAQ==>通用的代码库问题==>为什么我的信号处理函数不能工作？"}
{A004001006Zh:"最常见的问题是信号处理函数没有正确定义参数列表。它会被这样调用：

   handler(signum, frame)

因此它应当声明为带有两个形参:

   def handler(signum, frame):
       ..."}
{Q004002001En:"Library and Extension FAQ==>Common tasks==>How do I test a Python program or component?"}
{A004002001En:"Python comes with two testing frameworks.  The "doctest" module finds
examples in the docstrings for a module and runs them, comparing the
output with the expected output given in the docstring.

The "unittest" module is a fancier testing framework modelled on Java
and Smalltalk testing frameworks.

To make testing easier, you should use good modular design in your
program. Your program should have almost all functionality
encapsulated in either functions or class methods -- and this
sometimes has the surprising and delightful effect of making the
program run faster (because local variable accesses are faster than
global accesses).  Furthermore the program should avoid depending on
mutating global variables, since this makes testing much more
difficult to do.

The "global main logic" of your program may be as simple as

   if __name__ == "__main__":
       main_logic()

at the bottom of the main module of your program.

Once your program is organized as a tractable collection of function
and class behaviours, you should write test functions that exercise
the behaviours.  A test suite that automates a sequence of tests can
be associated with each module. This sounds like a lot of work, but
since Python is so terse and flexible it's surprisingly easy.  You can
make coding much more pleasant and fun by writing your test functions
in parallel with the "production code", since this makes it easy to
find bugs and even design flaws earlier.

"Support modules" that are not intended to be the main module of a
program may include a self-test of the module.

   if __name__ == "__main__":
       self_test()

Even programs that interact with complex external interfaces may be
tested when the external interfaces are unavailable by using "fake"
interfaces implemented in Python."}
{Q004002001Zh:"代码库和插件 FAQ==>通用任务==>怎样测试 Python 程序或组件？"}
{A004002001Zh:"Python 带有两个测试框架。"doctest" 模块从模块的 docstring 中寻找示例并
执行，对比输出是否与 docstring 中给出的是否一致。

"unittest" 模块是一个模仿 Java 和 Smalltalk 测试框架的更棒的测试框架。

为了使测试更容易，你应该在程序中使用良好的模块化设计。程序中的绝大多数
功能都应该用函数或类方法封装 —— 有时这样做会有额外惊喜，程序会运行得更
快（因为局部变量比全局变量访问要快）。除此之外，程序应该避免依赖可变的
局部变量，这会使得测试困难许多。

程序的“全局主逻辑”应该尽量简单：

   if __name__ == "__main__":
       main_logic()

并放置在程序主模块的最后面。

一旦你的程序已经组织为一个函数和类行为的有完整集合，你就应该编写测试函
数来检测这些行为。 可以将自动执行一系列测试的测试集关联到每个模块。 这
听起来似乎需要大量的工作，但是由于 Python 是如此简洁灵活因此它会极其容
易。 你可以通过与“生产代码”同步编写测试函数使编程更为愉快和有趣，因为
这将更容易并更早发现代码问题甚至设计缺陷。

程序主模块之外的其他“辅助模块”中可以增加自测试的入口。

   if __name__ == "__main__":
       self_test()

通过使用 Python 实现的“假”接口，即使是需要与复杂的外部接口交互的程序也
可以在外部接口不可用时进行测试。"}
{Q004002002En:"Library and Extension FAQ==>Common tasks==>How do I create documentation from doc strings?"}
{A004002002En:"The "pydoc" module can create HTML from the doc strings in your Python
source code.  An alternative for creating API documentation purely
from docstrings is epydoc.  Sphinx can also include docstring content."}
{Q004002002Zh:"代码库和插件 FAQ==>通用任务==>怎样用 docstring 创建文档？"}
{A004002002Zh:""pydoc" 模块可以用 Python 源码中的 docstring 创建 HTML 文件。也可以使
用 epydoc 来只通过 docstring 创建 API 文档。Sphinx 也可以引入
docstring 的内容。"}
{Q004002003En:"Library and Extension FAQ==>Common tasks==>How do I get a single keypress at a time?"}
{A004002003En:"For Unix variants there are several solutions.  It's straightforward
to do this using curses, but curses is a fairly large module to learn."}
{Q004002003Zh:"代码库和插件 FAQ==>通用任务==>怎样一次只获取一个按键？"}
{A004002003Zh:"在类 Unix 系统中有多种方案。最直接的方法是使用 curses，但是 curses 模
块太大了，难以学习。"}
{Q004003001En:"Library and Extension FAQ==>Threads==>How do I program using threads?"}
{A004003001En:"Be sure to use the "threading" module and not the "_thread" module.
The "threading" module builds convenient abstractions on top of the
low-level primitives provided by the "_thread" module.

Aahz has a set of slides from his threading tutorial that are helpful;
see http://www.pythoncraft.com/OSCON2001/."}
{Q004003001Zh:"代码库和插件 FAQ==>线程相关==>程序中怎样使用线程？"}
{A004003001Zh:"一定要使用 "threading" 模块，不要使用 "_thread" 模块。"threading" 模块
对 "_thread" 模块提供的底层线程原语做了更易用的抽象。

Aahz 的非常实用的 threading 教程中有一些幻灯片；可以参阅
http://www.pythoncraft.com/OSCON2001/ 。"}
{Q004003002En:"Library and Extension FAQ==>Threads==>None of my threads seem to run: why?"}
{A004003002En:"As soon as the main thread exits, all threads are killed.  Your main
thread is running too quickly, giving the threads no time to do any
work.

A simple fix is to add a sleep to the end of the program that's long
enough for all the threads to finish:

   import threading, time

   def thread_task(name, n):
       for i in range(n):
           print(name, i)

   for i in range(10):
       T = threading.Thread(target=thread_task, args=(str(i), i))
       T.start()

   time.sleep(10)  # <---------------------------!

But now (on many platforms) the threads don't run in parallel, but
appear to run sequentially, one at a time!  The reason is that the OS
thread scheduler doesn't start a new thread until the previous thread
is blocked.

A simple fix is to add a tiny sleep to the start of the run function:

   def thread_task(name, n):
       time.sleep(0.001)  # <--------------------!
       for i in range(n):
           print(name, i)

   for i in range(10):
       T = threading.Thread(target=thread_task, args=(str(i), i))
       T.start()

   time.sleep(10)

Instead of trying to guess a good delay value for "time.sleep()", it's
better to use some kind of semaphore mechanism.  One idea is to use
the "queue" module to create a queue object, let each thread append a
token to the queue when it finishes, and let the main thread read as
many tokens from the queue as there are threads."}
{Q004003002Zh:"代码库和插件 FAQ==>线程相关==>我的线程都没有运行，为什么？"}
{A004003002Zh:"一旦主线程退出，所有的子线程都会被杀掉。你的主线程运行得太快了，子线程
还没来得及工作。

简单的解决方法是在程序中加一个时间足够长的 sleep，让子线程能够完成运行
。

   import threading, time

   def thread_task(name, n):
       for i in range(n):
           print(name, i)

   for i in range(10):
       T = threading.Thread(target=thread_task, args=(str(i), i))
       T.start()

   time.sleep(10)  # <---------------------------!

但目前（在许多平台上）线程不是并行运行的，而是按顺序依次执行！原因是系
统线程调度器在前一个线程阻塞之前不会启动新线程。

简单的解决方法是在运行函数的开始处加一个时间很短的 sleep。

   def thread_task(name, n):
       time.sleep(0.001)  # <--------------------!
       for i in range(n):
           print(name, i)

   for i in range(10):
       T = threading.Thread(target=thread_task, args=(str(i), i))
       T.start()

   time.sleep(10)

比起用 "time.sleep()" 猜一个合适的等待时间，使用信号量机制会更好些。有
一个办法是使用 "queue" 模块创建一个 queue 对象，让每一个线程在运行结束
时 append 一个令牌到 queue 对象中，主线程中从 queue 对象中读取与线程数
量一致的令牌数量即可。"}
{Q004003003En:"Library and Extension FAQ==>Threads==>How do I parcel out work among a bunch of worker threads?"}
{A004003003En:"The easiest way is to use the "concurrent.futures" module, especially
the "ThreadPoolExecutor" class.

Or, if you want fine control over the dispatching algorithm, you can
write your own logic manually.  Use the "queue" module to create a
queue containing a list of jobs.  The "Queue" class maintains a list
of objects and has a ".put(obj)" method that adds items to the queue
and a ".get()" method to return them.  The class will take care of the
locking necessary to ensure that each job is handed out exactly once.

Here's a trivial example:

   import threading, queue, time

   # The worker thread gets jobs off the queue.  When the queue is empty, it
   # assumes there will be no more work and exits.
   # (Realistically workers will run until terminated.)
   def worker():
       print('Running worker')
       time.sleep(0.1)
       while True:
           try:
               arg = q.get(block=False)
           except queue.Empty:
               print('Worker', threading.currentThread(), end=' ')
               print('queue empty')
               break
           else:
               print('Worker', threading.currentThread(), end=' ')
               print('running with argument', arg)
               time.sleep(0.5)

   # Create queue
   q = queue.Queue()

   # Start a pool of 5 workers
   for i in range(5):
       t = threading.Thread(target=worker, name='worker %i' % (i+1))
       t.start()

   # Begin adding work to the queue
   for i in range(50):
       q.put(i)

   # Give threads time to run
   print('Main thread sleeping')
   time.sleep(5)

When run, this will produce the following output:

   Running worker
   Running worker
   Running worker
   Running worker
   Running worker
   Main thread sleeping
   Worker <Thread(worker 1, started 130283832797456)> running with argument 0
   Worker <Thread(worker 2, started 130283824404752)> running with argument 1
   Worker <Thread(worker 3, started 130283816012048)> running with argument 2
   Worker <Thread(worker 4, started 130283807619344)> running with argument 3
   Worker <Thread(worker 5, started 130283799226640)> running with argument 4
   Worker <Thread(worker 1, started 130283832797456)> running with argument 5
   ...

Consult the module's documentation for more details; the "Queue" class
provides a featureful interface."}
{Q004003003Zh:"代码库和插件 FAQ==>线程相关==>如何将任务分配给多个工作线程？"}
{A004003003Zh:"最简单的方式是使用 "concurrent.futures" 模块，特别是其中的
"ThreadPoolExecutor" 类。

或者，如果你想更好地控制分发算法，你也可以自己写逻辑实现。使用 "queue"
模块来创建任务列表队列。"Queue" 类维护一个了一个存有对象的列表，提供了
".put(obj)" 方法添加元素，并且可以用 ".get()" 方法获取元素。这个类会使
用必要的加锁操作，以此确保每个任务只会执行一次。

这是一个简单的例子：

   import threading, queue, time

   # The worker thread gets jobs off the queue.  When the queue is empty, it
   # assumes there will be no more work and exits.
   # (Realistically workers will run until terminated.)
   def worker():
       print('Running worker')
       time.sleep(0.1)
       while True:
           try:
               arg = q.get(block=False)
           except queue.Empty:
               print('Worker', threading.currentThread(), end=' ')
               print('queue empty')
               break
           else:
               print('Worker', threading.currentThread(), end=' ')
               print('running with argument', arg)
               time.sleep(0.5)

   # Create queue
   q = queue.Queue()

   # Start a pool of 5 workers
   for i in range(5):
       t = threading.Thread(target=worker, name='worker %i' % (i+1))
       t.start()

   # Begin adding work to the queue
   for i in range(50):
       q.put(i)

   # Give threads time to run
   print('Main thread sleeping')
   time.sleep(5)

运行时会产生如下输出：

   Running worker
   Running worker
   Running worker
   Running worker
   Running worker
   Main thread sleeping
   Worker <Thread(worker 1, started 130283832797456)> running with argument 0
   Worker <Thread(worker 2, started 130283824404752)> running with argument 1
   Worker <Thread(worker 3, started 130283816012048)> running with argument 2
   Worker <Thread(worker 4, started 130283807619344)> running with argument 3
   Worker <Thread(worker 5, started 130283799226640)> running with argument 4
   Worker <Thread(worker 1, started 130283832797456)> running with argument 5
   ...

查看模块的文档以获取更多信息；"Queue" 类提供了多种接口。"}
{Q004003004En:"Library and Extension FAQ==>Threads==>What kinds of global value mutation are thread-safe?"}
{A004003004En:"A *global interpreter lock* (GIL) is used internally to ensure that
only one thread runs in the Python VM at a time.  In general, Python
offers to switch among threads only between bytecode instructions; how
frequently it switches can be set via "sys.setswitchinterval()".  Each
bytecode instruction and therefore all the C implementation code
reached from each instruction is therefore atomic from the point of
view of a Python program.

In theory, this means an exact accounting requires an exact
understanding of the PVM bytecode implementation.  In practice, it
means that operations on shared variables of built-in data types
(ints, lists, dicts, etc) that "look atomic" really are.

For example, the following operations are all atomic (L, L1, L2 are
lists, D, D1, D2 are dicts, x, y are objects, i, j are ints):

   L.append(x)
   L1.extend(L2)
   x = L[i]
   x = L.pop()
   L1[i:j] = L2
   L.sort()
   x = y
   x.field = y
   D[x] = y
   D1.update(D2)
   D.keys()

These aren't:

   i = i+1
   L.append(L[-1])
   L[i] = L[j]
   D[x] = D[x] + 1

Operations that replace other objects may invoke those other objects'
"__del__()" method when their reference count reaches zero, and that
can affect things.  This is especially true for the mass updates to
dictionaries and lists.  When in doubt, use a mutex!"}
{Q004003004Zh:"代码库和插件 FAQ==>线程相关==>怎样修改全局变量是线程安全的？"}
{A004003004Zh:"Python VM 内部会使用 *global interpreter lock* （GIL）来确保同一时间只
有一个线程运行。通常 Python 只会在字节码指令之间切换线程；切换的频率可
以通过设置 "sys.setswitchinterval()" 指定。从 Python 程序的角度来看，
每一条字节码指令以及每一条指令对应的 C 代码实现都是原子的。

理论上说，具体的结果要看具体的 PVM 字节码实现对指令的解释。而实际上，
对内建类型（int，list，dict 等）的共享变量的“类原子”操作都是原子的。

举例来说，下面的操作是原子的（L、L1、L2 是列表，D、D1、D2 是字典，x、y
是对象，i，j 是 int 变量）：

   L.append(x)
   L1.extend(L2)
   x = L[i]
   x = L.pop()
   L1[i:j] = L2
   L.sort()
   x = y
   x.field = y
   D[x] = y
   D1.update(D2)
   D.keys()

这些不是原子的：

   i = i+1
   L.append(L[-1])
   L[i] = L[j]
   D[x] = D[x] + 1

覆盖其他对象的操作会在其他对象的引用计数变成 0 时触发其 "__del__()" 方
法，这可能会产生一些影响。对字典和列表进行大量操作时尤其如此。如果有疑
问的话，使用互斥锁！"}
{Q004003005En:"Library and Extension FAQ==>Threads==>Can't we get rid of the Global Interpreter Lock?"}
{A004003005En:"The *global interpreter lock* (GIL) is often seen as a hindrance to
Python's deployment on high-end multiprocessor server machines,
because a multi-threaded Python program effectively only uses one CPU,
due to the insistence that (almost) all Python code can only run while
the GIL is held.

Back in the days of Python 1.5, Greg Stein actually implemented a
comprehensive patch set (the "free threading" patches) that removed
the GIL and replaced it with fine-grained locking.  Adam Olsen
recently did a similar experiment in his python-safethread project.
Unfortunately, both experiments exhibited a sharp drop in single-
thread performance (at least 30% slower), due to the amount of fine-
grained locking necessary to compensate for the removal of the GIL.

This doesn't mean that you can't make good use of Python on multi-CPU
machines! You just have to be creative with dividing the work up
between multiple *processes* rather than multiple *threads*.  The
"ProcessPoolExecutor" class in the new "concurrent.futures" module
provides an easy way of doing so; the "multiprocessing" module
provides a lower-level API in case you want more control over
dispatching of tasks.

Judicious use of C extensions will also help; if you use a C extension
to perform a time-consuming task, the extension can release the GIL
while the thread of execution is in the C code and allow other threads
to get some work done.  Some standard library modules such as "zlib"
and "hashlib" already do this.

It has been suggested that the GIL should be a per-interpreter-state
lock rather than truly global; interpreters then wouldn't be able to
share objects. Unfortunately, this isn't likely to happen either.  It
would be a tremendous amount of work, because many object
implementations currently have global state. For example, small
integers and short strings are cached; these caches would have to be
moved to the interpreter state.  Other object types have their own
free list; these free lists would have to be moved to the interpreter
state. And so on.

And I doubt that it can even be done in finite time, because the same
problem exists for 3rd party extensions.  It is likely that 3rd party
extensions are being written at a faster rate than you can convert
them to store all their global state in the interpreter state.

And finally, once you have multiple interpreters not sharing any
state, what have you gained over running each interpreter in a
separate process?"}
{Q004003005Zh:"代码库和插件 FAQ==>线程相关==>不能删除全局解释器锁吗？"}
{A004003005Zh:"*global interpreter lock* （GIL）通常被视为 Python 在高端多核服务器上
开发时的阻力，因为（几乎）所有 Python 代码只有在获取到 GIL 时才能运行
，所以多线程的 Python 程序只能有效地使用一个 CPU。

在 Python 1.5 时代，Greg Stein 开发了一个完整的补丁包（“free
threadings” 补丁），移除了 GIL，并用粒度更合适的锁来代替。Adam Olsen
最近也在他的 python-safethread 项目里做了类似的实验。不幸的是，由于为
了移除 GIL 而使用了大量细粒度的锁，这两个实验在单线程测试中的性能都有
明显的下降（至少慢 30%）。

但这并意味着你不能在多核机器上很好地使用 Python！你只需将任务划分为多*
进程*，而不是多*线程*。新的 "concurrent.futures" 模块中的
"ProcessPoolExecutor" 类提供了一个简单的方法；如果你想对任务分发做更多
控制，可以使用 "multiprocessing" 模块提供的底层 API。

恰当地使用 C 拓展也很有用；使用 C 拓展处理耗时较久的任务时，拓展可以在
线程执行 C 代码时释放 GIL，让其他线程执行。"zlib" 和 "hashlib" 等标准
库模块已经这样做了。

也有建议说 GIL 应该是解释器状态锁，而不是完全的全局锁；解释器不应该共
享对象。不幸的是，这也不可能发生。由于目前许多对象的实现都有全局的状态
，因此这是一个艰巨的工作。举例来说，小整型数和短字符串会缓存起来，这些
缓存将不得不移动到解释器状态中。其他对象类型都有自己的自由变量列表，这
些自由变量列表也必须移动到解释器状态中。等等。

我甚至怀疑这些工作是否可能在优先的时间内完成，因为同样的问题在第三方拓
展中也会存在。第三方拓展编写的速度可比你将它们转换为把全局状态存入解释
器状态中的速度快得多。

最后，假设多个解释器不共享任何状态，那么这样做比每个进程一个解释器好在
哪里呢？"}
{Q004004001En:"Library and Extension FAQ==>Input and Output==>How do I delete a file? (And other file questions...)"}
{A004004001En:"Use "os.remove(filename)" or "os.unlink(filename)"; for documentation,
see the "os" module.  The two functions are identical; "unlink()" is
simply the name of the Unix system call for this function.

To remove a directory, use "os.rmdir()"; use "os.mkdir()" to create
one. "os.makedirs(path)" will create any intermediate directories in
"path" that don't exist. "os.removedirs(path)" will remove
intermediate directories as long as they're empty; if you want to
delete an entire directory tree and its contents, use
"shutil.rmtree()".

To rename a file, use "os.rename(old_path, new_path)".

To truncate a file, open it using "f = open(filename, "rb+")", and use
"f.truncate(offset)"; offset defaults to the current seek position.
There's also "os.ftruncate(fd, offset)" for files opened with
"os.open()", where *fd* is the file descriptor (a small integer).

The "shutil" module also contains a number of functions to work on
files including "copyfile()", "copytree()", and "rmtree()"."}
{Q004004001Zh:"代码库和插件 FAQ==>输入输出==>怎样删除文件？（以及其他文件相关的问题……）"}
{A004004001Zh:"使用 "os.remove(filename)" 或 "os.unlink(filename)"。查看 "os" 模块以
获取更多文档。这两个函数是一样的，"unlink()" 是这个函数在 Unix 系统调
用中的名字。

如果要删除目录，应该使用 "os.rmdir()"；使用 "os.mkdir()" 创建目录。
"os.makedirs(path)" 会创建 "path" 中任何不存在的目录。
"os.removedirs(path)" 则会删除其中的目录，只要它们都是空的；如果你想删
除整个目录以及其中的内容，可以使用 "shutil.rmtree()"。

重命名文件可以使用 "os.rename(old_path, new_path)"。

如果需要截断文件，使用 "f = open(filename, "rb+")" 打开文件，然后使用
"f.truncate(offset)"；offset 默认是当前的搜索位置。也可以对使用
"os.open()" 打开的文件使用 "os.ftruncate(fd, offset)"，其中 *fd* 是文
件描述符（一个小的整型数）。

"shutil" 模块也包含了一些处理文件的函数，包括 "copyfile()"，
"copytree()" 和 "rmtree()"。"}
{Q004004002En:"Library and Extension FAQ==>Input and Output==>How do I copy a file?"}
{A004004002En:"The "shutil" module contains a "copyfile()" function.  Note that on
MacOS 9 it doesn't copy the resource fork and Finder info."}
{Q004004002Zh:"代码库和插件 FAQ==>输入输出==>怎样复制文件？"}
{A004004002Zh:""shutil" 模块有一个 "copyfile()" 函数。注意在 MacOS 9  中不会复制
resource fork 和 Finder info。"}
{Q004004003En:"Library and Extension FAQ==>Input and Output==>How do I read (or write) binary data?"}
{A004004003En:"To read or write complex binary data formats, it's best to use the
"struct" module.  It allows you to take a string containing binary
data (usually numbers) and convert it to Python objects; and vice
versa.

For example, the following code reads two 2-byte integers and one
4-byte integer in big-endian format from a file:

   import struct

   with open(filename, "rb") as f:
       s = f.read(8)
       x, y, z = struct.unpack(">hhl", s)

The '>' in the format string forces big-endian data; the letter 'h'
reads one "short integer" (2 bytes), and 'l' reads one "long integer"
(4 bytes) from the string.

For data that is more regular (e.g. a homogeneous list of ints or
floats), you can also use the "array" module.

Note:

  To read and write binary data, it is mandatory to open the file in
  binary mode (here, passing ""rb"" to "open()").  If you use ""r""
  instead (the default), the file will be open in text mode and
  "f.read()" will return "str" objects rather than "bytes" objects."}
{Q004004003Zh:"代码库和插件 FAQ==>输入输出==>怎样读取（或写入）二进制数据？"}
{A004004003Zh:"要读写复杂的二进制数据格式，最好使用 "struct" 模块。该模块可以读取包含
二进制数据（通常是数字）的字符串并转换为 Python 对象，反之亦然。

举例来说，下面的代码会从文件中以大端序格式读取一个 2 字节的整型和一个
4 字节的整型：

   import struct

   with open(filename, "rb") as f:
       s = f.read(8)
       x, y, z = struct.unpack(">hhl", s)

格式字符串中的 ‘>’ 强制以大端序读取数据；字母 ‘h’ 从字符串中读取一个“
短整型”（2 字节），字母 ‘l’ 读取一个“长整型”（4 字节）。

对于更常规的数据（例如整型或浮点类型的列表），你也可以使用 "array" 模
块。

注解:

  要读写二进制数据的话，需要强制以二进制模式打开文件（这里为 "open()"
  函数传入 ""rb""）。如果（默认）传入 ""r"" 的话，文件会以文本模式打开
  ，"f.read()" 会返回 "str" 对象，而不是 "bytes" 对象。"}
{Q004004004En:"Library and Extension FAQ==>Input and Output==>I can't seem to use os.read() on a pipe created with os.popen(); why?"}
{A004004004En:""os.read()" is a low-level function which takes a file descriptor, a
small integer representing the opened file.  "os.popen()" creates a
high-level file object, the same type returned by the built-in
"open()" function. Thus, to read *n* bytes from a pipe *p* created
with "os.popen()", you need to use "p.read(n)"."}
{Q004004004Zh:"代码库和插件 FAQ==>输入输出==>似乎 os.popen() 创建的管道不能使用 os.read()，这是为什么？"}
{A004004004Zh:""os.read()" 是一个底层函数，它接收的是文件描述符 —— 用小整型数表示的打
开的文件。"os.popen()" 创建的是一个高级文件对象，和内建的 "open()" 方
法返回的类型一样。因此，如果要从 "os.popen()" 创建的管道 *p* 中读取
*n* 个字节的话，你应该使用 "p.read(n)"。"}
{Q004004005En:"Library and Extension FAQ==>Input and Output==>How do I access the serial (RS232) port?"}
{A004004005En:"For Win32, POSIX (Linux, BSD, etc.), Jython:

   http://pyserial.sourceforge.net

For Unix, see a Usenet post by Mitch Chapman:

   https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"}
{Q004004005Zh:"代码库和插件 FAQ==>输入输出==>怎样访问（RS232）串口？"}
{A004004005Zh:"对于 Win32，POSIX（Linux，BSD 等），Jython：

   http://pyserial.sourceforge.net

对于 Unix，查看 Mitch Chapman 发布的帖子：

   https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"}
{Q004004006En:"Library and Extension FAQ==>Input and Output==>Why doesn't closing sys.stdout (stdin, stderr) really close it?"}
{A004004006En:"Python *file objects* are a high-level layer of abstraction on low-
level C file descriptors.

For most file objects you create in Python via the built-in "open()"
function, "f.close()" marks the Python file object as being closed
from Python's point of view, and also arranges to close the underlying
C file descriptor.  This also happens automatically in "f"'s
destructor, when "f" becomes garbage.

But stdin, stdout and stderr are treated specially by Python, because
of the special status also given to them by C.  Running
"sys.stdout.close()" marks the Python-level file object as being
closed, but does *not* close the associated C file descriptor.

To close the underlying C file descriptor for one of these three, you
should first be sure that's what you really want to do (e.g., you may
confuse extension modules trying to do I/O).  If it is, use
"os.close()":

   os.close(stdin.fileno())
   os.close(stdout.fileno())
   os.close(stderr.fileno())

Or you can use the numeric constants 0, 1 and 2, respectively."}
{Q004004006Zh:"代码库和插件 FAQ==>输入输出==>为什么关闭 sys.stdout（stdin，stderr）并不会真正关掉它？"}
{A004004006Zh:"Python *文件对象* 是一个对底层 C 文件描述符的高层抽象。

对于在 Python 中通过内建的 "open()" 函数创建的多数文件对象来说，
"f.close()" 从 Python 的角度将其标记为已关闭，并且会关闭底层的 C 文件
描述符。在 "f" 被垃圾回收的时候，析构函数中也会自动处理。

但由于 stdin，stdout 和 stderr 在 C 中的特殊地位，在 Python 中也会对它
们做特殊处理。运行 "sys.stdout.close()" 会将 Python 的文件对象标记为已
关闭，但是*不会*关闭与之关联的文件描述符。

要关闭这三者的 C 文件描述符的话，首先你应该确认确实需要关闭它（比如，
这可能会影响到处理 I/O 的拓展）。如果确实需要这么做的话，使用
"os.close()"：

   os.close(stdin.fileno())
   os.close(stdout.fileno())
   os.close(stderr.fileno())

或者也可以使用常量 0，1，2 代替。"}
{Q004005001En:"Library and Extension FAQ==>Network/Internet Programming==>What WWW tools are there for Python?"}
{A004005001En:"See the chapters titled Internet Protocols and Support and Internet
Data Handling in the Library Reference Manual.  Python has many
modules that will help you build server-side and client-side web
systems.

A summary of available frameworks is maintained by Paul Boddie at
https://wiki.python.org/moin/WebProgramming.

Cameron Laird maintains a useful set of pages about Python web
technologies at http://phaseit.net/claird/comp.lang.python/web_python."}
{Q004005001Zh:"代码库和插件 FAQ==>网络 / Internet 编程==>Python 中的 WWW 工具是什么？"}
{A004005001Zh:"参阅代码库参考手册中 互联网协议和支持 和 互联网数据处理 这两章的内容。
Python 有大量模块来帮助你构建服务端和客户端 web 系统。

Paul Boddie 维护了一份可用框架的概览，见
https://wiki.python.org/moin/WebProgramming 。

Cameron Laird 维护了一份关于 Python web 技术的实用网页的集合，见
http://phaseit.net/claird/comp.lang.python/web_python 。"}
{Q004005002En:"Library and Extension FAQ==>Network/Internet Programming==>How can I mimic CGI form submission (METHOD=POST)?"}
{A004005002En:"I would like to retrieve web pages that are the result of POSTing a
form. Is there existing code that would let me do this easily?

Yes. Here's a simple example that uses "urllib.request":

   #!/usr/local/bin/python

   import urllib.request

   # build the query string
   qs = "First=Josephine&MI=Q&Last=Public"

   # connect and send the server a path
   req = urllib.request.urlopen('http://www.some-server.out-there'
                                '/cgi-bin/some-cgi-script', data=qs)
   with req:
       msg, hdrs = req.read(), req.info()

Note that in general for percent-encoded POST operations, query
strings must be quoted using "urllib.parse.urlencode()".  For example,
to send "name=Guy Steele, Jr.":

   >>> import urllib.parse
   >>> urllib.parse.urlencode({'name': 'Guy Steele, Jr.'})
   'name=Guy+Steele%2C+Jr.'

See also:

  HOWTO Fetch Internet Resources Using The urllib Package for
  extensive examples."}
{Q004005002Zh:"代码库和插件 FAQ==>网络 / Internet 编程==>怎样模拟发送 CGI 表单（METHOD=POST）？"}
{A004005002Zh:"我需要通过 POST 表单获取网页，有什么代码能简单做到吗？

是的。 这里是一个使用 "urllib.request" 的简单例子:

   #!/usr/local/bin/python

   import urllib.request

   # build the query string
   qs = "First=Josephine&MI=Q&Last=Public"

   # connect and send the server a path
   req = urllib.request.urlopen('http://www.some-server.out-there'
                                '/cgi-bin/some-cgi-script', data=qs)
   with req:
       msg, hdrs = req.read(), req.info()

注意，通常在百分号编码的 POST 操作中，查询字符串必须使用
"urllib.parse.urlencode()" 处理一下。举个例子，如果要发送 "name=Guy
Steele, Jr." 的话：

   >>> import urllib.parse
   >>> urllib.parse.urlencode({'name': 'Guy Steele, Jr.'})
   'name=Guy+Steele%2C+Jr.'

参见: 查看 HOWTO 使用 urllib 包获取网络资源 获取更多示例。"}
{Q004005003En:"Library and Extension FAQ==>Network/Internet Programming==>What module should I use to help with generating HTML?"}
{A004005003En:"You can find a collection of useful links on the Web Programming wiki
page."}
{Q004005003Zh:"代码库和插件 FAQ==>网络 / Internet 编程==>生成 HTML 需要使用什么模块？"}
{A004005003Zh:"你可以在 Web 编程 wiki 页面 找到许多有用的链接。"}
{Q004005004En:"Library and Extension FAQ==>Network/Internet Programming==>How do I send mail from a Python script?"}
{A004005004En:"Use the standard library module "smtplib".

Here's a very simple interactive mail sender that uses it.  This
method will work on any host that supports an SMTP listener.

   import sys, smtplib

   fromaddr = input("From: ")
   toaddrs  = input("To: ").split(',')
   print("Enter message, end with ^D:")
   msg = ''
   while True:
       line = sys.stdin.readline()
       if not line:
           break
       msg += line

   # The actual mail send
   server = smtplib.SMTP('localhost')
   server.sendmail(fromaddr, toaddrs, msg)
   server.quit()

A Unix-only alternative uses sendmail.  The location of the sendmail
program varies between systems; sometimes it is "/usr/lib/sendmail",
sometimes "/usr/sbin/sendmail".  The sendmail manual page will help
you out.  Here's some sample code:

   import os

   SENDMAIL = "/usr/sbin/sendmail"  # sendmail location
   p = os.popen("%s -t -i" % SENDMAIL, "w")
   p.write("To: receiver@example.com\n")
   p.write("Subject: test\n")
   p.write("\n")  # blank line separating headers from body
   p.write("Some text\n")
   p.write("some more text\n")
   sts = p.close()
   if sts != 0:
       print("Sendmail exit status", sts)"}
{Q004005004Zh:"代码库和插件 FAQ==>网络 / Internet 编程==>怎样使用 Python 脚本发送邮件？"}
{A004005004Zh:"使用 "smtplib" 标准库模块。

下面是一个很简单的交互式发送邮件的代码。这个方法适用于任何支持 SMTP 协
议的主机。

   import sys, smtplib

   fromaddr = input("From: ")
   toaddrs  = input("To: ").split(',')
   print("Enter message, end with ^D:")
   msg = ''
   while True:
       line = sys.stdin.readline()
       if not line:
           break
       msg += line

   # The actual mail send
   server = smtplib.SMTP('localhost')
   server.sendmail(fromaddr, toaddrs, msg)
   server.quit()

在 Unix 系统中还可以使用 sendmail。sendmail 程序的位置在不同系统中不一
样，有时是在 "/usr/lib/sendmail"，有时是在 "/usr/sbin/sendmail"。
sendmail 手册页面会对你有所帮助。以下是示例代码：

   import os

   SENDMAIL = "/usr/sbin/sendmail"  # sendmail location
   p = os.popen("%s -t -i" % SENDMAIL, "w")
   p.write("To: receiver@example.com\n")
   p.write("Subject: test\n")
   p.write("\n")  # blank line separating headers from body
   p.write("Some text\n")
   p.write("some more text\n")
   sts = p.close()
   if sts != 0:
       print("Sendmail exit status", sts)"}
{Q004005005En:"Library and Extension FAQ==>Network/Internet Programming==>How do I avoid blocking in the connect() method of a socket?"}
{A004005005En:"The "select" module is commonly used to help with asynchronous I/O on
sockets.

To prevent the TCP connect from blocking, you can set the socket to
non-blocking mode.  Then when you do the "socket.connect()", you will
either connect immediately (unlikely) or get an exception that
contains the error number as ".errno". "errno.EINPROGRESS" indicates
that the connection is in progress, but hasn't finished yet.
Different OSes will return different values, so you're going to have
to check what's returned on your system.

You can use the "socket.connect_ex()" method to avoid creating an
exception.  It will just return the errno value.  To poll, you can
call "socket.connect_ex()" again later -- "0" or "errno.EISCONN"
indicate that you're connected -- or you can pass this socket to
"select.select()" to check if it's writable.

Note:

  The "asyncio" module provides a general purpose single-threaded and
  concurrent asynchronous library, which can be used for writing non-
  blocking network code. The third-party Twisted library is a popular
  and feature-rich alternative."}
{Q004005005Zh:"代码库和插件 FAQ==>网络 / Internet 编程==>socket 的 connect() 方法怎样避免阻塞？"}
{A004005005Zh:"通常会用 "select" 模块处理 socket 异步 I/O。

要防止 TCP 连接发生阻塞，你可以将 socket 设为非阻塞模式。 这样当你执行
"socket.connect()" 时，你将或是立即完成连接（不大可能）或是收到一个包
含 ".errno" 错误码的异常。 "errno.EINPROGRESS" 表示连接正在进行但还没
有完成。 不同的操作系统将返回不同的值，因此你需要确认你的系统会返回什
么值。

你可以使用 "socket.connect_ex()" 方法来避免生成异常。 它将只返回 errno
值。 要进行轮询，你可以稍后再次调用 "socket.connect_ex()" -- "0" 或
"errno.EISCONN" 表示连接已完成 -- 或者你也可以将此 socket 传给
"select.select()" 来检查它是否可写。

注解:

  "asyncio" 模块提供了通用的单线程并发异步库，它可被用来编写非阻塞的网
  络代码。 第三方的 Twisted 库是一个热门且功能丰富的替代选择。"}
{Q004006001En:"Library and Extension FAQ==>Databases==>Are there any interfaces to database packages in Python?"}
{A004006001En:"Yes.

Interfaces to disk-based hashes such as "DBM" and "GDBM" are also
included with standard Python.  There is also the "sqlite3" module,
which provides a lightweight disk-based relational database.

Support for most relational databases is available.  See the
DatabaseProgramming wiki page for details."}
{Q004006001Zh:"代码库和插件 FAQ==>数据库==>Python 中有数据库包的接口吗？"}
{A004006001Zh:"当然。

标准 Python 还包含了基于磁盘的哈希接口例如 "DBM" 和 "GDBM" 。除此之外
还有 "sqlite3" 模块，该模块提供了一个轻量级的基于磁盘的关系型数据库。

大多数关系型数据库都已经支持。查看 数据库编程 wiki 页面 获取更多信息。"}
{Q004006002En:"Library and Extension FAQ==>Databases==>How do you implement persistent objects in Python?"}
{A004006002En:"The "pickle" library module solves this in a very general way (though
you still can't store things like open files, sockets or windows), and
the "shelve" library module uses pickle and (g)dbm to create
persistent mappings containing arbitrary Python objects."}
{Q004006002Zh:"代码库和插件 FAQ==>数据库==>在 Python 中如何实现持久化对象？"}
{A004006002Zh:""pickle" 库模块以一种非常通用的方式解决了这个问题（虽然你依然不能用它
保存打开的文件、套接字或窗口之类的东西），此外 "shelve" 库模块可使用
pickle 和 (g)dbm 来创建包含任意 Python 对象的持久化映射。"}
{Q004007001En:"Library and Extension FAQ==>Mathematics and Numerics==>How do I generate random numbers in Python?"}
{A004007001En:"The standard module "random" implements a random number generator.
Usage is simple:

   import random
   random.random()

This returns a random floating point number in the range [0, 1).

There are also many other specialized generators in this module, such
as:

* "randrange(a, b)" chooses an integer in the range [a, b).

* "uniform(a, b)" chooses a floating point number in the range [a, b).

* "normalvariate(mean, sdev)" samples the normal (Gaussian)
  distribution.

Some higher-level functions operate on sequences directly, such as:

* "choice(S)" chooses a random element from a given sequence.

* "shuffle(L)" shuffles a list in-place, i.e. permutes it randomly.

There's also a "Random" class you can instantiate to create
independent multiple random number generators."}
{Q004007001Zh:"代码库和插件 FAQ==>数学和数字==>Python 中怎样生成随机数？"}
{A004007001Zh:""random" 标准库模块实现了随机数生成器，使用起来非常简单：

   import random
   random.random()

这个函数会返回 [0, 1) 之间的随机浮点数。

该模块中还有许多其他的专门的生成器，例如：

* "randrange(a, b)" 返回 [a, b) 区间内的一个整型数。

* "uniform(a, b)" 返回 [a, b) 区间之间的浮点数。

* "normalvariate(mean, sdev)" 使用正态（高斯）分布采样。

还有一些高级函数直接对序列进行操作，例如：

* "choice(S)" 从给定的序列中随机选择一个元素。

* "shuffle(L)" 会对列表执行原地重排，即将其随机地打乱。

还有 "Random" 类，你可以将其实例化，用来创建多个独立的随机数生成器。"}
{Q005001En:"Extending/Embedding FAQ==>Can I create my own functions in C?"}
{A005001En:"Yes, you can create built-in modules containing functions, variables,
exceptions and even new types in C.  This is explained in the document
Extending and Embedding the Python Interpreter.

Most intermediate or advanced Python books will also cover this topic."}
{Q005001Zh:"扩展/嵌入常见问题==>可以使用 C 语言创建自己的函数吗？"}
{A005001Zh:"是的，您可以在C中创建包含函数、变量、异常甚至新类型的内置模块。在文档
扩展和嵌入 Python 解释器 中有说明。

大多数中级或高级的Python书籍也涵盖这个主题。"}
{Q005002En:"Extending/Embedding FAQ==>Can I create my own functions in C++?"}
{A005002En:"Yes, using the C compatibility features found in C++.  Place "extern
"C" { ... }" around the Python include files and put "extern "C""
before each function that is going to be called by the Python
interpreter.  Global or static C++ objects with constructors are
probably not a good idea."}
{Q005002Zh:"扩展/嵌入常见问题==>可以使用 C++ 语言创建自己的函数吗？"}
{A005002Zh:"是的，可以使用C ++中兼容C的功能。 在Python include文件周围放置`
*extern“C”{...}`* ，并在Python解释器调用的每个函数之前放置 "extern“C”"
。 具有构造函数的全局或静态C ++对象可能不是一个好主意。"}
{Q005003En:"Extending/Embedding FAQ==>Writing C is hard; are there any alternatives?"}
{A005003En:"There are a number of alternatives to writing your own C extensions,
depending on what you're trying to do.

Cython and its relative Pyrex are compilers that accept a slightly
modified form of Python and generate the corresponding C code.  Cython
and Pyrex make it possible to write an extension without having to
learn Python's C API.

If you need to interface to some C or C++ library for which no Python
extension currently exists, you can try wrapping the library's data
types and functions with a tool such as SWIG.  SIP, CXX Boost, or
Weave are also alternatives for wrapping C++ libraries."}
{Q005003Zh:"扩展/嵌入常见问题==>C很难写，有没有其他选择？"}
{A005003Zh:"编写自己的C扩展有很多选择，具体取决于您要做的事情。

Cython 及其相关的 Pyrex 是接受稍微修改过的Python形式并生成相应C代码的
编译器。 Cython和Pyrex可以编写扩展而无需学习Python的C API。

如果需要连接到某些当前不存在Python扩展的C或C ++库，可以尝试使用 SWIG
等工具包装库的数据类型和函数。  SIP ， CXX Boost , 或 Weave 也是包装C
++库的替代方案。"}
{Q005004En:"Extending/Embedding FAQ==>How can I execute arbitrary Python statements from C?"}
{A005004En:"The highest-level function to do this is "PyRun_SimpleString()" which
takes a single string argument to be executed in the context of the
module "__main__" and returns "0" for success and "-1" when an
exception occurred (including "SyntaxError").  If you want more
control, use "PyRun_String()"; see the source for
"PyRun_SimpleString()" in "Python/pythonrun.c"."}
{Q005004Zh:"扩展/嵌入常见问题==>如何在 C 中执行任意 Python 语句？"}
{A005004Zh:"执行此操作的最高层级函数为 "PyRun_SimpleString()"，它接受单个字符串参
数用于在模块 "__main__" 的上下文中执行并在成功时返回 "0" 而在发生异常
(包括 "SyntaxError") 时返回 "-1"。 如果你想要更多可控性，可以使用
"PyRun_String()"；请在 "Python/pythonrun.c" 中查看
"PyRun_SimpleString()" 的源码。"}
{Q005005En:"Extending/Embedding FAQ==>How can I evaluate an arbitrary Python expression from C?"}
{A005005En:"Call the function "PyRun_String()" from the previous question with the
start symbol "Py_eval_input"; it parses an expression, evaluates it
and returns its value."}
{Q005005Zh:"扩展/嵌入常见问题==>如何在 C 中对任意 Python 表达式求值？"}
{A005005Zh:"可以调用前一问题中介绍的函数 "PyRun_String()" 并附带起始标记符
"Py_eval_input"；它会解析表达式，对其求值并返回结果值。"}
{Q005006En:"Extending/Embedding FAQ==>How do I extract C values from a Python object?"}
{A005006En:"That depends on the object's type.  If it's a tuple, "PyTuple_Size()"
returns its length and "PyTuple_GetItem()" returns the item at a
specified index.  Lists have similar functions, "PyListSize()" and
"PyList_GetItem()".

For bytes, "PyBytes_Size()" returns its length and
"PyBytes_AsStringAndSize()" provides a pointer to its value and its
length.  Note that Python bytes objects may contain null bytes so C's
"strlen()" should not be used.

To test the type of an object, first make sure it isn't "NULL", and
then use "PyBytes_Check()", "PyTuple_Check()", "PyList_Check()", etc.

There is also a high-level API to Python objects which is provided by
the so-called 'abstract' interface -- read "Include/abstract.h" for
further details.  It allows interfacing with any kind of Python
sequence using calls like "PySequence_Length()",
"PySequence_GetItem()", etc. as well as many other useful protocols
such as numbers ("PyNumber_Index()" et al.) and mappings in the
PyMapping APIs."}
{Q005006Zh:"扩展/嵌入常见问题==>如何从Python对象中提取C的值？"}
{A005006Zh:"这取决于对象的类型。 如果是元组，"PyTuple_Size()" 可返回其长度而
"PyTuple_GetItem()" 可返回指定序号上的项。 对于列表也有类似的函数
"PyListSize()" 和 "PyList_GetItem()"。

对于字节串，"PyBytes_Size()" 可返回其长度而
"PyBytes_AsStringAndSize()" 提供一个指向其值和长度的指针。 请注意
Python 字节串可能为空，因此 C 的 "strlen()" 不应被使用。

要检测一个对象的类型，首先要确保它不为 "NULL"，然后使用
"PyBytes_Check()", "PyTuple_Check()", "PyList_Check()" 等等。

还有一个针对 Python 对象的高层级 API，通过所谓的‘抽象’接口提供 —— 请参
阅 "Include/abstract.h" 了解详情。 它允许使用 "PySequence_Length()",
"PySequence_GetItem()" 这样的调用来与任意种类的 Python 序列进行对接，
此外还可使用许多其他有用的协议例如数字 ("PyNumber_Index()" 等) 以及
PyMapping API 中的各种映射等等。"}
{Q005007En:"Extending/Embedding FAQ==>How do I use Py_BuildValue() to create a tuple of arbitrary length?"}
{A005007En:"You can't.  Use "PyTuple_Pack()" instead."}
{Q005007Zh:"扩展/嵌入常见问题==>如何使用Py_BuildValue()创建任意长度的元组？"}
{A005007Zh:"不可以。应该使用 "PyTuple_Pack()" 。"}
{Q005008En:"Extending/Embedding FAQ==>How do I call an object's method from C?"}
{A005008En:"The "PyObject_CallMethod()" function can be used to call an arbitrary
method of an object.  The parameters are the object, the name of the
method to call, a format string like that used with "Py_BuildValue()",
and the argument values:

   PyObject *
   PyObject_CallMethod(PyObject *object, const char *method_name,
                       const char *arg_format, ...);

This works for any object that has methods -- whether built-in or
user-defined. You are responsible for eventually "Py_DECREF()"'ing the
return value.

To call, e.g., a file object's "seek" method with arguments 10, 0
(assuming the file object pointer is "f"):

   res = PyObject_CallMethod(f, "seek", "(ii)", 10, 0);
   if (res == NULL) {
           ... an exception occurred ...
   }
   else {
           Py_DECREF(res);
   }

Note that since "PyObject_CallObject()" *always* wants a tuple for the
argument list, to call a function without arguments, pass "()" for the
format, and to call a function with one argument, surround the
argument in parentheses, e.g. "(i)"."}
{Q005008Zh:"扩展/嵌入常见问题==>如何从C调用对象的方法？"}
{A005008Zh:"可以使用 "PyObject_CallMethod()" 函数来调用某个对象的任意方法。 形参为
该对象、要调用的方法名、类似 "Py_BuildValue()" 所用的格式字符串以及要
传给方法的参数值:

   PyObject *
   PyObject_CallMethod(PyObject *object, const char *method_name,
                       const char *arg_format, ...);

这适用于任何具有方法的对象 —— 不论是内置方法还是用户自定义方法。 你需
要负责对返回值进行最终的 "Py_DECREF()" 处理。

例如调用某个文件对象的 "seek" 方法并传入参数 10, 0 (假定文件对象的指针
为 "f"):

   res = PyObject_CallMethod(f, "seek", "(ii)", 10, 0);
   if (res == NULL) {
           ... an exception occurred ...
   }
   else {
           Py_DECREF(res);
   }

请注意由于 "PyObject_CallObject()" *总是* 接受一个元组作为参数列表，要
调用不带参数的函数，则传入格式为 "()"，要调用只带一个参数的函数，则应
将参数包含于圆括号中，例如 "(i)"。"}
{Q005009En:"Extending/Embedding FAQ==>How do I catch the output from PyErr_Print() (or anything that prints to stdout/stderr)?"}
{A005009En:"In Python code, define an object that supports the "write()" method.
Assign this object to "sys.stdout" and "sys.stderr".  Call
print_error, or just allow the standard traceback mechanism to work.
Then, the output will go wherever your "write()" method sends it.

The easiest way to do this is to use the "io.StringIO" class:

   >>> import io, sys
   >>> sys.stdout = io.StringIO()
   >>> print('foo')
   >>> print('hello world!')
   >>> sys.stderr.write(sys.stdout.getvalue())
   foo
   hello world!

A custom object to do the same would look like this:

   >>> import io, sys
   >>> class StdoutCatcher(io.TextIOBase):
   ...     def __init__(self):
   ...         self.data = []
   ...     def write(self, stuff):
   ...         self.data.append(stuff)
   ...
   >>> import sys
   >>> sys.stdout = StdoutCatcher()
   >>> print('foo')
   >>> print('hello world!')
   >>> sys.stderr.write(''.join(sys.stdout.data))
   foo
   hello world!"}
{Q005009Zh:"扩展/嵌入常见问题==>如何捕获PyErr_Print()（或打印到stdout / stderr的任何内容）的输出？"}
{A005009Zh:"在 Python 代码中，定义一个支持 "write()" 方法的对象。 将此对象赋值给
"sys.stdout" 和 "sys.stderr"。 调用 print_error 或者只是允许标准回溯机
制生效。 在此之后，输出将转往你的 "write()" 方法所指向的任何地方。

做到这一点的最简单方式是使用 "io.StringIO" 类：

   >>> import io, sys
   >>> sys.stdout = io.StringIO()
   >>> print('foo')
   >>> print('hello world!')
   >>> sys.stderr.write(sys.stdout.getvalue())
   foo
   hello world!

实现同样效果的自定义对象看起来是这样的：

   >>> import io, sys
   >>> class StdoutCatcher(io.TextIOBase):
   ...     def __init__(self):
   ...         self.data = []
   ...     def write(self, stuff):
   ...         self.data.append(stuff)
   ...
   >>> import sys
   >>> sys.stdout = StdoutCatcher()
   >>> print('foo')
   >>> print('hello world!')
   >>> sys.stderr.write(''.join(sys.stdout.data))
   foo
   hello world!"}
{Q005010En:"Extending/Embedding FAQ==>How do I access a module written in Python from C?"}
{A005010En:"You can get a pointer to the module object as follows:

   module = PyImport_ImportModule("<modulename>");

If the module hasn't been imported yet (i.e. it is not yet present in
"sys.modules"), this initializes the module; otherwise it simply
returns the value of "sys.modules["<modulename>"]".  Note that it
doesn't enter the module into any namespace -- it only ensures it has
been initialized and is stored in "sys.modules".

You can then access the module's attributes (i.e. any name defined in
the module) as follows:

   attr = PyObject_GetAttrString(module, "<attrname>");

Calling "PyObject_SetAttrString()" to assign to variables in the
module also works."}
{Q005010Zh:"扩展/嵌入常见问题==>如何从C访问用Python编写的模块？"}
{A005010Zh:"你可以通过如下方式获得一个指向模块对象的指针:

   module = PyImport_ImportModule("<modulename>");

如果模块尚未被导入（即它还不存在于 "sys.modules" 中），这会初始化该模
块；否则它只是简单地返回 "sys.modules["<modulename>"]" 的值。 请注意它
并不会将模块加入任何命名空间 —— 它只是确保模块被初始化并存在于
"sys.modules" 中。

之后你就可以通过如下方式来访问模块的属性（即模块中定义的任何名称）:

   attr = PyObject_GetAttrString(module, "<attrname>");

调用 "PyObject_SetAttrString()" 为模块中的变量赋值也是可以的。"}
{Q005011En:"Extending/Embedding FAQ==>How do I interface to C++ objects from Python?"}
{A005011En:"Depending on your requirements, there are many approaches.  To do this
manually, begin by reading the "Extending and Embedding" document.
Realize that for the Python run-time system, there isn't a whole lot
of difference between C and C++ -- so the strategy of building a new
Python type around a C structure (pointer) type will also work for C++
objects.

For C++ libraries, see Writing C is hard; are there any alternatives?."}
{Q005011Zh:"扩展/嵌入常见问题==>如何在 Python 中对接 C ++ 对象？"}
{A005011Zh:"根据你的需求，可以选择许多方式。 手动的实现方式请查阅 "扩展与嵌入" 文
档 来入门。 需要知道的是对于 Python 运行时系统来说，C 和 C++ 并不没有
太大的区别 —— 因此围绕一个 C 结构（指针）类型构建新 Python 对象的策略
同样适用于 C++ 对象。

有关C ++库，请参阅 C很难写，有没有其他选择？"}
{Q005012En:"Extending/Embedding FAQ==>I added a module using the Setup file and the make fails; why?"}
{A005012En:"Setup must end in a newline, if there is no newline there, the build
process fails.  (Fixing this requires some ugly shell script hackery,
and this bug is so minor that it doesn't seem worth the effort.)"}
{Q005012Zh:"扩展/嵌入常见问题==>我使用Setup文件添加了一个模块，为什么make失败了？"}
{A005012Zh:"安装程序必须以换行符结束，如果没有换行符，则构建过程将失败。 （修复这
个需要一些丑陋的shell脚本编程，而且这个bug很小，看起来不值得花这么大力
气。)"}
{Q005013En:"Extending/Embedding FAQ==>How do I debug an extension?"}
{A005013En:"When using GDB with dynamically loaded extensions, you can't set a
breakpoint in your extension until your extension is loaded.

In your ".gdbinit" file (or interactively), add the command:

   br _PyImport_LoadDynamicModule

Then, when you run GDB:

   $ gdb /local/bin/python
   gdb) run myscript.py
   gdb) continue # repeat until your extension is loaded
   gdb) finish   # so that your extension is loaded
   gdb) br myfunction.c:50
   gdb) continue"}
{Q005013Zh:"扩展/嵌入常见问题==>如何调试扩展？"}
{A005013Zh:"将GDB与动态加载的扩展名一起使用时，在加载扩展名之前，不能在扩展名中设
置断点。

在您的 ".gdbinit" 文件中（或交互式）添加命令：

   br _PyImport_LoadDynamicModule

然后运行GDB：

   $ gdb /local/bin/python
   gdb) run myscript.py
   gdb) continue # repeat until your extension is loaded
   gdb) finish   # so that your extension is loaded
   gdb) br myfunction.c:50
   gdb) continue"}
{Q005014En:"Extending/Embedding FAQ==>I want to compile a Python module on my Linux system, but some files are missing. Why?"}
{A005014En:"Most packaged versions of Python don't include the
"/usr/lib/python2.*x*/config/" directory, which contains various files
required for compiling Python extensions.

For Red Hat, install the python-devel RPM to get the necessary files.

For Debian, run "apt-get install python-dev"."}
{Q005014Zh:"扩展/嵌入常见问题==>我想在Linux系统上编译一个Python模块，但是缺少一些文件。为什么?"}
{A005014Zh:"大多数打包的Python版本不包含 "/usr/lib/python2.*x*/config/" 目录，该目
录中包含编译Python扩展所需的各种文件。

对于Red Hat，安装python-devel RPM以获取必要的文件。

对于Debian，运行 "apt-get install python-dev" 。"}
{Q005015En:"Extending/Embedding FAQ==>How do I tell "incomplete input" from "invalid input"?"}
{A005015En:"Sometimes you want to emulate the Python interactive interpreter's
behavior, where it gives you a continuation prompt when the input is
incomplete (e.g. you typed the start of an "if" statement or you
didn't close your parentheses or triple string quotes), but it gives
you a syntax error message immediately when the input is invalid.

In Python you can use the "codeop" module, which approximates the
parser's behavior sufficiently.  IDLE uses this, for example.

The easiest way to do it in C is to call "PyRun_InteractiveLoop()"
(perhaps in a separate thread) and let the Python interpreter handle
the input for you. You can also set the
"PyOS_ReadlineFunctionPointer()" to point at your custom input
function. See "Modules/readline.c" and "Parser/myreadline.c" for more
hints.

However sometimes you have to run the embedded Python interpreter in
the same thread as your rest application and you can't allow the
"PyRun_InteractiveLoop()" to stop while waiting for user input.  The
one solution then is to call "PyParser_ParseString()" and test for
"e.error" equal to "E_EOF", which means the input is incomplete.
Here's a sample code fragment, untested, inspired by code from Alex
Farber:

   #define PY_SSIZE_T_CLEAN
   #include <Python.h>
   #include <node.h>
   #include <errcode.h>
   #include <grammar.h>
   #include <parsetok.h>
   #include <compile.h>

   int testcomplete(char *code)
     /* code should end in \n */
     /* return -1 for error, 0 for incomplete, 1 for complete */
   {
     node *n;
     perrdetail e;

     n = PyParser_ParseString(code, &_PyParser_Grammar,
                              Py_file_input, &e);
     if (n == NULL) {
       if (e.error == E_EOF)
         return 0;
       return -1;
     }

     PyNode_Free(n);
     return 1;
   }

Another solution is trying to compile the received string with
"Py_CompileString()". If it compiles without errors, try to execute
the returned code object by calling "PyEval_EvalCode()". Otherwise
save the input for later. If the compilation fails, find out if it's
an error or just more input is required - by extracting the message
string from the exception tuple and comparing it to the string
"unexpected EOF while parsing".  Here is a complete example using the
GNU readline library (you may want to ignore **SIGINT** while calling
readline()):

   #include <stdio.h>
   #include <readline.h>

   #define PY_SSIZE_T_CLEAN
   #include <Python.h>
   #include <object.h>
   #include <compile.h>
   #include <eval.h>

   int main (int argc, char* argv[])
   {
     int i, j, done = 0;                          /* lengths of line, code */
     char ps1[] = ">>> ";
     char ps2[] = "... ";
     char *prompt = ps1;
     char *msg, *line, *code = NULL;
     PyObject *src, *glb, *loc;
     PyObject *exc, *val, *trb, *obj, *dum;

     Py_Initialize ();
     loc = PyDict_New ();
     glb = PyDict_New ();
     PyDict_SetItemString (glb, "__builtins__", PyEval_GetBuiltins ());

     while (!done)
     {
       line = readline (prompt);

       if (NULL == line)                          /* Ctrl-D pressed */
       {
         done = 1;
       }
       else
       {
         i = strlen (line);

         if (i > 0)
           add_history (line);                    /* save non-empty lines */

         if (NULL == code)                        /* nothing in code yet */
           j = 0;
         else
           j = strlen (code);

         code = realloc (code, i + j + 2);
         if (NULL == code)                        /* out of memory */
           exit (1);

         if (0 == j)                              /* code was empty, so */
           code[0] = '\0';                        /* keep strncat happy */

         strncat (code, line, i);                 /* append line to code */
         code[i + j] = '\n';                      /* append '\n' to code */
         code[i + j + 1] = '\0';

         src = Py_CompileString (code, "<stdin>", Py_single_input);

         if (NULL != src)                         /* compiled just fine - */
         {
           if (ps1  == prompt ||                  /* ">>> " or */
               '\n' == code[i + j - 1])           /* "... " and double '\n' */
           {                                               /* so execute it */
             dum = PyEval_EvalCode (src, glb, loc);
             Py_XDECREF (dum);
             Py_XDECREF (src);
             free (code);
             code = NULL;
             if (PyErr_Occurred ())
               PyErr_Print ();
             prompt = ps1;
           }
         }                                        /* syntax error or E_EOF? */
         else if (PyErr_ExceptionMatches (PyExc_SyntaxError))
         {
           PyErr_Fetch (&exc, &val, &trb);        /* clears exception! */

           if (PyArg_ParseTuple (val, "sO", &msg, &obj) &&
               !strcmp (msg, "unexpected EOF while parsing")) /* E_EOF */
           {
             Py_XDECREF (exc);
             Py_XDECREF (val);
             Py_XDECREF (trb);
             prompt = ps2;
           }
           else                                   /* some other syntax error */
           {
             PyErr_Restore (exc, val, trb);
             PyErr_Print ();
             free (code);
             code = NULL;
             prompt = ps1;
           }
         }
         else                                     /* some non-syntax error */
         {
           PyErr_Print ();
           free (code);
           code = NULL;
           prompt = ps1;
         }

         free (line);
       }
     }

     Py_XDECREF(glb);
     Py_XDECREF(loc);
     Py_Finalize();
     exit(0);
   }"}
{Q005015Zh:"扩展/嵌入常见问题==>如何区分“输入不完整”和“输入无效”？"}
{A005015Zh:"有时，希望模仿Python交互式解释器的行为，在输入不完整时(例如，您键入了
“if”语句的开头，或者没有关闭括号或三个字符串引号)，给出一个延续提示，
但当输入无效时，立即给出一条语法错误消息。

在Python中，您可以使用 "codeop" 模块，该模块非常接近解析器的行为。例如
，IDLE就使用了这个。

在C中执行此操作的最简单方法是调用 "PyRun_InteractiveLoop()" （可能在单
独的线程中）并让Python解释器为您处理输入。您还可以设置
"PyOS_ReadlineFunctionPointer()" 指向您的自定义输入函数。有关更多提示
，请参阅 "Modules/readline.c" 和 "Parser/myreadline.c" 。

但是，有时必须在与其他应用程序相同的线程中运行嵌入式Python解释器，并且
不能允许 "PyRun_InteractiveLoop()" 在等待用户输入时停止。那么另一个解
决方案是调用 "PyParser_ParseString()" 并测试 "e.error" 等于 "E_EOF" ，
如果等于，就意味着输入不完整。这是一个示例代码片段，未经测试，灵感来自
Alex Farber的代码:

   #define PY_SSIZE_T_CLEAN
   #include <Python.h>
   #include <node.h>
   #include <errcode.h>
   #include <grammar.h>
   #include <parsetok.h>
   #include <compile.h>

   int testcomplete(char *code)
     /* code should end in \n */
     /* return -1 for error, 0 for incomplete, 1 for complete */
   {
     node *n;
     perrdetail e;

     n = PyParser_ParseString(code, &_PyParser_Grammar,
                              Py_file_input, &e);
     if (n == NULL) {
       if (e.error == E_EOF)
         return 0;
       return -1;
     }

     PyNode_Free(n);
     return 1;
   }

另一个解决方案是尝试使用 "Py_CompileString()" 编译接收到的字符串。如果
编译时没有出现错误，请尝试通过调用 "PyEval_EvalCode()" 来执行返回的代
码对象。否则，请将输入保存到以后。如果编译失败，找出是错误还是只需要更
多的输入-从异常元组中提取消息字符串，并将其与字符串 “分析时意外的EOF”
进行比较。下面是使用GNUreadline库的完整示例(您可能希望在调用readline()
时忽略 **SIGINT** )：

   #include <stdio.h>
   #include <readline.h>

   #define PY_SSIZE_T_CLEAN
   #include <Python.h>
   #include <object.h>
   #include <compile.h>
   #include <eval.h>

   int main (int argc, char* argv[])
   {
     int i, j, done = 0;                          /* lengths of line, code */
     char ps1[] = ">>> ";
     char ps2[] = "... ";
     char *prompt = ps1;
     char *msg, *line, *code = NULL;
     PyObject *src, *glb, *loc;
     PyObject *exc, *val, *trb, *obj, *dum;

     Py_Initialize ();
     loc = PyDict_New ();
     glb = PyDict_New ();
     PyDict_SetItemString (glb, "__builtins__", PyEval_GetBuiltins ());

     while (!done)
     {
       line = readline (prompt);

       if (NULL == line)                          /* Ctrl-D pressed */
       {
         done = 1;
       }
       else
       {
         i = strlen (line);

         if (i > 0)
           add_history (line);                    /* save non-empty lines */

         if (NULL == code)                        /* nothing in code yet */
           j = 0;
         else
           j = strlen (code);

         code = realloc (code, i + j + 2);
         if (NULL == code)                        /* out of memory */
           exit (1);

         if (0 == j)                              /* code was empty, so */
           code[0] = '\0';                        /* keep strncat happy */

         strncat (code, line, i);                 /* append line to code */
         code[i + j] = '\n';                      /* append '\n' to code */
         code[i + j + 1] = '\0';

         src = Py_CompileString (code, "<stdin>", Py_single_input);

         if (NULL != src)                         /* compiled just fine - */
         {
           if (ps1  == prompt ||                  /* ">>> " or */
               '\n' == code[i + j - 1])           /* "... " and double '\n' */
           {                                               /* so execute it */
             dum = PyEval_EvalCode (src, glb, loc);
             Py_XDECREF (dum);
             Py_XDECREF (src);
             free (code);
             code = NULL;
             if (PyErr_Occurred ())
               PyErr_Print ();
             prompt = ps1;
           }
         }                                        /* syntax error or E_EOF? */
         else if (PyErr_ExceptionMatches (PyExc_SyntaxError))
         {
           PyErr_Fetch (&exc, &val, &trb);        /* clears exception! */

           if (PyArg_ParseTuple (val, "sO", &msg, &obj) &&
               !strcmp (msg, "unexpected EOF while parsing")) /* E_EOF */
           {
             Py_XDECREF (exc);
             Py_XDECREF (val);
             Py_XDECREF (trb);
             prompt = ps2;
           }
           else                                   /* some other syntax error */
           {
             PyErr_Restore (exc, val, trb);
             PyErr_Print ();
             free (code);
             code = NULL;
             prompt = ps1;
           }
         }
         else                                     /* some non-syntax error */
         {
           PyErr_Print ();
           free (code);
           code = NULL;
           prompt = ps1;
         }

         free (line);
       }
     }

     Py_XDECREF(glb);
     Py_XDECREF(loc);
     Py_Finalize();
     exit(0);
   }"}
{Q005016En:"Extending/Embedding FAQ==>How do I find undefined g++ symbols __builtin_new or __pure_virtual?"}
{A005016En:"To dynamically load g++ extension modules, you must recompile Python,
relink it using g++ (change LINKCC in the Python Modules Makefile),
and link your extension module using g++ (e.g., "g++ -shared -o
mymodule.so mymodule.o")."}
{Q005016Zh:"扩展/嵌入常见问题==>如何找到未定义的g++符号__builtin_new或__pure_virtual？"}
{A005016Zh:"要动态加载g ++扩展模块，必须重新编译Python，要使用g ++重新链接（在
Python Modules Makefile中更改LINKCC），及链接扩展模块（例如： "g++
-shared -o mymodule.so mymodule.o" ）。"}
{Q005017En:"Extending/Embedding FAQ==>Can I create an object class with some methods implemented in C and others in Python (e.g. through inheritance)?"}
{A005017En:"Yes, you can inherit from built-in classes such as "int", "list",
"dict", etc.

The Boost Python Library (BPL,
http://www.boost.org/libs/python/doc/index.html) provides a way of
doing this from C++ (i.e. you can inherit from an extension class
written in C++ using the BPL)."}
{Q005017Zh:"扩展/嵌入常见问题==>能否创建一个对象类，其中部分方法在C中实现，而其他方法在Python中实现（例如通过继承）？"}
{A005017Zh:"是的，您可以继承内置类，例如 "int" ， "list" ， "dict" 等。

Boost Python库（BPL，http：//www.boost.org/libs/python/doc/index.html
）提供了一种从C ++执行此操作的方法（即，您可以使用BPL继承自C ++编写的
扩展类 ）。"}
{Q006001En:"Python on Windows FAQ==>How do I run a Python program under Windows?"}
{A006001En:"This is not necessarily a straightforward question. If you are already
familiar with running programs from the Windows command line then
everything will seem obvious; otherwise, you might need a little more
guidance.

Unless you use some sort of integrated development environment, you
will end up *typing* Windows commands into what is variously referred
to as a "DOS window" or "Command prompt window".  Usually you can
create such a window from your search bar by searching for "cmd".  You
should be able to recognize when you have started such a window
because you will see a Windows "command prompt", which usually looks
like this:

   C:\>

The letter may be different, and there might be other things after it,
so you might just as easily see something like:

   D:\YourName\Projects\Python>

depending on how your computer has been set up and what else you have
recently done with it.  Once you have started such a window, you are
well on the way to running Python programs.

You need to realize that your Python scripts have to be processed by
another program called the Python *interpreter*.  The interpreter
reads your script, compiles it into bytecodes, and then executes the
bytecodes to run your program. So, how do you arrange for the
interpreter to handle your Python?

First, you need to make sure that your command window recognises the
word "py" as an instruction to start the interpreter.  If you have
opened a command window, you should try entering the command "py" and
hitting return:

   C:\Users\YourName> py

You should then see something like:

   Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] on win32
   Type "help", "copyright", "credits" or "license" for more information.
   >>>

You have started the interpreter in "interactive mode". That means you
can enter Python statements or expressions interactively and have them
executed or evaluated while you wait.  This is one of Python's
strongest features.  Check it by entering a few expressions of your
choice and seeing the results:

   >>> print("Hello")
   Hello
   >>> "Hello" * 3
   'HelloHelloHello'

Many people use the interactive mode as a convenient yet highly
programmable calculator.  When you want to end your interactive Python
session, call the "exit()" function or hold the "Ctrl" key down while
you enter a "Z", then hit the ""Enter"" key to get back to your
Windows command prompt.

You may also find that you have a Start-menu entry such as Start ‣
Programs ‣ Python 3.x ‣ Python (command line) that results in you
seeing the ">>>" prompt in a new window.  If so, the window will
disappear after you call the "exit()" function or enter the "Ctrl-Z"
character; Windows is running a single "python" command in the window,
and closes it when you terminate the interpreter.

Now that we know the "py" command is recognized, you can give your
Python script to it. You'll have to give either an absolute or a
relative path to the Python script. Let's say your Python script is
located in your desktop and is named "hello.py", and your command
prompt is nicely opened in your home directory so you're seeing
something similar to:

   C:\Users\YourName>

So now you'll ask the "py" command to give your script to Python by
typing "py" followed by your script path:

   C:\Users\YourName> py Desktop\hello.py
   hello"}
{Q006001Zh:"Python在Windows上的常见问题==>我怎样在Windows下运行一个Python程序？"}
{A006001Zh:"这不一定是一个简单的问题。如果你已经熟悉在Windows的命令行中运行程序的
方法，一切都显而易见；不然的话，你也许需要额外获得些许指导。

除非你在使用某种集成开发环境，否则你将会在被称为“DOS 窗口”或“命令提示
符窗口”的地方 *输入* Windows 命令。 通常你可以在搜索栏搜索 "cmd" 来创
建这种窗口。 你应该能够识别你何时打开了这样的窗口，因为你将看到一个
Windows“命令提示符”，通常看起来是这样：

   C:\>

前面的字母可能会不同，而且后面有可能会有其他东西，所以你也许会看到类似
这样的东西：

   D:\YourName\Projects\Python>

出现的内容具体取决与你的电脑如何设置和你最近用它做的事。 当你启动了这
样一个窗口后，就可以开始运行Python程序了。

Python 脚本需要被另外一个叫做 Python *解释器* 的程序来处理。 解释器读
取脚本，把它编译成字节码，然后执行字节码来运行你的程序。 所以怎样安排
解释器来处理你的 Python 脚本呢？

首先，确保命令窗口能够将“py”识别为指令来开启解释器。 如果你打开过一个
命令窗口， 尝试输入命令 "py" 然后按回车：

   C:\Users\YourName> py

然后你应当看见类似类似这样的东西：

   Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] on win32
   Type "help", "copyright", "credits" or "license" for more information.
   >>>

解释器已经以“交互模式”打开。这意味着你可以交互输入Python语句或表达式，
并在等待时执行或评估它们。这是Python最强大的功能之一。输入几个表达式并
看看结果：

   >>> print("Hello")
   Hello
   >>> "Hello" * 3
   'HelloHelloHello'

许多人把交互模式当作方便和高度可编程的计算器。 想结束交互式Python会话
时，调用 "exit()" 函数，或者按住 "Ctrl" 键时输入 "Z"  ，之后按 "Enter"
键返回Windows命令提示符。

你可能发现在开始菜单有这样一个条目 开始 ‣ 所有程序 ‣ Python 3.x ‣
Python (命令行)， 运行它后会出现一个有着 ">>>" 提示的新窗口。 在此之后
，如果调用 "exit()" 函数或按 "Ctrl-Z" 组合键后窗口将会消失。 Windows
会在这个窗口中运行一个“python”命令，并且在你终止解释器的时候关闭它。

现在我们知道 "py" 命令已经被识别，可以输入 Python 脚本了。 你需要提供
Python 脚本的绝对路径或相对路径。 假设 Python 脚本位于桌面上并命名为
"hello.py"，并且命令提示符在用户主目录打开，那么可以看到类似于这样的东
西:

   C:\Users\YourName>

那么现在可以让``py``命令执行你的脚本，只需要输入``py`` 和脚本路径:

   C:\Users\YourName> py Desktop\hello.py
   hello"}
{Q006002En:"Python on Windows FAQ==>How do I make Python scripts executable?"}
{A006002En:"On Windows, the standard Python installer already associates the .py
extension with a file type (Python.File) and gives that file type an
open command that runs the interpreter ("D:\Program
Files\Python\python.exe "%1" %*").  This is enough to make scripts
executable from the command prompt as 'foo.py'.  If you'd rather be
able to execute the script by simple typing 'foo' with no extension
you need to add .py to the PATHEXT environment variable."}
{Q006002Zh:"Python在Windows上的常见问题==>我怎么让 Python 脚本可执行？"}
{A006002Zh:"在 Windows 上，标准 Python 安装程序已将 .py 扩展名与文件类型
(Python.File) 相关联，并为该文件类型提供运行解释器的打开命令
("D:\Program Files\Python\python.exe "%1" %*") 。 这足以使脚本在命令提
示符下作为“foo.py”命令被执行。 如果希望通过简单地键入“foo”而无需输入文
件扩展名来执行脚本，则需要将 .py 添加到 PATHEXT 环境变量中。"}
{Q006003En:"Python on Windows FAQ==>Why does Python sometimes take so long to start?"}
{A006003En:"Usually Python starts very quickly on Windows, but occasionally there
are bug reports that Python suddenly begins to take a long time to
start up.  This is made even more puzzling because Python will work
fine on other Windows systems which appear to be configured
identically.

The problem may be caused by a misconfiguration of virus checking
software on the problem machine.  Some virus scanners have been known
to introduce startup overhead of two orders of magnitude when the
scanner is configured to monitor all reads from the filesystem.  Try
checking the configuration of virus scanning software on your systems
to ensure that they are indeed configured identically. McAfee, when
configured to scan all file system read activity, is a particular
offender."}
{Q006003Zh:"Python在Windows上的常见问题==>为什么有时候 Python 程序会启动缓慢？"}
{A006003Zh:"通常，Python 在 Windows 上启动得很快，但偶尔会有错误报告说 Python 突然
需要很长时间才能启动。更令人费解的是，在其他配置相同的 Windows 系统上
，Python 却可以工作得很好。

该问题可能是由于计算机上的杀毒软件配置错误造成的。当将病毒扫描配置为监
视文件系统中所有读取行为时，一些杀毒扫描程序会导致两个数量级的启动开销
。请检查你系统安装的杀毒扫描程序的配置，确保两台机它们是同样的配置。已
知的， McAfee 杀毒软件在将它设置为扫描所有文件系统访问时，会产生这个问
题。"}
{Q006004En:"Python on Windows FAQ==>How do I make an executable from a Python script?"}
{A006004En:"See cx_Freeze for a distutils extension that allows you to create
console and GUI executables from Python code. py2exe, the most popular
extension for building Python 2.x-based executables, does not yet
support Python 3 but a version that does is in development."}
{Q006004Zh:"Python在Windows上的常见问题==>我怎样使用 Python 脚本制作可执行文件？"}
{A006004Zh:"请参阅 cx_Freeze 来了解 distutils 扩展，它允许你基于 Python 代码创建控
制台和 GUI 可执行文件。 py2exe 是最流行的用来构建基于 Python 2.x 的可
执行文件的扩展，它暂时还不支持 Python 3 但新的版本已在开发中。"}
{Q006005En:"Python on Windows FAQ==>Is a "*.pyd" file the same as a DLL?"}
{A006005En:"Yes, .pyd files are dll's, but there are a few differences.  If you
have a DLL named "foo.pyd", then it must have a function
"PyInit_foo()".  You can then write Python "import foo", and Python
will search for foo.pyd (as well as foo.py, foo.pyc) and if it finds
it, will attempt to call "PyInit_foo()" to initialize it.  You do not
link your .exe with foo.lib, as that would cause Windows to require
the DLL to be present.

Note that the search path for foo.pyd is PYTHONPATH, not the same as
the path that Windows uses to search for foo.dll.  Also, foo.pyd need
not be present to run your program, whereas if you linked your program
with a dll, the dll is required.  Of course, foo.pyd is required if
you want to say "import foo".  In a DLL, linkage is declared in the
source code with "__declspec(dllexport)". In a .pyd, linkage is
defined in a list of available functions."}
{Q006005Zh:"Python在Windows上的常见问题==>"*.pyd" 文件和 DLL 文件相同吗？"}
{A006005Zh:"是的， .pyd 文件也是 dll ，但有一些差异。如果你有一个名为 "foo.pyd" 的
DLL，那么它必须有一个函数 "PyInit_foo()" 。 然后你可以编写 Python 代码
“import foo” ，Python 将搜索 foo.pyd （以及 foo.py 、 foo.pyc ）。如果
找到它，将尝试调用 "PyInit_foo()" 来初始化它。你不应将 .exe 与 foo.lib
链接，因为这会导致 Windows 要求存在 DLL 。

请注意， foo.pyd 的搜索路径是 PYTHONPATH ，与 Windows 用于搜索 foo.dll
的路径不同。此外， foo.pyd 不需要存在来运行你的程序，而如果你将程序与
dll 链接，则需要 dll 。 当然，如果你想 "import foo" ，则需要 foo.pyd
。在 DLL 中，链接在源代码中用 "__declspec(dllexport)" 声明。 在 .pyd
中，链接在可用函数列表中定义。"}
{Q006006En:"Python on Windows FAQ==>How can I embed Python into a Windows application?"}
{A006006En:"Embedding the Python interpreter in a Windows app can be summarized as
follows:

1. Do _not_ build Python into your .exe file directly.  On Windows,
   Python must be a DLL to handle importing modules that are
   themselves DLL's.  (This is the first key undocumented fact.)
   Instead, link to "python*NN*.dll"; it is typically installed in
   "C:\Windows\System".  *NN* is the Python version, a number such as
   "33" for Python 3.3.

   You can link to Python in two different ways.  Load-time linking
   means linking against "python*NN*.lib", while run-time linking
   means linking against "python*NN*.dll".  (General note:
   "python*NN*.lib" is the so-called "import lib" corresponding to
   "python*NN*.dll".  It merely defines symbols for the linker.)

   Run-time linking greatly simplifies link options; everything
   happens at run time.  Your code must load "python*NN*.dll" using
   the Windows "LoadLibraryEx()" routine.  The code must also use
   access routines and data in "python*NN*.dll" (that is, Python's C
   API's) using pointers obtained by the Windows "GetProcAddress()"
   routine.  Macros can make using these pointers transparent to any C
   code that calls routines in Python's C API.

   Borland note: convert "python*NN*.lib" to OMF format using
   Coff2Omf.exe first.

2. If you use SWIG, it is easy to create a Python "extension module"
   that will make the app's data and methods available to Python.
   SWIG will handle just about all the grungy details for you.  The
   result is C code that you link *into* your .exe file (!)  You do
   _not_ have to create a DLL file, and this also simplifies linking.

3. SWIG will create an init function (a C function) whose name depends
   on the name of the extension module.  For example, if the name of
   the module is leo, the init function will be called initleo().  If
   you use SWIG shadow classes, as you should, the init function will
   be called initleoc().  This initializes a mostly hidden helper
   class used by the shadow class.

   The reason you can link the C code in step 2 into your .exe file is
   that calling the initialization function is equivalent to importing
   the module into Python! (This is the second key undocumented fact.)

4. In short, you can use the following code to initialize the Python
   interpreter with your extension module.

      #include "python.h"
      ...
      Py_Initialize();  // Initialize Python.
      initmyAppc();  // Initialize (import) the helper class.
      PyRun_SimpleString("import myApp");  // Import the shadow class.

5. There are two problems with Python's C API which will become
   apparent if you use a compiler other than MSVC, the compiler used
   to build pythonNN.dll.

   Problem 1: The so-called "Very High Level" functions that take FILE
   * arguments will not work in a multi-compiler environment because
   each compiler's notion of a struct FILE will be different.  From an
   implementation standpoint these are very _low_ level functions.

   Problem 2: SWIG generates the following code when generating
   wrappers to void functions:

      Py_INCREF(Py_None);
      _resultobj = Py_None;
      return _resultobj;

   Alas, Py_None is a macro that expands to a reference to a complex
   data structure called _Py_NoneStruct inside pythonNN.dll.  Again,
   this code will fail in a mult-compiler environment.  Replace such
   code by:

      return Py_BuildValue("");

   It may be possible to use SWIG's "%typemap" command to make the
   change automatically, though I have not been able to get this to
   work (I'm a complete SWIG newbie).

6. Using a Python shell script to put up a Python interpreter window
   from inside your Windows app is not a good idea; the resulting
   window will be independent of your app's windowing system.  Rather,
   you (or the wxPythonWindow class) should create a "native"
   interpreter window.  It is easy to connect that window to the
   Python interpreter.  You can redirect Python's i/o to _any_ object
   that supports read and write, so all you need is a Python object
   (defined in your extension module) that contains read() and write()
   methods."}
{Q006006Zh:"Python在Windows上的常见问题==>我怎样将 Python 嵌入一个 Windows 程序？"}
{A006006Zh:"在 Windows 应用程序中嵌入 Python 解释器可以总结如下：

1. 请 _不要_ 直接在你的 .exe 文件中内置 Python 。在 Windows 上，
   Python 必须是一个 DLL ，这样才可以处理导入的本身就是 DLL 的模块。（
   这是第一个未记录的关键事实。）相反，链接到 "python*NN*.dll" ；它通
   常安装在 "C:\Windows\System" 中。 *NN* 是 Python 版本，如数字“33”代
   表 Python 3.3 。

   你可以通过两种不同的方式链接到 Python 。加载时链接意味着链接到
   "python*NN*.lib" ，而运行时链接意味着链接 "python*NN*.dll" 。（一般
   说明： "python *NN*.lib" 是所谓的“import lib”，对应于
   "python*NN*.dll" 。它只定义了链接器的符号。）

   运行时链接极大地简化了链接选项，一切都在运行时发生。你的代码必须使
   用 Windows 的 "LoadLibraryEx()" 程序加载 "python*NN*.dll" 。代码还
   必须使用使用 Windows 的 "GetProcAddress()" 例程获得的指针访问
   "python*NN*.dll" 中程序和数据（即 Python 的 C API ）。宏可以使这些
   指针对任何调用 Python C API 中的例程的 C 代码都是透明的。

   Borland 提示：首先使用 Coff2Omf.exe 将 "python*NN*.lib" 转换为 OMF
   格式。

2. 如果你使用 SWIG ，很容易创建一个 Python “扩展模块”，它将使应用程序
   的数据和方法可供 Python 使用。SWIG将为你处理所有蹩脚的细节。结果是
   你将链接到 .exe 文件 *中* 的C代码 (!) 你不必创建 DLL 文件，这也简化
   了链接。

3. SWIG 将创建一个 init 函数（一个 C 函数），其名称取决于扩展模块的名
   称。例如，如果模块的名称是 leo ，则 init 函数将被称为 initleo() 。
   如果您使用 SWIG 阴影类，则 init 函数将被称为 initleoc() 。这初始化
   了一个由阴影类使用的隐藏辅助类。

   你可以将步骤 2 中的 C 代码链接到 .exe 文件的原因是调用初始化函数等
   同于将模块导入 Python ！ （这是第二个关键的未记载事实。）

4. 简而言之，你可以用以下代码使用扩展模块初始化 Python 解释器。

      #include "python.h"
      ...
      Py_Initialize();  // Initialize Python.
      initmyAppc();  // Initialize (import) the helper class.
      PyRun_SimpleString("import myApp");  // Import the shadow class.

5. Python C API 存在两个问题，如果你使用除 MSVC 之外的编译器用于构建
   python.dll ，这将会变得明显。

   问题1：采用 FILE* 参数的所谓“极高级”函数在多编译器环境中不起作用，
   因为每个编译器的FILE结构体概念都不同。从实现的角度来看，这些是非常
   _低_ 级的功能。

   问题2：在为 void 函数生成包装器时，SWIG 会生成以下代码：

      Py_INCREF(Py_None);
      _resultobj = Py_None;
      return _resultobj;

   Py_None 是一个宏，它扩展为对 pythonNN.dll 中名为 _Py_NoneStruct 的
   复杂数据结构的引用。同样，此代码将在多编译器环境中失败。将此类代码
   替换为：

      return Py_BuildValue("");

   有可能使用 SWIG 的 "%typemap" 命令自动进行更改，但我无法使其工作（
   我是一个完全的SWIG新手）。

6. 使用 Python shell 脚本从 Windows 应用程序内部建立 Python 解释器窗口
   并不是一个好主意；生成的窗口将独立于应用程序的窗口系统。相反，你（
   或 wxPythonWindow 类）应该创建一个“本机”解释器窗口。将该窗口连接到
   Python解释器很容易。你可以将 Python的 i/o 重定向到支持读写的 _任意_
   对象，因此你只需要一个包含 read() 和 write() 方法的 Python 对象（在
   扩展模块中定义）。"}
{Q006007En:"Python on Windows FAQ==>How do I keep editors from inserting tabs into my Python source?"}
{A006007En:"The FAQ does not recommend using tabs, and the Python style guide,
**PEP 8**, recommends 4 spaces for distributed Python code; this is
also the Emacs python-mode default.

Under any editor, mixing tabs and spaces is a bad idea.  MSVC is no
different in this respect, and is easily configured to use spaces:
Take Tools ‣ Options ‣ Tabs, and for file type "Default" set "Tab
size" and "Indent size" to 4, and select the "Insert spaces" radio
button.

Python raises "IndentationError" or "TabError" if mixed tabs and
spaces are causing problems in leading whitespace. You may also run
the "tabnanny" module to check a directory tree in batch mode."}
{Q006007Zh:"Python在Windows上的常见问题==>如何让编辑器不要在我的 Python 源代码中插入 tab ？"}
{A006007Zh:"本 FAQ 不建议使用制表符， Python 样式指南 **PEP 8** ，为发行的 Python
代码推荐 4 个空格；这也是 Emacs python-mode 默认值。

在任何编辑器下，混合制表符和空格都是一个坏主意。 MSVC 在这方面没有什么
不同，并且很容易配置为使用空格： 点击 Tools ‣ Options ‣ Tabs，对于文件
类型“Default”，设置“Tab size”和“Indent size”为 4 ，并选择“插入空格”单
选按钮。

如果混合制表符和空格导致前导空格出现问题， Python 会引发
"IndentationError" 或 "TabError" 。你还可以运行 "tabnanny" 模块以批处
理模式检查目录树。"}
{Q006008En:"Python on Windows FAQ==>How do I check for a keypress without blocking?"}
{A006008En:"Use the "msvcrt" module.  This is a standard Windows-specific
extension module. It defines a function "kbhit()" which checks whether
a keyboard hit is present, and "getch()" which gets one character
without echoing it."}
{Q006008Zh:"Python在Windows上的常见问题==>如何在不阻塞的情况下检查按键？"}
{A006008Zh:"使用 "msvcrt" 模块。 这是一个标准的 Windows 专属扩展模块。 它定义了一
个函数 "kbhit()" 用于检查是否有键盘中的某个键被按下，以及 "getch()" 用
于获取一个字符而不将其回显。"}
{Q007002En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?"}
{A007002En:"Depending on what platform(s) you are aiming at, there are several.
Some of them haven't been ported to Python 3 yet.  At least Tkinter
and Qt are known to be Python 3-compatible."}
{Q007002Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？"}
{A007002Zh:"针对不同的（操作系统或）平台，有多种工具包可供选择。虽然有些工具包还没
有移植到 Python 3 上，但至少目前 Tkinter 以及 Qt 是兼容 Python 3 的。"}
{Q007002001En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?==>Tkinter"}
{A007002001En:"Standard builds of Python include an object-oriented interface to the
Tcl/Tk widget set, called tkinter.  This is probably the easiest to
install (since it comes included with most binary distributions of
Python) and use. For more info about Tk, including pointers to the
source, see the Tcl/Tk home page.  Tcl/Tk is fully portable to the Mac
OS X, Windows, and Unix platforms."}
{Q007002001Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？==>Tkinter"}
{A007002001Zh:"Python 的标准编译包含了 tkinter。这是一个面向对象的接口，指向  Tcl/Tk
微件包。 该接口大概是最容易安装（因为该接口包含在 Python 的大部分 二进
制发行版 中）和使用的工具包。要了解 Tk 的详情，比如源代码等，可访问
Tcl/Tk 项目主页。 Tcl/Tk 可完整移植至 Mac OS X，Windows 和 Unix 操作系
统上。"}
{Q007002002En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?==>wxWidgets"}
{A007002002En:"wxWidgets (https://www.wxwidgets.org) is a free, portable GUI class
library written in C++ that provides a native look and feel on a
number of platforms, with Windows, Mac OS X, GTK, X11, all listed as
current stable targets.  Language bindings are available for a number
of languages including Python, Perl, Ruby, etc.

wxPython is the Python binding for wxwidgets.  While it often lags
slightly behind the official wxWidgets releases, it also offers a
number of features via pure Python extensions that are not available
in other language bindings.  There is an active wxPython user and
developer community.

Both wxWidgets and wxPython are free, open source, software with
permissive licences that allow their use in commercial products as
well as in freeware or shareware."}
{Q007002002Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？==>wxWidgets"}
{A007002002Zh:"wxWidgets (https://www.wxwidgets.org) 是一个自由、可移植的 GUI 图形用
户界面类库，使用 C++ 编写。它可以在多个操作系统平台上提供原生自然的界
面观感。包括Windows、Mac OS X、 GTK 和 X11 平台在内，都是wxWidgets 当
前稳定支持的平台。在语言绑定适配方面，wxWidgets 类库可用于较多语言，包
括 Python，Perl，Ruby等。

wxPython 是 wxWidgets 的 Python 适配。虽然该绑定在更新进度上经常会稍稍
落后于 wxWidgets，但它利用纯 Python 扩展，提供了许多其他语言绑定没有实
现的特性。wxPython 有一个活跃的用户和开发者社区。

wxWidgets 和 wxPython 都是自由开源库。宽松的许可证允许人们在商业软件、
自由软件和共享软件中使用它们。"}
{Q007002003En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?==>Qt"}
{A007002003En:"There are bindings available for the Qt toolkit (using either PyQt or
PySide) and for KDE (PyKDE4). PyQt is currently more mature than
PySide, but you must buy a PyQt license from Riverbank Computing if
you want to write proprietary applications.  PySide is free for all
applications.

Qt 4.5 upwards is licensed under the LGPL license; also, commercial
licenses are available from The Qt Company."}
{Q007002003Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？==>Qt"}
{A007002003Zh:"Qt 工具包 (可使用 PyQt 或 PySide) 及 KDE (PyKDE4) 有多个绑定适配可供选
择。 PyQt 当前相较 PySide 更成熟，但如果你想编写专有软件，就必须要从
Riverbank Computing 购买 PyQt 许可证。 PySide 则可以自由使用于各类软件
。

Qt 4.5 以上版本使用 LGPL 进行许可；此外，商业许可证可从 Qt 公司 那里获
得。"}
{Q007002004En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?==>Gtk+"}
{A007002004En:"The GObject introspection bindings for Python allow you to write GTK+
3 applications.  There is also a Python GTK+ 3 Tutorial.

The older PyGtk bindings for the Gtk+ 2 toolkit have been implemented
by James Henstridge; see <http://www.pygtk.org>."}
{Q007002004Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？==>Gtk+"}
{A007002004Zh:"针对 Python 的 GObject 内省绑定 可以用于编写 GTK+ 3 应用。 另请参阅
Python GTK+ 3 教程。

更早的、针对 Gtk+ 2 工具包 的 PyGtk 绑定，是由 James Henstridge 实现的
。具体请参考 <http://www.pygtk.org>。"}
{Q007002005En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?==>Kivy"}
{A007002005En:"Kivy is a cross-platform GUI library supporting both desktop operating
systems (Windows, macOS, Linux) and mobile devices (Android, iOS).  It
is written in Python and Cython, and can use a range of windowing
backends.

Kivy is free and open source software distributed under the MIT
license."}
{Q007002005Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？==>Kivy"}
{A007002005Zh:"Kivy 是一种跨平台图形用户界面库，同时支持桌面操作系统（Windows，macOS
和 Linux）以及移动设备（Android，iOS）。该库使用 Python 和 Cython 编写
，可以使用一系列窗口后端。

Kivy 是自由的开源软件，使用 MIT 许可证分发。"}
{Q007002006En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?==>FLTK"}
{A007002006En:"Python bindings for the FLTK toolkit, a simple yet powerful and mature
cross-platform windowing system, are available from the PyFLTK
project."}
{Q007002006Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？==>FLTK"}
{A007002006Zh:"the FLTK toolkit 的Python绑定是简单却功能强大且成熟的跨平台窗口系统，
可以在  the PyFLTK project 里获得相关信息。"}
{Q007002007En:"Graphic User Interface FAQ==>What platform-independent GUI toolkits exist for Python?==>OpenGL"}
{A007002007En:"For OpenGL bindings, see PyOpenGL."}
{Q007002007Zh:"图形用户界面（GUI）常见问题==>Python 是否有平台无关的图形界面工具包？==>OpenGL"}
{A007002007Zh:"对于OpenGL绑定，请参阅 PyOpenGL。"}
{Q007003En:"Graphic User Interface FAQ==>What platform-specific GUI toolkits exist for Python?"}
{A007003En:"By installing the PyObjc Objective-C bridge, Python programs can use
Mac OS X's Cocoa libraries.

Pythonwin by Mark Hammond includes an interface to the Microsoft
Foundation Classes and a Python programming environment that's written
mostly in Python using the MFC classes."}
{Q007003Zh:"图形用户界面（GUI）常见问题==>有哪些Python的GUI工具是某个平台专用的？"}
{A007003Zh:"通过安装 PyObjc Objective-C bridge，Python程序可以使用Mac OS X的Cocoa
库。

Mark Hammond的 Pythonwin 包括一个微软基础类(MFC)的接口和一个绝大多数由
使用MFC类的Python写成的Python编程环境。"}
{Q007004001En:"Graphic User Interface FAQ==>Tkinter questions==>How do I freeze Tkinter applications?"}
{A007004001En:"Freeze is a tool to create stand-alone applications.  When freezing
Tkinter applications, the applications will not be truly stand-alone,
as the application will still need the Tcl and Tk libraries.

One solution is to ship the application with the Tcl and Tk libraries,
and point to them at run-time using the "TCL_LIBRARY" and "TK_LIBRARY"
environment variables.

To get truly stand-alone applications, the Tcl scripts that form the
library have to be integrated into the application as well. One tool
supporting that is SAM (stand-alone modules), which is part of the Tix
distribution (http://tix.sourceforge.net/).

Build Tix with SAM enabled, perform the appropriate call to
"Tclsam_init()", etc. inside Python's "Modules/tkappinit.c", and link
with libtclsam and libtksam (you might include the Tix libraries as
well)."}
{Q007004001Zh:"图形用户界面（GUI）常见问题==>有关Tkinter的问题==>我怎样“冻结”Tkinter程序？"}
{A007004001Zh:"Freeze是一个用来创建独立应用程序的工具。 当冻结(freeze) Tkinter程序时
，程序并不是真的能够独立运行，因为程序仍然需要Tcl和Tk库。

一种解决方法是将程序与 Tcl 和 Tk 库一同发布，并且在运行时使用环境变量
"TCL_LIBRARY" 和 "TK_LIBRARY" 指向他们的位置。

为了获得真正能独立运行的应用程序，来自库里的 Tcl 脚本也需要被整合进应
用程序。 一个做这种事情的工具叫 SAM (stand-alone modules，独立模块) ，
它是 Tix distribution (http://tix.sourceforge.net/) 的一部分。

在启用 SAM 时编译 Tix ，在 Python 文件  "Modules/tkappinit.c" 中执行对
"Tclsam_init()" 等的适当调用，并且将程序与 libtclsam 和 libtksam 相链
接（可能也要包括 Tix 的库）。"}
{Q007004002En:"Graphic User Interface FAQ==>Tkinter questions==>Can I have Tk events handled while waiting for I/O?"}
{A007004002En:"On platforms other than Windows, yes, and you don't even need threads!
But you'll have to restructure your I/O code a bit.  Tk has the
equivalent of Xt's "XtAddInput()" call, which allows you to register a
callback function which will be called from the Tk mainloop when I/O
is possible on a file descriptor.  See File Handlers."}
{Q007004002Zh:"图形用户界面（GUI）常见问题==>有关Tkinter的问题==>在等待 I/O 操作时能够处理 Tk 事件吗？"}
{A007004002Zh:"在 Windows 以外的其他平台上可以，你甚至不需要使用线程！ 但是你必须稍微
修改一下你的 I/O 代码。 Tk 有与 Xt 的 "XtAddInput()" 对应的调用，它允
许你注册一个回调函数，当一个文件描述符可以进行 I/O 操作的时候，Tk 主循
环将会调用这个回调函数。 参见 File Handlers。"}
{Q007004003En:"Graphic User Interface FAQ==>Tkinter questions==>I can't get key bindings to work in Tkinter: why?"}
{A007004003En:"An often-heard complaint is that event handlers bound to events with
the "bind()" method don't get handled even when the appropriate key is
pressed.

The most common cause is that the widget to which the binding applies
doesn't have "keyboard focus".  Check out the Tk documentation for the
focus command. Usually a widget is given the keyboard focus by
clicking in it (but not for labels; see the takefocus option)."}
{Q007004003Zh:"图形用户界面（GUI）常见问题==>有关Tkinter的问题==>在Tkinter中键绑定不工作：为什么？"}
{A007004003Zh:"经常听到的抱怨是：已经通过  "bind()" 方法绑定了事件的处理程序，但是，
当按下相关的按键后，这个处理程序却没有执行。

最常见的原因是，那个绑定的控件没有“键盘焦点”。请在 Tk 文档中查找 focus
指令。通常一个控件要获得“键盘焦点”，需要点击那个控件（而不是标签；请查
看 takefocus 选项）。"}
{Q008001En:""Why is Python Installed on my Computer?" FAQ==>What is Python?"}
{A008001En:"Python is a programming language.  It's used for many different
applications. It's used in some high schools and colleges as an
introductory programming language because Python is easy to learn, but
it's also used by professional software developers at places such as
Google, NASA, and Lucasfilm Ltd.

If you wish to learn more about Python, start with the Beginner's
Guide to Python."}
{Q008001Zh:"“为什么我的电脑上安装了 Python ？”==>什么是Python？"}
{A008001Zh:"Python 是一种程序语言，被许多应用程序使用。它不仅因易学而在许多高校用
于编程入门，还被工作于 Google、NASA 和卢卡斯影业等公司的软件开发人员使
用。

如果你想学习更多 Python，看看 Beginner's Guide to Python."}
{Q008002En:""Why is Python Installed on my Computer?" FAQ==>Why is Python installed on my machine?"}
{A008002En:"If you find Python installed on your system but don't remember
installing it, there are several possible ways it could have gotten
there.

* Perhaps another user on the computer wanted to learn programming and
  installed it; you'll have to figure out who's been using the machine
  and might have installed it.

* A third-party application installed on the machine might have been
  written in Python and included a Python installation.  There are
  many such applications, from GUI programs to network servers and
  administrative scripts.

* Some Windows machines also have Python installed.  At this writing
  we're aware of computers from Hewlett-Packard and Compaq that
  include Python.  Apparently some of HP/Compaq's administrative tools
  are written in Python.

* Many Unix-compatible operating systems, such as Mac OS X and some
  Linux distributions, have Python installed by default; it's included
  in the base installation."}
{Q008002Zh:"“为什么我的电脑上安装了 Python ？”==>为什么我的电脑上安装了 Python ？"}
{A008002Zh:"如果你不记得你曾主动安装过 Python，但它却出现在了你的电脑上，这里有一
些可能的原因。

* 可能是这台电脑的其他用户因想学习编程而安装了它，你得琢磨一下谁用过这
  台电脑并安装了 Python。

* 电脑上安装的第三方应用程序可能由 Python 写成并附带了一份 Python。这
  样的应用程序有很多，例如GUI程序、网络服务器、管理脚本等。

* 一些 Windows 可能预装了 Python。在撰写本文时，我们了解到 Hewlett-
  Packard 和 Compaq 的计算机包含Python。显然，HP/Compaq 的一些管理工具
  是用 Python 编写的。

* 许多 Unix 兼容的操作系统，例如 Mac OS X 和一些 Linux 发行版，默认安
  装了Python；它被包含在基本安装套件中。"}
{Q008003En:""Why is Python Installed on my Computer?" FAQ==>Can I delete Python?"}
{A008003En:"That depends on where Python came from.

If someone installed it deliberately, you can remove it without
hurting anything.  On Windows, use the Add/Remove Programs icon in the
Control Panel.

If Python was installed by a third-party application, you can also
remove it, but that application will no longer work.  You should use
that application's uninstaller rather than removing Python directly.

If Python came with your operating system, removing it is not
recommended.  If you remove it, whatever tools were written in Python
will no longer run, and some of them might be important to you.
Reinstalling the whole system would then be required to fix things
again."}
{Q008003Zh:"“为什么我的电脑上安装了 Python ？”==>我能删除 Python 吗？"}
{A008003Zh:"这取决于所安装 Python 的来源

如果有人主动安装了 Python，你可以在不影响其它程序的情况下安全移除它。
在 Windows 中，可使用“控制面板”中的“添加/删除程序”卸载。

如果 Python 来源于第三方应用程序，你也能删除它，但那些程序将不能正常工
作。你应该使用那些应用程序的卸载器而不是直接删除 Python。

如果 Python 来自于你的操作系统，不推荐删除！如果删除了它，任何用
Python 写成的工具将无法工作，其中某些工具对于你来说可能十分重要。你甚
至可能需要重装整个系统来修复因删除 Python 留下的烂摊子。"}
